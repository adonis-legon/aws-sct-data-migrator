<?xml version="1.0" encoding="UTF-8"?>
<tree>
    <complex-attributes>
        <type name="materialized-view">
            <attr name="sql"></attr>
        </type>
        <type name="view">
            <attr name="sql"></attr>
        </type>
        <type name="metadata">
            <attr name="vendor-engine"></attr>
        </type>
        <type name="function">
            <attr name="sql"></attr>
        </type>
        <type name="constraint">
            <attr name="check-clause"></attr>
        </type>
        <type name="trigger">
            <attr name="trigger-definition"></attr>
            <attr name="comment"></attr>
            <attr name="sql"></attr>
        </type>
        <type name="procedure">
            <attr name="sql"></attr>
        </type>
    </complex-attributes>
    <metadata _I_D="1bbd62c3-d14e-4ce6-9969-547747cf5e23" vendor="POSTGRESQL" name="Chinook (Postgres From MSSQL)" metaStorageUuid="0fb7d794-8349-45ae-8b07-e94431520c0a" nonquoted-case="lower" allow-similarly-named-objects="y" quoted-case="specified" connection-data="postgres@192.168.0.10:5432/chinook_from_mssql" product-version="16.3.0.0" vendor-engine-version="16.3" mdl-waiting-complex-attributes="" connection-identifier="2af03b8dafc3a66455c8f43da04a2fb3" max-identifier-length="63">
        <complex-attribute name="vendor-engine"><![CDATA[PostgreSQL 16.3 (Debian 16.3-1.pgdg120+1) on aarch64-unknown-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit]]></complex-attribute>
        <category _I_D="af7e7256-05f2-4824-9cf5-14f70a0de288" name="Schemas" order-num="0" objects-loading="extended" subcategories-loading="none" child-type="schema">
            <schema _I_D="b1abf240-3095-447d-a4e0-9b0e6fc57ad7" name="aws_sqlserver_ext" is-empty="N" context="aws_sqlserver_ext" subcategories-loading="none" object-loading="extended" schema-owner="postgres" is-system="N">
                <category _I_D="2d70ca8b-2dea-4971-95ee-ffeeaf902574" name="Tables" order-num="0" objects-loading="extended" subcategories-loading="none" child-type="table">
                    <table _I_D="58ff4c8e-69c2-4f5f-a67e-50141292b97d" name="sys_languages" context="sys_languages" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO" comment="This table contains complete info about languages present in the instance of MS SQL Server.">
                        <category _I_D="bc3013de-61eb-4469-90d9-35b61142e573" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="a564142d-cbc8-45e8-ae72-a46bd9d28f2f" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="03146280-b40f-42a0-a7c2-756bedb79d60" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="4394cf2d-69bb-46ac-ae94-14a1eccc8642" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="eb23281e-3ea5-4b32-b1c9-55dc4cdd5fcf" name="Indexes" order-num="4" objects-loading="none" subcategories-loading="none" child-type="index" mdl-expected-node-count="2"/>
                        <category _I_D="539a68c7-c305-4f32-b3b6-33617d9c8ad1" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="b878d5fb-4ba9-4d95-b867-fdf4166639ff" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="2f179a56-10bd-40bf-b073-062843b61c10" name="sysjobhistory" context="sysjobhistory" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="62325d74-ce1a-48c4-b7c6-9e9ca737ce2f" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="3173df3a-e063-4e22-8b81-ee54d41603a0" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="beccc8e6-1dc5-40f9-926c-ffd85ab2b1a0" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="7247ee16-c67c-42b4-afd5-cd52f76992da" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="97295389-62b7-40fc-9fa9-af5d3bf1a643" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="6e4250fc-8bbc-48d4-9a68-75b2808c5b74" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="e72cb5a4-be1c-461b-bdad-4bd3c131f63d" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="51c57813-ce31-411d-b3c1-8e22ddd504e2" name="sysjobs" context="sysjobs" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="cdb52859-658a-42dd-b73f-8ac314c82ec7" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="9cbe47ca-86bf-4092-af78-0a978d3ac750" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="b5c3b4ee-4bc6-4be7-b72b-57c4286f1775" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="fa90dfcf-d3e3-40f9-930f-e3ce293c4afa" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="18e9f63a-92f1-47ef-8ed8-737ba6b4765f" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="7d9a8830-b14d-4e74-ba60-1678be6c2ecd" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="78a99316-c9ce-4a72-9f37-b28cda6071b5" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="dc019885-48bb-4236-9c63-e6ceca520745" name="sysjobschedules" context="sysjobschedules" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="fdd3f0f5-79ad-4c44-94a4-58d14a40bf81" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="7671a02e-e8e4-4033-aad2-cd4375565809" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="a41f6e5d-47e3-434d-b53a-4ced1180c32d" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="c01dca90-e8d1-4734-b90c-ab206e149828" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="22ca6613-1b4c-4d29-a095-19aa7983cf78" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="e2cd3bad-1e4e-4686-989a-3c10a5324ef8" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="ebed0a09-fabd-41f0-a499-8ba61dc98449" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="9ae7ec12-31e1-4bca-835b-603991f89633" name="sysjobsteps" context="sysjobsteps" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="a3bb647e-93c8-4237-8c37-36220da11503" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e11fd936-6b9e-4a36-a5c7-42577aa856d3" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="9cc86b53-403c-41f5-af78-3d0721b2dc85" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="67a34001-5a4e-47d1-80d0-d8fb7040a30d" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="c238593b-f677-4ab5-bb3e-4a1bc042f86b" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="d1f991ea-1635-4965-8e83-fc827456e28c" name="Triggers" order-num="5" objects-loading="none" subcategories-loading="none" child-type="trigger" mdl-expected-node-count="2"/>
                        <category _I_D="045494b5-c43f-4b95-9b8d-1128e9e150ce" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="8ecc6cab-5f0c-43c3-92db-ee43d63292d7" name="sysmail_account" context="sysmail_account" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="5a854cde-ccfb-49bc-9a25-c3c3ac5df4f9" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="a809dfc0-22ca-43e7-8be5-9e55481f65cf" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="05f4a89f-6278-4b74-b664-50580cfdb94d" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="40285087-c130-4c5e-b2c1-3e90b7030bf4" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="becfe9f2-4c3f-4e7a-9454-23aed3384e14" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="f468701b-859d-4040-96f3-c6471526324b" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="6aa6b9c9-a28a-4ad2-9568-efbf17da6aea" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="52d8c120-c5d8-4f13-8175-69240b118f14" name="sysmail_attachments" context="sysmail_attachments" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="0eff6d4c-5cb2-4fbe-8c6d-c86790c634b7" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="9b371a9e-8519-43c8-b5fb-d24dc35b6f27" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="7e3a5842-2e8e-4bda-a5dd-cdd2e406d62f" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="1fa5cf2c-0abe-4293-b6e5-97edf26601c9" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="c0352a40-733f-47f6-b5ee-cbf18e28eefb" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="5dc992d2-42ba-4107-b467-065e2980a8c2" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="6a5870df-ea1c-4f55-a4f0-68251c1a462b" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="6e2fa62b-69c8-4a64-81de-f4a3961b7a59" name="sysmail_log" context="sysmail_log" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="17399b5e-168d-4ffe-94a8-461bde29a222" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="5e2b6576-a86c-4e26-af57-4d19cef7269c" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="f8db9195-71d9-40d6-ab3e-7ea540cd6814" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="da0d2693-2015-4010-8676-898500af71a8" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="342c325c-28ca-43a8-b91d-ddd11cf50c9d" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="5f458cc5-f75d-4209-8d02-aafe2464e941" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="c51ba8e4-9eb5-45b8-80c7-65e828e67134" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="378a6246-cb68-4597-b2d7-d46506cd4943" name="sysmail_mailitems" context="sysmail_mailitems" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="9b822b83-daab-4a4f-a21c-0e853f7b9151" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="92a8262b-1422-4ff8-969b-0bc014fadbde" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="9c246e6c-d123-4186-a457-9ac828778185" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="f2495a38-aafb-465d-9bae-6396961b26c9" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="25669067-e682-4056-ac3c-34e43099c981" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="f9a646e1-9005-4bc1-8553-9d8944d1841c" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="87695fa0-5b97-40ea-b83d-ee4eed320389" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="c00a2c2e-11e9-40be-bb04-8a283c1eef13" name="sysmail_profile" context="sysmail_profile" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="8a712bd9-bb0a-416a-852e-45e888499838" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e8e4ebe3-231a-4e33-a07e-cd5ab60e7551" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="1c095c34-b1e7-4fd0-a1a7-0c788458758d" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e6804528-db40-4940-9cfe-9e0d77366316" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="1563d664-0c4d-4eef-84ba-8af42cb2f997" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="d92b3a0e-3542-4022-8497-6851adfc60bc" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="394b4c1f-5634-4b52-aca6-5a3341f9886d" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="9356d121-f9a7-4acc-8f8d-909eeb387781" name="sysmail_profileaccount" context="sysmail_profileaccount" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="73688ae5-e9b4-45c2-be31-d2b67aaa052b" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="867874c6-deba-4d6b-a816-3e12fd53cd3d" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="f744251b-033c-450b-a4b0-4d164884110f" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="94870aa4-5d9d-4345-aead-5d18869c7cf7" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="d245a273-462f-4d96-9e07-b001750b64e8" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="d6699441-1aaa-45d3-854a-550fcdb36f76" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="100cad56-3b80-4be6-88d5-8a666d3684db" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="400e3a97-da50-4bd5-95c7-9b650639d4af" name="sysmail_server" context="sysmail_server" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="33173e2a-ee65-4c8b-930a-076d9579dc30" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="54200d25-0cc0-45aa-a10e-8735a35f24ac" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e2753612-43c7-4d6b-a5ed-6bc05c1d9bf5" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="9ef2689d-c882-4958-91fa-64aeb28348c8" name="Constraints" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="constraint" mdl-expected-node-count="0"/>
                        <category _I_D="4175e859-98cf-4138-b16f-ef21ed6a775a" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="5b8ff862-c3ea-4382-99f6-18abe0c7e307" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="41591274-5348-4687-9a16-0f4b29524c36" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="259cf580-937f-40e4-b8e8-e6c647e0064c" name="sysschedules" context="sysschedules" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="4bd6a6ec-f6e9-45bf-85fe-f68d5c6f7a0d" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="b79253ec-6a8b-4afe-834b-7e05f54303a4" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="0ca4ead2-1a09-4e52-b4d6-fae3a92c99d6" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="7c4bd5ae-3fe0-4629-8408-459bc565aa91" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="7eac87ac-e778-4214-a162-8bf11283f140" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="d13985b1-2878-4b16-a588-37428d9a5b50" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="acda8d0c-3f28-46b3-ae6b-625d8b1c2926" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="faee2e85-9ef7-43ab-902f-b36c39624081" name="versions" context="versions" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="057f28fa-5bde-4881-8e23-420d808bf53e" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="ffd72c23-3b18-4ae4-8b1d-0c5bd30d41f7" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="89e64d12-3f50-4bab-970b-73311792c015" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="8bd9f30a-5f7a-42bd-8a49-314804aecf5c" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="e55c60cf-b822-448b-8aea-408b6bfd355f" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="b157bacd-a02b-447b-986f-cfd872adcd52" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="1ca54259-385e-4007-8479-f30530571e10" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                </category>
                <category _I_D="607b7cde-6980-4d97-9aa5-d15ac006d7a5" name="Foreign tables" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="foreigntable"/>
                <category _I_D="b5bd4820-4b03-4180-9200-bfca9e747d0b" name="Views" order-num="2" objects-loading="extended" subcategories-loading="none" child-type="view">
                    <view _I_D="bb2a0871-d03d-449f-baa0-228aa21fdf33" name="information_schema_check_constraints" context="information_schema_check_constraints" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS constraint_catalog,
    s.nspname AS constraint_schema,
    c.conname AS constraint_name,
    pg_get_constraintdef(c.oid) AS check_clause
   FROM (pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
  WHERE ((s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND (c.contype = 'c'::"char"));]]></complex-attribute>
                        <category _I_D="55affe2c-a153-48ed-a795-c5d0fe8b81d5" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="546501fa-064f-4bf2-9ecc-d9673b286efe" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="c0bc35b0-eb9d-4634-94d9-21f89e382b89" name="information_schema_columns" context="information_schema_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS table_catalog,
    s.nspname AS table_schema,
    c.relname AS table_name,
    a.attname AS column_name,
    a.attnum AS ordinal_position,
    pg_get_expr(d.adbin, d.adrelid) AS column_default,
        CASE
            WHEN a.attnotnull THEN 'NO'::character varying(3)
            ELSE 'YES'::character varying(3)
        END AS is_nullable,
    format_type(t.oid, NULL::integer) AS data_type,
    a.attlen AS character_maximum_length,
    a.attlen AS character_octet_length,
    NULL::integer AS numeric_precision,
    NULL::integer AS numeric_precision_radix,
    NULL::integer AS numeric_scale,
    NULL::integer AS datetime_precision,
    NULL::character varying(128) AS character_set_catalog,
    NULL::character varying(128) AS character_set_schema,
    NULL::character varying(128) AS character_set_name,
    NULL::character varying(128) AS collation_catalog,
    NULL::character varying(128) AS collation_schema,
    coll.collname AS collation_name,
    NULL::character varying(128) AS domain_catalog,
    NULL::character varying(128) AS domain_schema,
        CASE t.typtype
            WHEN 'd'::"char" THEN (t.typname)::character varying(128)
            ELSE NULL::character varying(128)
        END AS domain_name
   FROM (((((pg_attribute a
     JOIN pg_class c ON (((c.oid = a.attrelid) AND (c.relkind = 'r'::"char"))))
     LEFT JOIN pg_attrdef d ON (((d.adrelid = c.oid) AND (d.adnum = a.attnum))))
     JOIN pg_namespace s ON ((s.oid = c.relnamespace)))
     JOIN pg_type t ON ((t.oid = a.atttypid)))
     LEFT JOIN pg_collation coll ON ((coll.oid = t.typcollation)))
  WHERE (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="ad1ab549-695d-4798-a4b8-5fc830003dc9" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="9d853c54-33b7-4cbc-859f-c0d220dce916" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="60a62f42-f10c-453d-ad7d-d048d5867ff4" name="information_schema_constraint_column_usage" context="information_schema_constraint_column_usage" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS table_catalog,
    s.nspname AS table_schema,
    t.relname AS table_name,
    a.attname AS column_name,
    current_database() AS constraint_catalog,
    s.nspname AS constraint_schema,
    c.conname AS constraint_name
   FROM (((pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
     JOIN pg_class t ON ((t.oid = c.conrelid)))
     JOIN pg_attribute a ON (((a.attrelid = c.conrelid) AND (a.attnum = ANY (c.conkey)))))
  WHERE (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="b235a372-cf4b-4623-b8f8-6e229d7d429e" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="83dfaca7-0a2e-4c29-9d37-be1ed08cf6a8" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="db7e52b5-c6f4-4601-b584-92f1af0e048b" name="information_schema_constraint_table_usage" context="information_schema_constraint_table_usage" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS table_catalog,
    s.nspname AS table_schema,
    t.relname AS table_name,
    current_database() AS constraint_catalog,
    s.nspname AS constraint_schema,
    c.conname AS constraint_name
   FROM ((pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
     JOIN pg_class t ON ((t.oid = c.conrelid)))
  WHERE (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="9d7dd917-9bed-4bb6-9da8-29a8486af2f2" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="77b33a3f-ef21-4b01-9d8b-4a70bc68bf57" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="7f1830cd-f506-4374-9ebb-0786d05f010f" name="information_schema_key_column_usage" context="information_schema_key_column_usage" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS constraint_catalog,
    s.nspname AS constraint_schema,
    c.conname AS constraint_name,
    current_database() AS table_catalog,
    s.nspname AS table_schema,
    t.relname AS table_name,
    a.attname AS column_name,
    a.attnum AS ordinal_position
   FROM (((pg_constraint c
     JOIN pg_attribute a ON (((a.attrelid = c.conrelid) AND (a.attnum = ANY (c.conkey)))))
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
     JOIN pg_class t ON ((t.oid = c.conrelid)))
  WHERE ((s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND (c.contype = 'p'::"char"));]]></complex-attribute>
                        <category _I_D="99852d09-71b4-4ea5-8222-acc24bfc7816" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="9215bccf-b579-4565-a4cf-c167b45823c1" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="45266a79-6900-44ca-95f8-fd93bb022aab" name="information_schema_referential_constraints" context="information_schema_referential_constraints" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS constraint_catalog,
    s.nspname AS constraint_schema,
    c.conname AS constraint_name,
    current_database() AS unique_constraint_catalog,
    ( SELECT pk.conname
           FROM pg_constraint pk
          WHERE ((pk.conrelid = c.confrelid) AND (pk.contype = 'p'::"char"))
         LIMIT 1) AS conname,
    'SIMPLE'::character varying(7) AS match_option,
        CASE c.confupdtype
            WHEN 'a'::"char" THEN 'NO_ACTION'::text
            WHEN 'r'::"char" THEN 'NO_ACTION'::text
            WHEN 'c'::"char" THEN 'CASCADE'::text
            WHEN 'n'::"char" THEN 'SET_NULL'::text
            WHEN 'd'::"char" THEN 'SET_DEFAULT'::text
            ELSE NULL::text
        END AS update_rule,
        CASE c.confdeltype
            WHEN 'a'::"char" THEN 'NO_ACTION'::text
            WHEN 'r'::"char" THEN 'NO_ACTION'::text
            WHEN 'c'::"char" THEN 'CASCADE'::text
            WHEN 'n'::"char" THEN 'SET_NULL'::text
            WHEN 'd'::"char" THEN 'SET_DEFAULT'::text
            ELSE NULL::text
        END AS delete_rule
   FROM (pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
  WHERE ((s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND (c.contype = 'f'::"char"));]]></complex-attribute>
                        <category _I_D="ffc07685-a90c-4111-a799-67c58e67b023" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="15347030-203a-432f-9ba5-c8c00dbba39b" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="997b86f8-39d8-4c61-ae98-173a6a65284d" name="information_schema_routines" context="information_schema_routines" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS specific_catalog,
    s.nspname AS specific_schema,
    p.proname AS specific_name,
    current_database() AS routine_catalog,
    s.nspname AS routine_schema,
    p.proname AS routine_name,
        CASE format_type(p.prorettype, NULL::integer)
            WHEN 'void'::text THEN 'PROCEDURE'::character varying(20)
            ELSE 'FUNCTION'::character varying(20)
        END AS routine_type,
    NULL::character varying(128) AS module_catalog,
    NULL::character varying(128) AS module_schema,
    NULL::character varying(128) AS module_name,
    NULL::character varying(128) AS udt_catalog,
    NULL::character varying(128) AS udt_schema,
    NULL::character varying(128) AS udt_name,
        CASE format_type(p.prorettype, NULL::integer)
            WHEN 'void'::text THEN (NULL::character varying(128))::text
            ELSE format_type(p.prorettype, NULL::integer)
        END AS data_type,
    t.typlen AS character_maximum_length,
    t.typlen AS character_octet_length,
    NULL::character varying(128) AS collation_catalog,
    NULL::character varying(128) AS collation_schema,
    c.collname,
    NULL::character varying(128) AS character_set_catalog,
    NULL::character varying(128) AS character_set_schema,
    ( SELECT pg_encoding_to_char(pg_database.encoding) AS pg_encoding_to_char
           FROM pg_database
          WHERE (pg_database.datname = current_database())) AS character_set_name,
    NULL::smallint AS numeric_precision,
    NULL::smallint AS numeric_precision_radix,
    NULL::smallint AS numeric_scale,
    NULL::smallint AS datetime_precision,
    NULL::character varying(30) AS interval_type,
    NULL::smallint AS interval_precision,
    NULL::character varying(128) AS type_udt_catalog,
    NULL::character varying(128) AS type_udt_schema,
    NULL::character varying(128) AS type_udt_name,
    NULL::character varying(128) AS scope_catalog,
    NULL::character varying(128) AS scope_schema,
    NULL::character varying(128) AS scope_name,
    NULL::bigint AS maximum_cardinality,
    NULL::character varying(128) AS dtd_identifier,
    'SQL'::character varying(30) AS routine_body,
    pg_get_functiondef(p.oid) AS routine_definition,
    NULL::character varying(128) AS external_name,
    NULL::character varying(30) AS external_language,
    NULL::character varying(30) AS parameter_style,
        CASE p.provolatile
            WHEN 'i'::"char" THEN 'YES'::text
            ELSE 'NO'::text
        END AS is_deterministic,
        CASE format_type(p.prorettype, NULL::integer)
            WHEN 'void'::text THEN 'MODIFIES'::character varying(30)
            ELSE 'READS'::character varying
        END AS sql_data_access,
        CASE
            WHEN p.proisstrict THEN 'NO'::character varying(10)
            ELSE NULL::character varying(10)
        END AS is_null_call,
    NULL::character varying(128) AS sql_path,
    'YES'::character varying(10) AS schema_level_routine,
    0 AS max_dynamic_result_sets,
    'NO'::character varying(10) AS is_user_defined_cast,
    'NO'::character varying(10) AS is_implicitly_invocable,
    NULL::timestamp without time zone AS created,
    NULL::timestamp without time zone AS last_altered
   FROM (((pg_proc p
     JOIN pg_namespace s ON ((s.oid = p.pronamespace)))
     JOIN pg_type t ON ((t.oid = p.prorettype)))
     LEFT JOIN pg_collation c ON ((c.oid = t.typcollation)))
  WHERE ((s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND pg_function_is_visible(p.oid));]]></complex-attribute>
                        <category _I_D="338c68ff-4b9d-4a56-9bc0-afd26c29f1b6" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="815ca82c-5b40-4758-98bd-5ac14a62a859" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="14f62341-6625-443f-8119-86d17ee30042" name="information_schema_schemata" context="information_schema_schemata" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS catalog_name,
    s.nspname AS schema_name,
    a.rolname AS schema_owner,
    NULL::character varying(6) AS default_character_set_catalog,
    NULL::character varying(6) AS default_character_set_schema,
    ( SELECT pg_encoding_to_char(pg_database.encoding) AS pg_encoding_to_char
           FROM pg_database
          WHERE (pg_database.datname = current_database())) AS default_character_set_name
   FROM (pg_namespace s
     JOIN pg_authid a ON ((a.oid = s.nspowner)))
  WHERE (has_schema_privilege((s.nspname)::text, 'USAGE'::text) AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])));]]></complex-attribute>
                        <category _I_D="3b54d874-6d4a-4bd1-baf9-10012d680ef3" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="8f142340-a5b8-4458-a623-65b03e4420ba" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="209ca791-90ae-492e-8ec7-8c95b039955c" name="information_schema_table_constraints" context="information_schema_table_constraints" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS constraint_catalog,
    s.nspname AS constraint_schema,
    c.conname AS constraint_name,
    current_database() AS table_catalog,
    s.nspname AS table_schema,
    t.relname AS table_name,
        CASE c.contype
            WHEN 'c'::"char" THEN 'CHECK'::text
            WHEN 'f'::"char" THEN 'FOREIGN KEY'::text
            WHEN 'p'::"char" THEN 'PRIMARY KEY'::text
            WHEN 'u'::"char" THEN 'UNIQUE'::text
            ELSE 'OTHER'::text
        END AS constraint_type,
    'NO'::character varying(2) AS is_deferrable,
    'NO'::character varying(2) AS initially_deferred
   FROM ((pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
     JOIN pg_class t ON ((t.oid = c.conrelid)))
  WHERE (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="5d062b29-2e8c-499e-a152-cb5ce5914a13" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="c28e110b-e465-4f78-8e92-ace38737f943" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="fa20c1ff-3099-493d-8890-d7a8bf4f5cb0" name="information_schema_tables" context="information_schema_tables" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS table_catalog,
    s.nspname AS table_schema,
    t.tablename AS table_name,
    'BASE TABLE'::text AS table_type
   FROM ((pg_tables t
     JOIN pg_namespace s ON ((s.nspname = t.schemaname)))
     JOIN pg_class c ON (((c.relname = t.tablename) AND (c.relnamespace = s.oid))))
  WHERE (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]))
UNION ALL
 SELECT current_database() AS table_catalog,
    s.nspname AS table_schema,
    v.viewname AS table_name,
    'VIEW'::text AS table_type
   FROM ((pg_views v
     JOIN pg_namespace s ON ((s.nspname = v.schemaname)))
     JOIN pg_class c ON (((c.relname = v.viewname) AND (c.relnamespace = s.oid))))
  WHERE (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="9639bc4a-ceef-42d7-957e-a5f6be4be85b" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="83bc63bd-8275-4eff-a17e-aa1a288d8f57" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="c29a08ce-8a13-486e-b10c-6ec79385a667" name="information_schema_views" context="information_schema_views" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT current_database() AS table_catalog,
    s.nspname AS table_schema,
    v.viewname AS table_name,
    v.definition AS view_definition,
    'NONE'::character varying(7) AS check_option,
    'NO'::character varying(2) AS is_updatable
   FROM ((pg_views v
     JOIN pg_namespace s ON ((s.nspname = v.schemaname)))
     JOIN pg_class c ON (((c.relname = v.viewname) AND (c.relnamespace = s.oid))))
  WHERE (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="11348b04-d3d8-4e7c-aee6-2315a1081fa0" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="263b5acd-3c13-459d-87ba-17810ae7ec8c" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="f6bbb783-2960-40eb-8853-614c150f826f" name="sys_all_columns" context="sys_all_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT c.oid AS object_id,
    a.attname AS name,
    a.attnum AS column_id,
    t.oid AS system_type_id,
    t.oid AS user_type_id,
    a.attlen AS max_length,
    NULL::integer AS "precision",
    NULL::integer AS scale,
    coll.collname AS collation_name,
        CASE
            WHEN a.attnotnull THEN 0
            ELSE 1
        END AS is_nullable,
    0 AS is_ansi_padded,
    0 AS is_rowguidcol,
    0 AS is_identity,
    0 AS is_computed,
    0 AS is_filestream,
    0 AS is_replicated,
    0 AS is_non_sql_subscribed,
    0 AS is_merge_published,
    0 AS is_dts_replicated,
    0 AS is_xml_document,
    0 AS xml_collection_id,
    COALESCE(d.oid, (0)::oid) AS default_object_id,
    COALESCE(( SELECT pg_constraint.oid
           FROM pg_constraint
          WHERE ((pg_constraint.conrelid = t.oid) AND (pg_constraint.contype = 'c'::"char") AND (a.attnum = ANY (pg_constraint.conkey)))
         LIMIT 1), (0)::oid) AS rule_object_id,
    0 AS is_sparse,
    0 AS is_column_set,
    0 AS generated_always_type,
    'NOT_APPLICABLE'::character varying(60) AS generated_always_type_desc,
    NULL::integer AS encryption_type,
    NULL::character varying(64) AS encryption_type_desc,
    NULL::character varying AS encryption_algorithm_name,
    NULL::integer AS column_encryption_key_id,
    NULL::character varying AS column_encryption_key_database_name,
    0 AS is_hidden,
    0 AS is_masked
   FROM (((((pg_attribute a
     JOIN pg_class c ON ((c.oid = a.attrelid)))
     JOIN pg_type t ON ((t.oid = a.atttypid)))
     JOIN pg_namespace s ON ((s.oid = c.relnamespace)))
     LEFT JOIN pg_attrdef d ON (((c.oid = d.adrelid) AND (a.attnum = d.adnum))))
     LEFT JOIN pg_collation coll ON ((coll.oid = t.typcollation)))
  WHERE ((NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'm'::"char", 'f'::"char", 'p'::"char"])) AND has_column_privilege(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((c.relname)::text)), (a.attname)::text, 'SELECT,INSERT,UPDATE,REFERENCES'::text));]]></complex-attribute>
                        <category _I_D="1139ddd3-f054-492d-a6c4-f1ec0c8795b3" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="7baae896-b1e9-43eb-81fa-e9ad1eedd4ab" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="949621a7-4003-437b-8abd-92c0ba60d7bf" name="sys_all_objects" context="sys_all_objects" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT t.name,
    t.object_id,
    t.principal_id,
    t.schema_id,
    t.parent_object_id,
    'U'::text AS type,
    'USER_TABLE'::text AS type_desc,
    t.create_date,
    t.modify_date,
    t.is_ms_shipped,
    t.is_published,
    t.is_schema_published
   FROM aws_sqlserver_ext.sys_tables t
UNION ALL
 SELECT v.name,
    v.object_id,
    v.principal_id,
    v.schema_id,
    v.parent_object_id,
    'V'::text AS type,
    'VIEW'::text AS type_desc,
    v.create_date,
    v.modify_date,
    v.is_ms_shipped,
    v.is_published,
    v.is_schema_published
   FROM aws_sqlserver_ext.sys_all_views v
UNION ALL
 SELECT f.name,
    f.object_id,
    f.principal_id,
    f.schema_id,
    f.parent_object_id,
    'F'::text AS type,
    'FOREIGN_KEY_CONSTRAINT'::text AS type_desc,
    f.create_date,
    f.modify_date,
    f.is_ms_shipped,
    f.is_published,
    f.is_schema_published
   FROM aws_sqlserver_ext.sys_foreign_keys f
UNION ALL
 SELECT p.name,
    p.object_id,
    p.principal_id,
    p.schema_id,
    p.parent_object_id,
    'PK'::text AS type,
    'PRIMARY_KEY_CONSTRAINT'::text AS type_desc,
    p.create_date,
    p.modify_date,
    p.is_ms_shipped,
    p.is_published,
    p.is_schema_published
   FROM aws_sqlserver_ext.sys_key_constraints p
UNION ALL
 SELECT pr.name,
    pr.object_id,
    pr.principal_id,
    pr.schema_id,
    pr.parent_object_id,
    pr.type,
    pr.type_desc,
    pr.create_date,
    pr.modify_date,
    pr.is_ms_shipped,
    pr.is_published,
    pr.is_schema_published
   FROM aws_sqlserver_ext.sys_procedures pr
UNION ALL
 SELECT p.relname AS name,
    p.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    0 AS parent_object_id,
    'SO'::character varying(2) AS type,
    'SEQUENCE_OBJECT'::character varying(60) AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published
   FROM (pg_class p
     JOIN pg_namespace s ON ((s.oid = p.relnamespace)))
  WHERE (p.relkind = 'S'::"char");]]></complex-attribute>
                        <category _I_D="47009e30-932e-4129-8e49-98d197dc1456" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="8ba94d37-1e59-41b9-884d-c3912e647d3b" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="bca1dbb2-9a2a-427d-b45d-5f7fa073b231" name="sys_all_views" context="sys_all_views" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT t.relname AS name,
    t.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    0 AS parent_object_id,
    'V'::character varying(2) AS type,
    'VIEW'::character varying(60) AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published,
    0 AS with_check_option,
    0 AS is_date_correlation_view,
    0 AS is_tracked_by_cdc
   FROM (pg_class t
     JOIN pg_namespace s ON ((s.oid = t.relnamespace)))
  WHERE ((t.relkind = 'v'::"char") AND has_table_privilege(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((t.relname)::text)), 'SELECT,INSERT,UPDATE,DELETE,TRUNCATE,TRIGGER'::text));]]></complex-attribute>
                        <category _I_D="03a9fff8-5cb9-4415-8741-401d4c978b89" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e0429323-00dd-44b7-b5d2-87fe637ca43e" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="9751df52-a0d5-4bc3-bc2f-458cc2ee206f" name="sys_columns" context="sys_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT c.oid AS object_id,
    a.attname AS name,
    a.attnum AS column_id,
    t.oid AS system_type_id,
    t.oid AS user_type_id,
    a.attlen AS max_length,
    NULL::integer AS "precision",
    NULL::integer AS scale,
    coll.collname AS collation_name,
        CASE
            WHEN a.attnotnull THEN 0
            ELSE 1
        END AS is_nullable,
    0 AS is_ansi_padded,
    0 AS is_rowguidcol,
    0 AS is_identity,
    0 AS is_computed,
    0 AS is_filestream,
    0 AS is_replicated,
    0 AS is_non_sql_subscribed,
    0 AS is_merge_published,
    0 AS is_dts_replicated,
    0 AS is_xml_document,
    0 AS xml_collection_id,
    COALESCE(d.oid, (0)::oid) AS default_object_id,
    COALESCE(( SELECT pg_constraint.oid
           FROM pg_constraint
          WHERE ((pg_constraint.conrelid = t.oid) AND (pg_constraint.contype = 'c'::"char") AND (a.attnum = ANY (pg_constraint.conkey)))
         LIMIT 1), (0)::oid) AS rule_object_id,
    0 AS is_sparse,
    0 AS is_column_set,
    0 AS generated_always_type,
    'NOT_APPLICABLE'::character varying(60) AS generated_always_type_desc,
    NULL::integer AS encryption_type,
    NULL::character varying(64) AS encryption_type_desc,
    NULL::character varying AS encryption_algorithm_name,
    NULL::integer AS column_encryption_key_id,
    NULL::character varying AS column_encryption_key_database_name,
    0 AS is_hidden,
    0 AS is_masked
   FROM (((((pg_attribute a
     JOIN pg_class c ON ((c.oid = a.attrelid)))
     JOIN pg_type t ON ((t.oid = a.atttypid)))
     JOIN pg_namespace s ON ((s.oid = c.relnamespace)))
     LEFT JOIN pg_attrdef d ON (((c.oid = d.adrelid) AND (a.attnum = d.adnum))))
     LEFT JOIN pg_collation coll ON ((coll.oid = t.typcollation)))
  WHERE ((NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'm'::"char", 'f'::"char", 'p'::"char"])) AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND has_column_privilege(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((c.relname)::text)), (a.attname)::text, 'SELECT,INSERT,UPDATE,REFERENCES'::text));]]></complex-attribute>
                        <category _I_D="608b5185-543c-453f-b780-f3335f20498e" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="9a99aa27-50e9-4492-8e30-42b32e384142" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="52db7f45-d02b-4477-96c4-1e043452675b" name="sys_databases" context="sys_databases" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT datname AS name,
    oid AS database_id,
    NULL::integer AS source_database_id,
    NULL::character varying(85) AS owner_sid,
    NULL::integer AS compatibility_level,
    datcollate AS collation_name,
    0 AS user_access,
    NULL::character varying(60) AS user_access_desc,
    0 AS is_read_only,
    0 AS is_auto_close_on,
    0 AS is_auto_shrink_on,
    0 AS state,
    'ONLINE'::character varying(60) AS state_desc,
    0 AS is_in_standby,
    0 AS is_cleanly_shutdown,
    0 AS is_supplemental_logging_enabled,
    0 AS snapshot_isolation_state,
    NULL::character varying(60) AS snapshot_isolation_state_desc,
    0 AS is_read_committed_snapshot_on,
    1 AS recovery_model,
    'FULL'::character varying(60) AS recovery_model_desc,
    0 AS page_verify_option,
    NULL::character varying(60) AS page_verify_option_desc,
    1 AS is_auto_create_stats_on,
    0 AS is_auto_update_stats_on,
    0 AS is_auto_update_stats_async_on,
    0 AS is_ansi_null_default_on,
    0 AS is_ansi_nulls_on,
    0 AS is_ansi_padding_on,
    0 AS is_ansi_warnings_on,
    0 AS is_arithabort_on,
    0 AS is_concat_null_yields_null_on,
    0 AS is_numeric_roundabort_on,
    0 AS is_quoted_identifier_on,
    0 AS is_recursive_triggers_on,
    0 AS is_cursor_close_on_commit_on,
    0 AS is_local_cursor_default,
    0 AS is_fulltext_enabled,
    0 AS is_trustworthy_on,
    0 AS is_db_chaining_on,
    0 AS is_parameterization_forced,
    0 AS is_master_key_encrypted_by_server,
    0 AS is_published,
    0 AS is_subscribed,
    0 AS is_merge_published,
    0 AS is_distributor,
    0 AS is_sync_with_backup,
    NULL::oid AS service_broker_guid,
    0 AS is_broker_enabled,
    0 AS log_reuse_wait,
    'NOTHING'::character varying(60) AS log_reuse_wait_desc,
    0 AS is_date_correlation_on,
    0 AS is_cdc_enabled,
    0 AS is_encrypted,
    0 AS is_honor_broker_priority_on,
    NULL::oid AS replica_id,
    NULL::oid AS group_database_id,
    NULL::oid AS default_language_lcid,
    NULL::character varying(128) AS default_language_name,
    NULL::oid AS default_fulltext_language_lcid,
    NULL::character varying(128) AS default_fulltext_language_name,
    NULL::integer AS is_nested_triggers_on,
    NULL::integer AS is_transform_noise_words_on,
    NULL::integer AS two_digit_year_cutoff,
    0 AS containment,
    'NONE'::character varying(60) AS containment_desc,
    0 AS target_recovery_time_in_seconds,
    0 AS is_federation_member,
    0 AS is_memory_optimized_elevate_to_snapshot_on,
    0 AS is_auto_create_stats_incremental_on,
    0 AS is_query_store_on,
    NULL::integer AS resource_pool_id
   FROM pg_database d;]]></complex-attribute>
                        <category _I_D="65177267-a403-4cb9-b468-4efd33407137" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="91694a1e-c5b2-4ac9-83ce-6afe846b9e40" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="dffb984f-8222-49bf-8c95-cb371264e66c" name="sys_foreign_key_columns" context="sys_foreign_key_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT DISTINCT c.oid AS constraint_object_id,
    c.confkey AS constraint_column_id,
    c.conrelid AS parent_object_id,
    a_con.attnum AS parent_column_id,
    c.confrelid AS referenced_object_id,
    a_conf.attnum AS referenced_column_id
   FROM ((pg_constraint c
     JOIN pg_attribute a_con ON (((a_con.attrelid = c.conrelid) AND (a_con.attnum = ANY (c.conkey)))))
     JOIN pg_attribute a_conf ON (((a_conf.attrelid = c.confrelid) AND (a_conf.attnum = ANY (c.confkey)))))
  WHERE (c.contype = 'f'::"char");]]></complex-attribute>
                        <category _I_D="d39ff287-8220-4f2c-a329-b0f560b3f682" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="fc905788-ae93-4f56-9e1e-d1df557aaeaf" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="c4791edb-9c81-44b6-9144-9965844e2f45" name="sys_foreign_keys" context="sys_foreign_keys" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT c.conname AS name,
    c.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    c.conrelid AS parent_object_id,
    'F'::character varying(2) AS type,
    'FOREIGN_KEY_CONSTRAINT'::character varying(60) AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published,
    c.confrelid AS referenced_object_id,
    c.confkey AS key_index_id,
    0 AS is_disabled,
    0 AS is_not_for_replication,
    0 AS is_not_trusted,
        CASE c.confdeltype
            WHEN 'a'::"char" THEN 0
            WHEN 'r'::"char" THEN 0
            WHEN 'c'::"char" THEN 1
            WHEN 'n'::"char" THEN 2
            WHEN 'd'::"char" THEN 3
            ELSE NULL::integer
        END AS delete_referential_action,
        CASE c.confdeltype
            WHEN 'a'::"char" THEN 'NO_ACTION'::text
            WHEN 'r'::"char" THEN 'NO_ACTION'::text
            WHEN 'c'::"char" THEN 'CASCADE'::text
            WHEN 'n'::"char" THEN 'SET_NULL'::text
            WHEN 'd'::"char" THEN 'SET_DEFAULT'::text
            ELSE NULL::text
        END AS delete_referential_action_desc,
        CASE c.confupdtype
            WHEN 'a'::"char" THEN 0
            WHEN 'r'::"char" THEN 0
            WHEN 'c'::"char" THEN 1
            WHEN 'n'::"char" THEN 2
            WHEN 'd'::"char" THEN 3
            ELSE NULL::integer
        END AS update_referential_action,
        CASE c.confupdtype
            WHEN 'a'::"char" THEN 'NO_ACTION'::text
            WHEN 'r'::"char" THEN 'NO_ACTION'::text
            WHEN 'c'::"char" THEN 'CASCADE'::text
            WHEN 'n'::"char" THEN 'SET_NULL'::text
            WHEN 'd'::"char" THEN 'SET_DEFAULT'::text
            ELSE NULL::text
        END AS update_referential_action_desc,
    1 AS is_system_named
   FROM (pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
  WHERE ((c.contype = 'f'::"char") AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])));]]></complex-attribute>
                        <category _I_D="b984303f-dc99-4984-9f8e-a51dbba62f83" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="c58b3e92-1beb-42fb-bfb8-d121fedf9d3a" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="b412ae70-e487-4ed6-ad38-ac79910eeb73" name="sys_identity_columns" context="sys_identity_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT aws_sqlserver_ext.get_id_by_name(((c.oid)::text || (a.attname)::text)) AS object_id,
    a.attname AS name,
    a.attnum AS column_id,
    t.oid AS system_type_id,
    t.oid AS user_type_id,
    a.attlen AS max_length,
    NULL::integer AS "precision",
    NULL::integer AS scale,
    coll.collname AS collation_name,
        CASE
            WHEN a.attnotnull THEN 0
            ELSE 1
        END AS is_nullable,
    0 AS is_ansi_padded,
    0 AS is_rowguidcol,
    1 AS is_identity,
    0 AS is_computed,
    0 AS is_filestream,
    0 AS is_replicated,
    0 AS is_non_sql_subscribed,
    0 AS is_merge_published,
    0 AS is_dts_replicated,
    0 AS is_xml_document,
    0 AS xml_collection_id,
    COALESCE(d.oid, (0)::oid) AS default_object_id,
    COALESCE(( SELECT pg_constraint.oid
           FROM pg_constraint
          WHERE ((pg_constraint.conrelid = t.oid) AND (pg_constraint.contype = 'c'::"char") AND (a.attnum = ANY (pg_constraint.conkey)))
         LIMIT 1), (0)::oid) AS rule_object_id,
    0 AS is_sparse,
    0 AS is_column_set,
    0 AS generated_always_type,
    'NOT_APPLICABLE'::character varying(60) AS generated_always_type_desc,
    NULL::integer AS encryption_type,
    NULL::character varying(64) AS encryption_type_desc,
    NULL::character varying AS encryption_algorithm_name,
    NULL::integer AS column_encryption_key_id,
    NULL::character varying AS column_encryption_key_database_name,
    0 AS is_hidden,
    0 AS is_masked,
    NULL::bigint AS seed_value,
    NULL::bigint AS increment_value,
    aws_sqlserver_ext.get_sequence_value((pg_get_serial_sequence(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((c.relname)::text)), (a.attname)::text))::character varying) AS last_value
   FROM (((((pg_attribute a
     LEFT JOIN pg_attrdef d ON (((a.attrelid = d.adrelid) AND (a.attnum = d.adnum))))
     JOIN pg_class c ON ((c.oid = a.attrelid)))
     JOIN pg_namespace s ON ((s.oid = c.relnamespace)))
     LEFT JOIN pg_type t ON ((t.oid = a.atttypid)))
     LEFT JOIN pg_collation coll ON ((coll.oid = t.typcollation)))
  WHERE ((NOT a.attisdropped) AND (pg_get_serial_sequence(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((c.relname)::text)), (a.attname)::text) IS NOT NULL) AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND has_sequence_privilege(pg_get_serial_sequence(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((c.relname)::text)), (a.attname)::text), 'USAGE,SELECT,UPDATE'::text));]]></complex-attribute>
                        <category _I_D="de6bb7f3-c53a-40ca-986e-7b0b2861b3e6" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="f1ddfcc5-6e0d-46bd-8e0b-8a7a46ec9660" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="47b6f664-f056-4482-b4c3-9057ec7ad90a" name="sys_indexes" context="sys_indexes" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT i.indrelid AS object_id,
    c.relname AS name,
        CASE
            WHEN i.indisclustered THEN 1
            ELSE 2
        END AS type,
        CASE
            WHEN i.indisclustered THEN 'CLUSTERED'::character varying(60)
            ELSE 'NONCLUSTERED'::character varying(60)
        END AS type_desc,
        CASE
            WHEN i.indisunique THEN 1
            ELSE 0
        END AS is_unique,
    c.reltablespace AS data_space_id,
    0 AS ignore_dup_key,
        CASE
            WHEN i.indisprimary THEN 1
            ELSE 0
        END AS is_primary_key,
        CASE
            WHEN (constr.oid IS NULL) THEN 0
            ELSE 1
        END AS is_unique_constraint,
    0 AS fill_factor,
        CASE
            WHEN (i.indpred IS NULL) THEN 0
            ELSE 1
        END AS is_padded,
        CASE
            WHEN i.indisready THEN 0
            ELSE 1
        END AS is_disabled,
    0 AS is_hypothetical,
    1 AS allow_row_locks,
    1 AS allow_page_locks,
    0 AS has_filter,
    NULL::character varying AS filter_definition,
    0 AS auto_created
   FROM (((pg_class c
     JOIN pg_namespace s ON ((s.oid = c.relnamespace)))
     JOIN pg_index i ON ((i.indexrelid = c.oid)))
     LEFT JOIN pg_constraint constr ON ((constr.conindid = c.oid)))
  WHERE ((c.relkind = 'i'::"char") AND i.indislive AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])));]]></complex-attribute>
                        <category _I_D="9a1e0fad-c355-4b3e-8290-354b60ac80c0" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="7467d6b1-451b-41cf-b541-7614dd545805" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="278809cc-0492-4b47-b8a2-c0a6327e111d" name="sys_key_constraints" context="sys_key_constraints" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT c.conname AS name,
    c.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    c.conrelid AS parent_object_id,
        CASE c.contype
            WHEN 'p'::"char" THEN 'PK'::character varying(2)
            WHEN 'u'::"char" THEN 'UQ'::character varying(2)
            ELSE NULL::character varying
        END AS type,
        CASE c.contype
            WHEN 'p'::"char" THEN 'PRIMARY_KEY_CONSTRAINT'::character varying(60)
            WHEN 'u'::"char" THEN 'UNIQUE_CONSTRAINT'::character varying(60)
            ELSE NULL::character varying
        END AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    c.conindid AS unique_index_id,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published
   FROM (pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
  WHERE (c.contype = 'p'::"char");]]></complex-attribute>
                        <category _I_D="faf01762-736a-4357-8e00-bf45dab4180f" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="ad4e9a08-0a73-4637-8afd-2e37194a1ec8" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="6de52916-b98e-4592-acd5-be49c2de1eb9" name="sys_objects" context="sys_objects" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT t.name,
    t.object_id,
    t.principal_id,
    t.schema_id,
    t.parent_object_id,
    'U'::text AS type,
    'USER_TABLE'::text AS type_desc,
    t.create_date,
    t.modify_date,
    t.is_ms_shipped,
    t.is_published,
    t.is_schema_published
   FROM aws_sqlserver_ext.sys_tables t
UNION ALL
 SELECT v.name,
    v.object_id,
    v.principal_id,
    v.schema_id,
    v.parent_object_id,
    'V'::text AS type,
    'VIEW'::text AS type_desc,
    v.create_date,
    v.modify_date,
    v.is_ms_shipped,
    v.is_published,
    v.is_schema_published
   FROM aws_sqlserver_ext.sys_views v
UNION ALL
 SELECT f.name,
    f.object_id,
    f.principal_id,
    f.schema_id,
    f.parent_object_id,
    'F'::text AS type,
    'FOREIGN_KEY_CONSTRAINT'::text AS type_desc,
    f.create_date,
    f.modify_date,
    f.is_ms_shipped,
    f.is_published,
    f.is_schema_published
   FROM aws_sqlserver_ext.sys_foreign_keys f
UNION ALL
 SELECT p.name,
    p.object_id,
    p.principal_id,
    p.schema_id,
    p.parent_object_id,
    'PK'::text AS type,
    'PRIMARY_KEY_CONSTRAINT'::text AS type_desc,
    p.create_date,
    p.modify_date,
    p.is_ms_shipped,
    p.is_published,
    p.is_schema_published
   FROM aws_sqlserver_ext.sys_key_constraints p
UNION ALL
 SELECT pr.name,
    pr.object_id,
    pr.principal_id,
    pr.schema_id,
    pr.parent_object_id,
    pr.type,
    pr.type_desc,
    pr.create_date,
    pr.modify_date,
    pr.is_ms_shipped,
    pr.is_published,
    pr.is_schema_published
   FROM aws_sqlserver_ext.sys_procedures pr
UNION ALL
 SELECT p.relname AS name,
    p.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    0 AS parent_object_id,
    'SO'::character varying(2) AS type,
    'SEQUENCE_OBJECT'::character varying(60) AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published
   FROM (pg_class p
     JOIN pg_namespace s ON ((s.oid = p.relnamespace)))
  WHERE ((s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND (p.relkind = 'S'::"char"));]]></complex-attribute>
                        <category _I_D="d0941e3a-9508-4d13-85ed-50b9638c9af6" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="94bcfdca-4e4c-4410-b978-668072085fa7" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="f33f10e4-ac79-442d-a17b-02e0e7591d5b" name="sys_procedures" context="sys_procedures" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT p.proname AS name,
    p.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    0 AS parent_object_id,
        CASE format_type(p.prorettype, NULL::integer)
            WHEN 'void'::text THEN 'P'::character varying(2)
            ELSE
            CASE format_type(p.prorettype, NULL::integer)
                WHEN 'trigger'::text THEN 'TR'::character varying(2)
                ELSE 'FN'::character varying(2)
            END
        END AS type,
        CASE format_type(p.prorettype, NULL::integer)
            WHEN 'void'::text THEN 'SQL_STORED_PROCEDURE'::character varying(60)
            ELSE
            CASE format_type(p.prorettype, NULL::integer)
                WHEN 'trigger'::text THEN 'SQL_TRIGGER'::character varying(60)
                ELSE 'SQL_SCALAR_FUNCTION'::character varying(60)
            END
        END AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published
   FROM (pg_proc p
     JOIN pg_namespace s ON ((s.oid = p.pronamespace)))
  WHERE ((s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND pg_function_is_visible(p.oid));]]></complex-attribute>
                        <category _I_D="328dbc76-6087-4ea6-a5ff-b841d321915c" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="c2f61c2f-44f8-4dd4-9b18-e999b71948cb" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="b722a31a-b8fb-4b13-a4bd-59fb1677e8b9" name="sys_schemas" context="sys_schemas" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT nspname AS name,
    oid AS schema_id,
    oid AS principal_id
   FROM pg_namespace
  WHERE (nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="1aac6165-dd7c-49ad-9aa2-4f57cf985dfa" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e6dd30db-7284-4d9b-8376-d3f3e42f6981" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="edbaea87-8d5f-4fc0-a495-dd0caca92a36" name="sys_sql_modules" context="sys_sql_modules" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT p.oid AS object_id,
    pg_get_functiondef(p.oid) AS definition,
    1 AS uses_ansi_nulls,
    1 AS uses_quoted_identifier,
    0 AS is_schema_bound,
    0 AS uses_database_collation,
    0 AS is_recompiled,
        CASE
            WHEN p.proisstrict THEN 1
            ELSE 0
        END AS null_on_null_input,
    NULL::integer AS execute_as_principal_id,
    0 AS uses_native_compilation
   FROM (((pg_proc p
     JOIN pg_namespace s ON ((s.oid = p.pronamespace)))
     JOIN pg_type t ON ((t.oid = p.prorettype)))
     LEFT JOIN pg_collation c ON ((c.oid = t.typcollation)))
  WHERE ((s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])) AND pg_function_is_visible(p.oid));]]></complex-attribute>
                        <category _I_D="be7a54a1-3a67-4662-9a21-6ecb6a26b2f8" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="fbfe5a51-b1d9-4e76-ab3f-1f2df85f2822" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="34fc1d29-c175-44d1-a9d3-9e58a954eb9d" name="sys_sysforeignkeys" context="sys_sysforeignkeys" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT c.conname AS name,
    c.oid AS object_id,
    c.conrelid AS fkeyid,
    c.confrelid AS rkeyid,
    a_con.attnum AS fkey,
    a_conf.attnum AS rkey,
    a_conf.attnum AS keyno
   FROM (((pg_constraint c
     JOIN pg_namespace s ON ((s.oid = c.connamespace)))
     JOIN pg_attribute a_con ON (((a_con.attrelid = c.conrelid) AND (a_con.attnum = ANY (c.conkey)))))
     JOIN pg_attribute a_conf ON (((a_conf.attrelid = c.confrelid) AND (a_conf.attnum = ANY (c.confkey)))))
  WHERE ((c.contype = 'f'::"char") AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])));]]></complex-attribute>
                        <category _I_D="75821623-3141-440c-a574-ef232a4dd570" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="25a4c85b-0027-48ad-9c3e-3543ea3cfde3" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="5fa1b62b-e2d6-4ec7-b8c6-39519e110261" name="sys_sysindexes" context="sys_sysindexes" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT object_id AS id,
    NULL::integer AS status,
    NULL::oid AS first,
    type AS indid,
    NULL::oid AS root,
    0 AS minlen,
    1 AS keycnt,
    0 AS groupid,
    0 AS dpages,
    0 AS reserved,
    0 AS used,
    0 AS rowcnt,
    0 AS rowmodctr,
    0 AS reserved3,
    0 AS reserved4,
    0 AS xmaxlen,
    NULL::integer AS maxirow,
    0 AS origfillfactor,
    0 AS statversion,
    0 AS reserved2,
    NULL::integer AS firstiam,
    0 AS impid,
    0 AS lockflags,
    0 AS pgmodctr,
    NULL::bytea AS keys,
    name,
    NULL::bytea AS statblob,
    800 AS maxlen,
    0 AS rows
   FROM aws_sqlserver_ext.sys_indexes i;]]></complex-attribute>
                        <category _I_D="e4375a95-3d23-49c0-94b2-a3f7e46b8bdb" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="43cbb85d-18d9-4692-b4cd-ca15eb17b98e" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="13025323-b2e3-4777-a3af-912be6076920" name="sys_sysobjects" context="sys_sysobjects" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT name,
    object_id AS id,
    type AS xtype,
    schema_id AS uid,
    0 AS info,
    0 AS status,
    0 AS base_schema_ver,
    0 AS replinfo,
    parent_object_id AS parent_obj,
    create_date AS crdate,
    0 AS ftcatid,
    0 AS schema_ver,
    0 AS stats_schema_ver,
    type,
    0 AS userstat,
    0 AS sysstat,
    0 AS indexdel,
    modify_date AS refdate,
    0 AS version,
    0 AS deltrig,
    0 AS instrig,
    0 AS updtrig,
    0 AS seltrig,
    0 AS category,
    0 AS cache
   FROM aws_sqlserver_ext.sys_objects s;]]></complex-attribute>
                        <category _I_D="afcb6699-e2b1-4828-b033-c834c84a3609" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="4f4181a4-ab59-44b5-ae7c-56e77de69bb1" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="cc256601-e5d3-4fe2-905a-0417bcfbf25f" name="sys_sysprocesses" context="sys_sysprocesses" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT a.pid AS spid,
    NULL::integer AS kpid,
    COALESCE(blocking_activity.pid, 0) AS blocked,
    NULL::bytea AS waittype,
    0 AS waittime,
    a.wait_event_type AS lastwaittype,
    NULL::text AS waitresource,
    a.datid AS dbid,
    a.usesysid AS uid,
    0 AS cpu,
    0 AS physical_io,
    0 AS memusage,
    a.backend_start AS login_time,
    a.query_start AS last_batch,
    0 AS ecid,
    0 AS open_tran,
    a.state AS status,
    NULL::bytea AS sid,
    a.client_hostname AS hostname,
    a.application_name AS program_name,
    NULL::character varying(10) AS hostprocess,
    a.query AS cmd,
    NULL::character varying(128) AS nt_domain,
    NULL::character varying(128) AS nt_username,
    NULL::character varying(12) AS net_address,
    NULL::character varying(12) AS net_library,
    a.usename AS loginname,
    NULL::bytea AS context_info,
    NULL::bytea AS sql_handle,
    0 AS stmt_start,
    0 AS stmt_end,
    0 AS request_id
   FROM (((pg_stat_activity a
     LEFT JOIN pg_locks blocked_locks ON ((a.pid = blocked_locks.pid)))
     LEFT JOIN pg_locks blocking_locks ON (((blocking_locks.locktype = blocked_locks.locktype) AND (NOT (blocking_locks.database IS DISTINCT FROM blocked_locks.database)) AND (NOT (blocking_locks.relation IS DISTINCT FROM blocked_locks.relation)) AND (NOT (blocking_locks.page IS DISTINCT FROM blocked_locks.page)) AND (NOT (blocking_locks.tuple IS DISTINCT FROM blocked_locks.tuple)) AND (NOT (blocking_locks.virtualxid IS DISTINCT FROM blocked_locks.virtualxid)) AND (NOT (blocking_locks.transactionid IS DISTINCT FROM blocked_locks.transactionid)) AND (NOT (blocking_locks.classid IS DISTINCT FROM blocked_locks.classid)) AND (NOT (blocking_locks.objid IS DISTINCT FROM blocked_locks.objid)) AND (NOT (blocking_locks.objsubid IS DISTINCT FROM blocked_locks.objsubid)) AND (blocking_locks.pid <> blocked_locks.pid))))
     LEFT JOIN pg_stat_activity blocking_activity ON ((blocking_activity.pid = blocking_locks.pid)));]]></complex-attribute>
                        <category _I_D="58ba05a8-ad3b-4c7d-b7f9-15cab08a7627" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="da291e79-c329-404b-97ad-fbc0c2b463db" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="a6cfb967-6655-4baa-87e9-cdfe9f1b243d" name="sys_system_objects" context="sys_system_objects" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT o.name,
    o.object_id,
    o.principal_id,
    o.schema_id,
    o.parent_object_id,
    o.type,
    o.type_desc,
    o.create_date,
    o.modify_date,
    o.is_ms_shipped,
    o.is_published,
    o.is_schema_published,
    s.oid,
    s.nspname,
    s.nspowner,
    s.nspacl
   FROM (aws_sqlserver_ext.sys_all_objects o
     JOIN pg_namespace s ON ((s.oid = o.schema_id)))
  WHERE (s.nspname = ANY (ARRAY['information_schema'::name, 'pg_catalog'::name]));]]></complex-attribute>
                        <category _I_D="4ee3a2f5-807d-4395-981e-c95b4f7b2baf" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="5f115740-96fe-4c0f-8c42-8bfa8aff3a9a" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="f12f18a5-9478-4a20-a661-b218de414470" name="sys_tables" context="sys_tables" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT t.relname AS name,
    t.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    0 AS parent_object_id,
    'U'::character varying(2) AS type,
    'USER_TABLE'::character varying(60) AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published,
        CASE t.reltoastrelid
            WHEN 0 THEN 0
            ELSE 1
        END AS lob_data_space_id,
    NULL::integer AS filestream_data_space_id,
    t.relnatts AS max_column_id_used,
    0 AS lock_on_bulk_load,
    1 AS uses_ansi_nulls,
    0 AS is_replicated,
    0 AS has_replication_filter,
    0 AS is_merge_published,
    0 AS is_sync_tran_subscribed,
    0 AS has_unchecked_assembly_data,
    0 AS text_in_row_limit,
    0 AS large_value_types_out_of_row,
    0 AS is_tracked_by_cdc,
    0 AS lock_escalation,
    'TABLE'::character varying(60) AS lock_escalation_desc,
    0 AS is_filetable,
    0 AS durability,
    'SCHEMA_AND_DATA'::character varying(60) AS durability_desc,
    0 AS is_memory_optimized,
        CASE t.relpersistence
            WHEN 't'::"char" THEN 2
            ELSE 0
        END AS temporal_type,
        CASE t.relpersistence
            WHEN 't'::"char" THEN 'SYSTEM_VERSIONED_TEMPORAL_TABLE'::text
            ELSE 'NON_TEMPORAL_TABLE'::text
        END AS temporal_type_desc,
    NULL::integer AS history_table_id,
    0 AS is_remote_data_archive_enabled,
    0 AS is_external
   FROM (pg_class t
     JOIN pg_namespace s ON ((s.oid = t.relnamespace)))
  WHERE ((t.relpersistence = ANY (ARRAY['p'::"char", 'u'::"char", 't'::"char"])) AND (t.relkind = 'r'::"char") AND has_table_privilege(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((t.relname)::text)), 'SELECT,INSERT,UPDATE,DELETE,TRUNCATE,TRIGGER'::text) AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])));]]></complex-attribute>
                        <category _I_D="f233da57-fd4a-4e63-a09b-1f2879754204" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="69b24698-4e7d-459a-b873-a8ad72fec6b9" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="babcf345-4664-4680-bf69-8f165969a16c" name="sys_types" context="sys_types" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT format_type(t.oid, NULL::integer) AS name,
    t.oid AS system_type_id,
    t.oid AS user_type_id,
    s.oid AS schema_id,
    NULL::integer AS principal_id,
    t.typlen AS max_length,
    0 AS "precision",
    0 AS scale,
    c.collname AS collation_name,
        CASE
            WHEN t.typnotnull THEN 0
            ELSE 1
        END AS is_nullable,
        CASE t.typcategory
            WHEN 'U'::"char" THEN 1
            ELSE 0
        END AS is_user_defined,
    0 AS is_assembly_type,
    0 AS default_object_id,
    0 AS rule_object_id,
    0 AS is_table_type
   FROM ((pg_type t
     JOIN pg_namespace s ON ((s.oid = t.typnamespace)))
     LEFT JOIN pg_collation c ON ((c.oid = t.typcollation)));]]></complex-attribute>
                        <category _I_D="d8fc6f32-d5e3-4f94-b3b1-761e28ea9d9e" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="a24fd1d2-5324-41d6-af1a-b50850f8a3bd" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="4bd4c855-c32f-49d9-9e0d-5b7e5e27b6b4" name="sys_views" context="sys_views" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT t.relname AS name,
    t.oid AS object_id,
    NULL::integer AS principal_id,
    s.oid AS schema_id,
    0 AS parent_object_id,
    'V'::character varying(2) AS type,
    'VIEW'::character varying(60) AS type_desc,
    NULL::timestamp without time zone AS create_date,
    NULL::timestamp without time zone AS modify_date,
    0 AS is_ms_shipped,
    0 AS is_published,
    0 AS is_schema_published,
    0 AS with_check_option,
    0 AS is_date_correlation_view,
    0 AS is_tracked_by_cdc
   FROM (pg_class t
     JOIN pg_namespace s ON ((s.oid = t.relnamespace)))
  WHERE ((t.relkind = 'v'::"char") AND has_table_privilege(((quote_ident((s.nspname)::text) || '.'::text) || quote_ident((t.relname)::text)), 'SELECT,INSERT,UPDATE,DELETE,TRUNCATE,TRIGGER'::text) AND (s.nspname <> ALL (ARRAY['information_schema'::name, 'pg_catalog'::name])));]]></complex-attribute>
                        <category _I_D="66644f00-06e3-4e4a-99cf-5b460f186cdc" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="d902882b-1c34-48dd-a781-73b9d024716e" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="6e902df6-135e-453c-aadc-6b9b6add39ef" name="sysmail_allitems" context="sysmail_allitems" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT mailitem_id,
    profile_id,
    recipients,
    copy_recipients,
    blind_copy_recipients,
    subject,
    body,
    body_format,
    importance,
    sensitivity,
    file_attachments,
    attachment_encoding,
    query,
    execute_query_database,
    attach_query_result_as_file,
    query_result_header,
    query_result_width,
    query_result_separator,
    exclude_query_output,
    append_query_error,
    sent_account_id,
        CASE sent_status
            WHEN 0 THEN 'unsent'::text
            WHEN 1 THEN 'sent'::text
            WHEN 3 THEN 'retrying'::text
            ELSE 'failed'::text
        END AS sent_status,
    sent_date
   FROM aws_sqlserver_ext.sysmail_mailitems sa;]]></complex-attribute>
                        <category _I_D="45ae72e3-87c7-450e-821d-9f9782290974" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e0bdb2af-d0e0-411c-9c01-7461e73b83ff" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="8513e272-2a4c-42a1-a085-5a253fd466d2" name="sysmail_faileditems" context="sysmail_faileditems" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT mailitem_id,
    profile_id,
    recipients,
    copy_recipients,
    blind_copy_recipients,
    subject,
    body,
    body_format,
    importance,
    sensitivity,
    file_attachments,
    attachment_encoding,
    query,
    execute_query_database,
    attach_query_result_as_file,
    query_result_header,
    query_result_width,
    query_result_separator,
    exclude_query_output,
    append_query_error,
    sent_account_id,
    sent_status,
    sent_date
   FROM aws_sqlserver_ext.sysmail_allitems sa
  WHERE (lower(sent_status) = lower('failed'::text));]]></complex-attribute>
                        <category _I_D="910f0647-a76d-4a50-a822-78e26de05901" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="84e6ffd0-be0e-42fa-bbf8-7d36c99ae8bf" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="ae621ace-f7ce-47ea-b070-0c4eed3b0fc2" name="sysmail_mailattachments" context="sysmail_mailattachments" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT sa.attachment_id,
    sa.mailitem_id,
    sa.filename,
    sa.filesize,
    sa.attachment
   FROM (aws_sqlserver_ext.sysmail_attachments sa
     JOIN aws_sqlserver_ext.sysmail_mailitems sm ON ((sa.mailitem_id = sm.mailitem_id)));]]></complex-attribute>
                        <category _I_D="b2b6c3a5-c864-4203-8fe7-58b538284c6c" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="1b9400f6-67b4-4810-826e-39c753293b56" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="3866567e-53b4-4d00-91e8-b113dfa2cedc" name="sysmail_sentitems" context="sysmail_sentitems" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT mailitem_id,
    profile_id,
    recipients,
    copy_recipients,
    blind_copy_recipients,
    subject,
    body,
    body_format,
    importance,
    sensitivity,
    file_attachments,
    attachment_encoding,
    query,
    execute_query_database,
    attach_query_result_as_file,
    query_result_header,
    query_result_width,
    query_result_separator,
    exclude_query_output,
    append_query_error,
    sent_account_id,
    sent_status,
    sent_date
   FROM aws_sqlserver_ext.sysmail_allitems sa
  WHERE (lower(sent_status) = lower('sent'::text));]]></complex-attribute>
                        <category _I_D="47260978-07a6-4e08-9b0b-f9efb3f106f6" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="eb088ed4-1744-484e-8cb5-b26400c32b76" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="2757aef6-9e0a-420a-9235-1a7a57b7ee00" name="sysmail_unsentitems" context="sysmail_unsentitems" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT mailitem_id,
    profile_id,
    recipients,
    copy_recipients,
    blind_copy_recipients,
    subject,
    body,
    body_format,
    importance,
    sensitivity,
    file_attachments,
    attachment_encoding,
    query,
    execute_query_database,
    attach_query_result_as_file,
    query_result_header,
    query_result_width,
    query_result_separator,
    exclude_query_output,
    append_query_error,
    sent_account_id,
    sent_status,
    sent_date
   FROM aws_sqlserver_ext.sysmail_allitems sa
  WHERE ((lower(sent_status) = lower('unsent'::text)) OR (lower(sent_status) = lower('retrying'::text)));]]></complex-attribute>
                        <category _I_D="ae801cf9-4b18-45d4-9ac3-00dd590c3748" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="3f82767b-2076-450c-ba5d-617f8e7ed457" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                </category>
                <category _I_D="5e456e25-f9ae-459a-8f3e-a18b37c11ed9" name="Collations" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="collation"/>
                <category _I_D="68e65415-1b6f-4776-8531-bc1f86a2594b" name="Operators" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="operator"/>
                <category _I_D="bf2178fe-8c65-4731-b118-057cafb0f75b" name="Rules" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="rule"/>
                <category _I_D="b24a4585-6185-48df-9333-6d43da6b209a" name="FTS Configurations" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="ftsconfiguration"/>
                <category _I_D="49ab4640-e025-4bcc-a8c6-42c6ccbf7a10" name="FTS Dictionaries" order-num="7" objects-loading="empty" subcategories-loading="full" child-type="ftsdictionary"/>
                <category _I_D="e1af0d48-af18-42f4-8b93-6b1ed19e5baf" name="Functions" order-num="8" objects-loading="extended" subcategories-loading="none" child-type="function">
                    <function _I_D="c90a9802-ec0a-4d34-88be-36ce853db70d" name="char" is-trigger-function="0" unique-function-name="char" is-aggregate="f" language-name="plpgsql" context="char" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer" is-returning-set="f" ret-datatype="bpchar" function-arguments="x integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23920" volatility="VOLATILE" is-window="f" function-identity-arguments="x integer" overload-function-count="1" proc-language="plpgsql" function-signature="char(x integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
/***************************************************************
EXTENSION PACK function CHAR(x)
***************************************************************/
	if x between 1 and 255 then
		return chr(x);
	else
		return null; 
	end if;	
END;
]]></complex-attribute>
                        <category _I_D="f248118c-6661-4c73-a5d8-0dc7510b7e99" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="969310b0-dc12-46f8-9146-0580bc8568d2" name="checksum" is-trigger-function="0" unique-function-name="checksum" is-aggregate="f" language-name="sql" context="checksum" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="int4" function-arguments="_input text" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23919" volatility="VOLATILE" is-window="f" function-identity-arguments="_input text" overload-function-count="1" proc-language="sql" function-signature="checksum(_input text)">
                        <complex-attribute name="sql"><![CDATA[
  SELECT ('x'||SUBSTR(MD5(_input),1,8))::BIT(32)::INTEGER;
]]></complex-attribute>
                        <category _I_D="7d850b4f-fe83-41ae-adf1-a06dc03eba1c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7fb7b253-2914-461a-8c56-cc9e6f108404" name="conv_date_to_string" is-trigger-function="0" unique-function-name="conv_date_to_string" is-aggregate="f" language-name="plpgsql" context="conv_date_to_string" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,date,numeric" comment="This function converts the DATE value into a character string, according to specified style (conversion mask)." is-returning-set="f" ret-datatype="text" function-arguments="p_datatype text, p_dateval date, p_style numeric DEFAULT 20" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23944" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datatype text, p_dateval date, p_style numeric" overload-function-count="1" proc-language="plpgsql" function-signature="conv_date_to_string(p_datatype text, p_dateval date, p_style numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day VARCHAR;
    v_dateval DATE;
    v_style SMALLINT;
    v_month SMALLINT;
    v_resmask VARCHAR;
    v_datatype VARCHAR;
    v_language VARCHAR;
    v_monthname VARCHAR;
    v_resstring VARCHAR;
    v_lengthexpr VARCHAR;
    v_maxlength SMALLINT;
    v_res_length SMALLINT;
    v_err_message VARCHAR;
    v_res_datatype VARCHAR;
    v_lang_metadata_json JSONB;
    VARCHAR_MAX CONSTANT SMALLINT := 8000;
    NVARCHAR_MAX CONSTANT SMALLINT := 4000;
    CONVERSION_LANG CONSTANT VARCHAR := '';
    CHARACTER_REGEXP CONSTANT VARCHAR := 'CHAR|NCHAR|CHARACTER|NATIONAL CHARACTER';
    VARCHAR_REGEXP CONSTANT VARCHAR := 'VARCHAR|NVARCHAR|CHARACTER VARYING|NATIONAL CHARACTER VARYING';
    DATATYPE_REGEXP CONSTANT VARCHAR := concat('^\s*(', CHARACTER_REGEXP, '|', VARCHAR_REGEXP, ')\s*$');
    DATATYPE_MASK_REGEXP CONSTANT VARCHAR := concat('^\s*(?:', CHARACTER_REGEXP, '|', VARCHAR_REGEXP, ')\s*\(\s*(\d+|MAX)\s*\)\s*$');
BEGIN
    v_datatype := regexp_replace(upper(trim(p_datatype)), '\s+', ' ', 'gi');
    v_style := floor(p_style)::SMALLINT;

    IF (scale(p_style) > 0) THEN
        RAISE most_specific_type_mismatch;
    ELSIF (NOT ((v_style BETWEEN 0 AND 13) OR
                (v_style BETWEEN 20 AND 25) OR
                (v_style BETWEEN 100 AND 113) OR
                v_style IN (120, 121, 126, 127, 130, 131)))
    THEN
        RAISE invalid_parameter_value;
    ELSIF (v_style IN (8, 24, 108)) THEN
        RAISE invalid_datetime_format;
    END IF;

    IF (v_datatype ~* DATATYPE_MASK_REGEXP) THEN
        v_res_datatype := rtrim(split_part(v_datatype, '(', 1));

        v_maxlength := CASE
                          WHEN substring(v_res_datatype, '^(NCHAR|NATIONAL.*)$') IS NULL
                          THEN VARCHAR_MAX
                          ELSE NVARCHAR_MAX
                       END;

        v_lengthexpr := substring(v_datatype, DATATYPE_MASK_REGEXP);

        IF (v_lengthexpr <> 'MAX' AND char_length(v_lengthexpr) > 4) THEN
            RAISE interval_field_overflow;
        END IF;

        v_res_length := CASE v_lengthexpr
                           WHEN 'MAX' THEN v_maxlength
                           ELSE v_lengthexpr::SMALLINT
                        END;
    ELSIF (v_datatype ~* DATATYPE_REGEXP) THEN
        v_res_datatype := v_datatype;
    ELSE
        RAISE datatype_mismatch;
    END IF;

    v_dateval := CASE
                    WHEN (v_style NOT IN (130, 131)) THEN p_dateval
                    ELSE aws_sqlserver_ext.conv_greg_to_hijri(p_dateval) + 1
                 END;

    v_day := ltrim(to_char(v_dateval, 'DD'), '0');
    v_month := to_char(v_dateval, 'MM')::SMALLINT;

    v_language := CASE
                     WHEN (v_style IN (130, 131)) THEN 'HIJRI'
                     ELSE CONVERSION_LANG
                  END;
    BEGIN
        v_lang_metadata_json := aws_sqlserver_ext.get_lang_metadata_json(v_language);
    EXCEPTION
        WHEN OTHERS THEN
        RAISE invalid_character_value_for_cast;
    END;

    v_monthname := (v_lang_metadata_json -> 'months_shortnames') ->> v_month - 1;

    v_resmask := CASE
                    WHEN (v_style IN (1, 22)) THEN 'MM/DD/YY'
                    WHEN (v_style = 101) THEN 'MM/DD/YYYY'
                    WHEN (v_style = 2) THEN 'YY.MM.DD'
                    WHEN (v_style = 102) THEN 'YYYY.MM.DD'
                    WHEN (v_style = 3) THEN 'DD/MM/YY'
                    WHEN (v_style = 103) THEN 'DD/MM/YYYY'
                    WHEN (v_style = 4) THEN 'DD.MM.YY'
                    WHEN (v_style = 104) THEN 'DD.MM.YYYY'
                    WHEN (v_style = 5) THEN 'DD-MM-YY'
                    WHEN (v_style = 105) THEN 'DD-MM-YYYY'
                    WHEN (v_style = 6) THEN 'DD $mnme$ YY'
                    WHEN (v_style IN (13, 106, 113)) THEN 'DD $mnme$ YYYY'
                    WHEN (v_style = 7) THEN '$mnme$ DD, YY'
                    WHEN (v_style = 107) THEN '$mnme$ DD, YYYY'
                    WHEN (v_style = 10) THEN 'MM-DD-YY'
                    WHEN (v_style = 110) THEN 'MM-DD-YYYY'
                    WHEN (v_style = 11) THEN 'YY/MM/DD'
                    WHEN (v_style = 111) THEN 'YYYY/MM/DD'
                    WHEN (v_style = 12) THEN 'YYMMDD'
                    WHEN (v_style = 112) THEN 'YYYYMMDD'
                    WHEN (v_style IN (20, 21, 23, 25, 120, 121, 126, 127)) THEN 'YYYY-MM-DD'
                    WHEN (v_style = 130) THEN 'DD $mnme$ YYYY'
                    WHEN (v_style = 131) THEN format('%s/MM/YYYY', lpad(v_day, 2, ' '))
                    WHEN (v_style IN (0, 9, 100, 109)) THEN format('$mnme$ %s YYYY', lpad(v_day, 2, ' '))
                 END;

    v_resstring := to_char(v_dateval, v_resmask);
    v_resstring := replace(v_resstring, '$mnme$', v_monthname);

    v_resstring := substring(v_resstring, 1, coalesce(v_res_length, char_length(v_resstring)));

    RETURN CASE
              WHEN substring(v_res_datatype, concat('^(', CHARACTER_REGEXP, ')$')) IS NOT NULL
              THEN rpad(v_resstring, coalesce(v_res_length, 30), ' ')
              ELSE v_resstring
           END;
EXCEPTION
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Argument data type NUMERIC is invalid for argument 3 of convert function.',
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := format('%s is not a valid style number when converting from DATE to a character string.', v_style),
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := format('Error converting data type DATE to %s.', trim(p_datatype)),
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';

   WHEN interval_field_overflow THEN
       RAISE USING MESSAGE := format('The size (%s) given to the convert specification ''%s'' exceeds the maximum allowed for any data type (%s).',
                                     v_lengthexpr,
                                     lower(v_res_datatype),
                                     v_maxlength),
                   DETAIL := 'Use of incorrect size value of data type parameter during conversion process.',
                   HINT := 'Change size component of data type parameter to the allowable value and try again.';

    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := concat('Data type should be one of these values: ''CHAR(n|MAX)'', ''NCHAR(n|MAX)'', ''VARCHAR(n|MAX)'', ''NVARCHAR(n|MAX)'', ',
                                      '''CHARACTER VARYING(n|MAX)'', ''NATIONAL CHARACTER VARYING(n|MAX)''.'),
                    DETAIL := 'Use of incorrect "datatype" parameter value during conversion process.',
                    HINT := 'Change "datatype" parameter to the proper value and try again.';

    WHEN invalid_character_value_for_cast THEN
        RAISE USING MESSAGE := format('Invalid CONVERSION_LANG constant value - ''%s''. Allowed values are: ''English'', ''Deutsch'', etc.',
                                      CONVERSION_LANG),
                    DETAIL := 'Compiled incorrect CONVERSION_LANG constant value in function''s body.',
                    HINT := 'Correct CONVERSION_LANG constant value in function''s body, recompile it and try again.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT (or INTEGER) data type.',
                                      v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="746e427b-7931-41bb-bf69-994430f1d606" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="83bd267a-2d93-4a69-bc3a-f620f68da8d2" name="conv_datetime_to_string" is-trigger-function="0" unique-function-name="conv_datetime_to_string" is-aggregate="f" language-name="plpgsql" context="conv_datetime_to_string" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,timestamp without time zone,numeric" comment="This function converts the DATETIME value into a character string, according to specified style (conversion mask)." is-returning-set="f" ret-datatype="text" function-arguments="p_datatype text, p_src_datatype text, p_datetimeval timestamp without time zone, p_style numeric DEFAULT '-1'::integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="4" function-id="23946" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datatype text, p_src_datatype text, p_datetimeval timestamp without time zone, p_style numeric" overload-function-count="1" proc-language="plpgsql" function-signature="conv_datetime_to_string(p_datatype text, p_src_datatype text, p_datetimeval timestamp without time zone, p_style numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day VARCHAR;
    v_hour VARCHAR;
    v_month SMALLINT;
    v_style SMALLINT;
    v_scale SMALLINT;
    v_resmask VARCHAR;
    v_language VARCHAR;
    v_datatype VARCHAR;
    v_fseconds VARCHAR;
    v_fractsep VARCHAR;
    v_monthname VARCHAR;
    v_resstring VARCHAR;
    v_lengthexpr VARCHAR;
    v_maxlength SMALLINT;
    v_res_length SMALLINT;
    v_err_message VARCHAR;
    v_src_datatype VARCHAR;
    v_res_datatype VARCHAR;
    v_lang_metadata_json JSONB;
    VARCHAR_MAX CONSTANT SMALLINT := 8000;
    NVARCHAR_MAX CONSTANT SMALLINT := 4000;
    CONVERSION_LANG CONSTANT VARCHAR := '';
    CHARACTER_REGEXP CONSTANT VARCHAR := 'CHAR|NCHAR|CHARACTER|NATIONAL CHARACTER';
    VARCHAR_REGEXP CONSTANT VARCHAR := 'VARCHAR|NVARCHAR|CHARACTER VARYING|NATIONAL CHARACTER VARYING';
    DATATYPE_REGEXP CONSTANT VARCHAR := concat('^\s*(', CHARACTER_REGEXP, '|', VARCHAR_REGEXP, ')\s*$');
    DATATYPE_MASK_REGEXP CONSTANT VARCHAR := concat('^\s*(?:', CHARACTER_REGEXP, '|', VARCHAR_REGEXP, ')\s*\(\s*(\d+|MAX)\s*\)\s*$');
    SRCDATATYPE_MASK_REGEXP VARCHAR := '^(?:DATETIME|SMALLDATETIME|DATETIME2)\s*(?:\s*\(\s*(\d+)\s*\)\s*)?$';
    v_datetimeval TIMESTAMP(6) WITHOUT TIME ZONE;
BEGIN
    v_datatype := regexp_replace(upper(trim(p_datatype)), '\s+', ' ', 'gi');
    v_src_datatype := upper(trim(p_src_datatype));
    v_style := floor(p_style)::SMALLINT;

    IF (v_src_datatype ~* SRCDATATYPE_MASK_REGEXP)
    THEN
        v_scale := substring(v_src_datatype, SRCDATATYPE_MASK_REGEXP)::SMALLINT;

        v_src_datatype := rtrim(split_part(v_src_datatype, '(', 1));

        IF (v_src_datatype <> 'DATETIME2' AND v_scale IS NOT NULL) THEN
            RAISE invalid_indicator_parameter_value;
        ELSIF (v_scale NOT BETWEEN 0 AND 7) THEN
            RAISE invalid_regular_expression;
        END IF;

        v_scale := coalesce(v_scale, 7);
    ELSE
        RAISE most_specific_type_mismatch;
    END IF;

    IF (scale(p_style) > 0) THEN
        RAISE escape_character_conflict;
    ELSIF (NOT ((v_style BETWEEN 0 AND 14) OR
                (v_style BETWEEN 20 AND 25) OR
                (v_style BETWEEN 100 AND 114) OR
                v_style IN (-1, 120, 121, 126, 127, 130, 131)))
    THEN
        RAISE invalid_parameter_value;
    END IF;

    IF (v_datatype ~* DATATYPE_MASK_REGEXP) THEN
        v_res_datatype := rtrim(split_part(v_datatype, '(', 1));

        v_maxlength := CASE
                          WHEN substring(v_res_datatype, '^(NCHAR|NATIONAL.*)$') IS NULL
                          THEN VARCHAR_MAX
                          ELSE NVARCHAR_MAX
                       END;

        v_lengthexpr := substring(v_datatype, DATATYPE_MASK_REGEXP);

        IF (v_lengthexpr <> 'MAX' AND char_length(v_lengthexpr) > 4)
        THEN
            RAISE interval_field_overflow;
        END IF;

        v_res_length := CASE v_lengthexpr
                           WHEN 'MAX' THEN v_maxlength
                           ELSE v_lengthexpr::SMALLINT
                        END;
    ELSIF (v_datatype ~* DATATYPE_REGEXP) THEN
        v_res_datatype := v_datatype;
    ELSE
        RAISE datatype_mismatch;
    END IF;

    v_datetimeval := CASE
                        WHEN (v_style NOT IN (130, 131)) THEN p_datetimeval
                        ELSE aws_sqlserver_ext.conv_greg_to_hijri(p_datetimeval) + INTERVAL '1 day'
                     END;

    v_day := ltrim(to_char(v_datetimeval, 'DD'), '0');
    v_hour := ltrim(to_char(v_datetimeval, 'HH12'), '0');
    v_month := to_char(v_datetimeval, 'MM')::SMALLINT;

    v_language := CASE
                     WHEN (v_style IN (130, 131)) THEN 'HIJRI'
                     ELSE CONVERSION_LANG
                  END;
    BEGIN
        v_lang_metadata_json := aws_sqlserver_ext.get_lang_metadata_json(v_language);
    EXCEPTION
        WHEN OTHERS THEN
        RAISE invalid_character_value_for_cast;
    END;

    v_monthname := (v_lang_metadata_json -> 'months_shortnames') ->> v_month - 1;

    IF (v_src_datatype IN ('DATETIME', 'SMALLDATETIME')) THEN
        v_fseconds := aws_sqlserver_ext.round_fractseconds(to_char(v_datetimeval, 'MS'));

        IF (v_fseconds::INTEGER = 1000) THEN
            v_fseconds := '000';
            v_datetimeval := v_datetimeval + INTERVAL '1 second';
        ELSE
            v_fseconds := lpad(v_fseconds, 3, '0');
        END IF;
    ELSE
        v_fseconds := aws_sqlserver_ext.get_microsecs_from_fractsecs(to_char(v_datetimeval, 'US'), v_scale);

        IF (v_scale = 7) THEN
            v_fseconds := concat(v_fseconds, '0');
        END IF;
    END IF;

    v_fractsep := CASE v_src_datatype
                     WHEN 'DATETIME2' THEN '.'
                     ELSE ':'
                  END;

    IF ((v_style = -1 AND v_src_datatype <> 'DATETIME2') OR
        v_style IN (0, 9, 100, 109))
    THEN
        v_resmask := format('$mnme$ %s YYYY %s:MI%s',
                            lpad(v_day, 2, ' '),
                            lpad(v_hour, 2, ' '),
                            CASE
                               WHEN (v_style IN (-1, 0, 100)) THEN 'AM'
                               ELSE CASE
                                       WHEN char_length(v_fseconds) > 0
                                       THEN format(':SS:%sAM', v_fseconds)
                                       ELSE ':SSAM'
                                    END
                            END);
    ELSIF (v_style = 1) THEN
        v_resmask := 'MM/DD/YY';
    ELSIF (v_style = 101) THEN
        v_resmask := 'MM/DD/YYYY';
    ELSIF (v_style = 2) THEN
        v_resmask := 'YY.MM.DD';
    ELSIF (v_style = 102) THEN
        v_resmask := 'YYYY.MM.DD';
    ELSIF (v_style = 3) THEN
        v_resmask := 'DD/MM/YY';
    ELSIF (v_style = 103) THEN
        v_resmask := 'DD/MM/YYYY';
    ELSIF (v_style = 4) THEN
        v_resmask := 'DD.MM.YY';
    ELSIF (v_style = 104) THEN
        v_resmask := 'DD.MM.YYYY';
    ELSIF (v_style = 5) THEN
        v_resmask := 'DD-MM-YY';
    ELSIF (v_style = 105) THEN
        v_resmask := 'DD-MM-YYYY';
    ELSIF (v_style = 6) THEN
        v_resmask := 'DD $mnme$ YY';
    ELSIF (v_style = 106) THEN
        v_resmask := 'DD $mnme$ YYYY';
    ELSIF (v_style = 7) THEN
        v_resmask := '$mnme$ DD, YY';
    ELSIF (v_style = 107) THEN
        v_resmask := '$mnme$ DD, YYYY';
    ELSIF (v_style IN (8, 24, 108)) THEN
        v_resmask := 'HH24:MI:SS';
    ELSIF (v_style = 10) THEN
        v_resmask := 'MM-DD-YY';
    ELSIF (v_style = 110) THEN
        v_resmask := 'MM-DD-YYYY';
    ELSIF (v_style = 11) THEN
        v_resmask := 'YY/MM/DD';
    ELSIF (v_style = 111) THEN
        v_resmask := 'YYYY/MM/DD';
    ELSIF (v_style = 12) THEN
        v_resmask := 'YYMMDD';
    ELSIF (v_style = 112) THEN
        v_resmask := 'YYYYMMDD';
    ELSIF (v_style IN (13, 113)) THEN
        v_resmask := format('DD $mnme$ YYYY HH24:MI:SS%s%s', v_fractsep, v_fseconds);
    ELSIF (v_style IN (14, 114)) THEN
        v_resmask := format('HH24:MI:SS%s%s', v_fractsep, v_fseconds);
    ELSIF (v_style IN (20, 120)) THEN
        v_resmask := 'YYYY-MM-DD HH24:MI:SS';
    ELSIF ((v_style = -1 AND v_src_datatype = 'DATETIME2') OR
           v_style IN (21, 25, 121))
    THEN
        v_resmask := format('YYYY-MM-DD HH24:MI:SS%s',
                            CASE
                               WHEN char_length(v_fseconds) > 0 THEN '.' || v_fseconds
                            END);
    ELSIF (v_style = 22) THEN
        v_resmask := format('MM/DD/YY %s:MI:SS AM', lpad(v_hour, 2, ' '));
    ELSIF (v_style = 23) THEN
        v_resmask := 'YYYY-MM-DD';
    ELSIF (v_style IN (126, 127)) THEN
        v_resmask := CASE v_src_datatype
                        WHEN 'SMALLDATETIME' THEN 'YYYY-MM-DDT$rem$HH24:MI:SS'
                        ELSE format('YYYY-MM-DDT$rem$HH24:MI:SS%s',
                                    CASE
                                       WHEN char_length(v_fseconds) > 0 THEN '.' || v_fseconds
                                    END)
                     END;
    ELSIF (v_style IN (130, 131)) THEN
        v_resmask := concat(CASE p_style
                               WHEN 131 THEN format('%s/MM/YYYY ', lpad(v_day, 2, ' '))
                               ELSE format('%s $mnme$ YYYY ', lpad(v_day, 2, ' '))
                            END,
                            format('%s:MI:SS%sAM', lpad(v_hour, 2, ' '),
                                   CASE
                                      WHEN char_length(v_fseconds) > 0 THEN concat(v_fractsep, v_fseconds)
                                   END));
    END IF;

    v_resstring := to_char(v_datetimeval, v_resmask);
    v_resstring := replace(v_resstring, '$mnme$', v_monthname);
    v_resstring := replace(v_resstring, '$rem$', '');

    v_resstring := substring(v_resstring, 1, coalesce(v_res_length, char_length(v_resstring)));

    RETURN CASE
              WHEN substring(v_res_datatype, concat('^(', CHARACTER_REGEXP, ')$')) IS NOT NULL
              THEN rpad(v_resstring, coalesce(v_res_length, 30), ' ')
              ELSE v_resstring
           END;
EXCEPTION
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Source data type should be one of these values: ''DATETIME'', ''SMALLDATETIME'', ''DATETIME2'' or ''DATETIME2(n)''.',
                    DETAIL := 'Use of incorrect "src_datatype" parameter value during conversion process.',
                    HINT := 'Change "srcdatatype" parameter to the proper value and try again.';

   WHEN invalid_regular_expression THEN
       RAISE USING MESSAGE := format('The source data type scale (%s) given to the convert specification exceeds the maximum allowable value (7).',
                                     v_scale),
                   DETAIL := 'Use of incorrect scale value of source data type parameter during conversion process.',
                   HINT := 'Change scale component of source data type parameter to the allowable value and try again.';

    WHEN invalid_indicator_parameter_value THEN
        RAISE USING MESSAGE := format('Invalid attributes specified for data type %s.', v_src_datatype),
                    DETAIL := 'Use of incorrect scale value, which is not corresponding to specified data type.',
                    HINT := 'Change data type scale component or select different data type and try again.';

    WHEN escape_character_conflict THEN
        RAISE USING MESSAGE := 'Argument data type NUMERIC is invalid for argument 4 of convert function.',
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := format('%s is not a valid style number when converting from %s to a character string.',
                                      v_style, v_src_datatype),
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN interval_field_overflow THEN
        RAISE USING MESSAGE := format('The size (%s) given to the convert specification ''%s'' exceeds the maximum allowed for any data type (%s).',
                                      v_lengthexpr, lower(v_res_datatype), v_maxlength),
                    DETAIL := 'Use of incorrect size value of data type parameter during conversion process.',
                    HINT := 'Change size component of data type parameter to the allowable value and try again.';

    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := concat('Data type should be one of these values: ''CHAR(n|MAX)'', ''NCHAR(n|MAX)'', ''VARCHAR(n|MAX)'', ''NVARCHAR(n|MAX)'', ',
                                      '''CHARACTER VARYING(n|MAX)'', ''NATIONAL CHARACTER VARYING(n|MAX)''.'),
                    DETAIL := 'Use of incorrect "datatype" parameter value during conversion process.',
                    HINT := 'Change "datatype" parameter to the proper value and try again.';

    WHEN invalid_character_value_for_cast THEN
        RAISE USING MESSAGE := format('Invalid CONVERSION_LANG constant value - ''%s''. Allowed values are: ''English'', ''Deutsch'', etc.',
                                      CONVERSION_LANG),
                    DETAIL := 'Compiled incorrect CONVERSION_LANG constant value in function''s body.',
                    HINT := 'Correct CONVERSION_LANG constant value in function''s body, recompile it and try again.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:[[:space:]]\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="853e338c-8b5e-4b4a-8203-f17a880bec03" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6df1d755-9a19-45b3-9dcf-3edd26fa4594" name="conv_greg_to_hijri" is-trigger-function="0" unique-function-name="conv_greg_to_hijri(p_datetimeval timestamp without time zone)" is-aggregate="f" language-name="plpgsql" context="conv_greg_to_hijri(p_datetimeval timestamp without time zone)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone" comment="This function converts date and time from Gregorian calendar to the appropriate date and time in Hijri calendar." unique-suffix="(p_datetimeval timestamp without time zone)" routine-number="23928" is-returning-set="f" ret-datatype="timestamp" function-arguments="p_datetimeval timestamp without time zone" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23928" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datetimeval timestamp without time zone" overload-function-count="4" proc-language="plpgsql" function-signature="conv_greg_to_hijri(p_datetimeval timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_hijri_date DATE;
BEGIN
    v_hijri_date := aws_sqlserver_ext.conv_greg_to_hijri(extract(day from p_datetimeval)::SMALLINT,
                                                         extract(month from p_datetimeval)::SMALLINT,
                                                         extract(year from p_datetimeval)::INTEGER);

    RETURN to_timestamp(format('%s %s', to_char(v_hijri_date, 'DD.MM.YYYY'),
                                        to_char(p_datetimeval, ' HH24:MI:SS.US')),
                        'DD.MM.YYYY HH24:MI:SS.US');
END;
]]></complex-attribute>
                        <category _I_D="a47fb249-bd60-4ecf-a7bb-3cb041023c2c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d6d57f5d-3321-46f9-a617-1b8a2b9ab3be" name="conv_greg_to_hijri" is-trigger-function="0" unique-function-name="conv_greg_to_hijri(p_dateval date)" is-aggregate="f" language-name="plpgsql" context="conv_greg_to_hijri(p_dateval date)" subcategories-loading="none" object-loading="extended" arguments-datatypes="date" comment="This function converts date from Gregorian calendar to the appropriate date in Hijri calendar." unique-suffix="(p_dateval date)" routine-number="23925" is-returning-set="f" ret-datatype="date" function-arguments="p_dateval date" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23925" volatility="VOLATILE" is-window="f" function-identity-arguments="p_dateval date" overload-function-count="4" proc-language="plpgsql" function-signature="conv_greg_to_hijri(p_dateval date)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_greg_to_hijri(extract(day from p_dateval)::NUMERIC,
                                                extract(month from p_dateval)::NUMERIC,
                                                extract(year from p_dateval)::NUMERIC);
END;
]]></complex-attribute>
                        <category _I_D="a1be5eab-2b3b-4001-a2a4-48cdf9954609" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="82e6b0b8-4f08-4845-958f-eadfbe5c5cc7" name="conv_greg_to_hijri" is-trigger-function="0" unique-function-name="conv_greg_to_hijri(p_day numeric, p_month numeric, p_year numeric)" is-aggregate="f" language-name="plpgsql" context="conv_greg_to_hijri(p_day numeric, p_month numeric, p_year numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric,numeric" comment="This function converts date from Gregorian calendar to the appropriate date in Hijri calendar." unique-suffix="(p_day numeric, p_month numeric, p_year numeric)" routine-number="23926" is-returning-set="f" ret-datatype="date" function-arguments="p_day numeric, p_month numeric, p_year numeric" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23926" volatility="VOLATILE" is-window="f" function-identity-arguments="p_day numeric, p_month numeric, p_year numeric" overload-function-count="4" proc-language="plpgsql" function-signature="conv_greg_to_hijri(p_day numeric, p_month numeric, p_year numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day SMALLINT;
    v_month SMALLINT;
    v_year INTEGER;
    v_jdnum DOUBLE PRECISION;
    v_lnum DOUBLE PRECISION;
    v_inum DOUBLE PRECISION;
    v_nnum DOUBLE PRECISION;
    v_jnum DOUBLE PRECISION;
BEGIN
    v_day := floor(p_day)::SMALLINT;
    v_month := floor(p_month)::SMALLINT;
    v_year := floor(p_year)::INTEGER;

    IF ((sign(v_day) = -1) OR (sign(v_month) = -1) OR (sign(v_year) = -1))
    THEN
        RAISE invalid_character_value_for_cast;
    ELSIF (v_year = 0) THEN
        RAISE null_value_not_allowed;
    END IF;

    IF ((p_year > 1582) OR ((p_year = 1582) AND (p_month > 10)) OR ((p_year = 1582) AND (p_month = 10) AND (p_day > 14)))
    THEN
        v_jdnum := aws_sqlserver_ext.get_int_part((1461 * (p_year + 4800 + aws_sqlserver_ext.get_int_part((p_month - 14) / 12))) / 4) +
                   aws_sqlserver_ext.get_int_part((367 * (p_month - 2 - 12 * (aws_sqlserver_ext.get_int_part((p_month - 14) / 12)))) / 12) -
                   aws_sqlserver_ext.get_int_part((3 * (aws_sqlserver_ext.get_int_part((p_year + 4900 +
                   aws_sqlserver_ext.get_int_part((p_month - 14) / 12)) / 100))) / 4) + p_day - 32075;
    ELSE
        v_jdnum := 367 * p_year - aws_sqlserver_ext.get_int_part((7 * (p_year + 5001 +
                   aws_sqlserver_ext.get_int_part((p_month - 9) / 7))) / 4) +
                   aws_sqlserver_ext.get_int_part((275 * p_month) / 9) + p_day + 1729777;
    END IF;

    v_lnum := v_jdnum - 1948440 + 10632;
    v_nnum := aws_sqlserver_ext.get_int_part((v_lnum - 1) / 10631);
    v_lnum := v_lnum - 10631 * v_nnum + 354;
    v_jnum := (aws_sqlserver_ext.get_int_part((10985 - v_lnum) / 5316)) * (aws_sqlserver_ext.get_int_part((50 * v_lnum) / 17719)) +
              (aws_sqlserver_ext.get_int_part(v_lnum / 5670)) * (aws_sqlserver_ext.get_int_part((43 * v_lnum) / 15238));
    v_lnum := v_lnum - (aws_sqlserver_ext.get_int_part((30 - v_jnum) / 15)) * (aws_sqlserver_ext.get_int_part((17719 * v_jnum) / 50)) -
              (aws_sqlserver_ext.get_int_part(v_jnum / 16)) * (aws_sqlserver_ext.get_int_part((15238 * v_jnum) / 43)) + 29;

    v_month := aws_sqlserver_ext.get_int_part((24 * v_lnum) / 709);
    v_day := v_lnum - aws_sqlserver_ext.get_int_part((709 * v_month) / 24);
    v_year := 30 * v_nnum + v_jnum - 30;

    RETURN to_date(concat_ws('.', v_day, v_month, v_year), 'DD.MM.YYYY');
EXCEPTION
    WHEN invalid_character_value_for_cast THEN
        RAISE USING MESSAGE := 'Could not convert Gregorian to Hijri date if any part of the date is negative.',
                    DETAIL := 'Some of the supplied date parts (day, month, year) is negative.',
                    HINT := 'Change the value of the date part (day, month, year) wich was found to be negative.';

    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Could not convert Gregorian to Hijri date if year value is equal to zero.',
                    DETAIL := 'Supplied year value is equal to zero.',
                    HINT := 'Change the value of the year so that it is greater than zero.';
END;
]]></complex-attribute>
                        <category _I_D="5bcb37a4-36f6-43a1-bf6c-1463bdff0b50" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2f71332e-77d5-405b-952e-3b104888e1dc" name="conv_greg_to_hijri" is-trigger-function="0" unique-function-name="conv_greg_to_hijri(p_day text, p_month text, p_year text)" is-aggregate="f" language-name="plpgsql" context="conv_greg_to_hijri(p_day text, p_month text, p_year text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" comment="This function converts date from Gregorian calendar to the appropriate date in Hijri calendar." unique-suffix="(p_day text, p_month text, p_year text)" routine-number="23927" is-returning-set="f" ret-datatype="date" function-arguments="p_day text, p_month text, p_year text" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23927" volatility="VOLATILE" is-window="f" function-identity-arguments="p_day text, p_month text, p_year text" overload-function-count="4" proc-language="plpgsql" function-signature="conv_greg_to_hijri(p_day text, p_month text, p_year text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_greg_to_hijri(p_day::NUMERIC,
                                                p_month::NUMERIC,
                                                p_year::NUMERIC);
END;
]]></complex-attribute>
                        <category _I_D="f95c1b0c-5e13-4b8c-b40c-4bb0cb758b68" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4c1e0832-62a1-4ce5-adf9-50078c404947" name="conv_hijri_to_greg" is-trigger-function="0" unique-function-name="conv_hijri_to_greg(p_datetimeval timestamp without time zone)" is-aggregate="f" language-name="plpgsql" context="conv_hijri_to_greg(p_datetimeval timestamp without time zone)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone" comment="This function converts date from Hijri calendar to the appropriate date in Gregorian calendar." unique-suffix="(p_datetimeval timestamp without time zone)" routine-number="23932" is-returning-set="f" ret-datatype="timestamp" function-arguments="p_datetimeval timestamp without time zone" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23932" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datetimeval timestamp without time zone" overload-function-count="4" proc-language="plpgsql" function-signature="conv_hijri_to_greg(p_datetimeval timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_hijri_date DATE;
BEGIN
    v_hijri_date := aws_sqlserver_ext.conv_hijri_to_greg(extract(day from p_datetimeval)::NUMERIC,
                                                         extract(month from p_datetimeval)::NUMERIC,
                                                         extract(year from p_datetimeval)::NUMERIC);

    RETURN to_timestamp(format('%s %s', to_char(v_hijri_date, 'DD.MM.YYYY'),
                                        to_char(p_datetimeval, ' HH24:MI:SS.US')),
                        'DD.MM.YYYY HH24:MI:SS.US');
END;
]]></complex-attribute>
                        <category _I_D="a5d6f0c0-b914-4ee9-b327-f0c112f05a4c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ae8bc23f-366b-467c-b297-b61b8449a76c" name="conv_hijri_to_greg" is-trigger-function="0" unique-function-name="conv_hijri_to_greg(p_dateval date)" is-aggregate="f" language-name="plpgsql" context="conv_hijri_to_greg(p_dateval date)" subcategories-loading="none" object-loading="extended" arguments-datatypes="date" comment="This function converts date from Hijri calendar to the appropriate date in Gregorian calendar." unique-suffix="(p_dateval date)" routine-number="23929" is-returning-set="f" ret-datatype="date" function-arguments="p_dateval date" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23929" volatility="VOLATILE" is-window="f" function-identity-arguments="p_dateval date" overload-function-count="4" proc-language="plpgsql" function-signature="conv_hijri_to_greg(p_dateval date)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_hijri_to_greg(extract(day from p_dateval)::NUMERIC,
                                                extract(month from p_dateval)::NUMERIC,
                                                extract(year from p_dateval)::NUMERIC);
END;
]]></complex-attribute>
                        <category _I_D="c0ceb93f-8472-4ec3-9a03-02f7e6ec7b21" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="155d59b4-d83e-449e-b249-2910ff4bc712" name="conv_hijri_to_greg" is-trigger-function="0" unique-function-name="conv_hijri_to_greg(p_day numeric, p_month numeric, p_year numeric)" is-aggregate="f" language-name="plpgsql" context="conv_hijri_to_greg(p_day numeric, p_month numeric, p_year numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric,numeric" comment="This function converts date from Hijri calendar to the appropriate date in Gregorian calendar." unique-suffix="(p_day numeric, p_month numeric, p_year numeric)" routine-number="23930" is-returning-set="f" ret-datatype="date" function-arguments="p_day numeric, p_month numeric, p_year numeric" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23930" volatility="VOLATILE" is-window="f" function-identity-arguments="p_day numeric, p_month numeric, p_year numeric" overload-function-count="4" proc-language="plpgsql" function-signature="conv_hijri_to_greg(p_day numeric, p_month numeric, p_year numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day SMALLINT;
    v_month SMALLINT;
    v_year INTEGER;
    v_err_message VARCHAR;
    v_jdnum DOUBLE PRECISION;
    v_lnum DOUBLE PRECISION;
    v_inum DOUBLE PRECISION;
    v_nnum DOUBLE PRECISION;
    v_jnum DOUBLE PRECISION;
    v_knum DOUBLE PRECISION;
BEGIN
    v_day := floor(p_day)::SMALLINT;
    v_month := floor(p_month)::SMALLINT;
    v_year := floor(p_year)::INTEGER;

    IF ((sign(v_day) = -1) OR (sign(v_month) = -1) OR (sign(v_year) = -1))
    THEN
        RAISE invalid_character_value_for_cast;
    ELSIF (v_year = 0) THEN
        RAISE null_value_not_allowed;
    END IF;

    v_jdnum = aws_sqlserver_ext.get_int_part((11 * v_year + 3) / 30) + 354 * v_year + 30 * v_month -
              aws_sqlserver_ext.get_int_part((v_month - 1) / 2) + v_day + 1948440 - 385;

    IF (v_jdnum > 2299160)
    THEN
        v_lnum := v_jdnum + 68569;
        v_nnum := aws_sqlserver_ext.get_int_part((4 * v_lnum) / 146097);
        v_lnum := v_lnum - aws_sqlserver_ext.get_int_part((146097 * v_nnum + 3) / 4);
        v_inum := aws_sqlserver_ext.get_int_part((4000 * (v_lnum + 1)) / 1461001);
        v_lnum := v_lnum - aws_sqlserver_ext.get_int_part((1461 * v_inum) / 4) + 31;
        v_jnum := aws_sqlserver_ext.get_int_part((80 * v_lnum) / 2447);
        v_day := v_lnum - aws_sqlserver_ext.get_int_part((2447 * v_jnum) / 80);
        v_lnum := aws_sqlserver_ext.get_int_part(v_jnum / 11);
        v_month := v_jnum + 2 - 12 * v_lnum;
        v_year := 100 * (v_nnum - 49) + v_inum + v_lnum;
    ELSE
        v_jnum := v_jdnum + 1402;
        v_knum := aws_sqlserver_ext.get_int_part((v_jnum - 1) / 1461);
        v_lnum := v_jnum - 1461 * v_knum;
        v_nnum := aws_sqlserver_ext.get_int_part((v_lnum - 1) / 365) - aws_sqlserver_ext.get_int_part(v_lnum / 1461);
        v_inum := v_lnum - 365 * v_nnum + 30;
        v_jnum := aws_sqlserver_ext.get_int_part((80 * v_inum) / 2447);
        v_day := v_inum - aws_sqlserver_ext.get_int_part((2447 * v_jnum) / 80);
        v_inum := aws_sqlserver_ext.get_int_part(v_jnum / 11);
        v_month := v_jnum + 2 - 12 * v_inum;
        v_year := 4 * v_knum + v_nnum + v_inum - 4716;
    END IF;

    RETURN to_date(concat_ws('.', v_day, v_month, v_year), 'DD.MM.YYYY');
EXCEPTION
    WHEN invalid_character_value_for_cast THEN
        RAISE USING MESSAGE := 'Could not convert Hijri to Gregorian date if any part of the date is negative.',
                    DETAIL := 'Some of the supplied date parts (day, month, year) is negative.',
                    HINT := 'Change the value of the date part (day, month, year) wich was found to be negative.';

    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Could not convert Hijri to Gregorian date if year value is equal to zero.',
                    DETAIL := 'Supplied year value is equal to zero.',
                    HINT := 'Change the value of the year so that it is greater than zero.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.', v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="ff1ed6e2-63b0-4622-8ca4-5059a3c5975b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e6d28dc1-5fac-4ee6-bc31-9054cb47f75b" name="conv_hijri_to_greg" is-trigger-function="0" unique-function-name="conv_hijri_to_greg(p_day text, p_month text, p_year text)" is-aggregate="f" language-name="plpgsql" context="conv_hijri_to_greg(p_day text, p_month text, p_year text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" comment="This function converts date from Hijri calendar to the appropriate date in Gregorian calendar." unique-suffix="(p_day text, p_month text, p_year text)" routine-number="23931" is-returning-set="f" ret-datatype="date" function-arguments="p_day text, p_month text, p_year text" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23931" volatility="VOLATILE" is-window="f" function-identity-arguments="p_day text, p_month text, p_year text" overload-function-count="4" proc-language="plpgsql" function-signature="conv_hijri_to_greg(p_day text, p_month text, p_year text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_hijri_to_greg(p_day::NUMERIC,
                                                p_month::NUMERIC,
                                                p_year::NUMERIC);
END;
]]></complex-attribute>
                        <category _I_D="ce709f7a-a2b2-448f-84ba-445897bd1f46" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e4edf701-2d0e-492d-b3ea-776fc3002151" name="conv_string_to_date" is-trigger-function="0" unique-function-name="conv_string_to_date" is-aggregate="f" language-name="plpgsql" context="conv_string_to_date" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric" comment="This function parses the TEXT string and converts it into a DATE value, according to specified style (conversion mask)." is-returning-set="f" ret-datatype="date" function-arguments="p_datestring text, p_style numeric DEFAULT 0" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="23950" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datestring text, p_style numeric" overload-function-count="1" proc-language="plpgsql" function-signature="conv_string_to_date(p_datestring text, p_style numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day VARCHAR;
    v_year VARCHAR;
    v_month VARCHAR;
    v_hijridate DATE;
    v_style SMALLINT;
    v_leftpart VARCHAR;
    v_middlepart VARCHAR;
    v_rightpart VARCHAR;
    v_fractsecs VARCHAR;
    v_datestring VARCHAR;
    v_err_message VARCHAR;
    v_date_format VARCHAR;
    v_regmatch_groups TEXT[];
    v_lang_metadata_json JSONB;
    v_compmonth_regexp VARCHAR;
    CONVERSION_LANG CONSTANT VARCHAR := '';
    DATE_FORMAT CONSTANT VARCHAR := '';
    DAYMM_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    FULLYEAR_REGEXP CONSTANT VARCHAR := '(\d{4})';
    SHORTYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    COMPYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,2}|\d{4})';
    AMPM_REGEXP CONSTANT VARCHAR := '(?:[AP]M)';
    TIMEUNIT_REGEXP CONSTANT VARCHAR := '\s*\d{1,2}\s*';
    FRACTSECS_REGEXP CONSTANT VARCHAR := '\s*\d{1,9}';
    HHMMSSFS_PART_REGEXP CONSTANT VARCHAR := concat('(', TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
                                                    TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '|',
                                                    TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '|',
                                                    TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '(?:\.|\:)', FRACTSECS_REGEXP,
                                                    ')\s*', AMPM_REGEXP, '?');
    HHMMSSFS_DOTPART_REGEXP CONSTANT VARCHAR := concat('(', TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
                                                       TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '|',
                                                       TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '|',
                                                       TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\.', FRACTSECS_REGEXP,
                                                       ')\s*', AMPM_REGEXP, '?');
    HHMMSSFS_REGEXP CONSTANT VARCHAR := concat('^', HHMMSSFS_PART_REGEXP, '$');
    HHMMSSFS_DOT_REGEXP CONSTANT VARCHAR := concat('^', HHMMSSFS_DOTPART_REGEXP, '$');
    v_defmask1_regexp VARCHAR := concat('^($comp_month$)\s*', DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP, '$');
    v_defmask2_regexp VARCHAR := concat('^', DAYMM_REGEXP, '\s*($comp_month$)\s*', COMPYEAR_REGEXP, '$');
    v_defmask3_regexp VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*($comp_month$)\s*', DAYMM_REGEXP, '$');
    v_defmask4_regexp VARCHAR := concat('^', FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP, '\s*($comp_month$)$');
    v_defmask5_regexp VARCHAR := concat('^', DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP, '\s*($comp_month$)$');
    v_defmask6_regexp VARCHAR := concat('^($comp_month$)\s*', FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP, '$');
    v_defmask7_regexp VARCHAR := concat('^($comp_month$)\s*', DAYMM_REGEXP, '\s*\,\s*', COMPYEAR_REGEXP, '$');
    v_defmask8_regexp VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*($comp_month$)$');
    v_defmask9_regexp VARCHAR := concat('^($comp_month$)\s*', FULLYEAR_REGEXP, '$');
    v_defmask10_regexp VARCHAR := concat('^', DAYMM_REGEXP, '\s*(?:\.|/|-)\s*($comp_month$)\s*(?:\.|/|-)\s*', COMPYEAR_REGEXP, '$');
    DOT_SHORTYEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*\.\s*', DAYMM_REGEXP, '\s*\.\s*', SHORTYEAR_REGEXP, '$');
    DOT_FULLYEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*\.\s*', DAYMM_REGEXP, '\s*\.\s*', FULLYEAR_REGEXP, '$');
    SLASH_SHORTYEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*/\s*', DAYMM_REGEXP, '\s*/\s*', SHORTYEAR_REGEXP, '$');
    SLASH_FULLYEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*/\s*', DAYMM_REGEXP, '\s*/\s*', FULLYEAR_REGEXP, '$');
    DASH_SHORTYEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*-\s*', DAYMM_REGEXP, '\s*-\s*', SHORTYEAR_REGEXP, '$');
    DASH_FULLYEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*-\s*', DAYMM_REGEXP, '\s*-\s*', FULLYEAR_REGEXP, '$');
    DOT_SLASH_DASH_YEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*(?:\.|/|-)\s*', DAYMM_REGEXP, '\s*(?:\.|/|-)\s*', COMPYEAR_REGEXP, '$');
    YEAR_DOTMASK_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*\.\s*', DAYMM_REGEXP, '\s*\.\s*', DAYMM_REGEXP, '$');
    YEAR_SLASHMASK_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*/\s*', DAYMM_REGEXP, '\s*/\s*', DAYMM_REGEXP, '$');
    YEAR_DASHMASK_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*-\s*', DAYMM_REGEXP, '\s*-\s*', DAYMM_REGEXP, '$');
    YEAR_DOT_SLASH_DASH_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*(?:\.|/|-)\s*', DAYMM_REGEXP, '\s*(?:\.|/|-)\s*', DAYMM_REGEXP, '$');
    DIGITMASK1_REGEXP CONSTANT VARCHAR := '^\d{6}$';
    DIGITMASK2_REGEXP CONSTANT VARCHAR := '^\d{8}$';
BEGIN
    v_style := floor(p_style)::SMALLINT;
    v_datestring := trim(p_datestring);

    IF (scale(p_style) > 0) THEN
        RAISE most_specific_type_mismatch;
    ELSIF (NOT ((v_style BETWEEN 0 AND 14) OR
                (v_style BETWEEN 20 AND 25) OR
                (v_style BETWEEN 100 AND 114) OR
                v_style IN (120, 121, 126, 127, 130, 131)))
    THEN
        RAISE invalid_parameter_value;
    END IF;

    IF (v_datestring ~* HHMMSSFS_PART_REGEXP AND v_datestring !~* HHMMSSFS_REGEXP)
    THEN
        v_datestring := trim(regexp_replace(v_datestring, HHMMSSFS_PART_REGEXP, '', 'gi'));
    END IF;

    BEGIN
        v_lang_metadata_json := aws_sqlserver_ext.get_lang_metadata_json(CONVERSION_LANG);
    EXCEPTION
        WHEN OTHERS THEN
        RAISE invalid_character_value_for_cast;
    END;

    v_date_format := coalesce(nullif(DATE_FORMAT, ''), v_lang_metadata_json ->> 'date_format');

    v_compmonth_regexp := array_to_string(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_shortnames')),
                                                    ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_names'))), '|');

    v_defmask1_regexp := replace(v_defmask1_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask2_regexp := replace(v_defmask2_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask3_regexp := replace(v_defmask3_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask4_regexp := replace(v_defmask4_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask5_regexp := replace(v_defmask5_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask6_regexp := replace(v_defmask6_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask7_regexp := replace(v_defmask7_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask8_regexp := replace(v_defmask8_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask9_regexp := replace(v_defmask9_regexp, '$comp_month$', v_compmonth_regexp);
    v_defmask10_regexp := replace(v_defmask10_regexp, '$comp_month$', v_compmonth_regexp);

    IF (v_datestring ~* v_defmask1_regexp OR
        v_datestring ~* v_defmask2_regexp OR
        v_datestring ~* v_defmask3_regexp OR
        v_datestring ~* v_defmask4_regexp OR
        v_datestring ~* v_defmask5_regexp OR
        v_datestring ~* v_defmask6_regexp OR
        v_datestring ~* v_defmask7_regexp OR
        v_datestring ~* v_defmask8_regexp OR
        v_datestring ~* v_defmask9_regexp OR
        v_datestring ~* v_defmask10_regexp)
    THEN
        IF (v_style IN (130, 131)) THEN
            RAISE invalid_datetime_format;
        END IF;

        IF (v_datestring ~* v_defmask1_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask1_regexp, 'gi');
            v_day := v_regmatch_groups[2];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);

        ELSIF (v_datestring ~* v_defmask2_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask2_regexp, 'gi');
            v_day := v_regmatch_groups[1];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);

        ELSIF (v_datestring ~* v_defmask3_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask3_regexp, 'gi');
            v_day := v_regmatch_groups[3];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := v_regmatch_groups[1];

        ELSIF (v_datestring ~* v_defmask4_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask4_regexp, 'gi');
            v_day := v_regmatch_groups[2];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
            v_year := v_regmatch_groups[1];

        ELSIF (v_datestring ~* v_defmask5_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask5_regexp, 'gi');
            v_day := v_regmatch_groups[1];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[2]);

        ELSIF (v_datestring ~* v_defmask6_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask6_regexp, 'gi');
            v_day := v_regmatch_groups[3];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := v_regmatch_groups[2];

        ELSIF (v_datestring ~* v_defmask7_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask7_regexp, 'gi');
            v_day := v_regmatch_groups[2];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);

        ELSIF (v_datestring ~* v_defmask8_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask8_regexp, 'gi');
            v_day := '01';
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := v_regmatch_groups[1];

        ELSIF (v_datestring ~* v_defmask9_regexp)
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask9_regexp, 'gi');
            v_day := '01';
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := v_regmatch_groups[2];
        ELSE
            v_regmatch_groups := regexp_matches(v_datestring, v_defmask10_regexp, 'gi');
            v_day := v_regmatch_groups[1];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);
        END IF;
    ELSEIF (v_datestring ~* DOT_SHORTYEAR_REGEXP OR
            v_datestring ~* DOT_FULLYEAR_REGEXP OR
            v_datestring ~* SLASH_SHORTYEAR_REGEXP OR
            v_datestring ~* SLASH_FULLYEAR_REGEXP OR
            v_datestring ~* DASH_SHORTYEAR_REGEXP OR
            v_datestring ~* DASH_FULLYEAR_REGEXP)
    THEN
        IF (v_style IN (6, 7, 8, 9, 12, 13, 14, 24, 100, 106, 107, 108, 109, 112, 113, 114, 130)) THEN
            RAISE invalid_regular_expression;
        ELSIF (v_style IN (20, 21, 23, 25, 102, 111, 120, 121, 126, 127)) THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, DOT_SLASH_DASH_YEAR_REGEXP, 'gi');
        v_leftpart := v_regmatch_groups[1];
        v_middlepart := v_regmatch_groups[2];
        v_rightpart := v_regmatch_groups[3];

        IF (v_datestring ~* DOT_SHORTYEAR_REGEXP OR
            v_datestring ~* SLASH_SHORTYEAR_REGEXP OR
            v_datestring ~* DASH_SHORTYEAR_REGEXP)
        THEN
            IF ((v_style IN (1, 10, 22) AND v_date_format <> 'MDY') OR
                ((v_style IS NULL OR v_style IN (0, 1, 10, 22)) AND v_date_format NOT IN ('YDM', 'YMD', 'DMY', 'DYM', 'MYD')))
            THEN
                v_day := v_middlepart;
                v_month := v_leftpart;
                v_year := aws_sqlserver_ext.get_full_year(v_rightpart);

            ELSIF ((v_style IN (2, 11) AND v_date_format <> 'YMD') OR
                   ((v_style IS NULL OR v_style IN (0, 2, 11)) AND v_date_format = 'YMD'))
            THEN
                v_day := v_rightpart;
                v_month := v_middlepart;
                v_year := aws_sqlserver_ext.get_full_year(v_leftpart);

            ELSIF ((v_style IN (3, 4, 5) AND v_date_format <> 'DMY') OR
                   ((v_style IS NULL OR v_style IN (0, 3, 4, 5)) AND v_date_format = 'DMY'))
            THEN
                v_day := v_leftpart;
                v_month := v_middlepart;
                v_year := aws_sqlserver_ext.get_full_year(v_rightpart);

            ELSIF ((v_style IS NULL OR v_style = 0) AND v_date_format = 'DYM')
            THEN
                v_day := v_leftpart;
                v_month := v_rightpart;
                v_year := aws_sqlserver_ext.get_full_year(v_middlepart);

            ELSIF ((v_style IS NULL OR v_style = 0) AND v_date_format = 'MYD')
            THEN
                v_day := v_rightpart;
                v_month := v_leftpart;
                v_year := aws_sqlserver_ext.get_full_year(v_middlepart);

            ELSIF ((v_style IS NULL OR v_style = 0) AND v_date_format = 'YDM') THEN
                RAISE character_not_in_repertoire;
            ELSIF (v_style IN (101, 103, 104, 105, 110, 131)) THEN
                RAISE invalid_datetime_format;
            END IF;
        ELSE
            v_year := v_rightpart;

            IF (v_leftpart::SMALLINT <= 12)
            THEN
                IF ((v_style IN (103, 104, 105, 131) AND v_date_format <> 'DMY') OR
                    ((v_style IS NULL OR v_style IN (0, 103, 104, 105, 131)) AND v_date_format = 'DMY'))
                THEN
                    v_day := v_leftpart;
                    v_month := v_middlepart;
                ELSIF ((v_style IN (101, 110) AND v_date_format IN ('YDM', 'DMY', 'DYM')) OR
                       ((v_style IS NULL OR v_style IN (0, 101, 110)) AND v_date_format NOT IN ('YDM', 'DMY', 'DYM')))
                THEN
                    v_day := v_middlepart;
                    v_month := v_leftpart;
                ELSIF ((v_style IN (1, 2, 3, 4, 5, 10, 11, 22) AND v_date_format <> 'YDM') OR
                       ((v_style IS NULL OR v_style IN (0, 1, 2, 3, 4, 5, 10, 11, 22)) AND v_date_format = 'YDM'))
                THEN
                    RAISE invalid_datetime_format;
                END IF;
            ELSE
                IF ((v_style IN (103, 104, 105, 131) AND v_date_format <> 'DMY') OR
                    ((v_style IS NULL OR v_style IN (0, 103, 104, 105, 131)) AND v_date_format = 'DMY'))
                THEN
                    v_day := v_leftpart;
                    v_month := v_middlepart;
                ELSIF ((v_style IN (1, 2, 3, 4, 5, 10, 11, 22, 101, 110) AND v_date_format = 'DMY') OR
                       ((v_style IS NULL OR v_style IN (0, 1, 2, 3, 4, 5, 10, 11, 22, 101, 110)) AND v_date_format <> 'DMY'))
                THEN
                    RAISE invalid_datetime_format;
                END IF;
            END IF;
        END IF;
    ELSIF (v_datestring ~* YEAR_DOTMASK_REGEXP OR
           v_datestring ~* YEAR_SLASHMASK_REGEXP OR
           v_datestring ~* YEAR_DASHMASK_REGEXP)
    THEN
        IF (v_style IN (6, 7, 8, 9, 12, 13, 14, 24, 100, 106, 107, 108, 109, 112, 113, 114, 130)) THEN
            RAISE invalid_regular_expression;
        ELSIF (v_style IN (1, 2, 3, 4, 5, 10, 11, 22, 101, 103, 104, 105, 110, 131)) THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, YEAR_DOT_SLASH_DASH_REGEXP, 'gi');
        v_day := v_regmatch_groups[3];
        v_month := v_regmatch_groups[2];
        v_year := v_regmatch_groups[1];

    ELSIF (v_datestring ~* DIGITMASK1_REGEXP OR
           v_datestring ~* DIGITMASK2_REGEXP)
    THEN
        IF (v_datestring ~* DIGITMASK1_REGEXP)
        THEN
            v_day := substring(v_datestring, 5, 2);
            v_month := substring(v_datestring, 3, 2);
            v_year := aws_sqlserver_ext.get_full_year(substring(v_datestring, 1, 2));
        ELSE
            v_day := substring(v_datestring, 7, 2);
            v_month := substring(v_datestring, 5, 2);
            v_year := substring(v_datestring, 1, 4);
        END IF;
    ELSIF (v_datestring ~* HHMMSSFS_REGEXP)
    THEN
        v_fractsecs := coalesce(aws_sqlserver_ext.get_timeunit_from_string(v_datestring, 'FRACTSECONDS'), '');
        IF (v_datestring !~* HHMMSSFS_DOT_REGEXP AND char_length(v_fractsecs) > 3) THEN
            RAISE invalid_datetime_format;
        END IF;

        v_day := '01';
        v_month := '01';
        v_year := '1900';
    ELSE
        RAISE invalid_datetime_format;
    END IF;

    IF (((v_datestring ~* HHMMSSFS_REGEXP OR v_datestring ~* DIGITMASK1_REGEXP OR v_datestring ~* DIGITMASK2_REGEXP) AND v_style IN (130, 131)) OR
        ((v_datestring ~* DOT_FULLYEAR_REGEXP OR v_datestring ~* SLASH_FULLYEAR_REGEXP OR v_datestring ~* DASH_FULLYEAR_REGEXP) AND v_style = 131))
    THEN
        IF ((v_day::SMALLINT NOT BETWEEN 1 AND 29) OR
            (v_month::SMALLINT NOT BETWEEN 1 AND 12))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_year) - 1;
        v_datestring := to_char(v_hijridate, 'DD.MM.YYYY');

        v_day := split_part(v_datestring, '.', 1);
        v_month := split_part(v_datestring, '.', 2);
        v_year := split_part(v_datestring, '.', 3);
    END IF;

    RETURN to_date(concat_ws('.', v_day, v_month, v_year), 'DD.MM.YYYY');
EXCEPTION
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Argument data type NUMERIC is invalid for argument 2 of conv_string_to_date function.',
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := format('The style %s is not supported for conversions from VARCHAR to DATE.', v_style),
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_regular_expression THEN
        RAISE USING MESSAGE := format('The input character string doesn''t follow style %s.', v_style),
                    DETAIL := 'Selected "style" param value isn''t valid for conversion of passed character string.',
                    HINT := 'Either change the input character string or use a different style.';

    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := 'Conversion failed when converting date from character string.',
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';

    WHEN character_not_in_repertoire THEN
        RAISE USING MESSAGE := 'The YDM date format isn''t supported when converting from this string format to date.',
                    DETAIL := 'Use of incorrect DATE_FORMAT constant value regarding string format parameter during conversion process.',
                    HINT := 'Change DATE_FORMAT constant to one of these values: MDY|DMY|DYM, recompile function and try again.';

    WHEN invalid_character_value_for_cast THEN
        RAISE USING MESSAGE := format('Invalid CONVERSION_LANG constant value - ''%s''. Allowed values are: ''English'', ''Deutsch'', etc.',
                                      CONVERSION_LANG),
                    DETAIL := 'Compiled incorrect CONVERSION_LANG constant value in function''s body.',
                    HINT := 'Correct CONVERSION_LANG constant value in function''s body, recompile it and try again.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Passed argument value contains illegal characters.',
                    HINT := 'Correct passed argument value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="27f10e8a-a267-456b-8dd8-451e90b8a795" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8fb3bcc3-4b90-4a3c-b884-78a3b73d7884" name="conv_string_to_datetime" is-trigger-function="0" unique-function-name="conv_string_to_datetime" is-aggregate="f" language-name="plpgsql" context="conv_string_to_datetime" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,numeric" comment="This function parses the TEXT string and converts it into a DATETIME value, according to specified style (conversion mask)." is-returning-set="f" ret-datatype="timestamp" function-arguments="p_datatype text, p_datetimestring text, p_style numeric DEFAULT 0" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23952" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datatype text, p_datetimestring text, p_style numeric" overload-function-count="1" proc-language="plpgsql" function-signature="conv_string_to_datetime(p_datatype text, p_datetimestring text, p_style numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day VARCHAR;
    v_year VARCHAR;
    v_month VARCHAR;
    v_style SMALLINT;
    v_scale SMALLINT;
    v_hours VARCHAR;
    v_hijridate DATE;
    v_minutes VARCHAR;
    v_seconds VARCHAR;
    v_fseconds VARCHAR;
    v_datatype VARCHAR;
    v_timepart VARCHAR;
    v_leftpart VARCHAR;
    v_middlepart VARCHAR;
    v_rightpart VARCHAR;
    v_datestring VARCHAR;
    v_err_message VARCHAR;
    v_date_format VARCHAR;
    v_res_datatype VARCHAR;
    v_datetimestring VARCHAR;
    v_datatype_groups TEXT[];
    v_regmatch_groups TEXT[];
    v_lang_metadata_json JSONB;
    v_compmonth_regexp VARCHAR;
    v_resdatetime TIMESTAMP(6) WITHOUT TIME ZONE;
    CONVERSION_LANG CONSTANT VARCHAR := '';
    DATE_FORMAT CONSTANT VARCHAR := '';
    DAYMM_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    FULLYEAR_REGEXP CONSTANT VARCHAR := '(\d{4})';
    SHORTYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    COMPYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,2}|\d{4})';
    AMPM_REGEXP CONSTANT VARCHAR := '(?:[AP]M)';
    MASKSEP_REGEXP CONSTANT VARCHAR := '(?:\.|-|/)';
    TIMEUNIT_REGEXP CONSTANT VARCHAR := '\s*\d{1,2}\s*';
    FRACTSECS_REGEXP CONSTANT VARCHAR := '\s*\d{1,9}\s*';
    DATATYPE_REGEXP CONSTANT VARCHAR := '^(DATETIME|SMALLDATETIME|DATETIME2)\s*(?:\()?\s*((?:-)?\d+)?\s*(?:\))?$';
    HHMMSSFS_PART_REGEXP CONSTANT VARCHAR := concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
                                                    TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, AMPM_REGEXP, '?|',
                                                    TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\.', FRACTSECS_REGEXP, AMPM_REGEXP, '?|',
                                                    TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, AMPM_REGEXP, '?|',
                                                    TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '(?:\.|\:)', FRACTSECS_REGEXP, AMPM_REGEXP, '?');
    HHMMSSFS_DOT_PART_REGEXP CONSTANT VARCHAR := concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
                                                        TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, AMPM_REGEXP, '?|',
                                                        TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\.', FRACTSECS_REGEXP, AMPM_REGEXP, '?|',
                                                        TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, AMPM_REGEXP, '?|',
                                                        TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '(?:\.)', FRACTSECS_REGEXP, AMPM_REGEXP, '?');
    HHMMSSFS_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')$');
    DEFMASK1_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 MASKSEP_REGEXP, '*\s*($comp_month$)\s*', DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP,
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK1_1_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '?\s*($comp_month$)\s*', DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP, '$');
    DEFMASK1_2_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '\s*($comp_month$)\s*', DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP, '$');
    DEFMASK2_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '*\s*($comp_month$)\s*', COMPYEAR_REGEXP,
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK2_1_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '?\s*($comp_month$)\s*', COMPYEAR_REGEXP, '$');
    DEFMASK2_2_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*($comp_month$)\s*', COMPYEAR_REGEXP, '$');
    DEFMASK3_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '*\s*($comp_month$)\s*', DAYMM_REGEXP,
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK3_1_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '?\s*($comp_month$)\s*', DAYMM_REGEXP, '$');
    DEFMASK3_2_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '\s*($comp_month$)\s*', DAYMM_REGEXP, '$');
    DEFMASK4_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '*\s*($comp_month$)',
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK4_1_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '?\s*($comp_month$)$');
    DEFMASK4_2_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*($comp_month$)$');
    DEFMASK5_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '*\s*($comp_month$)',
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK5_1_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '?\s*($comp_month$)$');
    DEFMASK5_2_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s+', COMPYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '\s*($comp_month$)$');
    DEFMASK6_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 MASKSEP_REGEXP, '*\s*($comp_month$)\s*', FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP,
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK6_1_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '?\s*($comp_month$)\s*', FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP, '$');
    DEFMASK6_2_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '\s*($comp_month$)\s*', FULLYEAR_REGEXP, '\s+', DAYMM_REGEXP, '$');
    DEFMASK7_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 MASKSEP_REGEXP, '*\s*($comp_month$)\s*', DAYMM_REGEXP, '\s*,\s*', COMPYEAR_REGEXP,
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK7_1_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '?\s*($comp_month$)\s*', DAYMM_REGEXP, '\s*,\s*', COMPYEAR_REGEXP, '$');
    DEFMASK7_2_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '\s*($comp_month$)\s*', DAYMM_REGEXP, '\s*,\s*', COMPYEAR_REGEXP, '$');
    DEFMASK8_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '*\s*($comp_month$)',
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK8_1_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '?\s*($comp_month$)$');
    DEFMASK8_2_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '\s*($comp_month$)$');
    DEFMASK9_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                 MASKSEP_REGEXP, '*\s*($comp_month$)\s*', FULLYEAR_REGEXP,
                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK9_1_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '?\s*($comp_month$)\s*', FULLYEAR_REGEXP, '$');
    DEFMASK9_2_REGEXP CONSTANT VARCHAR := concat('^', MASKSEP_REGEXP, '\s*($comp_month$)\s*', FULLYEAR_REGEXP, '$');
    DEFMASK10_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                  DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*($comp_month$)\s*', MASKSEP_REGEXP, '\s*', COMPYEAR_REGEXP,
                                                  '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DEFMASK10_1_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*($comp_month$)\s*', MASKSEP_REGEXP, '\s*', COMPYEAR_REGEXP, '$');
    DOT_SLASH_DASH_COMPYEAR1_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                                 DAYMM_REGEXP, '\s*(?:\.|/|-)\s*', DAYMM_REGEXP, '\s*(?:\.|/|-)\s*', COMPYEAR_REGEXP,
                                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DOT_SLASH_DASH_COMPYEAR1_1_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', COMPYEAR_REGEXP, '$');
    DOT_SLASH_DASH_SHORTYEAR_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', SHORTYEAR_REGEXP, '$');
    DOT_SLASH_DASH_FULLYEAR1_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                                 DAYMM_REGEXP, '\s*(?:\.|/|-)\s*', DAYMM_REGEXP, '\s*(?:\.|/|-)\s*', FULLYEAR_REGEXP,
                                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    DOT_SLASH_DASH_FULLYEAR1_1_REGEXP CONSTANT VARCHAR := concat('^', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', FULLYEAR_REGEXP, '$');
    FULLYEAR_DOT_SLASH_DASH1_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*',
                                                                 FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', DAYMM_REGEXP,
                                                                 '\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    FULLYEAR_DOT_SLASH_DASH1_1_REGEXP CONSTANT VARCHAR := concat('^', FULLYEAR_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', DAYMM_REGEXP, '\s*', MASKSEP_REGEXP, '\s*', DAYMM_REGEXP, '$');
    SHORT_DIGITMASK1_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*\d{6}\s*(', HHMMSSFS_PART_REGEXP, ')?$');
    FULL_DIGITMASK1_0_REGEXP CONSTANT VARCHAR := concat('^(', HHMMSSFS_PART_REGEXP, ')?\s*\d{8}\s*(', HHMMSSFS_PART_REGEXP, ')?$');
BEGIN
    v_datatype := trim(p_datatype);
    v_datetimestring := upper(trim(p_datetimestring));
    v_style := floor(p_style)::SMALLINT;

    v_datatype_groups := regexp_matches(v_datatype, DATATYPE_REGEXP, 'gi');

    v_res_datatype := upper(v_datatype_groups[1]);
    v_scale := v_datatype_groups[2]::SMALLINT;

    IF (v_res_datatype IS NULL) THEN
        RAISE datatype_mismatch;
    ELSIF (v_res_datatype <> 'DATETIME2' AND v_scale IS NOT NULL)
    THEN
        RAISE invalid_indicator_parameter_value;
    ELSIF (coalesce(v_scale, 0) NOT BETWEEN 0 AND 7)
    THEN
        RAISE interval_field_overflow;
    ELSIF (v_scale IS NULL) THEN
        v_scale := 7;
    END IF;

    IF (scale(p_style) > 0) THEN
        RAISE most_specific_type_mismatch;
    ELSIF (NOT ((v_style BETWEEN 0 AND 14) OR
             (v_style BETWEEN 20 AND 25) OR
             (v_style BETWEEN 100 AND 114) OR
             (v_style IN (120, 121, 126, 127, 130, 131))) AND
             v_res_datatype = 'DATETIME2')
    THEN
        RAISE invalid_parameter_value;
    END IF;

    v_timepart := trim(substring(v_datetimestring, HHMMSSFS_PART_REGEXP));
    v_datestring := trim(regexp_replace(v_datetimestring, HHMMSSFS_PART_REGEXP, '', 'gi'));

    BEGIN
        v_lang_metadata_json := aws_sqlserver_ext.get_lang_metadata_json(CONVERSION_LANG);
    EXCEPTION
        WHEN OTHERS THEN
        RAISE invalid_escape_sequence;
    END;

    v_date_format := coalesce(nullif(DATE_FORMAT, ''), v_lang_metadata_json ->> 'date_format');

    v_compmonth_regexp := array_to_string(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_shortnames')),
                                                    ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_names'))), '|');

    IF (v_datetimestring ~* replace(DEFMASK1_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK2_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK3_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK4_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK5_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK6_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK7_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK8_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK9_0_REGEXP, '$comp_month$', v_compmonth_regexp) OR
        v_datetimestring ~* replace(DEFMASK10_0_REGEXP, '$comp_month$', v_compmonth_regexp))
    THEN
        IF ((v_style IN (127, 130, 131) AND v_res_datatype IN ('DATETIME', 'SMALLDATETIME')) OR
            (v_style IN (130, 131) AND v_res_datatype = 'DATETIME2'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        IF ((v_datestring ~* replace(DEFMASK1_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK2_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK3_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK4_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK5_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK6_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK7_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK8_2_REGEXP, '$comp_month$', v_compmonth_regexp) OR
             v_datestring ~* replace(DEFMASK9_2_REGEXP, '$comp_month$', v_compmonth_regexp)) AND
            v_res_datatype = 'DATETIME2')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        IF (v_datestring ~* replace(DEFMASK1_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK1_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[2];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);

        ELSIF (v_datestring ~* replace(DEFMASK2_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK2_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[1];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);

        ELSIF (v_datestring ~* replace(DEFMASK3_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK3_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[3];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := v_regmatch_groups[1];

        ELSIF (v_datestring ~* replace(DEFMASK4_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK4_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[2];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
            v_year := v_regmatch_groups[1];

        ELSIF (v_datestring ~* replace(DEFMASK5_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK5_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[1];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[2]);

        ELSIF (v_datestring ~* replace(DEFMASK6_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK6_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[3];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := v_regmatch_groups[2];

        ELSIF (v_datestring ~* replace(DEFMASK7_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK7_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[2];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);

        ELSIF (v_datestring ~* replace(DEFMASK8_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK8_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := '01';
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := v_regmatch_groups[1];

        ELSIF (v_datestring ~* replace(DEFMASK9_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK9_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := '01';
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[1], v_lang_metadata_json);
            v_year := v_regmatch_groups[2];

        ELSIF (v_datestring ~* replace(DEFMASK10_1_REGEXP, '$comp_month$', v_compmonth_regexp))
        THEN
            v_regmatch_groups := regexp_matches(v_datestring, replace(DEFMASK10_1_REGEXP, '$comp_month$', v_compmonth_regexp), 'gi');
            v_day := v_regmatch_groups[1];
            v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
            v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[3]);
        ELSE
            RAISE invalid_character_value_for_cast;
        END IF;
    ELSIF (v_datetimestring ~* DOT_SLASH_DASH_COMPYEAR1_0_REGEXP)
    THEN
        IF (v_style IN (6, 7, 8, 9, 12, 13, 14, 24, 100, 106, 107, 108, 109, 112, 113, 114, 130) AND
            v_res_datatype = 'DATETIME2')
        THEN
            RAISE invalid_regular_expression;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, DOT_SLASH_DASH_COMPYEAR1_1_REGEXP, 'gi');
        v_leftpart := v_regmatch_groups[1];
        v_middlepart := v_regmatch_groups[2];
        v_rightpart := v_regmatch_groups[3];

        IF (v_datestring ~* DOT_SLASH_DASH_SHORTYEAR_REGEXP)
        THEN
            IF ((v_style NOT IN (0, 1, 2, 3, 4, 5, 10, 11) AND v_res_datatype IN ('DATETIME', 'SMALLDATETIME')) OR
                (v_style NOT IN (0, 1, 2, 3, 4, 5, 10, 11, 12) AND v_res_datatype = 'DATETIME2'))
            THEN
                RAISE invalid_datetime_format;
            END IF;

            IF ((v_style IN (1, 10) AND v_date_format <> 'MDY' AND v_res_datatype IN ('DATETIME', 'SMALLDATETIME')) OR
                (v_style IN (0, 1, 10) AND v_date_format NOT IN ('DMY', 'DYM', 'MYD', 'YMD', 'YDM') AND v_res_datatype IN ('DATETIME', 'SMALLDATETIME')) OR
                (v_style IN (0, 1, 10, 22) AND v_date_format NOT IN ('DMY', 'DYM', 'MYD', 'YMD', 'YDM') AND v_res_datatype = 'DATETIME2') OR
                (v_style IN (1, 10, 22) AND v_date_format IN ('DMY', 'DYM', 'MYD', 'YMD', 'YDM') AND v_res_datatype = 'DATETIME2'))
            THEN
                v_day := v_middlepart;
                v_month := v_leftpart;
                v_year := aws_sqlserver_ext.get_full_year(v_rightpart);

            ELSIF ((v_style IN (2, 11) AND v_date_format <> 'YMD') OR
                   (v_style IN (0, 2, 11) AND v_date_format = 'YMD'))
            THEN
                v_day := v_rightpart;
                v_month := v_middlepart;
                v_year := aws_sqlserver_ext.get_full_year(v_leftpart);

            ELSIF ((v_style IN (3, 4, 5) AND v_date_format <> 'DMY') OR
                   (v_style IN (0, 3, 4, 5) AND v_date_format = 'DMY'))
            THEN
                v_day := v_leftpart;
                v_month := v_middlepart;
                v_year := aws_sqlserver_ext.get_full_year(v_rightpart);

            ELSIF (v_style = 0 AND v_date_format = 'DYM')
            THEN
                v_day = v_leftpart;
                v_month = v_rightpart;
                v_year = aws_sqlserver_ext.get_full_year(v_middlepart);

            ELSIF (v_style = 0 AND v_date_format = 'MYD')
            THEN
                v_day := v_rightpart;
                v_month := v_leftpart;
                v_year = aws_sqlserver_ext.get_full_year(v_middlepart);

            ELSIF (v_style = 0 AND v_date_format = 'YDM')
            THEN
                IF (v_res_datatype = 'DATETIME2') THEN
                    RAISE character_not_in_repertoire;
                END IF;

                v_day := v_middlepart;
                v_month := v_rightpart;
                v_year := aws_sqlserver_ext.get_full_year(v_leftpart);
            ELSE
                RAISE invalid_character_value_for_cast;
            END IF;
        ELSIF (v_datestring ~* DOT_SLASH_DASH_FULLYEAR1_1_REGEXP)
        THEN
            IF (v_style NOT IN (0, 20, 21, 101, 102, 103, 104, 105, 110, 111, 120, 121, 130, 131) AND
                v_res_datatype IN ('DATETIME', 'SMALLDATETIME'))
            THEN
                RAISE invalid_datetime_format;
            ELSIF (v_style IN (130, 131) AND v_res_datatype = 'SMALLDATETIME') THEN
                RAISE invalid_character_value_for_cast;
            END IF;

            v_year := v_rightpart;
            IF (v_leftpart::SMALLINT <= 12)
            THEN
                IF ((v_style IN (103, 104, 105, 130, 131) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')) OR
                    (v_style IN (0, 103, 104, 105, 130, 131) AND ((v_date_format = 'DMY' AND v_res_datatype = 'DATETIME2') OR
                    (v_date_format IN ('DMY', 'DYM', 'YDM') AND v_res_datatype <> 'DATETIME2'))) OR
                    (v_style IN (103, 104, 105, 130, 131) AND v_date_format IN ('DMY', 'DYM', 'YDM') AND v_res_datatype = 'DATETIME2'))
                THEN
                    v_day := v_leftpart;
                    v_month := v_middlepart;

                ELSIF ((v_style IN (20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format IN ('DMY', 'DYM', 'YDM') AND v_res_datatype IN ('DATETIME', 'SMALLDATETIME')) OR
                       (v_style IN (0, 20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM') AND v_res_datatype IN ('DATETIME', 'SMALLDATETIME')) OR
                       (v_style IN (101, 110) AND v_date_format IN ('DMY', 'DYM', 'MYD', 'YDM') AND v_res_datatype = 'DATETIME2') OR
                       (v_style IN (0, 101, 110) AND v_date_format NOT IN ('DMY', 'DYM', 'MYD', 'YDM') AND v_res_datatype = 'DATETIME2'))
                THEN
                    v_day := v_middlepart;
                    v_month := v_leftpart;
                END IF;
            ELSE
                IF ((v_style IN (103, 104, 105, 130, 131) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')) OR
                    (v_style IN (0, 103, 104, 105, 130, 131) AND ((v_date_format = 'DMY' AND v_res_datatype = 'DATETIME2') OR
                    (v_date_format IN ('DMY', 'DYM', 'YDM') AND v_res_datatype <> 'DATETIME2'))) OR
                    (v_style IN (103, 104, 105, 130, 131) AND v_date_format IN ('DMY', 'DYM', 'YDM') AND v_res_datatype = 'DATETIME2'))
                THEN
                    v_day := v_leftpart;
                    v_month := v_middlepart;
                ELSE
                    IF (v_res_datatype = 'DATETIME2') THEN
                        RAISE invalid_datetime_format;
                    END IF;

                    RAISE invalid_character_value_for_cast;
                END IF;
            END IF;
        END IF;
    ELSIF (v_datetimestring ~* FULLYEAR_DOT_SLASH_DASH1_0_REGEXP)
    THEN
        IF (v_style NOT IN (0, 20, 21, 101, 102, 103, 104, 105, 110, 111, 120, 121, 130, 131) AND
            v_res_datatype IN ('DATETIME', 'SMALLDATETIME'))
        THEN
            RAISE invalid_datetime_format;
        ELSIF (v_style IN (6, 7, 8, 9, 12, 13, 14, 24, 100, 106, 107, 108, 109, 112, 113, 114, 130) AND
            v_res_datatype = 'DATETIME2')
        THEN
            RAISE invalid_regular_expression;
        ELSIF (v_style IN (130, 131) AND v_res_datatype = 'SMALLDATETIME')
        THEN
            RAISE invalid_character_value_for_cast;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, FULLYEAR_DOT_SLASH_DASH1_1_REGEXP, 'gi');
        v_year := v_regmatch_groups[1];
        v_middlepart := v_regmatch_groups[2];
        v_rightpart := v_regmatch_groups[3];

        IF ((v_res_datatype IN ('DATETIME', 'SMALLDATETIME') AND v_rightpart::SMALLINT <= 12) OR v_res_datatype = 'DATETIME2')
        THEN
            IF ((v_style IN (20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format IN ('DMY', 'DYM', 'YDM') AND v_res_datatype <> 'DATETIME2') OR
                (v_style IN (0, 20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM') AND v_res_datatype <> 'DATETIME2') OR                
                (v_style IN (0, 20, 21, 23, 25, 101, 102, 110, 111, 120, 121, 126, 127) AND v_res_datatype = 'DATETIME2'))
            THEN
                v_day := v_rightpart;
                v_month := v_middlepart;

            ELSIF ((v_style IN (103, 104, 105, 130, 131) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')) OR
                    v_style IN (0, 103, 104, 105, 130, 131) AND v_date_format IN ('DMY', 'DYM', 'YDM'))
            THEN
                v_day := v_middlepart;
                v_month := v_rightpart;
            END IF;
        ELSIF (v_res_datatype IN ('DATETIME', 'SMALLDATETIME') AND v_rightpart::SMALLINT > 12)
        THEN
            IF ((v_style IN (20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format IN ('DMY', 'DYM', 'YDM')) OR
                (v_style IN (0, 20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')))
            THEN
                v_day := v_rightpart;
                v_month := v_middlepart;

            ELSIF ((v_style IN (103, 104, 105, 130, 131) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')) OR
                   (v_style IN (0, 103, 104, 105, 130, 131) AND v_date_format IN ('DMY', 'DYM', 'YDM')))
            THEN
                RAISE invalid_character_value_for_cast;
            END IF;
        END IF;
    ELSIF (v_datetimestring ~* SHORT_DIGITMASK1_0_REGEXP OR
           v_datetimestring ~* FULL_DIGITMASK1_0_REGEXP)
    THEN
        IF (v_style = 127 AND v_res_datatype <> 'DATETIME2')
        THEN
            RAISE invalid_datetime_format;
        ELSIF (v_style IN (130, 131) AND v_res_datatype = 'SMALLDATETIME')
        THEN
            RAISE invalid_character_value_for_cast;
        END IF;

        IF (v_datestring ~* '^\d{6}$')
        THEN
            v_day := substr(v_datestring, 5, 2);
            v_month := substr(v_datestring, 3, 2);
            v_year := aws_sqlserver_ext.get_full_year(substr(v_datestring, 1, 2));

        ELSIF (v_datestring ~* '^\d{8}$')
        THEN
            v_day := substr(v_datestring, 7, 2);
            v_month := substr(v_datestring, 5, 2);
            v_year := substr(v_datestring, 1, 4);
        END IF;
    ELSIF (v_datetimestring ~* HHMMSSFS_REGEXP)
    THEN
        v_day := '01';
        v_month := '01';
        v_year := '1900';
    ELSE
        RAISE invalid_datetime_format;
    END IF;

    IF (((v_datetimestring ~* HHMMSSFS_PART_REGEXP AND v_res_datatype = 'DATETIME2') OR
        (v_datetimestring ~* SHORT_DIGITMASK1_0_REGEXP OR v_datetimestring ~* FULL_DIGITMASK1_0_REGEXP OR
          v_datetimestring ~* FULLYEAR_DOT_SLASH_DASH1_0_REGEXP OR v_datetimestring ~* DOT_SLASH_DASH_FULLYEAR1_0_REGEXP)) AND
        v_style IN (130, 131))
    THEN
        v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_year) - 1;
        v_day = to_char(v_hijridate, 'DD');
        v_month = to_char(v_hijridate, 'MM');
        v_year = to_char(v_hijridate, 'YYYY');
    END IF;

    v_hours := coalesce(aws_sqlserver_ext.get_timeunit_from_string(v_timepart, 'HOURS'), '0');
    v_minutes := coalesce(aws_sqlserver_ext.get_timeunit_from_string(v_timepart, 'MINUTES'), '0');
    v_seconds := coalesce(aws_sqlserver_ext.get_timeunit_from_string(v_timepart, 'SECONDS'), '0');
    v_fseconds := coalesce(aws_sqlserver_ext.get_timeunit_from_string(v_timepart, 'FRACTSECONDS'), '0');

    IF ((v_res_datatype IN ('DATETIME', 'SMALLDATETIME') OR
         (v_res_datatype = 'DATETIME2' AND v_timepart !~* HHMMSSFS_DOT_PART_REGEXP)) AND
        char_length(v_fseconds) > 3)
    THEN
        RAISE invalid_datetime_format;
    END IF;

    BEGIN
        IF (v_res_datatype IN ('DATETIME', 'SMALLDATETIME'))
        THEN
            v_resdatetime := aws_sqlserver_ext.datetimefromparts(v_year, v_month, v_day,
                                                                 v_hours, v_minutes, v_seconds,
                                                                 rpad(v_fseconds, 3, '0'));
            IF (v_res_datatype = 'SMALLDATETIME' AND
                to_char(v_resdatetime, 'SS') <> '00')
            THEN
                IF (to_char(v_resdatetime, 'SS')::SMALLINT >= 30) THEN
                    v_resdatetime := v_resdatetime + INTERVAL '1 minute';
                END IF;

                v_resdatetime := to_timestamp(to_char(v_resdatetime, 'DD.MM.YYYY.HH24.MI'), 'DD.MM.YYYY.HH24.MI');
            END IF;
        ELSIF (v_res_datatype = 'DATETIME2')
        THEN
            v_fseconds := aws_sqlserver_ext.get_microsecs_from_fractsecs(v_fseconds, v_scale);
            v_seconds := concat_ws('.', v_seconds, v_fseconds);

            v_resdatetime := make_timestamp(v_year::SMALLINT, v_month::SMALLINT, v_day::SMALLINT,
                                            v_hours::SMALLINT, v_minutes::SMALLINT, v_seconds::NUMERIC);
        END IF;
    EXCEPTION
        WHEN datetime_field_overflow THEN
            RAISE invalid_datetime_format;
        WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;

        IF (v_err_message ~* 'Cannot construct data type') THEN
            RAISE invalid_character_value_for_cast;
        END IF;
    END;

    RETURN v_resdatetime;
EXCEPTION
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Argument data type NUMERIC is invalid for argument 3 of conv_string_to_datetime function.',
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := format('The style %s is not supported for conversions from VARCHAR to %s.', v_style, v_res_datatype),
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_regular_expression THEN
        RAISE USING MESSAGE := format('The input character string doesn''t follow style %s.', v_style),
                    DETAIL := 'Selected "style" param value isn''t valid for conversion of passed character string.',
                    HINT := 'Either change the input character string or use a different style.';

    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := 'Data type should be one of these values: ''DATETIME'', ''SMALLDATETIME'', ''DATETIME2''/''DATETIME2(n)''.',
                    DETAIL := 'Use of incorrect "datatype" parameter value during conversion process.',
                    HINT := 'Change "datatype" parameter to the proper value and try again.';

    WHEN invalid_indicator_parameter_value THEN
        RAISE USING MESSAGE := format('Invalid attributes specified for data type %s.', v_res_datatype),
                    DETAIL := 'Use of incorrect scale value, which is not corresponding to specified data type.',
                    HINT := 'Change data type scale component or select different data type and try again.';

    WHEN interval_field_overflow THEN
        RAISE USING MESSAGE := format('Specified scale %s is invalid.', v_scale),
                    DETAIL := 'Use of incorrect data type scale value during conversion process.',
                    HINT := 'Change scale component of data type parameter to be in range [0..7] and try again.';

    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := CASE v_res_datatype
                                  WHEN 'SMALLDATETIME' THEN 'Conversion failed when converting character string to SMALLDATETIME data type.'
                                  ELSE 'Conversion failed when converting date and time from character string.'
                               END,
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';

    WHEN invalid_character_value_for_cast THEN
        RAISE USING MESSAGE := 'The conversion of a VARCHAR data type to a DATETIME data type resulted in an out-of-range value.',
                    DETAIL := 'Use of incorrect pair of input parameter values during conversion process.',
                    HINT := 'Check input parameter values, correct them if needed, and try again.';

    WHEN character_not_in_repertoire THEN
        RAISE USING MESSAGE := 'The YDM date format isn''t supported when converting from this string format to date and time.',
                    DETAIL := 'Use of incorrect DATE_FORMAT constant value regarding string format parameter during conversion process.',
                    HINT := 'Change DATE_FORMAT constant to one of these values: MDY|DMY|DYM, recompile function and try again.';

    WHEN invalid_escape_sequence THEN
        RAISE USING MESSAGE := format('Invalid CONVERSION_LANG constant value - ''%s''. Allowed values are: ''English'', ''Deutsch'', etc.',
                                      CONVERSION_LANG),
                    DETAIL := 'Compiled incorrect CONVERSION_LANG constant value in function''s body.',
                    HINT := 'Correct CONVERSION_LANG constant value in function''s body, recompile it and try again.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Passed argument value contains illegal characters.',
                    HINT := 'Correct passed argument value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="f3f0f9da-27a9-4f96-bc37-4b4e6cde8cf3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7df381d4-ed60-4e6a-aa01-11fa2c9f5ebc" name="conv_string_to_time" is-trigger-function="0" unique-function-name="conv_string_to_time" is-aggregate="f" language-name="plpgsql" context="conv_string_to_time" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,numeric" comment="This function parses the TEXT string and converts it into a TIME value, according to specified style (conversion mask)." is-returning-set="f" ret-datatype="time" function-arguments="p_datatype text, p_timestring text, p_style numeric DEFAULT 0" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23954" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datatype text, p_timestring text, p_style numeric" overload-function-count="1" proc-language="plpgsql" function-signature="conv_string_to_time(p_datatype text, p_timestring text, p_style numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_hours SMALLINT;
    v_style SMALLINT;
    v_scale SMALLINT;
    v_daypart VARCHAR;
    v_seconds VARCHAR;
    v_minutes SMALLINT;
    v_fseconds VARCHAR;
    v_datatype VARCHAR;
    v_timestring VARCHAR;
    v_err_message VARCHAR;
    v_src_datatype VARCHAR;
    v_timeunit_mask VARCHAR;
    v_datatype_groups TEXT[];
    v_regmatch_groups TEXT[];
    AMPM_REGEXP CONSTANT VARCHAR := '\s*([AP]M)';
    TIMEUNIT_REGEXP CONSTANT VARCHAR := '\s*(\d{1,2})\s*';
    FRACTSECS_REGEXP CONSTANT VARCHAR := '\s*(\d{1,9})';
    HHMMSSFS_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP,
                                               '\:', TIMEUNIT_REGEXP,
                                               '\:', TIMEUNIT_REGEXP,
                                               '(?:\.|\:)', FRACTSECS_REGEXP, '$');
    HHMMSS_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '$');
    HHMMFS_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\.', FRACTSECS_REGEXP, '$');
    HHMM_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '$');
    HH_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '$');
    DATATYPE_REGEXP CONSTANT VARCHAR := '^(TIME)\s*(?:\()?\s*((?:-)?\d+)?\s*(?:\))?$';
BEGIN
    v_datatype := trim(regexp_replace(p_datatype, 'DATETIME', 'TIME', 'gi'));
    v_timestring := upper(trim(p_timestring));
    v_style := floor(p_style)::SMALLINT;

    v_datatype_groups := regexp_matches(v_datatype, DATATYPE_REGEXP, 'gi');

    v_src_datatype := upper(v_datatype_groups[1]);
    v_scale := v_datatype_groups[2]::SMALLINT;

    IF (v_src_datatype IS NULL) THEN
        RAISE datatype_mismatch;
    ELSIF (coalesce(v_scale, 0) NOT BETWEEN 0 AND 7)
    THEN
        RAISE interval_field_overflow;
    ELSIF (v_scale IS NULL) THEN
        v_scale := 7;
    END IF;

    IF (scale(p_style) > 0) THEN
        RAISE most_specific_type_mismatch;
    ELSIF (NOT ((v_style BETWEEN 0 AND 14) OR
             (v_style BETWEEN 20 AND 25) OR
             (v_style BETWEEN 100 AND 114) OR
             v_style IN (120, 121, 126, 127, 130, 131)))
    THEN
        RAISE invalid_parameter_value;
    END IF;

    v_daypart := substring(v_timestring, 'AM|PM');
    v_timestring := trim(regexp_replace(v_timestring, coalesce(v_daypart, ''), ''));

    v_timeunit_mask :=
        CASE
           WHEN (v_timestring ~* HHMMSSFS_REGEXP) THEN HHMMSSFS_REGEXP
           WHEN (v_timestring ~* HHMMSS_REGEXP) THEN HHMMSS_REGEXP
           WHEN (v_timestring ~* HHMMFS_REGEXP) THEN HHMMFS_REGEXP
           WHEN (v_timestring ~* HHMM_REGEXP) THEN HHMM_REGEXP
           WHEN (v_timestring ~* HH_REGEXP) THEN HH_REGEXP
        END;

    IF (v_timeunit_mask IS NULL) THEN
        RAISE invalid_datetime_format;
    END IF;

    v_regmatch_groups := regexp_matches(v_timestring, v_timeunit_mask, 'gi');

    v_hours := v_regmatch_groups[1]::SMALLINT;
    v_minutes := v_regmatch_groups[2]::SMALLINT;

    IF (v_timestring ~* HHMMFS_REGEXP) THEN
        v_fseconds := v_regmatch_groups[3];
    ELSE
        v_seconds := v_regmatch_groups[3];
        v_fseconds := v_regmatch_groups[4];
    END IF;

   IF (v_daypart IS NOT NULL) THEN
      IF ((v_daypart = 'AM' AND v_hours NOT BETWEEN 0 AND 12) OR
          (v_daypart = 'PM' AND v_hours NOT BETWEEN 1 AND 23))
      THEN
          RAISE numeric_value_out_of_range;
      ELSIF (v_daypart = 'PM' AND v_hours < 12) THEN
          v_hours := v_hours + 12;
      ELSIF (v_daypart = 'AM' AND v_hours = 12) THEN
          v_hours := v_hours - 12;
      END IF;
   END IF;

    v_fseconds := aws_sqlserver_ext.get_microsecs_from_fractsecs(v_fseconds, v_scale);
    v_seconds := concat_ws('.', v_seconds, v_fseconds);

    RETURN make_time(v_hours, v_minutes, v_seconds::NUMERIC);
EXCEPTION
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Argument data type NUMERIC is invalid for argument 3 of conv_string_to_time function.',
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := format('The style %s is not supported for conversions from VARCHAR to TIME.', v_style),
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := 'Source data type should be ''TIME'' or ''TIME(n)''.',
                    DETAIL := 'Use of incorrect "datatype" parameter value during conversion process.',
                    HINT := 'Change "datatype" parameter to the proper value and try again.';

    WHEN interval_field_overflow THEN
        RAISE USING MESSAGE := format('Specified scale %s is invalid.', v_scale),
                    DETAIL := 'Use of incorrect data type scale value during conversion process.',
                    HINT := 'Change scale component of data type parameter to be in range [0..7] and try again.';

    WHEN numeric_value_out_of_range THEN
        RAISE USING MESSAGE := 'Could not extract correct hour value due to it''s inconsistency with AM|PM day part mark.',
                    DETAIL := 'Extracted hour value doesn''t fall in correct day part mark range: 0..12 for "AM" or 1..23 for "PM".',
                    HINT := 'Correct a hour value in the source string or remove AM|PM day part mark out of it.';

    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := 'Conversion failed when converting time from character string.',
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="e9210f6e-4455-4559-96fe-e5ba0bd61992" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="474617db-bbb8-4e9e-a4fe-77bef9958649" name="conv_time_to_string" is-trigger-function="0" unique-function-name="conv_time_to_string" is-aggregate="f" language-name="plpgsql" context="conv_time_to_string" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,time without time zone,numeric" comment="This function converts the TIME value into a character string, according to specified style (conversion mask)." is-returning-set="f" ret-datatype="text" function-arguments="p_datatype text, p_src_datatype text, p_timeval time without time zone, p_style numeric DEFAULT 25" schema-id="23774" function-type="RET_SCALAR" count-arguments="4" function-id="23948" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datatype text, p_src_datatype text, p_timeval time without time zone, p_style numeric" overload-function-count="1" proc-language="plpgsql" function-signature="conv_time_to_string(p_datatype text, p_src_datatype text, p_timeval time without time zone, p_style numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_hours VARCHAR;
    v_style SMALLINT;
    v_scale SMALLINT;
    v_resmask VARCHAR;
    v_fseconds VARCHAR;
    v_datatype VARCHAR;
    v_resstring VARCHAR;
    v_lengthexpr VARCHAR;
    v_res_length SMALLINT;
    v_res_datatype VARCHAR;
    v_src_datatype VARCHAR;
    v_res_maxlength SMALLINT;
    VARCHAR_MAX CONSTANT SMALLINT := 8000;
    NVARCHAR_MAX CONSTANT SMALLINT := 4000;
    CHARACTER_REGEXP CONSTANT VARCHAR := 'CHAR|NCHAR|CHARACTER|NATIONAL CHARACTER';
    VARCHAR_REGEXP CONSTANT VARCHAR := 'VARCHAR|NVARCHAR|CHARACTER VARYING|NATIONAL CHARACTER VARYING';
    DATATYPE_REGEXP CONSTANT VARCHAR := concat('^\s*(', CHARACTER_REGEXP, '|', VARCHAR_REGEXP, ')\s*$');
    DATATYPE_MASK_REGEXP CONSTANT VARCHAR := concat('^\s*(?:', CHARACTER_REGEXP, '|', VARCHAR_REGEXP, ')\s*\(\s*(\d+|MAX)\s*\)\s*$');
    SRCDATATYPE_MASK_REGEXP CONSTANT VARCHAR := '^\s*(?:TIME)\s*(?:\s*\(\s*(\d+)\s*\)\s*)?\s*$';
BEGIN
    v_datatype := regexp_replace(upper(trim(p_datatype)), '\s+', ' ', 'gi');
    v_src_datatype := upper(trim(p_src_datatype));
    v_style := floor(p_style)::SMALLINT;

    IF (v_src_datatype ~* SRCDATATYPE_MASK_REGEXP)
    THEN
        v_scale := coalesce(substring(v_src_datatype, SRCDATATYPE_MASK_REGEXP)::SMALLINT, 7);

        IF (v_scale NOT BETWEEN 0 AND 7) THEN
            RAISE invalid_regular_expression;
        END IF;
    ELSE
        RAISE most_specific_type_mismatch;
    END IF;

    IF (v_datatype ~* DATATYPE_MASK_REGEXP)
    THEN
        v_res_datatype := rtrim(split_part(v_datatype, '(', 1));

        v_res_maxlength := CASE
                              WHEN substring(v_res_datatype, '^(NCHAR|NATIONAL.*)$') IS NULL
                              THEN VARCHAR_MAX
                              ELSE NVARCHAR_MAX
                           END;

        v_lengthexpr := substring(v_datatype, DATATYPE_MASK_REGEXP);

        IF (v_lengthexpr <> 'MAX' AND char_length(v_lengthexpr) > 4) THEN
            RAISE interval_field_overflow;
        END IF;

        v_res_length := CASE v_lengthexpr
                           WHEN 'MAX' THEN v_res_maxlength
                           ELSE v_lengthexpr::SMALLINT
                        END;
    ELSIF (v_datatype ~* DATATYPE_REGEXP) THEN
        v_res_datatype := v_datatype;
    ELSE
        RAISE datatype_mismatch;
    END IF;

    IF (scale(p_style) > 0) THEN
        RAISE escape_character_conflict;
    ELSIF (NOT ((v_style BETWEEN 0 AND 14) OR
                (v_style BETWEEN 20 AND 25) OR
                (v_style BETWEEN 100 AND 114) OR
                v_style IN (120, 121, 126, 127, 130, 131)))
    THEN
        RAISE invalid_parameter_value;
    ELSIF ((v_style BETWEEN 1 AND 7) OR
           (v_style BETWEEN 10 AND 12) OR
           (v_style BETWEEN 101 AND 107) OR
           (v_style BETWEEN 110 AND 112) OR
           v_style = 23)
    THEN
        RAISE invalid_datetime_format;
    END IF;

    v_hours := ltrim(to_char(p_timeval, 'HH12'), '0');
    v_fseconds := aws_sqlserver_ext.get_microsecs_from_fractsecs(to_char(p_timeval, 'US'), v_scale);

    IF (v_scale = 7) THEN
        v_fseconds := concat(v_fseconds, '0');
    END IF;

    IF (v_style IN (0, 100))
    THEN
        v_resmask := concat(v_hours, ':MIAM');
    ELSIF (v_style IN (8, 20, 24, 108, 120))
    THEN
        v_resmask := 'HH24:MI:SS';
    ELSIF (v_style IN (9, 109))
    THEN
        v_resmask := CASE
                        WHEN (char_length(v_fseconds) = 0) THEN concat(v_hours, ':MI:SSAM')
                        ELSE format('%s:MI:SS.%sAM', v_hours, v_fseconds)
                     END;
    ELSIF (v_style IN (13, 14, 21, 25, 113, 114, 121, 126, 127))
    THEN
        v_resmask := CASE
                        WHEN (char_length(v_fseconds) = 0) THEN 'HH24:MI:SS'
                        ELSE concat('HH24:MI:SS.', v_fseconds)
                     END;
    ELSIF (v_style = 22)
    THEN
        v_resmask := format('%s:MI:SS AM', lpad(v_hours, 2, ' '));
    ELSIF (v_style IN (130, 131))
    THEN
        v_resmask := CASE
                        WHEN (char_length(v_fseconds) = 0) THEN concat(lpad(v_hours, 2, ' '), ':MI:SSAM')
                        ELSE format('%s:MI:SS.%sAM', lpad(v_hours, 2, ' '), v_fseconds)
                     END;
    END IF;

    v_resstring := to_char(p_timeval, v_resmask);

    v_resstring := substring(v_resstring, 1, coalesce(v_res_length, char_length(v_resstring)));

    RETURN CASE
              WHEN substring(v_res_datatype, concat('^(', CHARACTER_REGEXP, ')$')) IS NOT NULL
              THEN rpad(v_resstring, coalesce(v_res_length, 30), ' ')
              ELSE v_resstring
           END;
EXCEPTION
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Source data type should be ''TIME'' or ''TIME(n)''.',
                    DETAIL := 'Use of incorrect "src_datatype" parameter value during conversion process.',
                    HINT := 'Change "src_datatype" parameter to the proper value and try again.';

   WHEN invalid_regular_expression THEN
       RAISE USING MESSAGE := format('The source data type scale (%s) given to the convert specification exceeds the maximum allowable value (7).',
                                     v_scale),
                   DETAIL := 'Use of incorrect scale value of source data type parameter during conversion process.',
                   HINT := 'Change scale component of source data type parameter to the allowable value and try again.';

   WHEN interval_field_overflow THEN
       RAISE USING MESSAGE := format('The size (%s) given to the convert specification ''%s'' exceeds the maximum allowed for any data type (%s).',
                                     v_lengthexpr, lower(v_res_datatype), v_res_maxlength),
                   DETAIL := 'Use of incorrect size value of target data type parameter during conversion process.',
                   HINT := 'Change size component of data type parameter to the allowable value and try again.';

    WHEN escape_character_conflict THEN
        RAISE USING MESSAGE := 'Argument data type NUMERIC is invalid for argument 4 of convert function.',
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := format('%s is not a valid style number when converting from TIME to a character string.', v_style),
                    DETAIL := 'Use of incorrect "style" parameter value during conversion process.',
                    HINT := 'Change "style" parameter to the proper value and try again.';

    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := concat('Data type should be one of these values: ''CHAR(n|MAX)'', ''NCHAR(n|MAX)'', ''VARCHAR(n|MAX)'', ''NVARCHAR(n|MAX)'', ',
                                      '''CHARACTER VARYING(n|MAX)'', ''NATIONAL CHARACTER VARYING(n|MAX)''.'),
                    DETAIL := 'Use of incorrect "datatype" parameter value during conversion process.',
                    HINT := 'Change "datatype" parameter to the proper value and try again.';

    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := format('Error converting data type TIME to %s.',
                                      rtrim(split_part(trim(p_datatype), '(', 1))),
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';
END;
]]></complex-attribute>
                        <category _I_D="c8de1721-743c-44f7-aee5-97cfea1f7e3a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4a963f36-5a68-4080-8a9a-6d313f333893" name="datediff" is-trigger-function="0" unique-function-name="datediff" is-aggregate="f" language-name="plpgsql" context="datediff" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,timestamp without time zone,timestamp without time zone" is-returning-set="f" ret-datatype="int4" function-arguments="units character varying, start_t timestamp without time zone, end_t timestamp without time zone" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="24052" volatility="VOLATILE" is-window="f" function-identity-arguments="units character varying, start_t timestamp without time zone, end_t timestamp without time zone" overload-function-count="1" proc-language="plpgsql" function-signature="datediff(units character varying, start_t timestamp without time zone, end_t timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
   DECLARE
     diff_interval INTERVAL; 
     diff INT = 0;
     years_diff INT = 0;
     shift_diff INT = 0;
     sign_shift INT = 0;
     dw INT = 0;
   BEGIN
     years_diff = DATE_PART('year', end_t) - DATE_PART('year', start_t);
     IF units IN ('yy', 'yyyy', 'year', 'mm', 'm', 'month') THEN
       IF units IN ('yy', 'yyyy', 'year') THEN
         -- SQL Server does not count full years passed (only difference between year parts)
         RETURN years_diff;
       ELSE
         -- If end month is less than start month it will subtracted
         RETURN years_diff * 12 + (DATE_PART('month', end_t) - DATE_PART('month', start_t)); 
       END IF;
     END IF;
    
     IF units IN ('quarter', 'qq', 'q') THEN         
        RETURN (4-EXTRACT(QUARTER FROM start_t)) + EXTRACT(QUARTER FROM end_t) + (years_diff - 1) * 4;
     END IF;
 
     -- Minus operator returns interval 'DDD days HH:MI:SS'  
     diff_interval = end_t - start_t;
     if end_t > start_t  THEN
        sign_shift=1;
     ELSEIF  end_t < start_t THEN   
        sign_shift=-1;
     ELSE   
        sign_shift=0;
     END IF;  

     IF units IN ('ms', 'millisecond', 'microsecond', 'mcs' ) THEN   
        IF units IN ('ms', 'millisecond') THEN
           diff = trunc(EXTRACT('epoch' FROM end_t)*1000 - EXTRACT('epoch' FROM start_t)*1000);              
           
           if (years_diff<>0) THEN
              shift_diff = sign_shift;
           end if; 

           RETURN diff+shift_diff;
        END IF;
   
        IF units IN ('microsecond', 'mcs') THEN   
           diff  = trunc((EXTRACT('epoch' FROM end_t)*1000000 - EXTRACT('epoch' FROM start_t)*1000000));
           RETURN diff;
        END IF;
     END IF;
    
     diff = diff + DATE_PART('day', diff_interval);
 
     IF units IN ('wk', 'ww', 'week') THEN	               
       
        diff =  DATE_PART('day', (date_trunc('day',end_t) - date_trunc('day',start_t))::interval);
        shift_diff = 0;
        if end_t > start_t then 
           dw := EXTRACT('ISODOW' FROM end_t);
        else 
           dw := EXTRACT('ISODOW' FROM start_t);
        end if; 
       
        if (((diff) % 7)<>0 and abs(((diff) % 7)) > dw and dw <>7) or (((diff) % 7)<>0 and dw =7) or ((diff)=0 and years_diff<>0 and dw = 7)  then 
           shift_diff := 1;
        end if;  
       
        shift_diff = shift_diff*sign_shift;
       
        diff = (diff)/7;
       
        RETURN diff+shift_diff;
     END IF;
     
     years_diff = DATE_PART('day', end_t) - DATE_PART('day', start_t);        
     IF units IN ('dd', 'd', 'day', 'dayofyear', 'dy', 'y', 'weekday', 'dw', 'w' ) THEN
       
        if (years_diff<>0)  THEN
           shift_diff = sign_shift;
        end if; 
        RETURN diff+shift_diff;
     END IF;
    
     diff = diff * 24 + DATE_PART('hour',  diff_interval); 
 
     IF units IN ('hh', 'hour') THEN
        if (years_diff<>0)  THEN
           shift_diff = sign_shift;
        end if; 

       RETURN diff+shift_diff;
     END IF;
 
     diff = diff * 60 + DATE_PART('minute', diff_interval);
 
     IF units IN ('mi', 'n', 'minute') THEN
        if (years_diff<>0) THEN
           shift_diff = sign_shift;
        end if; 

        RETURN diff+shift_diff;
     END IF;
 
     diff = diff * 60 + DATE_PART('second', diff_interval);
 
     if (years_diff<>0)THEN
        shift_diff = sign_shift;
     end if; 

     RETURN diff+shift_diff;
    
   END;
   ]]></complex-attribute>
                        <category _I_D="51a4d57b-5fc3-4091-87ae-c26c43e900bc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c9b08946-d3b7-4f2d-9bd6-338ff5f24c53" name="datetime2fromparts" is-trigger-function="0" unique-function-name="datetime2fromparts(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)" is-aggregate="f" language-name="plpgsql" context="datetime2fromparts(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric,numeric,numeric,numeric,numeric,numeric,numeric" comment="This function returns a fully initialized DATETIME2 value, constructed from separate date and time parts." unique-suffix="(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)" routine-number="23934" is-returning-set="f" ret-datatype="timestamp" function-arguments="p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric" schema-id="23774" function-type="RET_SCALAR" count-arguments="8" function-id="23934" volatility="VOLATILE" is-window="f" function-identity-arguments="p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric" overload-function-count="2" proc-language="plpgsql" function-signature="datetime2fromparts(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
   v_fractions VARCHAR;
   v_precision SMALLINT;
   v_err_message VARCHAR;
   v_calc_seconds NUMERIC;
BEGIN
   v_fractions := floor(p_fractions)::INTEGER::VARCHAR;
   v_precision := p_precision::SMALLINT;

   IF (scale(p_precision) > 0) THEN
      RAISE most_specific_type_mismatch;
   ELSIF ((p_year NOT BETWEEN 1 AND 9999) OR
       (p_month NOT BETWEEN 1 AND 12) OR
       (p_day NOT BETWEEN 1 AND 31) OR
       (p_hour NOT BETWEEN 0 AND 23) OR
       (p_minute NOT BETWEEN 0 AND 59) OR
       (p_seconds NOT BETWEEN 0 AND 59) OR
       (p_fractions NOT BETWEEN 0 AND 9999999) OR
       (p_fractions != 0 AND char_length(v_fractions) > p_precision))
   THEN
      RAISE invalid_datetime_format;
   ELSIF (v_precision NOT BETWEEN 0 AND 7) THEN
      RAISE invalid_parameter_value;
   END IF;

   v_calc_seconds := format('%s.%s',
                            floor(p_seconds)::SMALLINT,
                            substring(rpad(lpad(v_fractions, v_precision, '0'), 7, '0'), 1, 6))::NUMERIC;

   RETURN make_timestamp(floor(p_year)::SMALLINT,
                         floor(p_month)::SMALLINT,
                         floor(p_day)::SMALLINT,
                         floor(p_hour)::SMALLINT,
                         floor(p_minute)::SMALLINT,
                         v_calc_seconds);
EXCEPTION
   WHEN most_specific_type_mismatch THEN
      RAISE USING MESSAGE := 'Scale argument is not valid. Valid expressions for data type DATETIME2 scale argument are integer constants and integer constant expressions.',
                  DETAIL := 'Use of incorrect "precision" parameter value during conversion process.',
                  HINT := 'Change "precision" parameter to the proper value and try again.';

   WHEN invalid_parameter_value THEN
      RAISE USING MESSAGE := format('Specified scale %s is invalid.', v_precision),
                  DETAIL := 'Use of incorrect "precision" parameter value during conversion process.',
                  HINT := 'Change "precision" parameter to the proper value and try again.';

   WHEN invalid_datetime_format THEN
      RAISE USING MESSAGE := 'Cannot construct data type DATETIME2, some of the arguments have values which are not valid.',
                  DETAIL := 'Possible use of incorrect value of date or time part (which lies outside of valid range).',
                  HINT := 'Check each input argument belongs to the valid range and try again.';

   WHEN numeric_value_out_of_range THEN
      GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
      v_err_message := upper(split_part(v_err_message, ' ', 1));

      RAISE USING MESSAGE := format('Error while trying to cast to %s data type.', v_err_message),
                  DETAIL := format('Source value is out of %s data type range.', v_err_message),
                  HINT := format('Correct the source value you are trying to cast to %s data type and try again.',
                                 v_err_message);
END;
]]></complex-attribute>
                        <category _I_D="b799d1e9-1cac-4c96-a707-ee07275306d9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f0d0f62f-e9c6-4f39-b08f-0ce403a252ff" name="datetime2fromparts" is-trigger-function="0" unique-function-name="datetime2fromparts(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)" is-aggregate="f" language-name="plpgsql" context="datetime2fromparts(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text,text,text,text" comment="This function returns a fully initialized DATETIME2 value, constructed from separate date and time parts." unique-suffix="(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)" routine-number="23935" is-returning-set="f" ret-datatype="timestamp" function-arguments="p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text" schema-id="23774" function-type="RET_SCALAR" count-arguments="8" function-id="23935" volatility="VOLATILE" is-window="f" function-identity-arguments="p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text" overload-function-count="2" proc-language="plpgsql" function-signature="datetime2fromparts(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_err_message VARCHAR;
BEGIN
    RETURN aws_sqlserver_ext.datetime2fromparts(p_year::NUMERIC, p_month::NUMERIC, p_day::NUMERIC,
                                                p_hour::NUMERIC, p_minute::NUMERIC, p_seconds::NUMERIC,
                                                p_fractions::NUMERIC, p_precision::NUMERIC);
EXCEPTION
    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'numeric\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to NUMERIC data type.', v_err_message),
                    DETAIL := 'Supplied string value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters and try again.';
END;
]]></complex-attribute>
                        <category _I_D="4c6521ff-49bc-4901-81fe-2564941bab01" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ea9bf24a-d39a-4faf-8314-b74edaa3553c" name="datetimefromparts" is-trigger-function="0" unique-function-name="datetimefromparts(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_milliseconds numeric)" is-aggregate="f" language-name="plpgsql" context="datetimefromparts(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_milliseconds numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric,numeric,numeric,numeric,numeric,numeric" comment="This function returns a fully initialized DATETIME value, constructed from separate date and time parts." unique-suffix="(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_milliseconds numeric)" routine-number="23936" is-returning-set="f" ret-datatype="timestamp" function-arguments="p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_milliseconds numeric" schema-id="23774" function-type="RET_SCALAR" count-arguments="7" function-id="23936" volatility="VOLATILE" is-window="f" function-identity-arguments="p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_milliseconds numeric" overload-function-count="2" proc-language="plpgsql" function-signature="datetimefromparts(p_year numeric, p_month numeric, p_day numeric, p_hour numeric, p_minute numeric, p_seconds numeric, p_milliseconds numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_err_message VARCHAR;
    v_calc_seconds NUMERIC;
    v_milliseconds SMALLINT;
    v_resdatetime TIMESTAMP WITHOUT TIME ZONE;
BEGIN
    IF ((p_year NOT BETWEEN 1753 AND 9999) OR
        (p_month NOT BETWEEN 1 AND 12) OR
        (p_day NOT BETWEEN 1 AND 31) OR
        (p_hour NOT BETWEEN 0 AND 23) OR
        (p_minute NOT BETWEEN 0 AND 59) OR
        (p_seconds NOT BETWEEN 0 AND 59) OR
        (p_milliseconds NOT BETWEEN 0 AND 999))
    THEN
        RAISE invalid_datetime_format;
    END IF;

    v_milliseconds := aws_sqlserver_ext.round_fractseconds(p_milliseconds::INTEGER);

    v_calc_seconds := format('%s.%s',
                             floor(p_seconds)::SMALLINT,
                             CASE v_milliseconds
                                WHEN 1000 THEN '0'
                                ELSE lpad(v_milliseconds::VARCHAR, 3, '0')
                             END)::NUMERIC;

    v_resdatetime := make_timestamp(floor(p_year)::SMALLINT,
                                    floor(p_month)::SMALLINT,
                                    floor(p_day)::SMALLINT,
                                    floor(p_hour)::SMALLINT,
                                    floor(p_minute)::SMALLINT,
                                    v_calc_seconds);
    RETURN CASE
              WHEN (v_milliseconds != 1000) THEN v_resdatetime
              ELSE v_resdatetime + INTERVAL '1 second'
           END;
EXCEPTION
    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := 'Cannot construct data type datetime, some of the arguments have values which are not valid.',
                    DETAIL := 'Possible use of incorrect value of date or time part (which lies outside of valid range).',
                    HINT := 'Check each input argument belongs to the valid range and try again.';

    WHEN numeric_value_out_of_range THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := upper(split_part(v_err_message, ' ', 1));

        RAISE USING MESSAGE := format('Error while trying to cast to %s data type.', v_err_message),
                    DETAIL := format('Source value is out of %s data type range.', v_err_message),
                    HINT := format('Correct the source value you are trying to cast to %s data type and try again.',
                                   v_err_message);
END;
]]></complex-attribute>
                        <category _I_D="65e17dc7-6140-4da4-9901-afa85fa9df0c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3b1862ca-62ff-44a2-9422-dc8dbe2df425" name="datetimefromparts" is-trigger-function="0" unique-function-name="datetimefromparts(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_milliseconds text)" is-aggregate="f" language-name="plpgsql" context="datetimefromparts(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_milliseconds text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text,text,text" comment="This function returns a fully initialized DATETIME value, constructed from separate date and time parts." unique-suffix="(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_milliseconds text)" routine-number="23937" is-returning-set="f" ret-datatype="timestamp" function-arguments="p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_milliseconds text" schema-id="23774" function-type="RET_SCALAR" count-arguments="7" function-id="23937" volatility="VOLATILE" is-window="f" function-identity-arguments="p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_milliseconds text" overload-function-count="2" proc-language="plpgsql" function-signature="datetimefromparts(p_year text, p_month text, p_day text, p_hour text, p_minute text, p_seconds text, p_milliseconds text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_err_message VARCHAR;
BEGIN
    RETURN aws_sqlserver_ext.datetimefromparts(p_year::NUMERIC, p_month::NUMERIC, p_day::NUMERIC,
                                               p_hour::NUMERIC, p_minute::NUMERIC,
                                               p_seconds::NUMERIC, p_milliseconds::NUMERIC);
EXCEPTION
    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'numeric\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to NUMERIC data type.', v_err_message),
                    DETAIL := 'Supplied string value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters and try again.';
END;
]]></complex-attribute>
                        <category _I_D="bc4c015c-cc97-46d9-961c-f1d569ea3b25" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="58104e4b-bd40-4b2e-8bce-f57ac6939e93" name="dbts" is-trigger-function="0" unique-function-name="dbts" is-aggregate="f" language-name="plpgsql" context="dbts" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int8" schema-id="23774" function-type="RET_SCALAR" count-arguments="0" function-id="24048" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="dbts()">
                        <complex-attribute name="sql"><![CDATA[
declare
  v_res bigint;
begin
  SELECT last_value INTO v_res FROM aws_sqlserver_ext_data.inc_seq_rowversion;
  return v_res;
end;
]]></complex-attribute>
                        <category _I_D="54a582de-3760-4c7b-b4f4-4de037eb9031" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="db5765e5-64f6-441e-9b68-f32fb19d08d2" name="get_full_year" is-trigger-function="0" unique-function-name="get_full_year" is-aggregate="f" language-name="plpgsql" context="get_full_year" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,numeric" comment="This function transforms two-digit year to full-size four digit year value, according to base century and cutoff boundary optional parameters." is-returning-set="f" ret-datatype="varchar" function-arguments="p_short_year text, p_base_century text DEFAULT ''::text, p_year_cutoff numeric DEFAULT 49" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23940" volatility="STABLE" is-window="f" function-identity-arguments="p_short_year text, p_base_century text, p_year_cutoff numeric" overload-function-count="1" proc-language="plpgsql" function-signature="get_full_year(p_short_year text, p_base_century text, p_year_cutoff numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_err_message VARCHAR;
    v_full_year SMALLINT;
    v_short_year SMALLINT;
    v_base_century SMALLINT;
    v_result_param_set JSONB;
    v_full_year_res_jsonb JSONB;
BEGIN
    v_short_year := p_short_year::SMALLINT;

    BEGIN
        v_full_year_res_jsonb := nullif(current_setting('aws_sqlserver_ext.full_year_res_json'), '')::JSONB;
    EXCEPTION
        WHEN undefined_object THEN
        v_full_year_res_jsonb := NULL;
    END;

    SELECT result
      INTO v_full_year
      FROM jsonb_to_recordset(v_full_year_res_jsonb) AS result_set (param1 SMALLINT,
                                                                    param2 TEXT,
                                                                    param3 NUMERIC,
                                                                    result VARCHAR)
     WHERE param1 = v_short_year
       AND param2 = p_base_century
       AND param3 = p_year_cutoff;

    IF (v_full_year IS NULL)
    THEN
        IF (v_short_year <= 99)
        THEN
            v_base_century := CASE
                                 WHEN (p_base_century ~ '^\s*([1-9]{1,2})\s*$') THEN concat(trim(p_base_century), '00')::SMALLINT
                                 ELSE trunc(extract(year from current_date)::NUMERIC, -2)
                              END;

            v_full_year = v_base_century + v_short_year;
            v_full_year = CASE
                             WHEN (v_short_year > p_year_cutoff) THEN v_full_year - 100
                             ELSE v_full_year
                          END;
        ELSE v_full_year := v_short_year;
        END IF;

        v_result_param_set := jsonb_build_object('param1', v_short_year,
                                                 'param2', p_base_century,
                                                 'param3', p_year_cutoff,
                                                 'result', v_full_year);
        v_full_year_res_jsonb := CASE
                                    WHEN (v_full_year_res_jsonb IS NULL) THEN jsonb_build_array(v_result_param_set)
                                    ELSE v_full_year_res_jsonb || v_result_param_set
                                 END;

        PERFORM set_config('aws_sqlserver_ext.full_year_res_json',
                           v_full_year_res_jsonb::TEXT,
                           FALSE);
    END IF;

    RETURN v_full_year;
EXCEPTION
    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="f8800923-0a4e-4038-a671-8121f49ba243" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="28c9b97c-2392-48cb-9bb4-bc310b03d12a" name="get_id_by_name" is-trigger-function="0" unique-function-name="get_id_by_name" is-aggregate="f" language-name="plpgsql" context="get_id_by_name" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="int8" function-arguments="object_name text" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23971" volatility="VOLATILE" is-window="f" function-identity-arguments="object_name text" overload-function-count="1" proc-language="plpgsql" function-signature="get_id_by_name(object_name text)">
                        <complex-attribute name="sql"><![CDATA[
declare res bigint;
begin
  execute 'select x''' || substring(encode(digest(object_name, 'sha1'), 'hex'), 1, 8) || '''::bigint' into res;
  return res;  
end;
]]></complex-attribute>
                        <category _I_D="bfef3bc5-537e-4000-9ae0-8157b10604d9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c87428a8-abf6-499f-83a5-0f90a2c6fef4" name="get_int_part" is-trigger-function="0" unique-function-name="get_int_part" is-aggregate="f" language-name="plpgsql" context="get_int_part" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision" comment="This function returns an integer part of the passed value. Rounding to integer is applied according to the special logic." is-returning-set="f" ret-datatype="float8" function-arguments="p_srcnumber double precision" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23921" volatility="STABLE" is-window="f" function-identity-arguments="p_srcnumber double precision" overload-function-count="1" proc-language="plpgsql" function-signature="get_int_part(p_srcnumber double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN CASE
              WHEN (p_srcnumber < -0.0000001) THEN ceil(p_srcnumber - 0.0000001)
              ELSE floor(p_srcnumber + 0.0000001)
           END;
END;
]]></complex-attribute>
                        <category _I_D="2ea76706-68e6-46ad-bd01-41bf5be89c48" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="21c14791-a2da-4538-bdef-f834135846c3" name="get_jobs" is-trigger-function="0" unique-function-name="get_jobs" is-aggregate="f" language-name="plpgsql" context="get_jobs" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,text,character varying" is-returning-set="t" ret-datatype="table" schema-id="23774" function-type="RET_DATASET" count-arguments="0" function-id="23972" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="get_jobs()">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_job integer;
  var_what text;
  var_search_path varchar;
BEGIN

  SELECT js.job_step_id, js.command, '' 
    FROM aws_sqlserver_ext.sysjobschedules s
   INNER JOIN aws_sqlserver_ext.sysjobs j on j.job_id = s.job_id
   INNER JOIN aws_sqlserver_ext.sysjobsteps js ON js.job_id = j.job_id
    INTO var_job, var_what, var_search_path 
   WHERE (s.next_run_date + s.next_run_time) <= now()::timestamp
     AND j.enabled = 1
   ORDER BY (s.next_run_date + s.next_run_time) ASC
   LIMIT 1;

  IF var_job > 0
  THEN
    return query select var_job, var_what, var_search_path;
  END IF;

END;
]]></complex-attribute>
                        <category _I_D="403e0af7-cafe-40da-ab03-f8c9e4ce5145" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e9ba5b78-8a9c-465a-826f-62446f63aa4a" name="get_lang_metadata_json" is-trigger-function="0" unique-function-name="get_lang_metadata_json" is-aggregate="f" language-name="plpgsql" context="get_lang_metadata_json" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="This function returns language metadata JSON by corresponding lang name or spec culture abbreviation." is-returning-set="f" ret-datatype="jsonb" function-arguments="p_lang_spec_culture text" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23924" volatility="VOLATILE" is-window="f" function-identity-arguments="p_lang_spec_culture text" overload-function-count="1" proc-language="plpgsql" function-signature="get_lang_metadata_json(p_lang_spec_culture text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_locale_parts TEXT[];
    v_lang_data_jsonb JSONB;
    v_lang_spec_culture VARCHAR;
    v_is_cached BOOLEAN := FALSE;
BEGIN
    v_lang_spec_culture := upper(trim(p_lang_spec_culture));

    IF (char_length(v_lang_spec_culture) > 0)
    THEN
        BEGIN
            v_lang_data_jsonb := nullif(current_setting(format('aws_sqlserver_ext.lang_metadata_json.%s',
                                                               v_lang_spec_culture)), '')::JSONB;
        EXCEPTION
            WHEN undefined_object THEN
            v_lang_data_jsonb := NULL;
        END;

        IF (v_lang_data_jsonb IS NULL)
        THEN
            IF (v_lang_spec_culture IN ('AR', 'FI') OR
                v_lang_spec_culture ~ '-')
            THEN
                SELECT lang_data_jsonb
                  INTO STRICT v_lang_data_jsonb
                  FROM aws_sqlserver_ext.sys_languages
                 WHERE spec_culture = v_lang_spec_culture;
            ELSE
                SELECT lang_data_jsonb
                  INTO STRICT v_lang_data_jsonb
                  FROM aws_sqlserver_ext.sys_languages
                 WHERE lang_name_mssql = v_lang_spec_culture
                    OR lang_alias_mssql = v_lang_spec_culture;
            END IF;
        ELSE
            v_is_cached := TRUE;
        END IF;
    ELSE
        v_lang_spec_culture := current_setting('LC_TIME');

        v_lang_spec_culture := CASE
                                  WHEN (v_lang_spec_culture !~ '\.') THEN v_lang_spec_culture
                                  ELSE substring(v_lang_spec_culture, '(.*)(?:\.)')
                               END;

        v_lang_spec_culture := upper(regexp_replace(v_lang_spec_culture, '_|,\s*', '-', 'gi'));

        BEGIN
            v_lang_data_jsonb := nullif(current_setting(format('aws_sqlserver_ext.lang_metadata_json.%s',
                                                               v_lang_spec_culture)), '')::JSONB;
        EXCEPTION
            WHEN undefined_object THEN
            v_lang_data_jsonb := NULL;
        END;

        IF (v_lang_data_jsonb IS NULL)
        THEN
            BEGIN
                IF (char_length(v_lang_spec_culture) = 5)
                THEN
                    SELECT lang_data_jsonb
                      INTO STRICT v_lang_data_jsonb
                      FROM aws_sqlserver_ext.sys_languages
                     WHERE spec_culture = v_lang_spec_culture;
                ELSE
                    v_locale_parts := string_to_array(v_lang_spec_culture, '-');

                    SELECT lang_data_jsonb
                      INTO STRICT v_lang_data_jsonb
                      FROM aws_sqlserver_ext.sys_languages
                     WHERE lang_name_pg = v_locale_parts[1]
                       AND territory = v_locale_parts[2];
                END IF;
            EXCEPTION
                WHEN OTHERS THEN
                    v_lang_spec_culture := 'EN-US';

                    SELECT lang_data_jsonb
                      INTO v_lang_data_jsonb
                      FROM aws_sqlserver_ext.sys_languages
                     WHERE spec_culture = v_lang_spec_culture;
            END;
        ELSE
            v_is_cached := TRUE;
        END IF;
    END IF;

    IF (NOT v_is_cached) THEN
        PERFORM set_config(format('aws_sqlserver_ext.lang_metadata_json.%s',
                                  v_lang_spec_culture),
                           v_lang_data_jsonb::TEXT,
                           FALSE);
    END IF;

    RETURN v_lang_data_jsonb;
EXCEPTION
    WHEN invalid_text_representation THEN
        RAISE USING MESSAGE := format('The language metadata JSON value extracted from chache is not a valid JSON object.',
                                      p_lang_spec_culture),
                    HINT := 'Drop the current session, fix the appropriate record in "aws_sqlserver_ext.sys_languages" table, and try again after reconnection.';

    WHEN OTHERS THEN
        RAISE USING MESSAGE := format('"%s" is not a valid special culture or language name parameter.',
                                      p_lang_spec_culture),
                    DETAIL := 'Use of incorrect "lang_spec_culture" parameter value during conversion process.',
                    HINT := 'Change "lang_spec_culture" parameter to the proper value and try again.';
END;
]]></complex-attribute>
                        <category _I_D="a7c5673d-d749-4687-8b27-0e02915264cf" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="38e2331a-6d51-40d5-b9d4-91fdbddc7bb7" name="get_microsecs_from_fractsecs" is-trigger-function="0" unique-function-name="get_microsecs_from_fractsecs" is-aggregate="f" language-name="plpgsql" context="get_microsecs_from_fractsecs" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric" comment="This function transforms MS SQL Server DATETIME2 fractions and precision (scale) parts into PostgreSQL microsecond values." is-returning-set="f" ret-datatype="varchar" function-arguments="p_fractsecs text, p_scale numeric DEFAULT 7" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="23933" volatility="STABLE" is-window="f" function-identity-arguments="p_fractsecs text, p_scale numeric" overload-function-count="1" proc-language="plpgsql" function-signature="get_microsecs_from_fractsecs(p_fractsecs text, p_scale numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_scale SMALLINT;
    v_decplaces INTEGER;
    v_fractsecs VARCHAR;
    v_pureplaces VARCHAR;
    v_rnd_fractsecs INTEGER;
    v_fractsecs_len INTEGER;
    v_pureplaces_len INTEGER;
    v_err_message VARCHAR;
BEGIN
    v_fractsecs := trim(p_fractsecs);
    v_fractsecs_len := char_length(v_fractsecs);
    v_scale := floor(p_scale)::SMALLINT;

    IF (v_fractsecs_len < 7) THEN
        v_fractsecs := rpad(v_fractsecs, 7, '0');
        v_fractsecs_len := char_length(v_fractsecs);
    END IF;

    v_pureplaces := trim(leading '0' from v_fractsecs);
    v_pureplaces_len := char_length(v_pureplaces);

    v_decplaces := v_fractsecs_len - v_pureplaces_len;

    v_rnd_fractsecs := round(v_fractsecs::INTEGER, (v_pureplaces_len - (v_scale - (v_fractsecs_len - v_pureplaces_len))) * (-1));

    v_fractsecs := concat(replace(rpad('', v_decplaces), ' ', '0'), v_rnd_fractsecs);

    RETURN substring(v_fractsecs, 1, CASE
                                        WHEN (v_scale >= 7) THEN 6
                                        ELSE v_scale
                                     END);
EXCEPTION
    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.', v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="3868d1d4-81d7-456b-89e6-7cf3b5d360ef" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="cc83ffe3-d52f-4acd-8b9a-be246b36d47a" name="get_monthnum_by_name" is-trigger-function="0" unique-function-name="get_monthnum_by_name" is-aggregate="f" language-name="plpgsql" context="get_monthnum_by_name" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,jsonb" comment="This function returns month number (1-12) by corresponding month name, matched from language metadata JSON." is-returning-set="f" ret-datatype="int2" function-arguments="p_monthname text, p_lang_metadata_json jsonb" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="23943" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_monthname text, p_lang_metadata_json jsonb" overload-function-count="1" proc-language="plpgsql" function-signature="get_monthnum_by_name(p_monthname text, p_lang_metadata_json jsonb)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_monthname TEXT;
    v_monthnum SMALLINT;
BEGIN
    v_monthname := lower(trim(p_monthname));

    v_monthnum := array_position(ARRAY(SELECT lower(jsonb_array_elements_text(p_lang_metadata_json -> 'months_shortnames'))), v_monthname);

    v_monthnum := coalesce(v_monthnum,
                           array_position(ARRAY(SELECT lower(jsonb_array_elements_text(p_lang_metadata_json -> 'months_names'))), v_monthname));

    v_monthnum := coalesce(v_monthnum,
                           array_position(ARRAY(SELECT lower(jsonb_array_elements_text(p_lang_metadata_json -> 'months_extrashortnames'))), v_monthname));

    v_monthnum := coalesce(v_monthnum,
                           array_position(ARRAY(SELECT lower(jsonb_array_elements_text(p_lang_metadata_json -> 'months_extranames'))), v_monthname));

    IF (v_monthnum IS NULL) THEN
        RAISE datetime_field_overflow;
    END IF;

    RETURN v_monthnum;
EXCEPTION
    WHEN datetime_field_overflow THEN
        RAISE USING MESSAGE := format('Can not convert value "%s" to a correct month number.',
                                      trim(p_monthname)),
                    DETAIL := 'Supplied month name is not valid.',
                    HINT := 'Correct supplied month name value and try again.';
END;
]]></complex-attribute>
                        <category _I_D="97edce68-c0a1-42df-bf7f-a2fd7f8c487e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0c6af084-a54c-4520-a17c-ec6c5833497f" name="get_sequence_value" is-trigger-function="0" unique-function-name="get_sequence_value" is-aggregate="f" language-name="plpgsql" context="get_sequence_value" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="int8" function-arguments="sequence_name character varying" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23973" volatility="VOLATILE" is-window="f" function-identity-arguments="sequence_name character varying" overload-function-count="1" proc-language="plpgsql" function-signature="get_sequence_value(sequence_name character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare
  v_res bigint;
begin
  execute 'select last_value from '|| sequence_name into v_res;
  return v_res;
end;
]]></complex-attribute>
                        <category _I_D="74e6c64d-6abc-464a-833a-bf6bf6574247" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1e85bdab-e37e-4ce3-a4cc-1918f4827291" name="get_service_setting" is-trigger-function="0" unique-function-name="get_service_setting" is-aggregate="f" language-name="plpgsql" context="get_service_setting" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying" is-returning-set="f" ret-datatype="varchar" function-arguments="p_service character varying, p_setting character varying" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24051" volatility="VOLATILE" is-window="f" function-identity-arguments="p_service character varying, p_setting character varying" overload-function-count="1" proc-language="plpgsql" function-signature="get_service_setting(p_service character varying, p_setting character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  settingValue aws_sqlserver_ext_data.service_settings.value%TYPE;
BEGIN
  SELECT value
    INTO settingValue 
    FROM aws_sqlserver_ext_data.service_settings 
   WHERE service = p_service 
     AND setting = p_setting;
 
  RETURN settingValue;
END;
]]></complex-attribute>
                        <category _I_D="29151d79-e7f3-42a1-9fcd-17ea006b9b86" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dd0a5165-b223-46ad-8630-43e1ae5c9f4d" name="get_timeunit_from_string" is-trigger-function="0" unique-function-name="get_timeunit_from_string" is-aggregate="f" language-name="plpgsql" context="get_timeunit_from_string" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" comment="This function returns certain time part (identified by p_timeunit param) extracted from the source string." is-returning-set="f" ret-datatype="varchar" function-arguments="p_timepart text, p_timeunit text" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="23941" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_timepart text, p_timeunit text" overload-function-count="1" proc-language="plpgsql" function-signature="get_timeunit_from_string(p_timepart text, p_timeunit text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_hours VARCHAR;
    v_minutes VARCHAR;
    v_seconds VARCHAR;
    v_fractsecs VARCHAR;
    v_daypart VARCHAR;
    v_timepart VARCHAR;
    v_timeunit VARCHAR;
    v_err_message VARCHAR;
    v_timeunit_mask VARCHAR;
    v_regmatch_groups TEXT[];
    AMPM_REGEXP CONSTANT VARCHAR := '\s*([AP]M)';
    TIMEUNIT_REGEXP CONSTANT VARCHAR := '\s*(\d{1,2})\s*';
    FRACTSECS_REGEXP CONSTANT VARCHAR := '\s*(\d{1,9})';
    HHMMSSFS_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP,
                                               '\:', TIMEUNIT_REGEXP,
                                               '\:', TIMEUNIT_REGEXP,
                                               '(?:\.|\:)', FRACTSECS_REGEXP, '$');
    HHMMSS_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '$');
    HHMMFS_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '\.', FRACTSECS_REGEXP, '$');
    HHMM_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '\:', TIMEUNIT_REGEXP, '$');
    HH_REGEXP CONSTANT VARCHAR := concat('^', TIMEUNIT_REGEXP, '$');
BEGIN
    v_timepart := upper(trim(p_timepart));
    v_timeunit := upper(trim(p_timeunit));

    v_daypart := substring(v_timepart, 'AM|PM');
    v_timepart := trim(regexp_replace(v_timepart, coalesce(v_daypart, ''), ''));

    v_timeunit_mask :=
        CASE
           WHEN (v_timepart ~* HHMMSSFS_REGEXP) THEN HHMMSSFS_REGEXP
           WHEN (v_timepart ~* HHMMSS_REGEXP) THEN HHMMSS_REGEXP
           WHEN (v_timepart ~* HHMMFS_REGEXP) THEN HHMMFS_REGEXP
           WHEN (v_timepart ~* HHMM_REGEXP) THEN HHMM_REGEXP
           WHEN (v_timepart ~* HH_REGEXP) THEN HH_REGEXP
        END;

    v_regmatch_groups := regexp_matches(v_timepart, v_timeunit_mask, 'gi');

    v_hours := v_regmatch_groups[1];
    v_minutes := v_regmatch_groups[2];

    IF (v_timepart ~* HHMMFS_REGEXP) THEN
        v_fractsecs := v_regmatch_groups[3];
    ELSE
        v_seconds := v_regmatch_groups[3];
        v_fractsecs := v_regmatch_groups[4];
    END IF;

    IF (v_timeunit = 'HOURS' AND v_daypart IS NOT NULL)
    THEN
        IF ((v_daypart = 'AM' AND v_hours::SMALLINT NOT BETWEEN 0 AND 12) OR
            (v_daypart = 'PM' AND v_hours::SMALLINT NOT BETWEEN 1 AND 23))
        THEN
            RAISE numeric_value_out_of_range;
        ELSIF (v_daypart = 'PM' AND v_hours::SMALLINT < 12) THEN
            v_hours := (v_hours::SMALLINT + 12)::VARCHAR;
        ELSIF (v_daypart = 'AM' AND v_hours::SMALLINT = 12) THEN
            v_hours := (v_hours::SMALLINT - 12)::VARCHAR;
        END IF;
    END IF;

    RETURN CASE v_timeunit
              WHEN 'HOURS' THEN v_hours
              WHEN 'MINUTES' THEN v_minutes
              WHEN 'SECONDS' THEN v_seconds
              WHEN 'FRACTSECONDS' THEN v_fractsecs
           END;
EXCEPTION
    WHEN numeric_value_out_of_range THEN
        RAISE USING MESSAGE := 'Could not extract correct hour value due to it''s inconsistency with AM|PM day part mark.',
                    DETAIL := 'Extracted hour value doesn''t fall in correct day part mark range: 0..12 for "AM" or 1..23 for "PM".',
                    HINT := 'Correct a hour value in the source string or remove AM|PM day part mark out of it.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.', v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="4c008d83-9d96-40e4-aac7-3b76e026b3c7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c18e3379-8766-4d2f-93ad-0a47afcba0e5" name="get_version" is-trigger-function="0" unique-function-name="get_version" is-aggregate="f" language-name="plpgsql" context="get_version" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="varchar" function-arguments="pcomponentname character varying" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23974" volatility="VOLATILE" is-window="f" function-identity-arguments="pcomponentname character varying" overload-function-count="1" proc-language="plpgsql" function-signature="get_version(pcomponentname character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  lComponentVersion VARCHAR(256);
BEGIN
	SELECT componentversion 
	  INTO lComponentVersion 
	  FROM aws_sqlserver_ext.versions
	 WHERE extpackcomponentname = pComponentName;

	RETURN lComponentVersion;
END;
]]></complex-attribute>
                        <category _I_D="24ced8b4-d411-4c72-b847-e36c5c0f2979" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e1b6229b-ce1b-4712-a86c-1ef9290eba25" name="get_weekdaynum_by_name" is-trigger-function="0" unique-function-name="get_weekdaynum_by_name" is-aggregate="f" language-name="plpgsql" context="get_weekdaynum_by_name" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,jsonb" comment="This function returns weekday number (1-7) by corresponding weekday name, matched from language metadata JSON." is-returning-set="f" ret-datatype="int2" function-arguments="p_weekdayname text, p_lang_metadata_json jsonb" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="23942" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_weekdayname text, p_lang_metadata_json jsonb" overload-function-count="1" proc-language="plpgsql" function-signature="get_weekdaynum_by_name(p_weekdayname text, p_lang_metadata_json jsonb)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_weekdayname TEXT;
    v_weekdaynum SMALLINT;
BEGIN
    v_weekdayname := lower(trim(p_weekdayname));

    v_weekdaynum := array_position(ARRAY(SELECT lower(jsonb_array_elements_text(p_lang_metadata_json -> 'days_names'))), v_weekdayname);

    v_weekdaynum := coalesce(v_weekdaynum,
                             array_position(ARRAY(SELECT lower(jsonb_array_elements_text(p_lang_metadata_json -> 'days_shortnames'))), v_weekdayname));

    v_weekdaynum := coalesce(v_weekdaynum,
                             array_position(ARRAY(SELECT lower(jsonb_array_elements_text(p_lang_metadata_json -> 'days_extrashortnames'))), v_weekdayname));

    IF (v_weekdaynum IS NULL) THEN
        RAISE datetime_field_overflow;
    END IF;

    RETURN v_weekdaynum;
EXCEPTION
    WHEN datetime_field_overflow THEN
        RAISE USING MESSAGE := format('Can not convert value "%s" to a correct weekday number.',
                                      trim(p_weekdayname)),
                    DETAIL := 'Supplied weekday name is not valid.',
                    HINT := 'Correct supplied weekday name value and try again.';
END;
]]></complex-attribute>
                        <category _I_D="a14fe459-7546-40b8-a71e-9c7c878a7683" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e29aee4b-1a60-4014-87d3-8c6019d4c426" name="isdate" is-trigger-function="0" unique-function-name="isdate" is-aggregate="f" language-name="plpgsql" context="isdate" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="bool" function-arguments="v text" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23975" volatility="VOLATILE" is-window="f" function-identity-arguments="v text" overload-function-count="1" proc-language="plpgsql" function-signature="isdate(v text)">
                        <complex-attribute name="sql"><![CDATA[
begin
  perform v::date;
  return true;
exception
  when others then
   return false;
end
]]></complex-attribute>
                        <category _I_D="619956f3-c7f2-47e3-8a10-811e5b0121dd" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8e7df6d4-5d9c-4289-be51-675001c9944a" name="isnumeric" is-trigger-function="0" unique-function-name="isnumeric(_input numeric)" is-aggregate="f" language-name="plpgsql" context="isnumeric(_input numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" unique-suffix="(_input numeric)" routine-number="23976" is-returning-set="f" ret-datatype="bool" function-arguments="_input numeric" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23976" volatility="IMMUTABLE" is-window="f" function-identity-arguments="_input numeric" overload-function-count="2" proc-language="plpgsql" function-signature="isnumeric(_input numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE x NUMERIC;
/***************************************************************
EXTENSION PACK function ISNUMERIC(x)
***************************************************************/
BEGIN
    x = $1::VARCHAR::NUMERIC;
    RETURN TRUE;
EXCEPTION WHEN others THEN
    RETURN FALSE;
END;
]]></complex-attribute>
                        <category _I_D="ecf7a53b-b066-47cc-88a8-c1785271322d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a67ac037-7e2c-4d70-84ff-79a76cb2ae0d" name="isnumeric" is-trigger-function="0" unique-function-name="isnumeric(_input text)" is-aggregate="f" language-name="plpgsql" context="isnumeric(_input text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" unique-suffix="(_input text)" routine-number="23977" is-returning-set="f" ret-datatype="bool" function-arguments="_input text" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23977" volatility="IMMUTABLE" is-window="f" function-identity-arguments="_input text" overload-function-count="2" proc-language="plpgsql" function-signature="isnumeric(_input text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE x NUMERIC;
/***************************************************************
EXTENSION PACK function ISNUMERIC(x)
***************************************************************/
BEGIN
    x = $1::VARCHAR::NUMERIC;
    RETURN TRUE;
EXCEPTION WHEN others THEN
    RETURN FALSE;
END;
]]></complex-attribute>
                        <category _I_D="508f0773-b4d2-4111-8475-087cdec3f0a2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8ba587ee-06d6-4155-9932-87d76bfd28ef" name="istime" is-trigger-function="0" unique-function-name="istime" is-aggregate="f" language-name="plpgsql" context="istime" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="bool" function-arguments="v text" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23978" volatility="VOLATILE" is-window="f" function-identity-arguments="v text" overload-function-count="1" proc-language="plpgsql" function-signature="istime(v text)">
                        <complex-attribute name="sql"><![CDATA[
begin
  perform v::time;
  return true;
exception
  when others then
   return false;
end
]]></complex-attribute>
                        <category _I_D="fc0416cd-f115-454a-89b8-1db6cdf61532" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4e42785a-f555-4802-b1a0-e269efbb1f9f" name="newid" is-trigger-function="0" unique-function-name="newid" is-aggregate="f" language-name="plpgsql" context="newid" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="uuid" schema-id="23774" function-type="RET_SCALAR" count-arguments="0" function-id="23979" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="newid()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
  RETURN uuid_generate_v4();
END;
]]></complex-attribute>
                        <category _I_D="65d7f514-e02a-455b-9064-f94e67a51027" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b639b40e-b597-4e8d-bbd8-c349c14cfad7" name="object_id" is-trigger-function="0" unique-function-name="object_id" is-aggregate="f" language-name="plpgsql" context="object_id" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character" is-returning-set="f" ret-datatype="int4" function-arguments="object_name character varying, object_type character DEFAULT ''::bpchar" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24047" volatility="STABLE" is-window="f" function-identity-arguments="object_name character varying, object_type character" overload-function-count="1" proc-language="plpgsql" function-signature="object_id(object_name character varying, object_type character)">
                        <complex-attribute name="sql"><![CDATA[ 
declare id oid;
        lower_object_name character varying;
        is_temp_object boolean;
begin

  id := null;  
  lower_object_name := translate(lower(object_name),'[]','');
  is_temp_object := position('tempdb..#' in lower_object_name) > 0;
  
  while position('.' in lower_object_name) > 0 loop
    lower_object_name := substring(lower_object_name from strpos(lower_object_name, '.') + 1);
  end loop;

  -- in temp table replace # with t$
  if is_temp_object then
    lower_object_name := 't$'||substr(lower_object_name,2);
  end if; 
  
  if object_type <> '' then
    case 
      when upper(object_type) in ('S', 'U', 'V', 'IT', 'ET', 'SO') and is_temp_object then 
	id := (select oid from pg_class where lower(relname) = lower_object_name and relpersistence in ('u', 't') limit 1); 
	           
      when upper(object_type) in ('S', 'U', 'V', 'IT', 'ET', 'SO') and not is_temp_object then 
	id := (select oid from pg_class where lower(relname) = lower_object_name limit 1);      
	
      when upper(object_type) in ('C', 'D', 'F', 'PK', 'UQ') then 
	id := (select oid from pg_constraint where lower(conname) = lower_object_name limit 1);            
	
      when upper(object_type) in ('AF', 'FN', 'FS', 'FT', 'IF', 'P', 'PC', 'TF', 'RF', 'X') then 
	id := (select oid from pg_proc where lower(proname) = lower_object_name limit 1);      
	
      when upper(object_type) in ('TR', 'TA') then 
	id := (select oid from pg_trigger where lower(tgname) = lower_object_name limit 1);            

      -- unsupported object_type
      else id := null;
    end case;
  else 
    if not is_temp_object then id := (
				      select oid from pg_class where lower(relname) = lower_object_name
					union
				      select oid from pg_constraint where lower(conname) = lower_object_name
					union
				      select oid from pg_proc where lower(proname) = lower_object_name
					union
				      select oid from pg_trigger where lower(tgname) = lower_object_name
				      limit 1);
    else
      -- temp object without "object_type" in-argument 
      id := (select oid from pg_class where lower(relname) = lower_object_name and relpersistence in ('u', 't') limit 1);     
    end if;
  end if;  

  return id::integer;
  
end; 
]]></complex-attribute>
                        <category _I_D="bc7edf33-2fbd-4746-9b88-643dd87cde0d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0d965417-3542-4302-baec-abbb1ee8b8df" name="openxml" is-trigger-function="0" unique-function-name="openxml" is-aggregate="f" language-name="plpgsql" context="openxml" subcategories-loading="none" object-loading="extended" arguments-datatypes="bigint,xml" is-returning-set="t" ret-datatype="table" function-arguments="dochandle bigint" schema-id="23774" function-type="RET_DATASET" count-arguments="1" function-id="24246" volatility="VOLATILE" is-window="f" function-identity-arguments="dochandle bigint" overload-function-count="1" proc-language="plpgsql" function-signature="openxml(dochandle bigint)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE                       
   XmlDocument$data XML;
BEGIN
	 
    SELECT t.XmlData     
	  INTO STRICT XmlDocument$data
	  FROM aws_sqlserver_ext$openxml t
	 WHERE t.DocID = DocHandle;	  
   
   RETURN QUERY SELECT XmlDocument$data;
  
   EXCEPTION
	  WHEN SQLSTATE '42P01' OR SQLSTATE 'P0002' THEN 
	      RAISE EXCEPTION '%','Could not find prepared statement with handle '||CASE 
                                                                              WHEN DocHandle IS NULL THEN 'null'
                                                                                ELSE DocHandle::TEXT
                                                                             END;
END;
]]></complex-attribute>
                        <category _I_D="6be77013-f1db-45da-9ed6-1eda1dc029c3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="944a37b8-d026-41e0-bf1f-819e64f29e74" name="parse_to_date" is-trigger-function="0" unique-function-name="parse_to_date" is-aggregate="f" language-name="plpgsql" context="parse_to_date" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" comment="This function parses the TEXT string and translate it into a DATE value, according to specified culture (conversion mask)." is-returning-set="f" ret-datatype="date" function-arguments="p_datestring text, p_culture text DEFAULT ''::text" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="23962" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datestring text, p_culture text" overload-function-count="1" proc-language="plpgsql" function-signature="parse_to_date(p_datestring text, p_culture text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day VARCHAR;
    v_year SMALLINT;
    v_month VARCHAR;
    v_res_date DATE;
    v_hijridate DATE;
    v_culture VARCHAR;
    v_dayparts TEXT[];
    v_resmask VARCHAR;
    v_raw_year VARCHAR;
    v_left_part VARCHAR;
    v_right_part VARCHAR;
    v_resmask_fi VARCHAR;
    v_datestring VARCHAR;
    v_timestring VARCHAR;
    v_correctnum VARCHAR;
    v_weekdaynum SMALLINT;
    v_err_message VARCHAR;
    v_date_format VARCHAR;
    v_weekdaynames TEXT[];
    v_hours SMALLINT := 0;
    v_minutes SMALLINT := 0;
    v_seconds NUMERIC := 0;
    v_found BOOLEAN := TRUE;
    v_compday_regexp VARCHAR;
    v_regmatch_groups TEXT[];
    v_compmonth_regexp VARCHAR;
    v_lang_metadata_json JSONB;
    v_resmask_cnt SMALLINT := 10;
    DAYMM_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    FULLYEAR_REGEXP CONSTANT VARCHAR := '(\d{3,4})';
    SHORTYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    COMPYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,4})';
    AMPM_REGEXP CONSTANT VARCHAR := '(?:[AP]M||)';
    TIMEUNIT_REGEXP CONSTANT VARCHAR := '\s*\d{1,2}\s*';
    MASKSEPONE_REGEXP CONSTANT VARCHAR := '\s*(?:/|-)?';
    MASKSEPTWO_REGEXP CONSTANT VARCHAR := '\s*(?:\s|/|-|\.|,)';
    MASKSEPTWO_FI_REGEXP CONSTANT VARCHAR := '\s*(?:\s|/|-|,)';
    MASKSEPTHREE_REGEXP CONSTANT VARCHAR := '\s*(?:/|-|\.|,)';
    TIME_MASKSEP_REGEXP CONSTANT VARCHAR := '(?:\s|\.|,)*';
    TIME_MASKSEP_FI_REGEXP CONSTANT VARCHAR := '(?:\s|,)*';
    WEEKDAYAMPM_START_REGEXP CONSTANT VARCHAR := '(^|[[:digit:][:space:]\.,])';
    WEEKDAYAMPM_END_REGEXP CONSTANT VARCHAR := '([[:digit:][:space:]\.,]|$)(?=[^/-]|$)';
    CORRECTNUM_REGEXP CONSTANT VARCHAR := '(?:([+-]\d{1,4})(?:[[:space:]\.,]|[AP]M|||$))';
    ANNO_DOMINI_REGEXP VARCHAR := '(AD|A\.D\.)';
    ANNO_DOMINI_COMPREGEXP VARCHAR := concat(WEEKDAYAMPM_START_REGEXP, ANNO_DOMINI_REGEXP, WEEKDAYAMPM_END_REGEXP);
    HHMMSSFS_PART_REGEXP CONSTANT VARCHAR :=
        concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\s*\d{1,2}\.\d+(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?');
    HHMMSSFS_PART_FI_REGEXP CONSTANT VARCHAR :=
        concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?\.?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '\s*\d{1,2}\.\d+(?!\d)\.?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?');
    v_defmask1_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(?:[\.|,]+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP, '$');
    v_defmask1_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(?:[\.|,]+', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask2_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(?:(?:[\.|,]+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?)|',
                                        CORRECTNUM_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP, '$');
    v_defmask2_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           AMPM_REGEXP, TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(?:(?:[\.|,]+', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?)|',
                                           CORRECTNUM_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask3_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, ')|',
                                        '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(', TIME_MASKSEP_REGEXP, AMPM_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask3_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '[\./]?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)',
                                           FULLYEAR_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask4_0_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask4_1_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          '(?:\s|,)+',
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask4_2_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          '\s*[\.]+', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask5_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask5_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask6_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask6_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:\s*[\.])?',
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask7_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask7_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask8_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:[\.|,]+', AMPM_REGEXP, ')?',
                                        TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask8_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:[\,]+|\s*/\s*)', AMPM_REGEXP, ')?',
                                           TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask9_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(',
                                        HHMMSSFS_PART_REGEXP,
                                        ')', TIME_MASKSEP_REGEXP, '$');
    v_defmask9_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '(',
                                           HHMMSSFS_PART_FI_REGEXP,
                                           ')', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask10_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask10_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)?', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask11_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask11_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           '($comp_month$)',
                                           '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask12_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask12_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask13_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$');
    v_defmask13_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            FULLYEAR_REGEXP,
                                            TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask14_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)'
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask14_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)'
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_FI_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask15_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask15_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask16_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask16_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask17_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask17_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask18_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                         '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask18_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                            '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask19_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                         '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask19_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                            '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    CONVERSION_LANG CONSTANT VARCHAR := '';
    DATE_FORMAT CONSTANT VARCHAR := '';
BEGIN
    v_datestring := upper(trim(p_datestring));
    v_culture := coalesce(nullif(upper(trim(p_culture)), ''), 'EN-US');

    v_dayparts := ARRAY(SELECT upper(array_to_string(regexp_matches(v_datestring, '[AP]M||', 'gi'), '')));

    IF (array_length(v_dayparts, 1) > 1) THEN
        RAISE invalid_datetime_format;
    END IF;

    BEGIN
        v_lang_metadata_json := aws_sqlserver_ext.get_lang_metadata_json(coalesce(nullif(CONVERSION_LANG, ''), p_culture));
    EXCEPTION
        WHEN OTHERS THEN
        RAISE invalid_parameter_value;
    END;

    v_compday_regexp := array_to_string(array_cat(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_names')),
                                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_shortnames'))),
                                                  ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_extrashortnames'))), '|');

    v_weekdaynames := ARRAY(SELECT array_to_string(regexp_matches(v_datestring, v_compday_regexp, 'gi'), ''));

    IF (array_length(v_weekdaynames, 1) > 1) THEN
        RAISE invalid_datetime_format;
    END IF;

    IF (v_weekdaynames[1] IS NOT NULL AND
        v_datestring ~* concat(WEEKDAYAMPM_START_REGEXP, '(', v_compday_regexp, ')', WEEKDAYAMPM_END_REGEXP))
    THEN
        v_datestring := replace(v_datestring, v_weekdaynames[1], ' ');
    END IF;

    IF (v_datestring ~* ANNO_DOMINI_COMPREGEXP)
    THEN
        IF (v_culture !~ 'EN[-_]US|DA[-_]DK|SV[-_]SE|EN[-_]GB|HI[-_]IS') THEN
            RAISE invalid_datetime_format;
        END IF;

        v_datestring := regexp_replace(v_datestring,
                                       ANNO_DOMINI_COMPREGEXP,
                                       regexp_replace(array_to_string(regexp_matches(v_datestring, ANNO_DOMINI_COMPREGEXP, 'gi'), ''),
                                                      ANNO_DOMINI_REGEXP, ' ', 'gi'),
                                       'gi');
    END IF;

    v_date_format := coalesce(nullif(upper(trim(DATE_FORMAT)), ''), v_lang_metadata_json ->> 'date_format');

    v_compmonth_regexp :=
        array_to_string(array_cat(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_shortnames')),
                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_names'))),
                                  array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_extrashortnames')),
                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_extranames')))
                                 ), '|');

    IF ((v_datestring ~* v_defmask1_regexp AND v_culture <> 'FI') OR
        (v_datestring ~* v_defmask1_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_datestring ~ concat(CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                  CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                  AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                  '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                  CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
            v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, CASE v_culture
                                                             WHEN 'FI' THEN v_defmask1_fi_regexp
                                                             ELSE v_defmask1_regexp
                                                          END, 'gi');
        v_timestring := v_regmatch_groups[2];
        v_correctnum := coalesce(v_regmatch_groups[1], v_regmatch_groups[3],
                                 v_regmatch_groups[5], v_regmatch_groups[6]);

        IF (v_date_format = 'DMY' OR
            v_culture IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[4];
            v_month := v_regmatch_groups[7];
        ELSE
            v_day := v_regmatch_groups[7];
            v_month := v_regmatch_groups[4];
        END IF;

        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
        THEN
            IF (v_day::SMALLINT > 30 OR
                v_month::SMALLINT > 12) THEN
                RAISE invalid_datetime_format;
            END IF;

            v_raw_year := to_char(aws_sqlserver_ext.conv_greg_to_hijri(current_date + 1), 'YYYY');
            v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

            v_day := to_char(v_hijridate, 'DD');
            v_month := to_char(v_hijridate, 'MM');
            v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;
        ELSE
            v_year := to_char(current_date, 'YYYY')::SMALLINT;
        END IF;

    ELSIF ((v_datestring ~* v_defmask6_regexp AND v_culture <> 'FI') OR
           (v_datestring ~* v_defmask6_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}',
                                   '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                   '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                   '\d{3,4}', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                   TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                   '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, CASE v_culture
                                                             WHEN 'FI' THEN v_defmask6_fi_regexp
                                                             ELSE v_defmask6_regexp
                                                          END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_day := v_regmatch_groups[4];
        v_month := v_regmatch_groups[3];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[2]::SMALLINT - 543
                     ELSE v_regmatch_groups[2]::SMALLINT
                  END;

    ELSIF ((v_datestring ~* v_defmask2_regexp AND v_culture <> 'FI') OR
           (v_datestring ~* v_defmask2_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}',
                                   '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                   '(?:', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                   AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                   '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, CASE v_culture
                                                             WHEN 'FI' THEN v_defmask2_fi_regexp
                                                             ELSE v_defmask2_regexp
                                                          END, 'gi');
        v_timestring := v_regmatch_groups[2];
        v_correctnum := coalesce(v_regmatch_groups[1], v_regmatch_groups[3], v_regmatch_groups[5],
                                 v_regmatch_groups[6], v_regmatch_groups[8], v_regmatch_groups[9]);
        v_day := '01';
        v_month := v_regmatch_groups[7];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[4]::SMALLINT - 543
                     ELSE v_regmatch_groups[4]::SMALLINT
                  END;

    ELSIF (v_datestring ~* v_defmask4_1_regexp OR
           (v_datestring ~* v_defmask4_2_regexp AND v_culture !~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV') OR
           (v_datestring ~* v_defmask9_regexp AND v_culture <> 'FI') OR
           (v_datestring ~* v_defmask9_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_datestring ~ concat('\d+\s*\.?(?:,+|,*', AMPM_REGEXP, ')', TIME_MASKSEP_FI_REGEXP, '\.+', TIME_MASKSEP_REGEXP, '$|',
                                  '\d+\s*\.', TIME_MASKSEP_FI_REGEXP, '\.', TIME_MASKSEP_FI_REGEXP, '$') AND
            v_culture = 'FI')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        IF (v_datestring ~* v_defmask4_0_regexp) THEN
            v_timestring := (regexp_matches(v_datestring, v_defmask4_0_regexp, 'gi'))[1];
        ELSE
            v_timestring := v_datestring;
        END IF;

        v_res_date := current_date;
        v_day := to_char(v_res_date, 'DD');
        v_month := to_char(v_res_date, 'MM');
        v_year := to_char(v_res_date, 'YYYY')::SMALLINT;

    ELSIF ((v_datestring ~* v_defmask3_regexp AND v_culture <> 'FI') OR
           (v_datestring ~* v_defmask3_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?',
                                   TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP, '|',
                                   '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, CASE v_culture
                                                             WHEN 'FI' THEN v_defmask3_fi_regexp
                                                             ELSE v_defmask3_regexp
                                                          END, 'gi');
        v_timestring := v_regmatch_groups[1];
        v_day := '01';
        v_month := v_regmatch_groups[2];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[3]::SMALLINT - 543
                     ELSE v_regmatch_groups[3]::SMALLINT
                  END;

    ELSIF ((v_datestring ~* v_defmask5_regexp AND v_culture <> 'FI') OR
           (v_datestring ~* v_defmask5_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                   TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                   TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$|',
                                   '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}\s*(?:\.)+|',
                                   '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, v_defmask5_regexp, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[4]::SMALLINT - 543
                     ELSE v_regmatch_groups[4]::SMALLINT
                  END;

        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[2];
            v_month := v_regmatch_groups[3];
        ELSE
            v_day := v_regmatch_groups[3];
            v_month := v_regmatch_groups[2];
        END IF;

    ELSIF ((v_datestring ~* v_defmask7_regexp AND v_culture <> 'FI') OR
           (v_datestring ~* v_defmask7_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}',
                                   MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}|',
                                   '\d{3,4}', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                   '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, CASE v_culture
                                                             WHEN 'FI' THEN v_defmask7_fi_regexp
                                                             ELSE v_defmask7_regexp
                                                          END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_day := v_regmatch_groups[4];
        v_month := v_regmatch_groups[2];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[3]::SMALLINT - 543
                     ELSE v_regmatch_groups[3]::SMALLINT
                  END;

    ELSIF ((v_datestring ~* v_defmask8_regexp AND v_culture <> 'FI') OR
           (v_datestring ~* v_defmask8_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_datestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}',
                                  MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                  TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                  '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                  TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                  '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
            v_culture ~ 'FI|DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datestring, CASE v_culture
                                                             WHEN 'FI' THEN v_defmask8_fi_regexp
                                                             ELSE v_defmask8_regexp
                                                          END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);

        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[2];
            v_month := v_regmatch_groups[3];
            v_raw_year := v_regmatch_groups[4];
        ELSIF (v_date_format = 'YMD')
        THEN
            v_day := v_regmatch_groups[4];
            v_month := v_regmatch_groups[3];
            v_raw_year := v_regmatch_groups[2];
        ELSE
            v_day := v_regmatch_groups[3];
            v_month := v_regmatch_groups[2];
            v_raw_year := v_regmatch_groups[4];
        END IF;

        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
        THEN
            IF (v_day::SMALLINT > 30 OR
                v_month::SMALLINT > 12) THEN
                RAISE invalid_datetime_format;
            END IF;

            v_raw_year := aws_sqlserver_ext.get_full_year(v_raw_year, '14');
            v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

            v_day := to_char(v_hijridate, 'DD');
            v_month := to_char(v_hijridate, 'MM');
            v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;

        ELSIF (v_culture IN ('TH-TH', 'TH_TH')) THEN
            v_year := aws_sqlserver_ext.get_full_year(v_raw_year)::SMALLINT - 43;
        ELSE
            v_year := aws_sqlserver_ext.get_full_year(v_raw_year, '', 29)::SMALLINT;
        END IF;
    ELSE
        v_found := FALSE;
    END IF;

    WHILE (NOT v_found AND v_resmask_cnt < 20)
    LOOP
        v_resmask := replace(CASE v_resmask_cnt
                                WHEN 10 THEN v_defmask10_regexp
                                WHEN 11 THEN v_defmask11_regexp
                                WHEN 12 THEN v_defmask12_regexp
                                WHEN 13 THEN v_defmask13_regexp
                                WHEN 14 THEN v_defmask14_regexp
                                WHEN 15 THEN v_defmask15_regexp
                                WHEN 16 THEN v_defmask16_regexp
                                WHEN 17 THEN v_defmask17_regexp
                                WHEN 18 THEN v_defmask18_regexp
                                WHEN 19 THEN v_defmask19_regexp
                             END,
                             '$comp_month$', v_compmonth_regexp);

        v_resmask_fi := replace(CASE v_resmask_cnt
                                   WHEN 10 THEN v_defmask10_fi_regexp
                                   WHEN 11 THEN v_defmask11_fi_regexp
                                   WHEN 12 THEN v_defmask12_fi_regexp
                                   WHEN 13 THEN v_defmask13_fi_regexp
                                   WHEN 14 THEN v_defmask14_fi_regexp
                                   WHEN 15 THEN v_defmask15_fi_regexp
                                   WHEN 16 THEN v_defmask16_fi_regexp
                                   WHEN 17 THEN v_defmask17_fi_regexp
                                   WHEN 18 THEN v_defmask18_fi_regexp
                                   WHEN 19 THEN v_defmask19_fi_regexp
                                END,
                                '$comp_month$', v_compmonth_regexp);

        IF ((v_datestring ~* v_resmask AND v_culture <> 'FI') OR
            (v_datestring ~* v_resmask_fi AND v_culture = 'FI'))
        THEN
            v_found := TRUE;
            v_regmatch_groups := regexp_matches(v_datestring, CASE v_culture
                                                                 WHEN 'FI' THEN v_resmask_fi
                                                                 ELSE v_resmask
                                                              END, 'gi');
            v_timestring := CASE
                               WHEN v_resmask_cnt IN (10, 11, 12, 13) THEN concat(v_regmatch_groups[1], v_regmatch_groups[4])
                               ELSE concat(v_regmatch_groups[1], v_regmatch_groups[5])
                            END;

            IF (v_resmask_cnt = 10)
            THEN
                IF (v_regmatch_groups[3] = 'MAR' AND
                    v_culture IN ('IT-IT', 'IT_IT'))
                THEN
                    RAISE invalid_datetime_format;
                END IF;

                IF (v_date_format = 'YMD' AND v_culture NOT IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
                THEN
                    v_day := '01';
                    v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[2], '', 29)::SMALLINT;
                ELSE
                    v_day := v_regmatch_groups[2];
                    v_year := to_char(current_date, 'YYYY')::SMALLINT;
                END IF;

                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := to_char(aws_sqlserver_ext.conv_greg_to_hijri(current_date + 1), 'YYYY');

            ELSIF (v_resmask_cnt = 11)
            THEN
                IF (v_date_format IN ('YMD', 'MDY') AND v_culture NOT IN ('SV-SE', 'SV_SE'))
                THEN
                    v_day := v_regmatch_groups[3];
                    v_year := to_char(current_date, 'YYYY')::SMALLINT;
                ELSE
                    v_day := '01';
                    v_year := CASE
                                 WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_regmatch_groups[3])::SMALLINT - 43
                                 ELSE aws_sqlserver_ext.get_full_year(v_regmatch_groups[3], '', 29)::SMALLINT
                              END;
                END IF;

                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := aws_sqlserver_ext.get_full_year(substring(v_year::TEXT, 3, 2), '14');

            ELSIF (v_resmask_cnt = 12)
            THEN
                v_day := '01';
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 13)
            THEN
                v_day := '01';
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[3];

            ELSIF (v_resmask_cnt IN (14, 15, 16))
            THEN
                IF (v_resmask_cnt = 14)
                THEN
                    v_left_part := v_regmatch_groups[4];
                    v_right_part := v_regmatch_groups[3];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                ELSIF (v_resmask_cnt = 15)
                THEN
                    v_left_part := v_regmatch_groups[4];
                    v_right_part := v_regmatch_groups[2];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                ELSE
                    v_left_part := v_regmatch_groups[3];
                    v_right_part := v_regmatch_groups[2];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[4], v_lang_metadata_json);
                END IF;

                IF (char_length(v_left_part) <= 2)
                THEN
                    IF (v_date_format = 'YMD' AND v_culture NOT IN ('LV-LV', 'LV_LV'))
                    THEN
                        v_day := v_left_part;
                        v_raw_year := aws_sqlserver_ext.get_full_year(v_right_part, '14');
                        v_year := CASE
                                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_right_part)::SMALLINT - 43
                                     ELSE aws_sqlserver_ext.get_full_year(v_right_part, '', 29)::SMALLINT
                                  END;
                        BEGIN
                            v_res_date := make_date(v_year, v_month::SMALLINT, v_day::SMALLINT);
                        EXCEPTION
                        WHEN OTHERS THEN
                            v_day := v_right_part;
                            v_raw_year := aws_sqlserver_ext.get_full_year(v_left_part, '14');
                            v_year := CASE
                                         WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_left_part)::SMALLINT - 43
                                         ELSE aws_sqlserver_ext.get_full_year(v_left_part, '', 29)::SMALLINT
                                      END;
                        END;
                    END IF;

                    IF (v_date_format IN ('MDY', 'DMY') OR v_culture IN ('LV-LV', 'LV_LV'))
                    THEN
                        v_day := v_right_part;
                        v_raw_year := aws_sqlserver_ext.get_full_year(v_left_part, '14');
                        v_year := CASE
                                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_left_part)::SMALLINT - 43
                                     ELSE aws_sqlserver_ext.get_full_year(v_left_part, '', 29)::SMALLINT
                                  END;
                        BEGIN
                            v_res_date := make_date(v_year, v_month::SMALLINT, v_day::SMALLINT);
                        EXCEPTION
                        WHEN OTHERS THEN
                            v_day := v_left_part;
                            v_raw_year := aws_sqlserver_ext.get_full_year(v_right_part, '14');
                            v_year := CASE
                                         WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_right_part)::SMALLINT - 43
                                         ELSE aws_sqlserver_ext.get_full_year(v_right_part, '', 29)::SMALLINT
                                      END;
                        END;
                    END IF;
                ELSE
                    v_day := v_right_part;
                    v_raw_year := v_left_part;
	            v_year := CASE
                                 WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_left_part::SMALLINT - 543
                                 ELSE v_left_part::SMALLINT
                              END;
                END IF;

            ELSIF (v_resmask_cnt = 17)
            THEN
                v_day := v_regmatch_groups[4];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 18)
            THEN
                v_day := v_regmatch_groups[3];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[4], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 19)
            THEN
                v_day := v_regmatch_groups[4];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[3];
            END IF;

            IF (v_resmask_cnt NOT IN (10, 11, 14, 15, 16))
            THEN
                v_year := CASE
                             WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_raw_year::SMALLINT - 543
                             ELSE v_raw_year::SMALLINT
                          END;
            END IF;

            IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
            THEN
                IF (v_day::SMALLINT > 30 OR
                    (v_resmask_cnt NOT IN (10, 11, 14, 15, 16) AND v_year NOT BETWEEN 1318 AND 1501) OR
                    (v_resmask_cnt IN (14, 15, 16) AND v_raw_year::SMALLINT NOT BETWEEN 1318 AND 1501))
                THEN
                    RAISE invalid_datetime_format;
                END IF;

                v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

                v_day := to_char(v_hijridate, 'DD');
                v_month := to_char(v_hijridate, 'MM');
                v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;
            END IF;
        END IF;

        v_resmask_cnt := v_resmask_cnt + 1;
    END LOOP;

    IF (NOT v_found) THEN
        RAISE invalid_datetime_format;
    END IF;

    IF (char_length(v_timestring) > 0 AND v_timestring NOT IN ('AM', '', 'PM', ''))
    THEN
        IF (v_culture = 'FI') THEN
            v_timestring := translate(v_timestring, '.,', ': ');

            IF (char_length(split_part(v_timestring, ':', 4)) > 0) THEN
                v_timestring := regexp_replace(v_timestring, ':(?=\s*\d+\s*:?\s*(?:[AP]M||)?\s*$)', '.');
            END IF;
        END IF;

        v_timestring := replace(regexp_replace(v_timestring, '\.?[AP]M|||\s|\,|\.\D|[\.|:]$', '', 'gi'), ':.', ':');
        BEGIN
            v_hours := coalesce(split_part(v_timestring, ':', 1)::SMALLINT, 0);

            IF ((v_dayparts[1] IN ('AM', '') AND v_hours NOT BETWEEN 0 AND 12) OR
                (v_dayparts[1] IN ('PM', '') AND v_hours NOT BETWEEN 1 AND 23))
            THEN
                RAISE invalid_datetime_format;
            END IF;

            v_minutes := coalesce(nullif(split_part(v_timestring, ':', 2), '')::SMALLINT, 0);
            v_seconds := coalesce(nullif(split_part(v_timestring, ':', 3), '')::NUMERIC, 0);
        EXCEPTION
            WHEN OTHERS THEN
            RAISE invalid_datetime_format;
        END;
    ELSIF (v_dayparts[1] IN ('PM', ''))
    THEN
        v_hours := 12;
    END IF;

    v_res_date := make_timestamp(v_year, v_month::SMALLINT, v_day::SMALLINT,
                                 v_hours, v_minutes, v_seconds);

    IF (v_weekdaynames[1] IS NOT NULL) THEN
        v_weekdaynum := aws_sqlserver_ext.get_weekdaynum_by_name(v_weekdaynames[1], v_lang_metadata_json);

        IF (CASE date_part('dow', v_res_date)::SMALLINT
               WHEN 0 THEN 7
               ELSE date_part('dow', v_res_date)::SMALLINT
            END <> v_weekdaynum)
        THEN
            RAISE invalid_datetime_format;
        END IF;
    END IF;

    RETURN v_res_date;
EXCEPTION
    WHEN invalid_datetime_format OR datetime_field_overflow THEN
        RAISE USING MESSAGE := format('Error converting string value ''%s'' into data type DATE using culture ''%s''.',
                                      p_datestring, p_culture),
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := CASE char_length(coalesce(CONVERSION_LANG, ''))
                                  WHEN 0 THEN format('The culture parameter ''%s'' provided in the function call is not supported.',
                                                     p_culture)
                                  ELSE format('Invalid CONVERSION_LANG constant value - ''%s''. Allowed values are: ''English'', ''Deutsch'', etc.',
                                              CONVERSION_LANG)
                               END,
                    DETAIL := 'Passed incorrect value for "p_culture" parameter or compiled incorrect CONVERSION_LANG constant value in function''s body.',
                    HINT := 'Check "p_culture" input parameter value, correct it if needed, and try again. Also check CONVERSION_LANG constant value.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="7c9e791f-9f3a-476b-851e-e3108e251cec" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1cb9e43e-a9ee-411e-893b-b9a5dac2fda9" name="parse_to_datetime" is-trigger-function="0" unique-function-name="parse_to_datetime" is-aggregate="f" language-name="plpgsql" context="parse_to_datetime" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" comment="This function parses the TEXT string and converts it into a DATETIME value, according to specified culture (conversion mask)." is-returning-set="f" ret-datatype="timestamp" function-arguments="p_datatype text, p_datetimestring text, p_culture text DEFAULT ''::text" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23964" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datatype text, p_datetimestring text, p_culture text" overload-function-count="1" proc-language="plpgsql" function-signature="parse_to_datetime(p_datatype text, p_datetimestring text, p_culture text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day VARCHAR;
    v_year SMALLINT;
    v_month VARCHAR;
    v_res_date DATE;
    v_scale SMALLINT;
    v_hijridate DATE;
    v_culture VARCHAR;
    v_dayparts TEXT[];
    v_resmask VARCHAR;
    v_datatype VARCHAR;
    v_raw_year VARCHAR;
    v_left_part VARCHAR;
    v_right_part VARCHAR;
    v_resmask_fi VARCHAR;
    v_timestring VARCHAR;
    v_correctnum VARCHAR;
    v_weekdaynum SMALLINT;
    v_err_message VARCHAR;
    v_date_format VARCHAR;
    v_weekdaynames TEXT[];
    v_hours SMALLINT := 0;
    v_minutes SMALLINT := 0;
    v_res_datatype VARCHAR;
    v_error_message VARCHAR;
    v_found BOOLEAN := TRUE;
    v_compday_regexp VARCHAR;
    v_regmatch_groups TEXT[];
    v_datatype_groups TEXT[];
    v_datetimestring VARCHAR;
    v_seconds VARCHAR := '0';
    v_fseconds VARCHAR := '0';
    v_compmonth_regexp VARCHAR;
    v_lang_metadata_json JSONB;
    v_resmask_cnt SMALLINT := 10;
    v_res_datetime TIMESTAMP(6) WITHOUT TIME ZONE;
    DAYMM_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    FULLYEAR_REGEXP CONSTANT VARCHAR := '(\d{3,4})';
    SHORTYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    COMPYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,4})';
    AMPM_REGEXP CONSTANT VARCHAR := '(?:[AP]M||)';
    TIMEUNIT_REGEXP CONSTANT VARCHAR := '\s*\d{1,2}\s*';
    MASKSEPONE_REGEXP CONSTANT VARCHAR := '\s*(?:/|-)?';
    MASKSEPTWO_REGEXP CONSTANT VARCHAR := '\s*(?:\s|/|-|\.|,)';
    MASKSEPTWO_FI_REGEXP CONSTANT VARCHAR := '\s*(?:\s|/|-|,)';
    MASKSEPTHREE_REGEXP CONSTANT VARCHAR := '\s*(?:/|-|\.|,)';
    TIME_MASKSEP_REGEXP CONSTANT VARCHAR := '(?:\s|\.|,)*';
    TIME_MASKSEP_FI_REGEXP CONSTANT VARCHAR := '(?:\s|,)*';
    WEEKDAYAMPM_START_REGEXP CONSTANT VARCHAR := '(^|[[:digit:][:space:]\.,])';
    WEEKDAYAMPM_END_REGEXP CONSTANT VARCHAR := '([[:digit:][:space:]\.,]|$)(?=[^/-]|$)';
    CORRECTNUM_REGEXP CONSTANT VARCHAR := '(?:([+-]\d{1,4})(?:[[:space:]\.,]|[AP]M|||$))';
    DATATYPE_REGEXP CONSTANT VARCHAR := '^(DATETIME|SMALLDATETIME|DATETIME2)\s*(?:\()?\s*((?:-)?\d+)?\s*(?:\))?$';
    ANNO_DOMINI_REGEXP VARCHAR := '(AD|A\.D\.)';
    ANNO_DOMINI_COMPREGEXP VARCHAR := concat(WEEKDAYAMPM_START_REGEXP, ANNO_DOMINI_REGEXP, WEEKDAYAMPM_END_REGEXP);
    HHMMSSFS_PART_REGEXP CONSTANT VARCHAR :=
        concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\s*\d{1,2}\.\d+(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?');
    HHMMSSFS_PART_FI_REGEXP CONSTANT VARCHAR :=
        concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?\.?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '\s*\d{1,2}\.\d+(?!\d)\.?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?');
    v_defmask1_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(?:[\.|,]+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP, '$');
    v_defmask1_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(?:[\.|,]+', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask2_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(?:(?:[\.|,]+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?)|',
                                        CORRECTNUM_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP, '$');
    v_defmask2_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           AMPM_REGEXP, TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(?:(?:[\.|,]+', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?)|',
                                           CORRECTNUM_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask3_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, ')|',
                                        '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(', TIME_MASKSEP_REGEXP, AMPM_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask3_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '[\./]?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)',
                                           FULLYEAR_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask4_0_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask4_1_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          '(?:\s|,)+',
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask4_2_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          '\s*[\.]+', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask5_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask5_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask6_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask6_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:\s*[\.])?',
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask7_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask7_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask8_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:[\.|,]+', AMPM_REGEXP, ')?',
                                        TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask8_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:[\,]+|\s*/\s*)', AMPM_REGEXP, ')?',
                                           TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask9_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(',
                                        HHMMSSFS_PART_REGEXP,
                                        ')', TIME_MASKSEP_REGEXP, '$');
    v_defmask9_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '(',
                                           HHMMSSFS_PART_FI_REGEXP,
                                           ')', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask10_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask10_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)?', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask11_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask11_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           '($comp_month$)',
                                           '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask12_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask12_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask13_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$');
    v_defmask13_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            FULLYEAR_REGEXP,
                                            TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask14_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)'
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask14_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)'
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_FI_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask15_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask15_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask16_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask16_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask17_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask17_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask18_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                         '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask18_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                            '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask19_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                         '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask19_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                            '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    CONVERSION_LANG CONSTANT VARCHAR := '';
    DATE_FORMAT CONSTANT VARCHAR := '';
BEGIN
    v_datatype := trim(p_datatype);
    v_datetimestring := upper(trim(p_datetimestring));
    v_culture := coalesce(nullif(upper(trim(p_culture)), ''), 'EN-US');

    v_datatype_groups := regexp_matches(v_datatype, DATATYPE_REGEXP, 'gi');

    v_res_datatype := upper(v_datatype_groups[1]);
    v_scale := v_datatype_groups[2]::SMALLINT;

    IF (v_res_datatype IS NULL) THEN
        RAISE datatype_mismatch;
    ELSIF (v_res_datatype <> 'DATETIME2' AND v_scale IS NOT NULL)
    THEN
        RAISE invalid_indicator_parameter_value;
    ELSIF (coalesce(v_scale, 0) NOT BETWEEN 0 AND 7)
    THEN
        RAISE interval_field_overflow;
    ELSIF (v_scale IS NULL) THEN
        v_scale := 7;
    END IF;

    v_dayparts := ARRAY(SELECT upper(array_to_string(regexp_matches(v_datetimestring, '[AP]M||', 'gi'), '')));

    IF (array_length(v_dayparts, 1) > 1) THEN
        RAISE invalid_datetime_format;
    END IF;

    BEGIN
        v_lang_metadata_json := aws_sqlserver_ext.get_lang_metadata_json(coalesce(nullif(CONVERSION_LANG, ''), p_culture));
    EXCEPTION
        WHEN OTHERS THEN
        RAISE invalid_parameter_value;
    END;

    v_compday_regexp := array_to_string(array_cat(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_names')),
                                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_shortnames'))),
                                                  ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_extrashortnames'))), '|');

    v_weekdaynames := ARRAY(SELECT array_to_string(regexp_matches(v_datetimestring, v_compday_regexp, 'gi'), ''));

    IF (array_length(v_weekdaynames, 1) > 1) THEN
        RAISE invalid_datetime_format;
    END IF;

    IF (v_weekdaynames[1] IS NOT NULL AND
        v_datetimestring ~* concat(WEEKDAYAMPM_START_REGEXP, '(', v_compday_regexp, ')', WEEKDAYAMPM_END_REGEXP))
    THEN
        v_datetimestring := replace(v_datetimestring, v_weekdaynames[1], ' ');
    END IF;

    IF (v_datetimestring ~* ANNO_DOMINI_COMPREGEXP)
    THEN
        IF (v_culture !~ 'EN[-_]US|DA[-_]DK|SV[-_]SE|EN[-_]GB|HI[-_]IS') THEN
            RAISE invalid_datetime_format;
        END IF;

        v_datetimestring := regexp_replace(v_datetimestring,
                                           ANNO_DOMINI_COMPREGEXP,
                                           regexp_replace(array_to_string(regexp_matches(v_datetimestring, ANNO_DOMINI_COMPREGEXP, 'gi'), ''),
                                                          ANNO_DOMINI_REGEXP, ' ', 'gi'),
                                           'gi');
    END IF;

    v_date_format := coalesce(nullif(upper(trim(DATE_FORMAT)), ''), v_lang_metadata_json ->> 'date_format');

    v_compmonth_regexp :=
        array_to_string(array_cat(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_shortnames')),
                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_names'))),
                                  array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_extrashortnames')),
                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_extranames')))
                                 ), '|');

    IF ((v_datetimestring ~* v_defmask1_regexp AND v_culture <> 'FI') OR
        (v_datetimestring ~* v_defmask1_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_datetimestring ~ concat(CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                      CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                      AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                      '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                      CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
            v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datetimestring, CASE v_culture
                                                                 WHEN 'FI' THEN v_defmask1_fi_regexp
                                                                 ELSE v_defmask1_regexp
                                                              END, 'gi');
        v_timestring := v_regmatch_groups[2];
        v_correctnum := coalesce(v_regmatch_groups[1], v_regmatch_groups[3],
                                 v_regmatch_groups[5], v_regmatch_groups[6]);

        IF (v_date_format = 'DMY' OR
            v_culture IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[4];
            v_month := v_regmatch_groups[7];
        ELSE
            v_day := v_regmatch_groups[7];
            v_month := v_regmatch_groups[4];
        END IF;

        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
        THEN
            IF (v_day::SMALLINT > 30 OR
                v_month::SMALLINT > 12) THEN
                RAISE invalid_datetime_format;
            END IF;

            v_raw_year := to_char(aws_sqlserver_ext.conv_greg_to_hijri(current_date + 1), 'YYYY');
            v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

            v_day := to_char(v_hijridate, 'DD');
            v_month := to_char(v_hijridate, 'MM');
            v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;
        ELSE
            v_year := to_char(current_date, 'YYYY')::SMALLINT;
        END IF;

    ELSIF ((v_datetimestring ~* v_defmask6_regexp AND v_culture <> 'FI') OR
           (v_datetimestring ~* v_defmask6_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datetimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}',
                                       '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                       '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                       '\d{3,4}', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                       TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                       '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datetimestring, CASE v_culture
                                                                 WHEN 'FI' THEN v_defmask6_fi_regexp
                                                                 ELSE v_defmask6_regexp
                                                              END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_day := v_regmatch_groups[4];
        v_month := v_regmatch_groups[3];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[2]::SMALLINT - 543
                     ELSE v_regmatch_groups[2]::SMALLINT
                  END;

    ELSIF ((v_datetimestring ~* v_defmask2_regexp AND v_culture <> 'FI') OR
           (v_datetimestring ~* v_defmask2_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datetimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}',
                                       '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                       '(?:', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                       AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                       '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datetimestring, CASE v_culture
                                                                 WHEN 'FI' THEN v_defmask2_fi_regexp
                                                                 ELSE v_defmask2_regexp
                                                              END, 'gi');
        v_timestring := v_regmatch_groups[2];
        v_correctnum := coalesce(v_regmatch_groups[1], v_regmatch_groups[3], v_regmatch_groups[5],
                                 v_regmatch_groups[6], v_regmatch_groups[8], v_regmatch_groups[9]);
        v_day := '01';
        v_month := v_regmatch_groups[7];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[4]::SMALLINT - 543
                     ELSE v_regmatch_groups[4]::SMALLINT
                  END;

    ELSIF (v_datetimestring ~* v_defmask4_1_regexp OR
           (v_datetimestring ~* v_defmask4_2_regexp AND v_culture !~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV') OR
           (v_datetimestring ~* v_defmask9_regexp AND v_culture <> 'FI') OR
           (v_datetimestring ~* v_defmask9_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_datetimestring ~ concat('\d+\s*\.?(?:,+|,*', AMPM_REGEXP, ')', TIME_MASKSEP_FI_REGEXP, '\.+', TIME_MASKSEP_REGEXP, '$|',
                                      '\d+\s*\.', TIME_MASKSEP_FI_REGEXP, '\.', TIME_MASKSEP_FI_REGEXP, '$') AND
            v_culture = 'FI')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        IF (v_datetimestring ~* v_defmask4_0_regexp) THEN
            v_timestring := (regexp_matches(v_datetimestring, v_defmask4_0_regexp, 'gi'))[1];
        ELSE
            v_timestring := v_datetimestring;
        END IF;

        v_res_date := current_date;
        v_day := to_char(v_res_date, 'DD');
        v_month := to_char(v_res_date, 'MM');
        v_year := to_char(v_res_date, 'YYYY')::SMALLINT;

    ELSIF ((v_datetimestring ~* v_defmask3_regexp AND v_culture <> 'FI') OR
           (v_datetimestring ~* v_defmask3_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datetimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?',
                                       TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP, '|',
                                       '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datetimestring, CASE v_culture
                                                                 WHEN 'FI' THEN v_defmask3_fi_regexp
                                                                 ELSE v_defmask3_regexp
                                                              END, 'gi');
        v_timestring := v_regmatch_groups[1];
        v_day := '01';
        v_month := v_regmatch_groups[2];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[3]::SMALLINT - 543
                     ELSE v_regmatch_groups[3]::SMALLINT
                  END;

    ELSIF ((v_datetimestring ~* v_defmask5_regexp AND v_culture <> 'FI') OR
           (v_datetimestring ~* v_defmask5_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datetimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                       TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                       TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$|',
                                       '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}\s*(?:\.)+|',
                                       '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datetimestring, v_defmask5_regexp, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[4]::SMALLINT - 543
                     ELSE v_regmatch_groups[4]::SMALLINT
                  END;

        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[2];
            v_month := v_regmatch_groups[3];
        ELSE
            v_day := v_regmatch_groups[3];
            v_month := v_regmatch_groups[2];
        END IF;

    ELSIF ((v_datetimestring ~* v_defmask7_regexp AND v_culture <> 'FI') OR
           (v_datetimestring ~* v_defmask7_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_datetimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}',
                                       MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}|',
                                       '\d{3,4}', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                       '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datetimestring, CASE v_culture
                                                                 WHEN 'FI' THEN v_defmask7_fi_regexp
                                                                 ELSE v_defmask7_regexp
                                                              END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_day := v_regmatch_groups[4];
        v_month := v_regmatch_groups[2];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[3]::SMALLINT - 543
                     ELSE v_regmatch_groups[3]::SMALLINT
                  END;

    ELSIF ((v_datetimestring ~* v_defmask8_regexp AND v_culture <> 'FI') OR
           (v_datetimestring ~* v_defmask8_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_datetimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}',
                                      MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                      TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                      '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                      TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                      '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
            v_culture ~ 'FI|DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_datetimestring, CASE v_culture
                                                                 WHEN 'FI' THEN v_defmask8_fi_regexp
                                                                 ELSE v_defmask8_regexp
                                                              END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);

        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[2];
            v_month := v_regmatch_groups[3];
            v_raw_year := v_regmatch_groups[4];
        ELSIF (v_date_format = 'YMD')
        THEN
            v_day := v_regmatch_groups[4];
            v_month := v_regmatch_groups[3];
            v_raw_year := v_regmatch_groups[2];
        ELSE
            v_day := v_regmatch_groups[3];
            v_month := v_regmatch_groups[2];
            v_raw_year := v_regmatch_groups[4];
        END IF;

        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
        THEN
            IF (v_day::SMALLINT > 30 OR
                v_month::SMALLINT > 12) THEN
                RAISE invalid_datetime_format;
            END IF;

            v_raw_year := aws_sqlserver_ext.get_full_year(v_raw_year, '14');
            v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

            v_day := to_char(v_hijridate, 'DD');
            v_month := to_char(v_hijridate, 'MM');
            v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;

        ELSIF (v_culture IN ('TH-TH', 'TH_TH')) THEN
            v_year := aws_sqlserver_ext.get_full_year(v_raw_year)::SMALLINT - 43;
        ELSE
            v_year := aws_sqlserver_ext.get_full_year(v_raw_year, '', 29)::SMALLINT;
        END IF;
    ELSE
        v_found := FALSE;
    END IF;

    WHILE (NOT v_found AND v_resmask_cnt < 20)
    LOOP
        v_resmask := replace(CASE v_resmask_cnt
                                WHEN 10 THEN v_defmask10_regexp
                                WHEN 11 THEN v_defmask11_regexp
                                WHEN 12 THEN v_defmask12_regexp
                                WHEN 13 THEN v_defmask13_regexp
                                WHEN 14 THEN v_defmask14_regexp
                                WHEN 15 THEN v_defmask15_regexp
                                WHEN 16 THEN v_defmask16_regexp
                                WHEN 17 THEN v_defmask17_regexp
                                WHEN 18 THEN v_defmask18_regexp
                                WHEN 19 THEN v_defmask19_regexp
                             END,
                             '$comp_month$', v_compmonth_regexp);

        v_resmask_fi := replace(CASE v_resmask_cnt
                                   WHEN 10 THEN v_defmask10_fi_regexp
                                   WHEN 11 THEN v_defmask11_fi_regexp
                                   WHEN 12 THEN v_defmask12_fi_regexp
                                   WHEN 13 THEN v_defmask13_fi_regexp
                                   WHEN 14 THEN v_defmask14_fi_regexp
                                   WHEN 15 THEN v_defmask15_fi_regexp
                                   WHEN 16 THEN v_defmask16_fi_regexp
                                   WHEN 17 THEN v_defmask17_fi_regexp
                                   WHEN 18 THEN v_defmask18_fi_regexp
                                   WHEN 19 THEN v_defmask19_fi_regexp
                                END,
                                '$comp_month$', v_compmonth_regexp);

        IF ((v_datetimestring ~* v_resmask AND v_culture <> 'FI') OR
            (v_datetimestring ~* v_resmask_fi AND v_culture = 'FI'))
        THEN
            v_found := TRUE;
            v_regmatch_groups := regexp_matches(v_datetimestring, CASE v_culture
                                                                     WHEN 'FI' THEN v_resmask_fi
                                                                     ELSE v_resmask
                                                                  END, 'gi');
            v_timestring := CASE
                               WHEN v_resmask_cnt IN (10, 11, 12, 13) THEN concat(v_regmatch_groups[1], v_regmatch_groups[4])
                               ELSE concat(v_regmatch_groups[1], v_regmatch_groups[5])
                            END;

            IF (v_resmask_cnt = 10)
            THEN
                IF (v_regmatch_groups[3] = 'MAR' AND
                    v_culture IN ('IT-IT', 'IT_IT'))
                THEN
                    RAISE invalid_datetime_format;
                END IF;

                IF (v_date_format = 'YMD' AND v_culture NOT IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
                THEN
                    v_day := '01';
                    v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[2], '', 29)::SMALLINT;
                ELSE
                    v_day := v_regmatch_groups[2];
                    v_year := to_char(current_date, 'YYYY')::SMALLINT;
                END IF;

                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := to_char(aws_sqlserver_ext.conv_greg_to_hijri(current_date + 1), 'YYYY');

            ELSIF (v_resmask_cnt = 11)
            THEN
                IF (v_date_format IN ('YMD', 'MDY') AND v_culture NOT IN ('SV-SE', 'SV_SE'))
                THEN
                    v_day := v_regmatch_groups[3];
                    v_year := to_char(current_date, 'YYYY')::SMALLINT;
                ELSE
                    v_day := '01';
                    v_year := CASE
                                 WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_regmatch_groups[3])::SMALLINT - 43
                                 ELSE aws_sqlserver_ext.get_full_year(v_regmatch_groups[3], '', 29)::SMALLINT
                              END;
                END IF;

                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := aws_sqlserver_ext.get_full_year(substring(v_year::TEXT, 3, 2), '14');

            ELSIF (v_resmask_cnt = 12)
            THEN
                v_day := '01';
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 13)
            THEN
                v_day := '01';
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[3];

            ELSIF (v_resmask_cnt IN (14, 15, 16))
            THEN
                IF (v_resmask_cnt = 14)
                THEN
                    v_left_part := v_regmatch_groups[4];
                    v_right_part := v_regmatch_groups[3];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                ELSIF (v_resmask_cnt = 15)
                THEN
                    v_left_part := v_regmatch_groups[4];
                    v_right_part := v_regmatch_groups[2];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                ELSE
                    v_left_part := v_regmatch_groups[3];
                    v_right_part := v_regmatch_groups[2];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[4], v_lang_metadata_json);
                END IF;

                IF (char_length(v_left_part) <= 2)
                THEN
                    IF (v_date_format = 'YMD' AND v_culture NOT IN ('LV-LV', 'LV_LV'))
                    THEN
                        v_day := v_left_part;
                        v_raw_year := aws_sqlserver_ext.get_full_year(v_right_part, '14');
                        v_year := CASE
                                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_right_part)::SMALLINT - 43
                                     ELSE aws_sqlserver_ext.get_full_year(v_right_part, '', 29)::SMALLINT
                                  END;
                        BEGIN
                            v_res_date := make_date(v_year, v_month::SMALLINT, v_day::SMALLINT);
                        EXCEPTION
                        WHEN OTHERS THEN
                            v_day := v_right_part;
                            v_raw_year := aws_sqlserver_ext.get_full_year(v_left_part, '14');
                            v_year := CASE
                                         WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_left_part)::SMALLINT - 43
                                         ELSE aws_sqlserver_ext.get_full_year(v_left_part, '', 29)::SMALLINT
                                      END;
                        END;
                    END IF;

                    IF (v_date_format IN ('MDY', 'DMY') OR v_culture IN ('LV-LV', 'LV_LV'))
                    THEN
                        v_day := v_right_part;
                        v_raw_year := aws_sqlserver_ext.get_full_year(v_left_part, '14');
                        v_year := CASE
                                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_left_part)::SMALLINT - 43
                                     ELSE aws_sqlserver_ext.get_full_year(v_left_part, '', 29)::SMALLINT
                                  END;
                        BEGIN
                            v_res_date := make_date(v_year, v_month::SMALLINT, v_day::SMALLINT);
                        EXCEPTION
                        WHEN OTHERS THEN
                            v_day := v_left_part;
                            v_raw_year := aws_sqlserver_ext.get_full_year(v_right_part, '14');
                            v_year := CASE
                                         WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_right_part)::SMALLINT - 43
                                         ELSE aws_sqlserver_ext.get_full_year(v_right_part, '', 29)::SMALLINT
                                      END;
                        END;
                    END IF;
                ELSE
                    v_day := v_right_part;
                    v_raw_year := v_left_part;
	            v_year := CASE
                                 WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_left_part::SMALLINT - 543
                                 ELSE v_left_part::SMALLINT
                              END;
                END IF;

            ELSIF (v_resmask_cnt = 17)
            THEN
                v_day := v_regmatch_groups[4];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 18)
            THEN
                v_day := v_regmatch_groups[3];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[4], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 19)
            THEN
                v_day := v_regmatch_groups[4];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[3];
            END IF;

            IF (v_resmask_cnt NOT IN (10, 11, 14, 15, 16))
            THEN
                v_year := CASE
                             WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_raw_year::SMALLINT - 543
                             ELSE v_raw_year::SMALLINT
                          END;
            END IF;

            IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
            THEN
                IF (v_day::SMALLINT > 30 OR
                    (v_resmask_cnt NOT IN (10, 11, 14, 15, 16) AND v_year NOT BETWEEN 1318 AND 1501) OR
                    (v_resmask_cnt IN (14, 15, 16) AND v_raw_year::SMALLINT NOT BETWEEN 1318 AND 1501))
                THEN
                    RAISE invalid_datetime_format;
                END IF;

                v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

                v_day := to_char(v_hijridate, 'DD');
                v_month := to_char(v_hijridate, 'MM');
                v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;
            END IF;
        END IF;

        v_resmask_cnt := v_resmask_cnt + 1;
    END LOOP;

    IF (NOT v_found) THEN
        RAISE invalid_datetime_format;
    END IF;

    IF (char_length(v_timestring) > 0 AND v_timestring NOT IN ('AM', '', 'PM', ''))
    THEN
        IF (v_culture = 'FI') THEN
            v_timestring := translate(v_timestring, '.,', ': ');

            IF (char_length(split_part(v_timestring, ':', 4)) > 0) THEN
                v_timestring := regexp_replace(v_timestring, ':(?=\s*\d+\s*:?\s*(?:[AP]M||)?\s*$)', '.');
            END IF;
        END IF;

        v_timestring := replace(regexp_replace(v_timestring, '\.?[AP]M|||\s|\,|\.\D|[\.|:]$', '', 'gi'), ':.', ':');
        BEGIN
            v_hours := coalesce(split_part(v_timestring, ':', 1)::SMALLINT, 0);

            IF ((v_dayparts[1] IN ('AM', '') AND v_hours NOT BETWEEN 0 AND 12) OR
                (v_dayparts[1] IN ('PM', '') AND v_hours NOT BETWEEN 1 AND 23))
            THEN
                RAISE invalid_datetime_format;
            ELSIF (v_dayparts[1] = 'PM' AND v_hours < 12) THEN
                v_hours := v_hours + 12;
            ELSIF (v_dayparts[1] = 'AM' AND v_hours = 12) THEN
                v_hours := v_hours - 12;
            END IF;

            v_minutes := coalesce(nullif(split_part(v_timestring, ':', 2), '')::SMALLINT, 0);
            v_seconds := coalesce(nullif(split_part(v_timestring, ':', 3), ''), '0');

            IF (v_seconds ~ '\.') THEN
                v_fseconds := split_part(v_seconds, '.', 2);
                v_seconds := split_part(v_seconds, '.', 1);
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
            RAISE invalid_datetime_format;
        END;
    ELSIF (v_dayparts[1] IN ('PM', ''))
    THEN
        v_hours := 12;
    END IF;

    BEGIN
        IF (v_res_datatype IN ('DATETIME', 'SMALLDATETIME'))
        THEN
            v_res_datetime := aws_sqlserver_ext.datetimefromparts(v_year, v_month::SMALLINT, v_day::SMALLINT,
                                                                  v_hours, v_minutes, v_seconds::SMALLINT,
                                                                  rpad(v_fseconds, 3, '0')::NUMERIC);
            IF (v_res_datatype = 'SMALLDATETIME' AND
                to_char(v_res_datetime, 'SS') <> '00')
            THEN
                IF (to_char(v_res_datetime, 'SS')::SMALLINT >= 30) THEN
                    v_res_datetime := v_res_datetime + INTERVAL '1 minute';
                END IF;

                v_res_datetime := to_timestamp(to_char(v_res_datetime, 'DD.MM.YYYY.HH24.MI'), 'DD.MM.YYYY.HH24.MI');
            END IF;
        ELSE
            v_fseconds := aws_sqlserver_ext.get_microsecs_from_fractsecs(rpad(v_fseconds, 9, '0'), v_scale);
            v_seconds := concat_ws('.', v_seconds, v_fseconds);

            v_res_datetime := make_timestamp(v_year, v_month::SMALLINT, v_day::SMALLINT,
                                             v_hours, v_minutes, v_seconds::NUMERIC);
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;

        IF (v_err_message ~* 'Cannot construct data type') THEN
            RAISE invalid_datetime_format;
        END IF;
    END;

    IF (v_weekdaynames[1] IS NOT NULL) THEN
        v_weekdaynum := aws_sqlserver_ext.get_weekdaynum_by_name(v_weekdaynames[1], v_lang_metadata_json);

        IF (CASE date_part('dow', v_res_date)::SMALLINT
               WHEN 0 THEN 7
               ELSE date_part('dow', v_res_date)::SMALLINT
            END <> v_weekdaynum)
        THEN
            RAISE invalid_datetime_format;
        END IF;
    END IF;

    RETURN v_res_datetime;
EXCEPTION
    WHEN invalid_datetime_format OR datetime_field_overflow THEN
        RAISE USING MESSAGE := format('Error converting string value ''%s'' into data type %s using culture ''%s''.',
                                      p_datetimestring, v_res_datatype, p_culture),
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';

    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := 'Data type should be one of these values: ''DATETIME'', ''SMALLDATETIME'', ''DATETIME2''/''DATETIME2(n)''.',
                    DETAIL := 'Use of incorrect "datatype" parameter value during conversion process.',
                    HINT := 'Change "datatype" parameter to the proper value and try again.';

    WHEN invalid_indicator_parameter_value THEN
        RAISE USING MESSAGE := format('Invalid attributes specified for data type %s.', v_res_datatype),
                    DETAIL := 'Use of incorrect scale value, which is not corresponding to specified data type.',
                    HINT := 'Change data type scale component or select different data type and try again.';

    WHEN interval_field_overflow THEN
        RAISE USING MESSAGE := format('Specified scale %s is invalid.', v_scale),
                    DETAIL := 'Use of incorrect data type scale value during conversion process.',
                    HINT := 'Change scale component of data type parameter to be in range [0..7] and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := CASE char_length(coalesce(CONVERSION_LANG, ''))
                                  WHEN 0 THEN format('The culture parameter ''%s'' provided in the function call is not supported.',
                                                     p_culture)
                                  ELSE format('Invalid CONVERSION_LANG constant value - ''%s''. Allowed values are: ''English'', ''Deutsch'', etc.',
                                              CONVERSION_LANG)
                               END,
                    DETAIL := 'Passed incorrect value for "p_culture" parameter or compiled incorrect CONVERSION_LANG constant value in function''s body.',
                    HINT := 'Check "p_culture" input parameter value, correct it if needed, and try again. Also check CONVERSION_LANG constant value.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="2a3cca5e-12e0-4532-a851-eb6549f1a535" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="09d5f7f7-5c28-4e42-aa59-0161132da32f" name="parse_to_time" is-trigger-function="0" unique-function-name="parse_to_time" is-aggregate="f" language-name="plpgsql" context="parse_to_time" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" comment="This function parses the TEXT string and converts it into a TIME value, according to specified culture (conversion mask)." is-returning-set="f" ret-datatype="time" function-arguments="p_datatype text, p_srctimestring text, p_culture text DEFAULT ''::text" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23966" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datatype text, p_srctimestring text, p_culture text" overload-function-count="1" proc-language="plpgsql" function-signature="parse_to_time(p_datatype text, p_srctimestring text, p_culture text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_day VARCHAR;
    v_year SMALLINT;
    v_month VARCHAR;
    v_res_date DATE;
    v_scale SMALLINT;
    v_hijridate DATE;
    v_culture VARCHAR;
    v_dayparts TEXT[];
    v_resmask VARCHAR;
    v_datatype VARCHAR;
    v_raw_year VARCHAR;
    v_left_part VARCHAR;
    v_right_part VARCHAR;
    v_resmask_fi VARCHAR;
    v_timestring VARCHAR;
    v_correctnum VARCHAR;
    v_weekdaynum SMALLINT;
    v_err_message VARCHAR;
    v_date_format VARCHAR;
    v_weekdaynames TEXT[];
    v_hours SMALLINT := 0;
    v_srctimestring VARCHAR;
    v_minutes SMALLINT := 0;
    v_res_datatype VARCHAR;
    v_error_message VARCHAR;
    v_found BOOLEAN := TRUE;
    v_compday_regexp VARCHAR;
    v_regmatch_groups TEXT[];
    v_datatype_groups TEXT[];
    v_seconds VARCHAR := '0';
    v_fseconds VARCHAR := '0';
    v_compmonth_regexp VARCHAR;
    v_lang_metadata_json JSONB;
    v_resmask_cnt SMALLINT := 10;
    v_res_time TIME WITHOUT TIME ZONE;
    DAYMM_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    FULLYEAR_REGEXP CONSTANT VARCHAR := '(\d{3,4})';
    SHORTYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,2})';
    COMPYEAR_REGEXP CONSTANT VARCHAR := '(\d{1,4})';
    AMPM_REGEXP CONSTANT VARCHAR := '(?:[AP]M||)';
    TIMEUNIT_REGEXP CONSTANT VARCHAR := '\s*\d{1,2}\s*';
    MASKSEPONE_REGEXP CONSTANT VARCHAR := '\s*(?:/|-)?';
    MASKSEPTWO_REGEXP CONSTANT VARCHAR := '\s*(?:\s|/|-|\.|,)';
    MASKSEPTWO_FI_REGEXP CONSTANT VARCHAR := '\s*(?:\s|/|-|,)';
    MASKSEPTHREE_REGEXP CONSTANT VARCHAR := '\s*(?:/|-|\.|,)';
    TIME_MASKSEP_REGEXP CONSTANT VARCHAR := '(?:\s|\.|,)*';
    TIME_MASKSEP_FI_REGEXP CONSTANT VARCHAR := '(?:\s|,)*';
    WEEKDAYAMPM_START_REGEXP CONSTANT VARCHAR := '(^|[[:digit:][:space:]\.,])';
    WEEKDAYAMPM_END_REGEXP CONSTANT VARCHAR := '([[:digit:][:space:]\.,]|$)(?=[^/-]|$)';
    CORRECTNUM_REGEXP CONSTANT VARCHAR := '(?:([+-]\d{1,4})(?:[[:space:]\.,]|[AP]M|||$))';
    DATATYPE_REGEXP CONSTANT VARCHAR := '^(TIME)\s*(?:\()?\s*((?:-)?\d+)?\s*(?:\))?$';
    ANNO_DOMINI_REGEXP VARCHAR := '(AD|A\.D\.)';
    ANNO_DOMINI_COMPREGEXP VARCHAR := concat(WEEKDAYAMPM_START_REGEXP, ANNO_DOMINI_REGEXP, WEEKDAYAMPM_END_REGEXP);
    HHMMSSFS_PART_REGEXP CONSTANT VARCHAR :=
        concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, TIMEUNIT_REGEXP, '\:', TIME_MASKSEP_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\s*\d{1,2}\.\d+(?!\d)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?');
    HHMMSSFS_PART_FI_REGEXP CONSTANT VARCHAR :=
        concat(TIMEUNIT_REGEXP, AMPM_REGEXP, '|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?\.?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '(?!\d)', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, TIMEUNIT_REGEXP, '[\:\.]', TIME_MASKSEP_FI_REGEXP,
               AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '\s*\d{1,2}\.\d+(?!\d)\.?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?|',
               AMPM_REGEXP, '?');
    v_defmask1_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(?:[\.|,]+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP, '$');
    v_defmask1_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(?:[\.|,]+', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask2_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                        AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(?:(?:[\.|,]+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?)|',
                                        CORRECTNUM_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP, '$');
    v_defmask2_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP,
                                           AMPM_REGEXP, TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(?:(?:[\.|,]+', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, TIME_MASKSEP_FI_REGEXP, CORRECTNUM_REGEXP, '?)|',
                                           CORRECTNUM_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask3_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, ')|',
                                        '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(', TIME_MASKSEP_REGEXP, AMPM_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask3_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '[\./]?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)',
                                           FULLYEAR_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask4_0_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask4_1_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          '(?:\s|,)+',
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask4_2_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP,
                                          '\s*[\.]+', TIME_MASKSEP_REGEXP,
                                          DAYMM_REGEXP, '\s*(', AMPM_REGEXP, ')',
                                          TIME_MASKSEP_REGEXP, '$');
    v_defmask5_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask5_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask6_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask6_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:\s*[\.])?',
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask7_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        FULLYEAR_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask7_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           FULLYEAR_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask8_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                        '(?:[\.|,]+', AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                        DAYMM_REGEXP,
                                        '(?:[\.|,]+', AMPM_REGEXP, ')?',
                                        TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask8_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_FI_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)|',
                                           '(?:[,]+', AMPM_REGEXP, '))', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '(?:(?:[\,]+|\s*/\s*)', AMPM_REGEXP, ')?',
                                           TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask9_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(',
                                        HHMMSSFS_PART_REGEXP,
                                        ')', TIME_MASKSEP_REGEXP, '$');
    v_defmask9_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '(',
                                           HHMMSSFS_PART_FI_REGEXP,
                                           ')', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask10_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask10_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)?', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask11_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask11_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                           '($comp_month$)',
                                           '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP,
                                           DAYMM_REGEXP,
                                           '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask12_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask12_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask13_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$');
    v_defmask13_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            FULLYEAR_REGEXP,
                                            TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask14_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)'
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask14_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)'
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_FI_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_FI_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask15_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask15_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask16_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                         COMPYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask16_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)', TIME_MASKSEP_REGEXP,
                                            COMPYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask17_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask17_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask18_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                         '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                         '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP, '$');
    v_defmask18_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                            '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, '(?:', AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))?)|',
                                            '(?:(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '(?=(?:[[:space:]\.,])+))))', TIME_MASKSEP_REGEXP,
                                            '($comp_month$)',
                                            TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP, '$');
    v_defmask19_regexp VARCHAR := concat('^', TIME_MASKSEP_REGEXP, '(', HHMMSSFS_PART_REGEXP, ')?', TIME_MASKSEP_REGEXP,
                                         '($comp_month$)',
                                         '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                         FULLYEAR_REGEXP,
                                         '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                         '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                         DAYMM_REGEXP,
                                         '((?:(?:\s|\.|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_REGEXP, '))?', TIME_MASKSEP_REGEXP, '$');
    v_defmask19_fi_regexp VARCHAR := concat('^', TIME_MASKSEP_FI_REGEXP, '(', HHMMSSFS_PART_FI_REGEXP, ')?', TIME_MASKSEP_FI_REGEXP,
                                            '($comp_month$)',
                                            '(?:', MASKSEPTHREE_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)?', TIME_MASKSEP_REGEXP,
                                            FULLYEAR_REGEXP,
                                            '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                            '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP,
                                            DAYMM_REGEXP,
                                            '((?:(?:\s|,)+|', AMPM_REGEXP, ')(?:', HHMMSSFS_PART_FI_REGEXP, '))?', TIME_MASKSEP_FI_REGEXP, '$');
    CONVERSION_LANG CONSTANT VARCHAR := '';
    DATE_FORMAT CONSTANT VARCHAR := '';
BEGIN
    v_datatype := trim(p_datatype);
    v_srctimestring := upper(trim(p_srctimestring));
    v_culture := coalesce(nullif(upper(trim(p_culture)), ''), 'EN-US');

    v_datatype_groups := regexp_matches(v_datatype, DATATYPE_REGEXP, 'gi');

    v_res_datatype := upper(v_datatype_groups[1]);
    v_scale := v_datatype_groups[2]::SMALLINT;

    IF (v_res_datatype IS NULL) THEN
        RAISE datatype_mismatch;
    ELSIF (coalesce(v_scale, 0) NOT BETWEEN 0 AND 7)
    THEN
        RAISE interval_field_overflow;
    ELSIF (v_scale IS NULL) THEN
        v_scale := 7;
    END IF;

    v_dayparts := ARRAY(SELECT upper(array_to_string(regexp_matches(v_srctimestring, '[AP]M||', 'gi'), '')));

    IF (array_length(v_dayparts, 1) > 1) THEN
        RAISE invalid_datetime_format;
    END IF;

    BEGIN
        v_lang_metadata_json := aws_sqlserver_ext.get_lang_metadata_json(coalesce(nullif(CONVERSION_LANG, ''), p_culture));
    EXCEPTION
        WHEN OTHERS THEN
        RAISE invalid_parameter_value;
    END;

    v_compday_regexp := array_to_string(array_cat(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_names')),
                                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_shortnames'))),
                                                  ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'days_extrashortnames'))), '|');

    v_weekdaynames := ARRAY(SELECT array_to_string(regexp_matches(v_srctimestring, v_compday_regexp, 'gi'), ''));

    IF (array_length(v_weekdaynames, 1) > 1) THEN
        RAISE invalid_datetime_format;
    END IF;

    IF (v_weekdaynames[1] IS NOT NULL AND
        v_srctimestring ~* concat(WEEKDAYAMPM_START_REGEXP, '(', v_compday_regexp, ')', WEEKDAYAMPM_END_REGEXP))
    THEN
        v_srctimestring := replace(v_srctimestring, v_weekdaynames[1], ' ');
    END IF;

    IF (v_srctimestring ~* ANNO_DOMINI_COMPREGEXP)
    THEN
        IF (v_culture !~ 'EN[-_]US|DA[-_]DK|SV[-_]SE|EN[-_]GB|HI[-_]IS') THEN
            RAISE invalid_datetime_format;
        END IF;

        v_srctimestring := regexp_replace(v_srctimestring,
                                          ANNO_DOMINI_COMPREGEXP,
                                          regexp_replace(array_to_string(regexp_matches(v_srctimestring, ANNO_DOMINI_COMPREGEXP, 'gi'), ''),
                                                         ANNO_DOMINI_REGEXP, ' ', 'gi'),
                                          'gi');
    END IF;

    v_date_format := coalesce(nullif(upper(trim(DATE_FORMAT)), ''), v_lang_metadata_json ->> 'date_format');

    v_compmonth_regexp :=
        array_to_string(array_cat(array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_shortnames')),
                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_names'))),
                                  array_cat(ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_extrashortnames')),
                                            ARRAY(SELECT jsonb_array_elements_text(v_lang_metadata_json -> 'months_extranames')))
                                 ), '|');

    IF ((v_srctimestring ~* v_defmask1_regexp AND v_culture <> 'FI') OR
        (v_srctimestring ~* v_defmask1_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_srctimestring ~ concat(CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                     CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP,
                                     AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                     '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                     CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
            v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_srctimestring, CASE v_culture
                                                                WHEN 'FI' THEN v_defmask1_fi_regexp
                                                                ELSE v_defmask1_regexp
                                                             END, 'gi');
        v_timestring := v_regmatch_groups[2];
        v_correctnum := coalesce(v_regmatch_groups[1], v_regmatch_groups[3],
                                 v_regmatch_groups[5], v_regmatch_groups[6]);

        IF (v_date_format = 'DMY' OR
            v_culture IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[4];
            v_month := v_regmatch_groups[7];
        ELSE
            v_day := v_regmatch_groups[7];
            v_month := v_regmatch_groups[4];
        END IF;

        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
        THEN
            IF (v_day::SMALLINT > 30 OR
                v_month::SMALLINT > 12) THEN
                RAISE invalid_datetime_format;
            END IF;

            v_raw_year := to_char(aws_sqlserver_ext.conv_greg_to_hijri(current_date + 1), 'YYYY');
            v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

            v_day := to_char(v_hijridate, 'DD');
            v_month := to_char(v_hijridate, 'MM');
            v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;
        ELSE
            v_year := to_char(current_date, 'YYYY')::SMALLINT;
        END IF;

    ELSIF ((v_srctimestring ~* v_defmask6_regexp AND v_culture <> 'FI') OR
           (v_srctimestring ~* v_defmask6_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_srctimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}',
                                      '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                      '(?:', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '))', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                      '\d{3,4}', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                      TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                      '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_srctimestring, CASE v_culture
                                                                WHEN 'FI' THEN v_defmask6_fi_regexp
                                                                ELSE v_defmask6_regexp
                                                             END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_day := v_regmatch_groups[4];
        v_month := v_regmatch_groups[3];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[2]::SMALLINT - 543
                     ELSE v_regmatch_groups[2]::SMALLINT
                  END;

    ELSIF ((v_srctimestring ~* v_defmask2_regexp AND v_culture <> 'FI') OR
           (v_srctimestring ~* v_defmask2_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_srctimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}',
                                      '(?:(?:', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?)|',
                                      '(?:', TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?', TIME_MASKSEP_REGEXP,
                                      AMPM_REGEXP, TIME_MASKSEP_REGEXP, CORRECTNUM_REGEXP, '?))', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                      '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_srctimestring, CASE v_culture
                                                                WHEN 'FI' THEN v_defmask2_fi_regexp
                                                                ELSE v_defmask2_regexp
                                                             END, 'gi');
        v_timestring := v_regmatch_groups[2];
        v_correctnum := coalesce(v_regmatch_groups[1], v_regmatch_groups[3], v_regmatch_groups[5],
                                 v_regmatch_groups[6], v_regmatch_groups[8], v_regmatch_groups[9]);
        v_day := '01';
        v_month := v_regmatch_groups[7];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[4]::SMALLINT - 543
                     ELSE v_regmatch_groups[4]::SMALLINT
                  END;

    ELSIF (v_srctimestring ~* v_defmask4_1_regexp OR
           (v_srctimestring ~* v_defmask4_2_regexp AND v_culture !~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV') OR
           (v_srctimestring ~* v_defmask9_regexp AND v_culture <> 'FI') OR
           (v_srctimestring ~* v_defmask9_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_srctimestring ~ concat('\d+\s*\.?(?:,+|,*', AMPM_REGEXP, ')', TIME_MASKSEP_FI_REGEXP, '\.+', TIME_MASKSEP_REGEXP, '$|',
                                     '\d+\s*\.', TIME_MASKSEP_FI_REGEXP, '\.', TIME_MASKSEP_FI_REGEXP, '$') AND
            v_culture = 'FI')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        IF (v_srctimestring ~* v_defmask4_0_regexp) THEN
            v_timestring := (regexp_matches(v_srctimestring, v_defmask4_0_regexp, 'gi'))[1];
        ELSE
            v_timestring := v_srctimestring;
        END IF;

        v_res_date := current_date;
        v_day := to_char(v_res_date, 'DD');
        v_month := to_char(v_res_date, 'MM');
        v_year := to_char(v_res_date, 'YYYY')::SMALLINT;

    ELSIF ((v_srctimestring ~* v_defmask3_regexp AND v_culture <> 'FI') OR
           (v_srctimestring ~* v_defmask3_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_srctimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?',
                                      TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP, '|',
                                      '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_srctimestring, CASE v_culture
                                                                WHEN 'FI' THEN v_defmask3_fi_regexp
                                                                ELSE v_defmask3_regexp
                                                             END, 'gi');
        v_timestring := v_regmatch_groups[1];
        v_day := '01';
        v_month := v_regmatch_groups[2];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[3]::SMALLINT - 543
                     ELSE v_regmatch_groups[3]::SMALLINT
                  END;

    ELSIF ((v_srctimestring ~* v_defmask5_regexp AND v_culture <> 'FI') OR
           (v_srctimestring ~* v_defmask5_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_srctimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                      TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                      TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$|',
                                      '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}\s*(?:\.)+|',
                                      '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_srctimestring, v_defmask5_regexp, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[4]::SMALLINT - 543
                     ELSE v_regmatch_groups[4]::SMALLINT
                  END;

        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[2];
            v_month := v_regmatch_groups[3];
        ELSE
            v_day := v_regmatch_groups[3];
            v_month := v_regmatch_groups[2];
        END IF;

    ELSIF ((v_srctimestring ~* v_defmask7_regexp AND v_culture <> 'FI') OR
           (v_srctimestring ~* v_defmask7_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA') OR
            (v_srctimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}',
                                      MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{3,4}|',
                                      '\d{3,4}', MASKSEPTWO_REGEXP, '?', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                      '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
             v_culture ~ 'DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV'))
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_srctimestring, CASE v_culture
                                                                WHEN 'FI' THEN v_defmask7_fi_regexp
                                                                ELSE v_defmask7_regexp
                                                             END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);
        v_day := v_regmatch_groups[4];
        v_month := v_regmatch_groups[2];
        v_year := CASE
                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_regmatch_groups[3]::SMALLINT - 543
                     ELSE v_regmatch_groups[3]::SMALLINT
                  END;

    ELSIF ((v_srctimestring ~* v_defmask8_regexp AND v_culture <> 'FI') OR
           (v_srctimestring ~* v_defmask8_fi_regexp AND v_culture = 'FI'))
    THEN
        IF (v_srctimestring ~ concat('\s*\d{1,2}\.\s*(?:\.|\d+(?!\d)\s*\.)', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}',
                                     MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                     TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}|',
                                     '\d{1,2}', MASKSEPTWO_REGEXP, TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}', MASKSEPTWO_REGEXP,
                                     TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '\d{1,2}\s*(?:\.)+|',
                                     '\d+\s*(?:\.)+', TIME_MASKSEP_REGEXP, AMPM_REGEXP, '?', TIME_MASKSEP_REGEXP, '$') AND
            v_culture ~ 'FI|DE[-_]DE|NN[-_]NO|CS[-_]CZ|PL[-_]PL|RO[-_]RO|SK[-_]SK|SL[-_]SI|BG[-_]BG|RU[-_]RU|TR[-_]TR|ET[-_]EE|LV[-_]LV')
        THEN
            RAISE invalid_datetime_format;
        END IF;

        v_regmatch_groups := regexp_matches(v_srctimestring, CASE v_culture
                                                                WHEN 'FI' THEN v_defmask8_fi_regexp
                                                                ELSE v_defmask8_regexp
                                                             END, 'gi');
        v_timestring := concat(v_regmatch_groups[1], v_regmatch_groups[5]);

        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN
            v_day := v_regmatch_groups[2];
            v_month := v_regmatch_groups[3];
            v_raw_year := v_regmatch_groups[4];
        ELSIF (v_date_format = 'YMD')
        THEN
            v_day := v_regmatch_groups[4];
            v_month := v_regmatch_groups[3];
            v_raw_year := v_regmatch_groups[2];
        ELSE
            v_day := v_regmatch_groups[3];
            v_month := v_regmatch_groups[2];
            v_raw_year := v_regmatch_groups[4];
        END IF;

        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
        THEN
            IF (v_day::SMALLINT > 30 OR
                v_month::SMALLINT > 12) THEN
                RAISE invalid_datetime_format;
            END IF;

            v_raw_year := aws_sqlserver_ext.get_full_year(v_raw_year, '14');
            v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

            v_day := to_char(v_hijridate, 'DD');
            v_month := to_char(v_hijridate, 'MM');
            v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;

        ELSIF (v_culture IN ('TH-TH', 'TH_TH')) THEN
            v_year := aws_sqlserver_ext.get_full_year(v_raw_year)::SMALLINT - 43;
        ELSE
            v_year := aws_sqlserver_ext.get_full_year(v_raw_year, '', 29)::SMALLINT;
        END IF;
    ELSE
        v_found := FALSE;
    END IF;

    WHILE (NOT v_found AND v_resmask_cnt < 20)
    LOOP
        v_resmask := replace(CASE v_resmask_cnt
                                WHEN 10 THEN v_defmask10_regexp
                                WHEN 11 THEN v_defmask11_regexp
                                WHEN 12 THEN v_defmask12_regexp
                                WHEN 13 THEN v_defmask13_regexp
                                WHEN 14 THEN v_defmask14_regexp
                                WHEN 15 THEN v_defmask15_regexp
                                WHEN 16 THEN v_defmask16_regexp
                                WHEN 17 THEN v_defmask17_regexp
                                WHEN 18 THEN v_defmask18_regexp
                                WHEN 19 THEN v_defmask19_regexp
                             END,
                             '$comp_month$', v_compmonth_regexp);

        v_resmask_fi := replace(CASE v_resmask_cnt
                                   WHEN 10 THEN v_defmask10_fi_regexp
                                   WHEN 11 THEN v_defmask11_fi_regexp
                                   WHEN 12 THEN v_defmask12_fi_regexp
                                   WHEN 13 THEN v_defmask13_fi_regexp
                                   WHEN 14 THEN v_defmask14_fi_regexp
                                   WHEN 15 THEN v_defmask15_fi_regexp
                                   WHEN 16 THEN v_defmask16_fi_regexp
                                   WHEN 17 THEN v_defmask17_fi_regexp
                                   WHEN 18 THEN v_defmask18_fi_regexp
                                   WHEN 19 THEN v_defmask19_fi_regexp
                                END,
                                '$comp_month$', v_compmonth_regexp);

        IF ((v_srctimestring ~* v_resmask AND v_culture <> 'FI') OR
            (v_srctimestring ~* v_resmask_fi AND v_culture = 'FI'))
        THEN
            v_found := TRUE;
            v_regmatch_groups := regexp_matches(v_srctimestring, CASE v_culture
                                                                    WHEN 'FI' THEN v_resmask_fi
                                                                    ELSE v_resmask
                                                                 END, 'gi');
            v_timestring := CASE
                               WHEN v_resmask_cnt IN (10, 11, 12, 13) THEN concat(v_regmatch_groups[1], v_regmatch_groups[4])
                               ELSE concat(v_regmatch_groups[1], v_regmatch_groups[5])
                            END;

            IF (v_resmask_cnt = 10)
            THEN
                IF (v_regmatch_groups[3] = 'MAR' AND
                    v_culture IN ('IT-IT', 'IT_IT'))
                THEN
                    RAISE invalid_datetime_format;
                END IF;

                IF (v_date_format = 'YMD' AND v_culture NOT IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
                THEN
                    v_day := '01';
                    v_year := aws_sqlserver_ext.get_full_year(v_regmatch_groups[2], '', 29)::SMALLINT;
                ELSE
                    v_day := v_regmatch_groups[2];
                    v_year := to_char(current_date, 'YYYY')::SMALLINT;
                END IF;

                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := to_char(aws_sqlserver_ext.conv_greg_to_hijri(current_date + 1), 'YYYY');

            ELSIF (v_resmask_cnt = 11)
            THEN
                IF (v_date_format IN ('YMD', 'MDY') AND v_culture NOT IN ('SV-SE', 'SV_SE'))
                THEN
                    v_day := v_regmatch_groups[3];
                    v_year := to_char(current_date, 'YYYY')::SMALLINT;
                ELSE
                    v_day := '01';
                    v_year := CASE
                                 WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_regmatch_groups[3])::SMALLINT - 43
                                 ELSE aws_sqlserver_ext.get_full_year(v_regmatch_groups[3], '', 29)::SMALLINT
                              END;
                END IF;

                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := aws_sqlserver_ext.get_full_year(substring(v_year::TEXT, 3, 2), '14');

            ELSIF (v_resmask_cnt = 12)
            THEN
                v_day := '01';
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 13)
            THEN
                v_day := '01';
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[3];

            ELSIF (v_resmask_cnt IN (14, 15, 16))
            THEN
                IF (v_resmask_cnt = 14)
                THEN
                    v_left_part := v_regmatch_groups[4];
                    v_right_part := v_regmatch_groups[3];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                ELSIF (v_resmask_cnt = 15)
                THEN
                    v_left_part := v_regmatch_groups[4];
                    v_right_part := v_regmatch_groups[2];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                ELSE
                    v_left_part := v_regmatch_groups[3];
                    v_right_part := v_regmatch_groups[2];
                    v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[4], v_lang_metadata_json);
                END IF;

                IF (char_length(v_left_part) <= 2)
                THEN
                    IF (v_date_format = 'YMD' AND v_culture NOT IN ('LV-LV', 'LV_LV'))
                    THEN
                        v_day := v_left_part;
                        v_raw_year := aws_sqlserver_ext.get_full_year(v_right_part, '14');
                        v_year := CASE
                                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_right_part)::SMALLINT - 43
                                     ELSE aws_sqlserver_ext.get_full_year(v_right_part, '', 29)::SMALLINT
                                  END;
                        BEGIN
                            v_res_date := make_date(v_year, v_month::SMALLINT, v_day::SMALLINT);
                        EXCEPTION
                        WHEN OTHERS THEN
                            v_day := v_right_part;
                            v_raw_year := aws_sqlserver_ext.get_full_year(v_left_part, '14');
                            v_year := CASE
                                         WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_left_part)::SMALLINT - 43
                                         ELSE aws_sqlserver_ext.get_full_year(v_left_part, '', 29)::SMALLINT
                                      END;
                        END;
                    END IF;

                    IF (v_date_format IN ('MDY', 'DMY') OR v_culture IN ('LV-LV', 'LV_LV'))
                    THEN
                        v_day := v_right_part;
                        v_raw_year := aws_sqlserver_ext.get_full_year(v_left_part, '14');
                        v_year := CASE
                                     WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_left_part)::SMALLINT - 43
                                     ELSE aws_sqlserver_ext.get_full_year(v_left_part, '', 29)::SMALLINT
                                  END;
                        BEGIN
                            v_res_date := make_date(v_year, v_month::SMALLINT, v_day::SMALLINT);
                        EXCEPTION
                        WHEN OTHERS THEN
                            v_day := v_left_part;
                            v_raw_year := aws_sqlserver_ext.get_full_year(v_right_part, '14');
                            v_year := CASE
                                         WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_right_part)::SMALLINT - 43
                                         ELSE aws_sqlserver_ext.get_full_year(v_right_part, '', 29)::SMALLINT
                                      END;
                        END;
                    END IF;
                ELSE
                    v_day := v_right_part;
                    v_raw_year := v_left_part;
	            v_year := CASE
                                 WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_left_part::SMALLINT - 543
                                 ELSE v_left_part::SMALLINT
                              END;
                END IF;

            ELSIF (v_resmask_cnt = 17)
            THEN
                v_day := v_regmatch_groups[4];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[3], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 18)
            THEN
                v_day := v_regmatch_groups[3];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[4], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[2];

            ELSIF (v_resmask_cnt = 19)
            THEN
                v_day := v_regmatch_groups[4];
                v_month := aws_sqlserver_ext.get_monthnum_by_name(v_regmatch_groups[2], v_lang_metadata_json);
                v_raw_year := v_regmatch_groups[3];
            END IF;

            IF (v_resmask_cnt NOT IN (10, 11, 14, 15, 16))
            THEN
                v_year := CASE
                             WHEN v_culture IN ('TH-TH', 'TH_TH') THEN v_raw_year::SMALLINT - 543
                             ELSE v_raw_year::SMALLINT
                          END;
            END IF;

            IF (v_culture IN ('AR', 'AR-SA', 'AR_SA'))
            THEN
                IF (v_day::SMALLINT > 30 OR
                    (v_resmask_cnt NOT IN (10, 11, 14, 15, 16) AND v_year NOT BETWEEN 1318 AND 1501) OR
                    (v_resmask_cnt IN (14, 15, 16) AND v_raw_year::SMALLINT NOT BETWEEN 1318 AND 1501))
                THEN
                    RAISE invalid_datetime_format;
                END IF;

                v_hijridate := aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year) - 1;

                v_day := to_char(v_hijridate, 'DD');
                v_month := to_char(v_hijridate, 'MM');
                v_year := to_char(v_hijridate, 'YYYY')::SMALLINT;
            END IF;
        END IF;

        v_resmask_cnt := v_resmask_cnt + 1;
    END LOOP;

    IF (NOT v_found) THEN
        RAISE invalid_datetime_format;
    END IF;

    v_res_date := make_date(v_year, v_month::SMALLINT, v_day::SMALLINT);

    IF (v_weekdaynames[1] IS NOT NULL) THEN
        v_weekdaynum := aws_sqlserver_ext.get_weekdaynum_by_name(v_weekdaynames[1], v_lang_metadata_json);

        IF (date_part('dow', v_res_date)::SMALLINT <> v_weekdaynum) THEN
            RAISE invalid_datetime_format;
        END IF;
    END IF;

    IF (char_length(v_timestring) > 0 AND v_timestring NOT IN ('AM', '', 'PM', ''))
    THEN
        IF (v_culture = 'FI') THEN
            v_timestring := translate(v_timestring, '.,', ': ');

            IF (char_length(split_part(v_timestring, ':', 4)) > 0) THEN
                v_timestring := regexp_replace(v_timestring, ':(?=\s*\d+\s*:?\s*(?:[AP]M||)?\s*$)', '.');
            END IF;
        END IF;

        v_timestring := replace(regexp_replace(v_timestring, '\.?[AP]M|||\s|\,|\.\D|[\.|:]$', '', 'gi'), ':.', ':');

        BEGIN
            v_hours := coalesce(split_part(v_timestring, ':', 1)::SMALLINT, 0);

            IF ((v_dayparts[1] IN ('AM', '') AND v_hours NOT BETWEEN 0 AND 12) OR
                (v_dayparts[1] IN ('PM', '') AND v_hours NOT BETWEEN 1 AND 23))
            THEN
                RAISE invalid_datetime_format;
            ELSIF (v_dayparts[1] = 'PM' AND v_hours < 12) THEN
                v_hours := v_hours + 12;
            ELSIF (v_dayparts[1] = 'AM' AND v_hours = 12) THEN
                v_hours := v_hours - 12;
            END IF;

            v_minutes := coalesce(nullif(split_part(v_timestring, ':', 2), '')::SMALLINT, 0);
            v_seconds := coalesce(nullif(split_part(v_timestring, ':', 3), ''), '0');

            IF (v_seconds ~ '\.') THEN
                v_fseconds := split_part(v_seconds, '.', 2);
                v_seconds := split_part(v_seconds, '.', 1);
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
            RAISE invalid_datetime_format;
        END;
    ELSIF (v_dayparts[1] IN ('PM', ''))
    THEN
        v_hours := 12;
    END IF;

    v_fseconds := aws_sqlserver_ext.get_microsecs_from_fractsecs(rpad(v_fseconds, 9, '0'), v_scale);
    v_seconds := concat_ws('.', v_seconds, v_fseconds);

    v_res_time := make_time(v_hours, v_minutes, v_seconds::NUMERIC);

    RETURN v_res_time;
EXCEPTION
    WHEN invalid_datetime_format OR datetime_field_overflow THEN
        RAISE USING MESSAGE := format('Error converting string value ''%s'' into data type %s using culture ''%s''.',
                                      p_srctimestring, v_res_datatype, p_culture),
                    DETAIL := 'Incorrect using of pair of input parameters values during conversion process.',
                    HINT := 'Check the input parameters values, correct them if needed, and try again.';

    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := 'Source data type should be ''TIME'' or ''TIME(n)''.',
                    DETAIL := 'Use of incorrect "datatype" parameter value during conversion process.',
                    HINT := 'Change "datatype" parameter to the proper value and try again.';

    WHEN invalid_indicator_parameter_value THEN
        RAISE USING MESSAGE := format('Invalid attributes specified for data type %s.', v_res_datatype),
                    DETAIL := 'Use of incorrect scale value, which is not corresponding to specified data type.',
                    HINT := 'Change data type scale component or select different data type and try again.';

    WHEN interval_field_overflow THEN
        RAISE USING MESSAGE := format('Specified scale %s is invalid.', v_scale),
                    DETAIL := 'Use of incorrect data type scale value during conversion process.',
                    HINT := 'Change scale component of data type parameter to be in range [0..7] and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := CASE char_length(coalesce(CONVERSION_LANG, ''))
                                  WHEN 0 THEN format('The culture parameter ''%s'' provided in the function call is not supported.',
                                                     p_culture)
                                  ELSE format('Invalid CONVERSION_LANG constant value - ''%s''. Allowed values are: ''English'', ''Deutsch'', etc.',
                                              CONVERSION_LANG)
                               END,
                    DETAIL := 'Passed incorrect value for "p_culture" parameter or compiled incorrect CONVERSION_LANG constant value in function''s body.',
                    HINT := 'Check "p_culture" input parameter value, correct it if needed, and try again. Also check CONVERSION_LANG constant value.';

    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'integer\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to SMALLINT data type.',
                                      v_err_message),
                    DETAIL := 'Supplied value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters.';
END;
]]></complex-attribute>
                        <category _I_D="9048a795-122a-4602-9a1e-0dd1b77d12bc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="262e4655-e3be-4ad2-bd8a-ce7c5ceb8bcc" name="parsename" is-trigger-function="0" unique-function-name="parsename" is-aggregate="f" language-name="sql" context="parsename" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,integer" is-returning-set="f" ret-datatype="varchar" function-arguments="object_name character varying, object_piece integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="23980" volatility="IMMUTABLE" is-window="f" function-identity-arguments="object_name character varying, object_piece integer" overload-function-count="1" proc-language="sql" function-signature="parsename(object_name character varying, object_piece integer)">
                        <complex-attribute name="sql"><![CDATA[
/***************************************************************
EXTENSION PACK function PARSENAME(x)
***************************************************************/
SELECT CASE 
		WHEN char_length($1) < char_length(replace($1, '.', '')) + 4
			AND $2 BETWEEN 1
				AND 4
			THEN reverse(split_part(reverse($1), '.', $2))
		ELSE NULL
		END ]]></complex-attribute>
                        <category _I_D="024213b0-c8df-4950-b7b7-4d0410e5cfa2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d792b104-b8d3-493d-bb3d-35d3dc3795a0" name="patindex" is-trigger-function="0" unique-function-name="patindex" is-aggregate="f" language-name="plpgsql" context="patindex" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying" is-returning-set="f" ret-datatype="int8" function-arguments="pattern character varying, expression character varying" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="23981" volatility="VOLATILE" is-window="f" function-identity-arguments="pattern character varying, expression character varying" overload-function-count="1" proc-language="plpgsql" function-signature="patindex(pattern character varying, expression character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  v_find_result character varying;
  v_pos bigint;
  v_regexp_pattern character varying;
begin  
  v_pos := null;
  if left(pattern, 1) = '%' then
    v_regexp_pattern := regexp_replace(pattern, '^%', '%#"');
  else 
    v_regexp_pattern := '#"' || pattern;
  end if;
  
  if right(pattern, 1) = '%' then
    v_regexp_pattern := regexp_replace(v_regexp_pattern, '%$', '#"%');
  else  
   v_regexp_pattern := v_regexp_pattern || '#"';
 end if;  
  v_find_result := substring(expression from v_regexp_pattern for '#');
  if v_find_result <> '' then
    v_pos := strpos(expression, v_find_result);
  end if;  
  return v_pos;
end;
]]></complex-attribute>
                        <category _I_D="6ac430b0-f434-4cba-87c1-dfa1c1545f70" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="80ef1786-5dab-4d5b-a6fb-f205e5bdf8c0" name="rand" is-trigger-function="0" unique-function-name="rand" is-aggregate="f" language-name="plpgsql" context="rand" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer" is-returning-set="f" ret-datatype="float8" function-arguments="x integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23982" volatility="VOLATILE" is-window="f" function-identity-arguments="x integer" overload-function-count="1" proc-language="plpgsql" function-signature="rand(x integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
/***************************************************************
EXTENSION PACK function RAND(x)
***************************************************************/
	perform setseed(x::double precision/2147483649);
	return random();
END;
]]></complex-attribute>
                        <category _I_D="e26b35a2-34e3-4e21-90ee-bc3ce67cab4a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="59548f42-2eb0-4571-8b62-c26a7884634c" name="round3" is-trigger-function="0" unique-function-name="round3" is-aggregate="f" language-name="plpgsql" context="round3" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,integer,integer" is-returning-set="f" ret-datatype="numeric" function-arguments="x numeric, y integer, z integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23983" volatility="VOLATILE" is-window="f" function-identity-arguments="x numeric, y integer, z integer" overload-function-count="1" proc-language="plpgsql" function-signature="round3(x numeric, y integer, z integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
/***************************************************************
EXTENSION PACK function ROUND3(arg1, arg2, arg3)
***************************************************************/
	if z = 0 or z is null then
		return round(x,y);
	else
		return trunc(x,y);
	end if;
END;
]]></complex-attribute>
                        <category _I_D="e2fb0a1f-25e4-4801-9c62-5304b94dc4fe" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3f64875c-a6f0-4ce1-a473-bc4cdc9ecfa6" name="round_fractseconds" is-trigger-function="0" unique-function-name="round_fractseconds(p_fractseconds numeric)" is-aggregate="f" language-name="plpgsql" context="round_fractseconds(p_fractseconds numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" comment="This function rounds milliseconds or microseconds in accordance with MS SQL Server conversion policy of datetime fractional second precision part." unique-suffix="(p_fractseconds numeric)" routine-number="23922" is-returning-set="f" ret-datatype="int4" function-arguments="p_fractseconds numeric" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23922" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_fractseconds numeric" overload-function-count="2" proc-language="plpgsql" function-signature="round_fractseconds(p_fractseconds numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
   v_modpart INTEGER;
   v_decpart INTEGER;
   v_fractseconds INTEGER;
BEGIN
    v_fractseconds := floor(p_fractseconds)::INTEGER;
    v_modpart := v_fractseconds % 10;
    v_decpart := v_fractseconds - v_modpart;  

    RETURN CASE
              WHEN (v_modpart BETWEEN 0 AND 1) THEN v_decpart
              WHEN (v_modpart BETWEEN 2 AND 4) THEN v_decpart + 3
              WHEN (v_modpart BETWEEN 5 AND 8) THEN v_decpart + 7
              ELSE v_decpart + 10 -- 9
           END;
END;
]]></complex-attribute>
                        <category _I_D="aa48ecaa-cc5a-44f8-81b7-21137133c032" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="73c0b018-807f-497a-b972-15b5e5ab7b50" name="round_fractseconds" is-trigger-function="0" unique-function-name="round_fractseconds(p_fractseconds text)" is-aggregate="f" language-name="plpgsql" context="round_fractseconds(p_fractseconds text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="This function rounds milliseconds or microseconds in accordance with MS SQL Server conversion policy of datetime fractional second precision part." unique-suffix="(p_fractseconds text)" routine-number="23923" is-returning-set="f" ret-datatype="int4" function-arguments="p_fractseconds text" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="23923" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_fractseconds text" overload-function-count="2" proc-language="plpgsql" function-signature="round_fractseconds(p_fractseconds text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.round_fractseconds(p_fractseconds::NUMERIC);
EXCEPTION
    WHEN invalid_text_representation THEN
        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to NUMERIC data type.', trim(p_fractseconds)),
                    DETAIL := 'Passed argument value contains illegal characters.',
                    HINT := 'Correct passed argument value, remove all illegal characters.';


END;
]]></complex-attribute>
                        <category _I_D="9c56a355-e8bd-45a6-946a-5e0ffdd6ac83" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="fbb55d96-ba21-4278-b549-068504bc2600" name="set_service_setting" is-trigger-function="0" unique-function-name="set_service_setting" is-aggregate="f" language-name="plpgsql" context="set_service_setting" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying" is-returning-set="f" ret-datatype="void" function-arguments="p_service character varying, p_setting character varying, p_value character varying" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="24050" volatility="VOLATILE" is-window="f" function-identity-arguments="p_service character varying, p_setting character varying, p_value character varying" overload-function-count="1" proc-language="plpgsql" function-signature="set_service_setting(p_service character varying, p_setting character varying, p_value character varying)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  DELETE FROM aws_sqlserver_ext_data.service_settings
   WHERE service = p_service
     AND setting = p_setting;

  INSERT INTO aws_sqlserver_ext_data.service_settings(service, setting, value)
  VALUES (p_service, p_setting, p_value);

  DELETE FROM aws_sqlserver_ext.sysmail_server;
 
  IF p_service = 'MAIL' THEN 
    PERFORM aws_sqlserver_ext.sysmail_set_arn_sp(p_value);
  END IF;
END;
]]></complex-attribute>
                        <category _I_D="eeadc79c-f8eb-4a02-b9fc-76864451c082" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d1178b94-a479-4663-93b1-2974f3190b23" name="set_version" is-trigger-function="0" unique-function-name="set_version" is-aggregate="f" language-name="plpgsql" context="set_version" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying" is-returning-set="f" ret-datatype="void" function-arguments="pcomponentversion character varying, pcomponentname character varying" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="23984" volatility="VOLATILE" is-window="f" function-identity-arguments="pcomponentversion character varying, pcomponentname character varying" overload-function-count="1" proc-language="plpgsql" function-signature="set_version(pcomponentversion character varying, pcomponentname character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  rowcount smallint;
BEGIN
	UPDATE aws_sqlserver_ext.versions 
	   SET componentversion = pComponentVersion
	 WHERE extpackcomponentname = pComponentName;	 
	GET DIAGNOSTICS rowcount = ROW_COUNT;
	
	IF rowcount < 1 THEN
	 INSERT INTO aws_sqlserver_ext.versions(extpackcomponentname,componentversion) 
	      VALUES (pComponentName,pComponentVersion);
	END IF;
END;
]]></complex-attribute>
                        <category _I_D="7f515e68-befe-4b02-a275-516d3746633b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="45a3964e-99d3-4705-aa85-75737d124168" name="sp_add_job" is-trigger-function="0" unique-function-name="sp_add_job" is-aggregate="f" language-name="plpgsql" context="sp_add_job" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,smallint,character varying,integer,character varying,integer,character varying,integer,integer,integer,integer,character varying,character varying,character varying,integer,integer,character varying,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_job_name character varying, par_enabled smallint DEFAULT 1, par_description character varying DEFAULT NULL::character varying, par_start_step_id integer DEFAULT 1, par_category_name character varying DEFAULT NULL::character varying, par_category_id integer DEFAULT NULL::integer, par_owner_login_name character varying DEFAULT NULL::character varying, par_notify_level_eventlog integer DEFAULT 2, par_notify_level_email integer DEFAULT 0, par_notify_level_netsend integer DEFAULT 0, par_notify_level_page integer DEFAULT 0, par_notify_email_operator_name character varying DEFAULT NULL::character varying, par_notify_netsend_operator_name character varying DEFAULT NULL::character varying, par_notify_page_operator_name character varying DEFAULT NULL::character varying, par_delete_level integer DEFAULT 0, INOUT par_job_id integer DEFAULT NULL::integer, par_originating_server character varying DEFAULT NULL::character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="17" function-id="23986" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_name character varying, par_enabled smallint, par_description character varying, par_start_step_id integer, par_category_name character varying, par_category_id integer, par_owner_login_name character varying, par_notify_level_eventlog integer, par_notify_level_email integer, par_notify_level_netsend integer, par_notify_level_page integer, par_notify_email_operator_name character varying, par_notify_netsend_operator_name character varying, par_notify_page_operator_name character varying, par_delete_level integer, INOUT par_job_id integer, par_originating_server character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_add_job(par_job_name character varying, par_enabled smallint, par_description character varying, par_start_step_id integer, par_category_name character varying, par_category_id integer, par_owner_login_name character varying, par_notify_level_eventlog integer, par_notify_level_email integer, par_notify_level_netsend integer, par_notify_level_page integer, par_notify_email_operator_name character varying, par_notify_netsend_operator_name character varying, par_notify_page_operator_name character varying, par_delete_level integer, INOUT par_job_id integer, par_originating_server character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT DEFAULT 0;
  var_notify_email_operator_id INT DEFAULT 0;
  var_notify_email_operator_name VARCHAR(128);
  var_notify_netsend_operator_id INT DEFAULT 0;
  var_notify_page_operator_id INT DEFAULT 0;
  var_owner_sid CHAR(85) ;
  var_originating_server_id INT DEFAULT 0;
BEGIN
  /* Remove any leading/trailing spaces from parameters (except @owner_login_name) */
  SELECT UPPER(LTRIM(RTRIM(par_originating_server))) INTO par_originating_server;
  SELECT LTRIM(RTRIM(par_job_name)) INTO par_job_name;
  SELECT LTRIM(RTRIM(par_description)) INTO par_description;
  SELECT '[Uncategorized (Local)]' INTO par_category_name;
  SELECT 0 INTO par_category_id;
  SELECT LTRIM(RTRIM(par_notify_email_operator_name)) INTO par_notify_email_operator_name;
  SELECT LTRIM(RTRIM(par_notify_netsend_operator_name)) INTO par_notify_netsend_operator_name;
  SELECT LTRIM(RTRIM(par_notify_page_operator_name)) INTO par_notify_page_operator_name;
  SELECT NULL INTO var_originating_server_id; /* Turn [nullable] empty string parameters into NULLs */
  SELECT NULL INTO par_job_id;

  IF (par_originating_server = '') 
  THEN
    SELECT NULL INTO par_originating_server;
  END IF;

  IF (par_description = '') 
  THEN
    SELECT NULL INTO par_description;
  END IF;

  IF (par_category_name = '') 
  THEN
    SELECT NULL INTO par_category_name;
  END IF;

  IF (par_notify_email_operator_name = '') 
  THEN 
    SELECT NULL INTO par_notify_email_operator_name;
  END IF;

  IF (par_notify_netsend_operator_name = '') 
  THEN
    SELECT NULL INTO par_notify_netsend_operator_name;
  END IF;

  IF (par_notify_page_operator_name = '') 
  THEN 
    SELECT NULL INTO par_notify_page_operator_name;
  END IF;

  /* Check parameters */
  SELECT t.par_owner_sid
       , t.par_notify_level_email
       , t.par_notify_level_netsend
       , t.par_notify_level_page
       , t.par_category_id
       , t.par_notify_email_operator_id
       , t.par_notify_netsend_operator_id
       , t.par_notify_page_operator_id
       , t.par_originating_server
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_job(
         par_job_id /* NULL::integer */
       , par_job_name
       , par_enabled
       , par_start_step_id
       , par_category_name
       , var_owner_sid /* par_owner_sid */
       , par_notify_level_eventlog
       , par_notify_level_email
       , par_notify_level_netsend
       , par_notify_level_page
       , par_notify_email_operator_name
       , par_notify_netsend_operator_name
       , par_notify_page_operator_name
       , par_delete_level
       , par_category_id
       , var_notify_email_operator_id /* par_notify_email_operator_id */
       , var_notify_netsend_operator_id /* par_notify_netsend_operator_id */
       , var_notify_page_operator_id /* par_notify_page_operator_id */
       , par_originating_server
       ) t
    INTO var_owner_sid
       , par_notify_level_email
       , par_notify_level_netsend
       , par_notify_level_page
       , par_category_id
       , var_notify_email_operator_id
       , var_notify_netsend_operator_id
       , var_notify_page_operator_id
       , par_originating_server
       , var_retval;

  IF (var_retval <> 0)  /* Failure */
  THEN
    returncode := 1;
    RETURN;
  END IF;

  var_notify_email_operator_name := par_notify_email_operator_name;

  /* Default the description (if not supplied) */
  IF (par_description IS NULL) 
  THEN
    SELECT 'No description available.' INTO par_description;
  END IF;
  
  var_originating_server_id := 0;
  var_owner_sid := '';
    
  INSERT 
    INTO aws_sqlserver_ext.sysjobs (
         originating_server_id
       , name
       , enabled
       , description
       , start_step_id
       , category_id
       , owner_sid
       , notify_level_eventlog
       , notify_level_email
       , notify_level_netsend
       , notify_level_page
       , notify_email_operator_id
       , notify_email_operator_name
       , notify_netsend_operator_id
       , notify_page_operator_id
       , delete_level
       , version_number
    )
  VALUES (
         var_originating_server_id
       , par_job_name
       , par_enabled
       , par_description
       , par_start_step_id
       , par_category_id
       , var_owner_sid
       , par_notify_level_eventlog
       , par_notify_level_email
       , par_notify_level_netsend
       , par_notify_level_page
       , var_notify_email_operator_id
       , var_notify_email_operator_name
       , var_notify_netsend_operator_id
       , var_notify_page_operator_id
       , par_delete_level
       , 1);
  
  /* scope_identity() */
  SELECT LASTVAL() INTO par_job_id;
       
  /* Version number 1 */
  /* SELECT @retval = @@error */
  /* 0 means success */
  returncode := var_retval;
  RETURN;
    
END;
]]></complex-attribute>
                        <category _I_D="55f98db6-92cf-4ddb-b8d8-9daa52c57b78" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9dac8901-3510-40e8-a141-f1284d0b6aec" name="sp_add_jobschedule" is-trigger-function="0" unique-function-name="sp_add_jobschedule" is-aggregate="f" language-name="plpgsql" context="sp_add_jobschedule" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,character varying,smallint,integer,integer,integer,integer,integer,integer,integer,integer,integer,integer,integer,smallint,character,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_name character varying DEFAULT NULL::character varying, par_enabled smallint DEFAULT 1, par_freq_type integer DEFAULT 1, par_freq_interval integer DEFAULT 0, par_freq_subday_type integer DEFAULT 0, par_freq_subday_interval integer DEFAULT 0, par_freq_relative_interval integer DEFAULT 0, par_freq_recurrence_factor integer DEFAULT 0, par_active_start_date integer DEFAULT 20000101, par_active_end_date integer DEFAULT 99991231, par_active_start_time integer DEFAULT 0, par_active_end_time integer DEFAULT 235959, INOUT par_schedule_id integer DEFAULT NULL::integer, par_automatic_post smallint DEFAULT 1, INOUT par_schedule_uid character DEFAULT NULL::bpchar, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="17" function-id="23985" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_job_name character varying, par_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, INOUT par_schedule_id integer, par_automatic_post smallint, INOUT par_schedule_uid character, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_add_jobschedule(par_job_id integer, par_job_name character varying, par_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, INOUT par_schedule_id integer, par_automatic_post smallint, INOUT par_schedule_uid character, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_owner_login_name VARCHAR(128);
BEGIN

  -- Check that we can uniquely identify the job
  SELECT t.par_job_name
       , t.par_job_id
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_identifiers (
         '@job_name'
       , '@job_id'
       , par_job_name
       , par_job_id
       , 'TEST'::character varying
       , NULL::bpchar
       ) t
    INTO par_job_name
       , par_job_id
       , var_retval;
  
  IF (var_retval <> 0) 
  THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;  

  /* Add the schedule first */
  SELECT t.par_schedule_uid
       , t.par_schedule_id
       , t.returncode
    FROM aws_sqlserver_ext.sp_add_schedule(
         par_name
       , par_enabled
       , par_freq_type
       , par_freq_interval
       , par_freq_subday_type
       , par_freq_subday_interval
       , par_freq_relative_interval
       , par_freq_recurrence_factor
       , par_active_start_date
       , par_active_end_date
       , par_active_start_time
       , par_active_end_time
       , var_owner_login_name
       , par_schedule_uid
       , par_schedule_id
       , NULL
       ) t
    INTO par_schedule_uid
       , par_schedule_id
       , var_retval;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  SELECT t.returncode
    FROM aws_sqlserver_ext.sp_attach_schedule(
         par_job_id := par_job_id
       , par_job_name := NULL
       , par_schedule_id := par_schedule_id
       , par_schedule_name := NULL
       , par_automatic_post := par_automatic_post
       ) t
    INTO var_retval;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  SELECT t.returncode 
    FROM aws_sqlserver_ext.sp_aws_add_jobschedule(par_job_id, par_schedule_id) t
    INTO var_retval;  

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;

  /* 0 means success */
  returncode := (var_retval);
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="ad0e1ea4-97d1-46f0-8ba2-0bbf51daf6f8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2cf53afe-888b-4f3c-a687-ca4c22c0b181" name="sp_add_jobstep" is-trigger-function="0" unique-function-name="sp_add_jobstep" is-aggregate="f" language-name="plpgsql" context="sp_add_jobstep" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,integer,character varying,character varying,text,text,integer,smallint,integer,smallint,integer,character varying,character varying,character varying,integer,integer,integer,character varying,integer,integer,character varying,character,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_step_id integer DEFAULT NULL::integer, par_step_name character varying DEFAULT NULL::character varying, par_subsystem character varying DEFAULT 'TSQL'::bpchar, par_command text DEFAULT NULL::text, par_additional_parameters text DEFAULT NULL::text, par_cmdexec_success_code integer DEFAULT 0, par_on_success_action smallint DEFAULT 1, par_on_success_step_id integer DEFAULT 0, par_on_fail_action smallint DEFAULT 2, par_on_fail_step_id integer DEFAULT 0, par_server character varying DEFAULT NULL::character varying, par_database_name character varying DEFAULT NULL::character varying, par_database_user_name character varying DEFAULT NULL::character varying, par_retry_attempts integer DEFAULT 0, par_retry_interval integer DEFAULT 0, par_os_run_priority integer DEFAULT 0, par_output_file_name character varying DEFAULT NULL::character varying, par_flags integer DEFAULT 0, par_proxy_id integer DEFAULT NULL::integer, par_proxy_name character varying DEFAULT NULL::character varying, INOUT par_step_uid character DEFAULT NULL::bpchar, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="23" function-id="23988" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_job_name character varying, par_step_id integer, par_step_name character varying, par_subsystem character varying, par_command text, par_additional_parameters text, par_cmdexec_success_code integer, par_on_success_action smallint, par_on_success_step_id integer, par_on_fail_action smallint, par_on_fail_step_id integer, par_server character varying, par_database_name character varying, par_database_user_name character varying, par_retry_attempts integer, par_retry_interval integer, par_os_run_priority integer, par_output_file_name character varying, par_flags integer, par_proxy_id integer, par_proxy_name character varying, INOUT par_step_uid character, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_add_jobstep(par_job_id integer, par_job_name character varying, par_step_id integer, par_step_name character varying, par_subsystem character varying, par_command text, par_additional_parameters text, par_cmdexec_success_code integer, par_on_success_action smallint, par_on_success_step_id integer, par_on_fail_action smallint, par_on_fail_step_id integer, par_server character varying, par_database_name character varying, par_database_user_name character varying, par_retry_attempts integer, par_retry_interval integer, par_os_run_priority integer, par_output_file_name character varying, par_flags integer, par_proxy_id integer, par_proxy_name character varying, INOUT par_step_uid character, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_max_step_id INT;
  var_step_id INT;
BEGIN

  SELECT t.par_job_name
       , t.par_job_id
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_identifiers (
         '@job_name'
       , '@job_id'
       , par_job_name
       , par_job_id
       , 'TEST'::character varying
       , NULL::bpchar
       ) t
    INTO par_job_name
       , par_job_id
       , var_retval;
  
  IF (var_retval <> 0) THEN
    returncode := 1;
    RETURN;
  END IF;  
    
  -- Default step id (if not supplied)
  IF (par_step_id IS NULL) 
  THEN
     SELECT COALESCE(MAX(step_id), 0) + 1
        INTO var_step_id
       FROM aws_sqlserver_ext.sysjobsteps
      WHERE (job_id = par_job_id);
  ELSE 
    var_step_id := par_step_id; 
  END IF;

  -- Get current maximum step id    
  SELECT COALESCE(MAX(step_id), 0)
    INTO var_max_step_id
    FROM aws_sqlserver_ext.sysjobsteps
   WHERE (job_id = par_job_id);

  /* Check parameters */
  SELECT t.returncode
    FROM aws_sqlserver_ext.sp_verify_jobstep(
         par_job_id
       , var_step_id --par_step_id
       , par_step_name
       , par_subsystem
       , par_command
       , par_server
       , par_on_success_action
       , par_on_success_step_id
       , par_on_fail_action
       , par_on_fail_step_id
       , par_os_run_priority
       , par_flags
       , par_output_file_name
       , par_proxy_id
    ) t
    INTO var_retval;

  IF (var_retval <> 0) 
  THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  /* Modify database. */
  /* Update the job's version/last-modified information */
  UPDATE aws_sqlserver_ext.sysjobs
     SET version_number = version_number + 1
       --, date_modified = GETDATE() 
   WHERE (job_id = par_job_id);
   
  /* Adjust step id's (unless the new step is being inserted at the 'end') */
  /* NOTE: We MUST do this before inserting the step. */
  IF (var_step_id <= var_max_step_id) 
  THEN
    UPDATE aws_sqlserver_ext.sysjobsteps
       SET step_id = step_id + 1
     WHERE (step_id >= var_step_id) AND (job_id = par_job_id);
     
    /* Clean up OnSuccess/OnFail references */
    UPDATE aws_sqlserver_ext.sysjobsteps
       SET on_success_step_id = on_success_step_id + 1
     WHERE (on_success_step_id >= var_step_id) AND (job_id = par_job_id);
     
    UPDATE aws_sqlserver_ext.sysjobsteps
       SET on_fail_step_id = on_fail_step_id + 1
     WHERE (on_fail_step_id >= var_step_id) AND (job_id = par_job_id);
     
    UPDATE aws_sqlserver_ext.sysjobsteps
       SET on_success_step_id = 0
         , on_success_action = 1 /* Quit With Success */
     WHERE (on_success_step_id = var_step_id) 
       AND (job_id = par_job_id);
       
    UPDATE aws_sqlserver_ext.sysjobsteps
       SET on_fail_step_id = 0
         , on_fail_action = 2 /* Quit With Failure */
     WHERE (on_fail_step_id = var_step_id) 
       AND (job_id = par_job_id);
  END IF;

  /* uuid without extensions uuid-ossp (cheat) */
  SELECT uuid_in(md5(random()::text || clock_timestamp()::text)::cstring) INTO par_step_uid;
  
  /* Insert the step */
  INSERT 
    INTO aws_sqlserver_ext.sysjobsteps (
         job_id
       , step_id
       , step_name
       , subsystem
       , command
       , flags
       , additional_parameters
       , cmdexec_success_code
       , on_success_action
       , on_success_step_id
       , on_fail_action
       , on_fail_step_id
       , server
       , database_name
       , database_user_name
       , retry_attempts
       , retry_interval
       , os_run_priority
       , output_file_name
       , last_run_outcome
       , last_run_duration
       , last_run_retries
       , last_run_date
       , last_run_time
       , proxy_id
       , step_uid
   )
  VALUES (
         par_job_id
       , var_step_id
       , par_step_name
       , par_subsystem
       , par_command
       , par_flags
       , par_additional_parameters
       , par_cmdexec_success_code
       , par_on_success_action
       , par_on_success_step_id
       , par_on_fail_action
       , par_on_fail_step_id
       , par_server
       , par_database_name
       , par_database_user_name
       , par_retry_attempts
       , par_retry_interval
       , par_os_run_priority
       , par_output_file_name
       , 0
       , 0
       , 0
       , 0
       , 0
       , par_proxy_id
       , par_step_uid
  );
  
  --PERFORM aws_sqlserver_ext.sp_jobstep_create_proc (par_step_uid);

  returncode := var_retval;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="f55f43a5-e599-412d-bbfa-8adcd8041ba5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="161a3213-a865-4dba-b7db-b07462d49c83" name="sp_add_schedule" is-trigger-function="0" unique-function-name="sp_add_schedule" is-aggregate="f" language-name="plpgsql" context="sp_add_schedule" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,smallint,integer,integer,integer,integer,integer,integer,integer,integer,integer,integer,character varying,character,integer,character varying,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_schedule_name character varying, par_enabled smallint DEFAULT 1, par_freq_type integer DEFAULT 0, par_freq_interval integer DEFAULT 0, par_freq_subday_type integer DEFAULT 0, par_freq_subday_interval integer DEFAULT 0, par_freq_relative_interval integer DEFAULT 0, par_freq_recurrence_factor integer DEFAULT 0, par_active_start_date integer DEFAULT NULL::integer, par_active_end_date integer DEFAULT 99991231, par_active_start_time integer DEFAULT 0, par_active_end_time integer DEFAULT 235959, par_owner_login_name character varying DEFAULT NULL::character varying, INOUT par_schedule_uid character DEFAULT NULL::bpchar, INOUT par_schedule_id integer DEFAULT NULL::integer, par_originating_server character varying DEFAULT NULL::character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="16" function-id="23990" volatility="VOLATILE" is-window="f" function-identity-arguments="par_schedule_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, par_owner_login_name character varying, INOUT par_schedule_uid character, INOUT par_schedule_id integer, par_originating_server character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_add_schedule(par_schedule_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, par_owner_login_name character varying, INOUT par_schedule_uid character, INOUT par_schedule_id integer, par_originating_server character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_owner_sid CHAR(85);
  var_orig_server_id INT;
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_schedule_name))
       , LTRIM(RTRIM(par_owner_login_name))
       , UPPER(LTRIM(RTRIM(par_originating_server)))
       , 0
    INTO par_schedule_name
       , par_owner_login_name
       , par_originating_server
       , par_schedule_id;

  /* Check schedule (frequency and owner) parameters */
  SELECT t.par_freq_interval
       , t.par_freq_subday_type
       , t.par_freq_subday_interval
       , t.par_freq_relative_interval
       , t.par_freq_recurrence_factor
       , t.par_active_start_date
       , t.par_active_start_time
       , t.par_active_end_date
       , t.par_active_end_time
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_schedule(
         NULL::integer /* @schedule_id  -- schedule_id does not exist for the new schedule */
       , par_schedule_name /* @name */
       , par_enabled /* @enabled */
       , par_freq_type /* @freq_type */
       , par_freq_interval /* @freq_interval */
       , par_freq_subday_type /* @freq_subday_type */
       , par_freq_subday_interval /* @freq_subday_interval */
       , par_freq_relative_interval /* @freq_relative_interval */
       , par_freq_recurrence_factor /* @freq_recurrence_factor */
       , par_active_start_date /* @active_start_date */
       , par_active_start_time /* @active_start_time */
       , par_active_end_date /* @active_end_date */
       , par_active_end_time /* @active_end_time */
       , var_owner_sid
       ) t
    INTO par_freq_interval
       , par_freq_subday_type
       , par_freq_subday_interval
       , par_freq_relative_interval
       , par_freq_recurrence_factor
       , par_active_start_date
       , par_active_start_time
       , par_active_end_date
       , par_active_end_time
       , var_retval /* @owner_sid */;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
        RETURN;
    END IF;

  IF (par_schedule_uid IS NULL) 
  THEN /* Assign the GUID */
    /* uuid without extensions uuid-ossp (cheat) */
    SELECT uuid_in(md5(random()::text || clock_timestamp()::text)::cstring) INTO par_schedule_uid;
  END IF;
   
  var_orig_server_id := 0;
  var_owner_sid := uuid_in(md5(random()::text || clock_timestamp()::text)::cstring);


  INSERT 
    INTO aws_sqlserver_ext.sysschedules (
         schedule_uid
       , originating_server_id
       , name
       , owner_sid
       , enabled
       , freq_type
       , freq_interval
       , freq_subday_type
       , freq_subday_interval
       , freq_relative_interval
       , freq_recurrence_factor
       , active_start_date
       , active_end_date
       , active_start_time
       , active_end_time
   )
  VALUES (
         par_schedule_uid
       , var_orig_server_id
       , par_schedule_name
       , var_owner_sid
       , par_enabled
       , par_freq_type
       , par_freq_interval
       , par_freq_subday_type
       , par_freq_subday_interval
       , par_freq_relative_interval
       , par_freq_recurrence_factor
       , par_active_start_date
       , par_active_end_date
       , par_active_start_time
       , par_active_end_time
  );

  /* ZZZ */       
  SELECT 0 /* @@ERROR, */, LASTVAL()
    INTO var_retval, par_schedule_id;
    
  /* 0 means success */    
  returncode := var_retval;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="d7276d22-7e67-4e4c-9f31-4e6e8e45ab79" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="31e6cf31-ef3f-4479-b9af-80f4852af4f2" name="sp_attach_schedule" is-trigger-function="0" unique-function-name="sp_attach_schedule" is-aggregate="f" language-name="plpgsql" context="sp_attach_schedule" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,integer,character varying,smallint,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_schedule_id integer DEFAULT NULL::integer, par_schedule_name character varying DEFAULT NULL::character varying, par_automatic_post smallint DEFAULT 1, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="5" function-id="23992" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_job_name character varying, par_schedule_id integer, par_schedule_name character varying, par_automatic_post smallint, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_attach_schedule(par_job_id integer, par_job_name character varying, par_schedule_id integer, par_schedule_name character varying, par_automatic_post smallint, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_sched_owner_sid CHAR(85);
  var_job_owner_sid CHAR(85);
BEGIN
  /* Check that we can uniquely identify the job */
  SELECT t.par_job_name
       , t.par_job_id
       , t.par_owner_sid
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_identifiers(
         '@job_name'
       , '@job_id'
       , par_job_name /* @job_name */
       , par_job_id /* @job_id */
       , 'TEST' /* @sqlagent_starting_test */
       , var_job_owner_sid) t
    INTO par_job_name
       , par_job_id
       , var_job_owner_sid
       , var_retval;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  /* Check that we can uniquely identify the schedule */
  SELECT t.par_schedule_name
       , t.par_schedule_id
       , t.par_owner_sid
       --, t.par_orig_server_id
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_schedule_identifiers(
         '@schedule_name'::character varying /* @name_of_name_parameter */
       , '@schedule_id'::character varying /* @name_of_id_parameter */
       , par_schedule_name /* @schedule_name */
       , par_schedule_id /* @schedule_id */
       , var_sched_owner_sid /* @owner_sid */
       , NULL::integer /* @orig_server_id */
       , NULL::integer) t
    INTO par_schedule_name
       , par_schedule_id
       , var_sched_owner_sid
       , var_retval /* @job_id_filter */;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF
    
  /* If the record doesn't already exist create it */;
  IF (
    NOT EXISTS (
      SELECT 1 
        FROM aws_sqlserver_ext.sysjobschedules
       WHERE (schedule_id = par_schedule_id) 
         AND (job_id = par_job_id))) 
  THEN
    INSERT 
      INTO aws_sqlserver_ext.sysjobschedules (schedule_id, job_id)
    VALUES (par_schedule_id, par_job_id);
    
    SELECT 0 INTO var_retval; /* @@ERROR */
  END IF;


  PERFORM aws_sqlserver_ext.sp_set_next_run (par_job_id, par_schedule_id);
  
  /* 0 means success */
  returncode := var_retval;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="7027ac2d-7652-43d2-81e7-e1f684e7d695" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b73f8330-522f-488b-a115-daba5a9b9b19" name="sp_aws_add_jobschedule" is-trigger-function="0" unique-function-name="sp_aws_add_jobschedule" is-aggregate="f" language-name="plpgsql" context="sp_aws_add_jobschedule" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_job_id integer DEFAULT NULL::integer, par_schedule_id integer DEFAULT NULL::integer, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24022" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_schedule_id integer, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_aws_add_jobschedule(par_job_id integer, par_schedule_id integer, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  proc_name_mask VARCHAR(100) DEFAULT 'aws_sqlserver_ext_data.sql_agent$job_%s_step_%s';
  var_cron_expression VARCHAR(50); 
  var_job_cmd VARCHAR(255); 
  var_schedule_name VARCHAR(255);

  var_job_name VARCHAR(128);
  var_start_step_id INTEGER;
  var_notify_level_email INTEGER;
  var_notify_email_operator_id INTEGER;
  var_notify_email_operator_name VARCHAR(128);
  notify_email_sender VARCHAR(128);
  var_delete_level INTEGER;
BEGIN

  IF (EXISTS 
    (
      SELECT 1
        FROM aws_sqlserver_ext.sysjobschedules
       WHERE schedule_id = par_schedule_id
         AND job_id = par_job_id
    )
  ) 
  THEN

    SELECT cron_expression 
      FROM aws_sqlserver_ext.sp_schedule_to_cron(par_job_id, par_schedule_id) 
      INTO var_cron_expression;
      
    SELECT name 
      FROM aws_sqlserver_ext.sysschedules
     WHERE schedule_id = par_schedule_id 
      INTO var_schedule_name;

    SELECT name
         , start_step_id
         , COALESCE(notify_level_email,0)
         , COALESCE(notify_email_operator_id,0)
         , COALESCE(notify_email_operator_name,'')
         , COALESCE(delete_level,0) 
      FROM aws_sqlserver_ext.sysjobs
     WHERE job_id = par_job_id
      INTO var_job_name
         , var_start_step_id 
         , var_notify_level_email 
         , var_notify_email_operator_id 
         , var_notify_email_operator_name 
         , var_delete_level;
  
    var_job_cmd := FORMAT(proc_name_mask, par_job_id, '1');   
    notify_email_sender := 'aws_test_email_sender@dbbest.com';
    
    PERFORM aws_sqlserver_ext.awslambda_fn
    (
      aws_sqlserver_ext.get_service_setting
      (
        'JOB',
        'LAMBDA_ARN'
      ),
      JSON_BUILD_OBJECT
      (
        'mode', 'add_job',
        'parameters', JSON_BUILD_OBJECT
        (
          'vendor', 'postgresql',
          'job_name', var_schedule_name,
          'job_frequency', var_cron_expression,
          'job_cmd', var_job_cmd,
          'notify_level_email', var_notify_level_email,
          'delete_level', var_delete_level,
          'uid', par_job_id,
          'callback', 'aws_sqlserver_ext.sp_job_log',
          'notification', JSON_BUILD_OBJECT
          (
            'notify_email_sender', notify_email_sender,
            'notify_email_recipient', var_notify_email_operator_name
          )

        )
      )
    );

    returncode := 0;

  ELSE

    returncode := 1;
    RAISE 'Job not found' USING ERRCODE := '50000';

  END IF;

END;
]]></complex-attribute>
                        <category _I_D="7be32adb-fdaa-431d-bd60-a91d0b669d6d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2a36a4f1-1be2-4cb6-9f5d-41d39dc493fe" name="sp_aws_del_jobschedule" is-trigger-function="0" unique-function-name="sp_aws_del_jobschedule" is-aggregate="f" language-name="plpgsql" context="sp_aws_del_jobschedule" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_job_id integer DEFAULT NULL::integer, par_schedule_id integer DEFAULT NULL::integer, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24023" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_schedule_id integer, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_aws_del_jobschedule(par_job_id integer, par_schedule_id integer, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_schedule_name VARCHAR(255);
BEGIN

  IF (EXISTS 
    (
        SELECT 1
          FROM aws_sqlserver_ext.sysjobschedules
        WHERE schedule_id = par_schedule_id
          AND job_id = par_job_id
    )
  )
  THEN

    SELECT name
      FROM aws_sqlserver_ext.sysschedules
     WHERE schedule_id = par_schedule_id
      INTO var_schedule_name;

    PERFORM aws_sqlserver_ext.awslambda_fn
    (
      aws_sqlserver_ext.get_service_setting
      (
        'JOB',
        'LAMBDA_ARN'
      ),
      JSON_BUILD_OBJECT
      (
        'mode', 'del_schedule',
        'parameters', JSON_BUILD_OBJECT
        (
          'schedule_name', var_schedule_name,
          'force_delete', 'TRUE'
        )
      )
    );

    returncode := 0;

  ELSE

    returncode := 1;
    RAISE 'Job not found' USING ERRCODE := '50000';

  END IF;

END;
]]></complex-attribute>
                        <category _I_D="14e8b9b6-2de4-4591-9327-37379e01a8a8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="13bc1351-5384-43a2-89c0-644ccaa32319" name="sp_delete_job" is-trigger-function="0" unique-function-name="sp_delete_job" is-aggregate="f" language-name="plpgsql" context="sp_delete_job" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,character varying,smallint,smallint,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_originating_server character varying DEFAULT NULL::character varying, par_delete_history smallint DEFAULT 1, par_delete_unused_schedule smallint DEFAULT 1, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="5" function-id="23995" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_job_name character varying, par_originating_server character varying, par_delete_history smallint, par_delete_unused_schedule smallint, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_delete_job(par_job_id integer, par_job_name character varying, par_originating_server character varying, par_delete_history smallint, par_delete_unused_schedule smallint, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_category_id INT;
  var_job_owner_sid CHAR(85);
  var_err INT;
  var_schedule_id INT;
BEGIN
  IF ((par_job_id IS NOT NULL) OR (par_job_name IS NOT NULL)) 
  THEN
    SELECT t.par_job_name
         , t.par_job_id
         , t.par_owner_sid
         , t.returncode
      FROM aws_sqlserver_ext.sp_verify_job_identifiers(
           '@job_name'
         , '@job_id'
         , par_job_name
         , par_job_id
         , 'TEST'
         , var_job_owner_sid
         ) t
      INTO par_job_name
         , par_job_id
         , var_job_owner_sid
         , var_retval;
         
    IF (var_retval <> 0) THEN /* Failure */
      returncode := (1);
      RETURN;
    END IF;
  END IF;
  
  /* Get category to see if it is a misc. replication agent. @category_id will be */
  /* NULL if there is no @job_id. */
  
  SELECT category_id
    INTO var_category_id
    FROM aws_sqlserver_ext.sysjobs
   WHERE job_id = par_job_id;
   
  /* Do the delete (for a specific job) */
  IF (par_job_id IS NOT NULL) 
  THEN
    --CREATE TEMPORARY TABLE "#temp_schedules_to_delete" (schedule_id INT NOT NULL);
     
    -- Delete all traces of the job 
    -- BEGIN TRANSACTION 
    -- Get the schedules to delete before deleting records from sysjobschedules 



    --IF (par_delete_unused_schedule = 1) 
    --THEN
      -- ZZZ optimize 
      -- Get the list of schedules to delete 
      --INSERT INTO "#temp_schedules_to_delete"
      --SELECT DISTINCT schedule_id 
      --  FROM aws_sqlserver_ext.sysschedules
      -- WHERE schedule_id IN (SELECT schedule_id
      --                         FROM aws_sqlserver_ext.sysjobschedules
      --                         WHERE job_id = par_job_id);
      --INSERT INTO "#temp_schedules_to_delete"
      SELECT schedule_id
    	FROM aws_sqlserver_ext.sysjobschedules
       WHERE job_id = par_job_id
        INTO var_schedule_id;

    PERFORM aws_sqlserver_ext.sp_aws_del_jobschedule (par_job_id := par_job_id, par_schedule_id := var_schedule_id);  


--    END IF;


    --DELETE FROM aws_sqlserver_ext.sysschedules
    -- WHERE schedule_id IN (SELECT schedule_id FROM aws_sqlserver_ext.sysjobschedules WHERE job_id = par_job_id);
  
    DELETE FROM aws_sqlserver_ext.sysjobschedules
     WHERE job_id = par_job_id;
     
    DELETE FROM aws_sqlserver_ext.sysjobsteps
     WHERE job_id = par_job_id;
     
    DELETE FROM aws_sqlserver_ext.sysjobs
     WHERE job_id = par_job_id;
     
    SELECT 0 /* @@ERROR */ INTO var_err;
          
    /* Delete the schedule(s) if requested to and it isn't being used by other jobs */
    IF (par_delete_unused_schedule = 1) 
    THEN
      /* Now OK to delete the schedule */
      DELETE FROM aws_sqlserver_ext.sysschedules
       WHERE schedule_id = var_schedule_id; --IN (SELECT schedule_id FROM "#temp_schedules_to_delete");

      --DELETE FROM aws_sqlserver_ext.sysschedules
      -- WHERE schedule_id IN (SELECT schedule_id
      --                         FROM "#temp_schedules_to_delete" AS sdel
      --                        WHERE NOT EXISTS (SELECT *
      --                                            FROM aws_sqlserver_ext.sysjobschedules AS js
      --                                           WHERE js.schedule_id = sdel.schedule_id));
    END IF;
    
    /* Delete the job history if requested */
    IF (par_delete_history = 1)
    THEN
      DELETE FROM aws_sqlserver_ext.sysjobhistory
      WHERE job_id = par_job_id;
    END IF;

    /* All done */
    /* COMMIT TRANSACTION */
    --DROP TABLE "#temp_schedules_to_delete";
  END IF;
  
  /* 0 means success */
  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="3166de04-0025-4998-8e65-b09588c2da38" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8e0c3420-d417-416e-b95d-3908a6b94f22" name="sp_delete_jobschedule" is-trigger-function="0" unique-function-name="sp_delete_jobschedule" is-aggregate="f" language-name="plpgsql" context="sp_delete_jobschedule" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,character varying,integer,smallint,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_name character varying DEFAULT NULL::character varying, par_keep_schedule integer DEFAULT 0, par_automatic_post smallint DEFAULT 1, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="5" function-id="23993" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_job_name character varying, par_name character varying, par_keep_schedule integer, par_automatic_post smallint, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_delete_jobschedule(par_job_id integer, par_job_name character varying, par_name character varying, par_keep_schedule integer, par_automatic_post smallint, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_sched_count INT;
  var_schedule_id INT;
  var_job_owner_sid CHAR(85);
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_name)) INTO par_name;
  
  /* Check that we can uniquely identify the job */
  SELECT t.par_job_name
       , t.par_job_id
       , t.par_owner_sid
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_identifiers(
         '@job_name'
       , '@job_id'
       , par_job_name
       , par_job_id
       , 'TEST'
       , var_job_owner_sid
       ) t
    INTO par_job_name
       , par_job_id
       , var_job_owner_sid
       , var_retval;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
   
  IF (LOWER(UPPER(par_name)) = LOWER('ALL')) 
  THEN
    SELECT - 1 INTO var_schedule_id;
    
    /* We use this in the call to sp_sqlagent_notify */
    /* Delete the schedule(s) if it isn't being used by other jobs */
    CREATE TEMPORARY TABLE "#temp_schedules_to_delete" (schedule_id INT NOT NULL)
    /* If user requests that the schedules be removed (the legacy behavoir) */
    /* make sure it isnt being used by other jobs */;

    IF (par_keep_schedule = 0) 
    THEN
      /* Get the list of schedules to delete */
      INSERT INTO "#temp_schedules_to_delete"
      SELECT DISTINCT schedule_id
        FROM aws_sqlserver_ext.sysschedules
       WHERE (schedule_id IN (SELECT schedule_id
                                FROM aws_sqlserver_ext.sysjobschedules
                               WHERE (job_id = par_job_id)));
      /* make sure no other jobs use these schedules */
      IF (EXISTS (SELECT *
                    FROM aws_sqlserver_ext.sysjobschedules
                   WHERE (job_id <> par_job_id) 
                     AND (schedule_id IN (SELECT schedule_id
                                            FROM "#temp_schedules_to_delete")))) 
      THEN /* Failure */
        RAISE 'One or more schedules were not deleted because they are being used by at least one other job. Use "sp_detach_schedule" to remove schedules from a job.' USING ERRCODE := '50000';
        returncode := 1;
        RETURN;
      END IF;
    END IF;
    
    /* OK to delete the jobschedule */
    DELETE FROM aws_sqlserver_ext.sysjobschedules
     WHERE (job_id = par_job_id);
     
    /* OK to delete the schedule - temp_schedules_to_delete is empty if @keep_schedule <> 0 */
    DELETE FROM aws_sqlserver_ext.sysschedules
     WHERE schedule_id IN (SELECT schedule_id FROM "#temp_schedules_to_delete");
  ELSE ---- IF (LOWER(UPPER(par_name)) = LOWER('ALL')) 

    -- Need to use sp_detach_schedule to remove this ambiguous schedule name
    IF(var_sched_count > 1) /* Failure */
    THEN
      RAISE 'More than one schedule named "%" is attached to job "%". Use "sp_detach_schedule" to remove schedules from a job.', par_name, par_job_name  USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;

    --If user requests that the schedule be removed (the legacy behavoir)
    --make sure it isnt being used by another job
    IF (par_keep_schedule = 0)
    THEN
      IF(EXISTS(SELECT *
                  FROM aws_sqlserver_ext.sysjobschedules
                 WHERE (schedule_id = var_schedule_id)
                   AND (job_id <> par_job_id)))
      THEN /* Failure */
        RAISE 'Schedule "%" was not deleted because it is being used by at least one other job. Use "sp_detach_schedule" to remove schedules from a job.', par_name USING ERRCODE := '50000';
        returncode := 1;
        RETURN;
      END IF;
    END IF;

    /* Delete the job schedule link first */
    DELETE FROM aws_sqlserver_ext.sysjobschedules
     WHERE (job_id = par_job_id) 
       AND (schedule_id = var_schedule_id);
       
    /* Delete schedule if required */
    IF (par_keep_schedule = 0) 
    THEN
      /* Now delete the schedule if required */
      DELETE FROM aws_sqlserver_ext.sysschedules
       WHERE (schedule_id = var_schedule_id);
    END IF;

    SELECT t.returncode 
    FROM aws_sqlserver_ext.sp_aws_del_jobschedule(par_job_id, var_schedule_id) t
    INTO var_retval;  
	

  END IF;
  
  /* Update the job's version/last-modified information */
  UPDATE aws_sqlserver_ext.sysjobs
     SET version_number = version_number + 1
       -- , date_modified = GETDATE() /
   WHERE job_id = par_job_id;

  DROP TABLE IF EXISTS "#temp_schedules_to_delete";
 
   
  /* 0 means success */ 
  returncode := var_retval;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="7ce160ec-175a-4c81-a7b9-2b65a811c32f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4ef392c0-3b8c-42b5-99cc-cc98eefdf613" name="sp_delete_jobstep" is-trigger-function="0" unique-function-name="sp_delete_jobstep" is-aggregate="f" language-name="plpgsql" context="sp_delete_jobstep" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,integer,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_step_id integer DEFAULT NULL::integer, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23996" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_job_name character varying, par_step_id integer, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_delete_jobstep(par_job_id integer, par_job_name character varying, par_step_id integer, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_max_step_id INT;
  var_valid_range VARCHAR(50);
  var_job_owner_sid CHAR(85);
BEGIN
  SELECT t.par_job_name
       , t.par_job_id
       , t.par_owner_sid
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_identifiers(
         '@job_name'
       , '@job_id'
       , par_job_name
       , par_job_id
       , 'TEST'
       , var_job_owner_sid
       ) t
    INTO par_job_name
       , par_job_id
       , var_job_owner_sid
       , var_retval;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  /* Get current maximum step id */
  SELECT COALESCE(MAX(step_id), 0)
    INTO var_max_step_id
    FROM aws_sqlserver_ext.sysjobsteps
   WHERE (job_id = par_job_id);
    
  /* Check step id */
  IF (par_step_id < 0) OR (par_step_id > var_max_step_id) 
  THEN
    SELECT CONCAT('0 (all steps) ..', CAST (var_max_step_id AS VARCHAR(1)))
      INTO var_valid_range;
     RAISE 'The specified "%" is invalid (valid values are: %).', 'step_id', var_valid_range USING ERRCODE := '50000';
     returncode := 1;
     RETURN;
        /* Failure */
    END IF;
    
    /* BEGIN TRANSACTION */
    /* Delete either the specified step or ALL the steps (if step id is 0) */
    IF (par_step_id = 0) 
    THEN
      DELETE FROM aws_sqlserver_ext.sysjobsteps
       WHERE (job_id = par_job_id);
    ELSE
      DELETE FROM aws_sqlserver_ext.sysjobsteps
       WHERE (job_id = par_job_id) AND (step_id = par_step_id);
    END IF;

    IF (par_step_id <> 0) 
    THEN
      /* Adjust step id's */
      UPDATE aws_sqlserver_ext.sysjobsteps
         SET step_id = step_id - 1
       WHERE (step_id > par_step_id) 
         AND (job_id = par_job_id);
         
      /* Clean up OnSuccess/OnFail references */
      UPDATE aws_sqlserver_ext.sysjobsteps
         SET on_success_step_id = on_success_step_id - 1
       WHERE (on_success_step_id > par_step_id) AND (job_id = par_job_id);
       
      UPDATE aws_sqlserver_ext.sysjobsteps
         SET on_fail_step_id = on_fail_step_id - 1
       WHERE (on_fail_step_id > par_step_id) AND (job_id = par_job_id);
       
      /* Quit With Success */        
      UPDATE aws_sqlserver_ext.sysjobsteps 
         SET on_success_step_id = 0
           , on_success_action = 1 
       WHERE (on_success_step_id = par_step_id) 
         AND (job_id = par_job_id);
        
      /* Quit With Failure */
      UPDATE aws_sqlserver_ext.sysjobsteps
         SET on_fail_step_id = 0
           , on_fail_action = 2
       WHERE (on_fail_step_id = par_step_id) AND (job_id = par_job_id);
    END IF;
    
    /* Update the job's version/last-modified information */
    UPDATE aws_sqlserver_ext.sysjobs
       SET version_number = version_number + 1
         --, date_modified = GETDATE() /
     WHERE (job_id = par_job_id);
     
    /* COMMIT TRANSACTION */
    
    /* Success */
    returncode := 0;
    RETURN;
END;
]]></complex-attribute>
                        <category _I_D="e75c00ba-0708-480a-83d0-67a526b9680e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="75aaee47-9af3-4600-900e-e9ba7d218d47" name="sp_delete_schedule" is-trigger-function="0" unique-function-name="sp_delete_schedule" is-aggregate="f" language-name="plpgsql" context="sp_delete_schedule" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,smallint,smallint,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_schedule_id integer DEFAULT NULL::integer, par_schedule_name character varying DEFAULT NULL::character varying, par_force_delete smallint DEFAULT 0, par_automatic_post smallint DEFAULT 1, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="4" function-id="23997" volatility="VOLATILE" is-window="f" function-identity-arguments="par_schedule_id integer, par_schedule_name character varying, par_force_delete smallint, par_automatic_post smallint, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_delete_schedule(par_schedule_id integer, par_schedule_name character varying, par_force_delete smallint, par_automatic_post smallint, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_job_count INT;
BEGIN
  /* check if there are jobs using this schedule */
  SELECT COUNT(*)
    INTO var_job_count
    FROM aws_sqlserver_ext.sysjobschedules
   WHERE (schedule_id = par_schedule_id);
   
  /* If we aren't force deleting the schedule make sure no jobs are using it */
  IF ((par_force_delete = 0) AND (var_job_count > 0)) 
  THEN /* Failure */
    RAISE 'The schedule was not deleted because it is being used by one or more jobs.' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* OK to delete the job - schedule link */
  DELETE FROM aws_sqlserver_ext.sysjobschedules
   WHERE schedule_id = par_schedule_id;
   
  /* OK to delete the schedule */
  DELETE FROM aws_sqlserver_ext.sysschedules
   WHERE schedule_id = par_schedule_id;
   
  /* 0 means success */
  returncode := var_retval;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="828264af-21e8-414a-bf21-33cf451c721d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1a2d1eea-1d1b-4a7c-a09a-db488c11793f" name="sp_detach_schedule" is-trigger-function="0" unique-function-name="sp_detach_schedule" is-aggregate="f" language-name="plpgsql" context="sp_detach_schedule" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,integer,character varying,smallint,smallint,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_schedule_id integer DEFAULT NULL::integer, par_schedule_name character varying DEFAULT NULL::character varying, par_delete_unused_schedule smallint DEFAULT 0, par_automatic_post smallint DEFAULT 1, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="6" function-id="23998" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_job_name character varying, par_schedule_id integer, par_schedule_name character varying, par_delete_unused_schedule smallint, par_automatic_post smallint, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_detach_schedule(par_job_id integer, par_job_name character varying, par_schedule_id integer, par_schedule_name character varying, par_delete_unused_schedule smallint, par_automatic_post smallint, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_sched_owner_sid CHAR(85);
  var_job_owner_sid CHAR(85);
BEGIN
  /* Check that we can uniquely identify the job */
  SELECT t.par_job_name
       , t.par_job_id
       , t.par_owner_sid
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_identifiers(
         '@job_name'
       , '@job_id'
       , par_job_name
       , par_job_id
       , 'TEST'
       , var_job_owner_sid
       ) t
    INTO par_job_name
       , par_job_id
       , var_job_owner_sid
       , var_retval;

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  /* Check that we can uniquely identify the schedule */
  SELECT t.par_schedule_name
       , t.par_schedule_id
       , t.par_owner_sid
       , t.par_orig_server_id
       , t.returncode
    FROM aws_sqlserver_ext.sp_verify_schedule_identifiers(
         '@schedule_name' /* @name_of_name_parameter */
       , '@schedule_id' /* @name_of_id_parameter */
       , par_schedule_name /* @schedule_name */
       , par_schedule_id /* @schedule_id */
       , var_sched_owner_sid /* @owner_sid */
       , NULL /* @orig_server_id */
       , par_job_id
       ) t
    INTO par_schedule_name
       , par_schedule_id
       , var_sched_owner_sid
       , var_retval;
       -- job_id_filter

  IF (var_retval <> 0) THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  /* If the record doesn't exist raise an error */
  IF (NOT EXISTS (
    SELECT * 
      FROM aws_sqlserver_ext.sysjobschedules
     WHERE (schedule_id = par_schedule_id) 
       AND (job_id = par_job_id))) 
  THEN /* Failure */
    RAISE 'The specified schedule name "%s" is not associated with the job "%s".', par_schedule_name, par_job_name USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  SELECT t.returncode 
    FROM aws_sqlserver_ext.sp_aws_del_jobschedule(par_job_id, par_schedule_id) t
    INTO var_retval;  

  DELETE FROM aws_sqlserver_ext.sysjobschedules
   WHERE (job_id = par_job_id) 
     AND (schedule_id = par_schedule_id);
     
  SELECT /* @@ERROR */ 0 -- ZZZ
    INTO var_retval;
    
  /* delete the schedule if requested and it isn't referenced */
  IF (var_retval = 0 AND par_delete_unused_schedule = 1) 
  THEN
    IF (NOT EXISTS (
      SELECT * 
        FROM aws_sqlserver_ext.sysjobschedules
       WHERE (schedule_id = par_schedule_id))) 
    THEN
      DELETE FROM aws_sqlserver_ext.sysschedules
       WHERE (schedule_id = par_schedule_id);
    END IF;
  END IF;
  
  /* Update the job's version/last-modified information */
  /* 
  UPDATE aws_sqlserver_ext.sysjobs
     SET version_number = version_number + 1
       -- , date_modified = GETDATE()
   WHERE (job_id = par_job_id); 
  */

  -- PERFORM aws_sqlserver_ext.sp_delete_job (par_job_id := par_job_id);  

  /* 0 means success */   
  returncode := var_retval;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="f28b0036-58dc-426a-a4a2-8db7f9bbc270" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d3c9e1e9-06b6-4079-ad94-dcfb9e2a72e3" name="sp_get_dbmail" is-trigger-function="0" unique-function-name="sp_get_dbmail" is-aggregate="f" language-name="plpgsql" context="sp_get_dbmail" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,text" is-returning-set="f" ret-datatype="record" function-arguments="OUT par_mail_id integer, OUT par_mail_data text" schema-id="23774" function-type="RET_SCALAR" count-arguments="0" function-id="23999" volatility="VOLATILE" is-window="f" function-identity-arguments="OUT par_mail_id integer, OUT par_mail_data text" overload-function-count="1" proc-language="plpgsql" function-signature="sp_get_dbmail(OUT par_mail_id integer, OUT par_mail_data text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_mailitem_id INTEGER;
  var_xml TEXT;
  var_rc INTEGER;
BEGIN

  SELECT mailitem_id
    INTO var_mailitem_id
    FROM aws_sqlserver_ext.sysmail_mailitems
   WHERE sent_status = 0
   ORDER BY mailitem_id ASC
   LIMIT 1;

  IF var_mailitem_id IS NULL THEN

    RAISE 'E-mail messages are missing.' USING ERRCODE := '50000';

    RETURN;

  END IF;

  UPDATE aws_sqlserver_ext.sysmail_mailitems
     SET sent_status = 1
   WHERE mailitem_id = var_mailitem_id;

  SELECT t.par_mail_data,
    t.returncode
  INTO var_xml, var_rc
  FROM aws_sqlserver_ext.sysmail_dbmail_json(var_mailitem_id) t; 

  IF var_rc <> 0 THEN

    RETURN;

  END IF;

  par_mail_id := var_mailitem_id;
  par_mail_data := var_xml;

END;
]]></complex-attribute>
                        <category _I_D="ad7cb146-2e4d-48d6-a052-0c0bf490be28" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0c1e2b38-c137-49a5-aa4d-40e3a704ae90" name="sp_job_log" is-trigger-function="0" unique-function-name="sp_job_log" is-aggregate="f" language-name="plpgsql" context="sp_job_log" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer,character varying" is-returning-set="f" ret-datatype="void" function-arguments="pid integer, pstatus integer, pmessage character varying" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="24049" volatility="VOLATILE" is-window="f" function-identity-arguments="pid integer, pstatus integer, pmessage character varying" overload-function-count="1" proc-language="plpgsql" function-signature="sp_job_log(pid integer, pstatus integer, pmessage character varying)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  PERFORM aws_sqlserver_ext.update_job (pid, pmessage);

  -- INSERT INTO ms_test.jobs_log(id, t, status, message)
  -- VALUES (pid, CURRENT_TIMESTAMP, pstatus, pmessage);
END;
]]></complex-attribute>
                        <category _I_D="48f28d74-999d-4904-8470-fc9388e14818" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0c69215e-1c62-481e-a47a-67344ce3ba98" name="sp_schedule_to_cron" is-trigger-function="0" unique-function-name="sp_schedule_to_cron" is-aggregate="f" language-name="plpgsql" context="sp_schedule_to_cron" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer,character varying" is-returning-set="f" ret-datatype="varchar" function-arguments="par_job_id integer, par_schedule_id integer, OUT cron_expression character varying" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24005" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_schedule_id integer, OUT cron_expression character varying" overload-function-count="1" proc-language="plpgsql" function-signature="sp_schedule_to_cron(par_job_id integer, par_schedule_id integer, OUT cron_expression character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_enabled INTEGER;
  var_freq_type INTEGER;
  var_freq_interval INTEGER;
  var_freq_subday_type INTEGER;
  var_freq_subday_interval INTEGER;
  var_freq_relative_interval INTEGER;
  var_freq_recurrence_factor INTEGER;
  var_active_start_date INTEGER;
  var_active_end_date INTEGER;
  var_active_start_time INTEGER;
  var_active_end_time INTEGER;

  var_next_run_date date;
  var_next_run_time time;
  var_next_run_dt timestamp;

  var_tmp_interval varchar(50);
  var_current_dt timestamp;
  var_next_dt timestamp;
BEGIN

  SELECT enabled
       , freq_type
       , freq_interval
       , freq_subday_type
       , freq_subday_interval
       , freq_relative_interval
       , freq_recurrence_factor
       , active_start_date
       , active_end_date
       , active_start_time
       , active_end_time
    FROM aws_sqlserver_ext.sysschedules
    INTO var_enabled
       , var_freq_type
       , var_freq_interval
       , var_freq_subday_type
       , var_freq_subday_interval
       , var_freq_relative_interval
       , var_freq_recurrence_factor
       , var_active_start_date
       , var_active_end_date
       , var_active_start_time
       , var_active_end_time
   WHERE schedule_id = par_schedule_id;

  /* if enabled = 0 return */
  CASE var_freq_type
    WHEN 1 THEN
      NULL;

    WHEN 4 THEN
    BEGIN
        cron_expression :=
        CASE
          /* WHEN var_freq_subday_type = 1 THEN var_freq_subday_interval::character varying || ' At the specified time'  -- start time */
          /* WHEN var_freq_subday_type = 2 THEN var_freq_subday_interval::character varying || ' second'  -- ADD var_freq_subday_interval SECOND */
          WHEN var_freq_subday_type = 4 THEN format('cron(*/%s * * * ? *)', var_freq_subday_interval::character varying) /* ADD var_freq_subday_interval MINUTE */
          WHEN var_freq_subday_type = 8 THEN format('cron(0 */%s * * ? *)', var_freq_subday_interval::character varying) /* ADD var_freq_subday_interval HOUR */
          ELSE ''
        END;
    END;

    WHEN 8 THEN
      NULL;

    WHEN 16 THEN
      NULL;

    WHEN 32 THEN
      NULL;

    WHEN 64 THEN
      NULL;

    WHEN 128 THEN
     NULL;
     
  END CASE;

 -- return cron_expression;

END;
]]></complex-attribute>
                        <category _I_D="64064a67-28ae-4d86-b115-6ba1d980f359" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e64cb96e-6908-4a2b-b611-7f3efa934615" name="sp_send_dbmail" is-trigger-function="0" unique-function-name="sp_send_dbmail" is-aggregate="f" language-name="plpgsql" context="sp_send_dbmail" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,text,text,text,character varying,text,character varying,character varying,character varying,text,text,character varying,smallint,character varying,smallint,integer,character varying,smallint,smallint,smallint,smallint,integer,text,text,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_profile_name character varying DEFAULT NULL::character varying, par_recipients text DEFAULT NULL::text, par_copy_recipients text DEFAULT NULL::text, par_blind_copy_recipients text DEFAULT NULL::text, par_subject character varying DEFAULT NULL::character varying, par_body text DEFAULT NULL::text, par_body_format character varying DEFAULT NULL::character varying, par_importance character varying DEFAULT 'NORMAL'::character varying, par_sensitivity character varying DEFAULT 'NORMAL'::character varying, par_file_attachments text DEFAULT NULL::text, par_query text DEFAULT NULL::text, par_execute_query_database character varying DEFAULT NULL::character varying, par_attach_query_result_as_file smallint DEFAULT 0, par_query_attachment_filename character varying DEFAULT NULL::character varying, par_query_result_header smallint DEFAULT 1, par_query_result_width integer DEFAULT 256, par_query_result_separator character varying DEFAULT ' '::character varying, par_exclude_query_output smallint DEFAULT 0, par_append_query_error smallint DEFAULT 0, par_query_no_truncate smallint DEFAULT 0, par_query_result_no_padding smallint DEFAULT 0, OUT par_mailitem_id integer, par_from_address text DEFAULT NULL::text, par_reply_to text DEFAULT NULL::text, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="23" function-id="24000" volatility="VOLATILE" is-window="f" function-identity-arguments="par_profile_name character varying, par_recipients text, par_copy_recipients text, par_blind_copy_recipients text, par_subject character varying, par_body text, par_body_format character varying, par_importance character varying, par_sensitivity character varying, par_file_attachments text, par_query text, par_execute_query_database character varying, par_attach_query_result_as_file smallint, par_query_attachment_filename character varying, par_query_result_header smallint, par_query_result_width integer, par_query_result_separator character varying, par_exclude_query_output smallint, par_append_query_error smallint, par_query_no_truncate smallint, par_query_result_no_padding smallint, OUT par_mailitem_id integer, par_from_address text, par_reply_to text, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_send_dbmail(par_profile_name character varying, par_recipients text, par_copy_recipients text, par_blind_copy_recipients text, par_subject character varying, par_body text, par_body_format character varying, par_importance character varying, par_sensitivity character varying, par_file_attachments text, par_query text, par_execute_query_database character varying, par_attach_query_result_as_file smallint, par_query_attachment_filename character varying, par_query_result_header smallint, par_query_result_width integer, par_query_result_separator character varying, par_exclude_query_output smallint, par_append_query_error smallint, par_query_no_truncate smallint, par_query_result_no_padding smallint, OUT par_mailitem_id integer, par_from_address text, par_reply_to text, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_profile_id INTEGER;
  var_rc INTEGER DEFAULT 0;
  var_mail_data TEXT;
  var_sent_result JSON;
  var_server_name VARCHAR(255);
BEGIN

  /* Get primary account if profile name is supplied */
  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp
    (
      NULL::integer,
      par_profile_name,
      0::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_profile_id, var_rc;

  IF var_rc <> 0 THEN

    returncode := var_rc;
    RETURN;

  END IF;

  /* Attach results must be specified */
  IF par_attach_query_result_as_file IS NULL THEN

    RAISE 'Parameter "%" must be specified. This parameter cannot be NULL.', 'attach_query_result_as_file' USING ERRCODE := '50000';
    returncode := 2;
    RETURN;

  END IF;

  /* No output must be specified */
  IF par_exclude_query_output IS NULL THEN

    RAISE 'Parameter "%" must be specified. This parameter cannot be NULL.', 'exclude_query_output' USING ERRCODE := '50000';
    returncode := 3;
    RETURN;

  END IF;

  /* No header must be specified */
  IF par_query_result_header IS NULL THEN

    RAISE 'Parameter "%" must be specified. This parameter cannot be NULL.', 'query_result_header' USING ERRCODE := '50000';
    returncode := 4;
    RETURN;

  END IF;

  /* Check if query_result_separator is specifed */
  IF par_query_result_separator IS NULL OR LENGTH(par_query_result_separator) = 0 THEN

    RAISE 'Parameter "%" must be specified. This parameter cannot be NULL.', 'query_result_separator' USING ERRCODE := '50000';
    returncode := 5;
    RETURN;

  END IF;
  
  /* Echo error must be specified */
  IF par_append_query_error IS NULL THEN

    RAISE 'Parameter "%" must be specified. This parameter cannot be NULL.', 'append_query_error' USING ERRCODE := '50000';
    returncode := 6;
    RETURN;

  END IF;
  
  /* @body_format can be TEXT (default) or HTML */
  IF par_body_format IS NULL THEN

    par_body_format := 'TEXT';

  ELSE

    par_body_format := UPPER(par_body_format);

    IF par_body_format NOT IN ('TEXT', 'HTML') THEN

      RAISE 'Parameter mailformat does not support the value "%". The mail format must be TEXT or HTML.', par_body_format USING ERRCODE := '50000';
      returncode := 13;
      RETURN;

    END IF;
  END IF;
  
  /* Importance must be specified */
  IF par_importance IS NULL THEN

    RAISE 'Parameter "%" must be specified. This parameter cannot be NULL.', 'importance' USING ERRCODE := '50000';
    returncode := 15;
    RETURN;

  END IF;

  par_importance := UPPER(par_importance);
  
  /* Importance must be one of the predefined values */
  IF par_importance NOT IN ('LOW', 'NORMAL', 'HIGH') THEN

    RAISE 'Parameter importance does not support the value "%". Mail importance must be one of LOW, NORMAL, or HIGH.', par_importance USING ERRCODE := '50000';
    returncode := 16;
    RETURN;

  END IF;
  
  /* Sensitivity must be specified */
  IF par_sensitivity IS NULL 
  THEN
    RAISE 'Parameter "%" must be specified. This parameter cannot be NULL.', 'sensitivity' USING ERRCODE := '50000';
    returncode := 17;
    RETURN;
  END IF;
  par_sensitivity := UPPER(par_sensitivity);
  
  /* Sensitivity must be one of predefined values */
  IF par_sensitivity NOT IN ('NORMAL', 'PERSONAL', 'PRIVATE', 'CONFIDENTIAL') THEN

    RAISE 'Parameter sensitivity does not support the value "%". Mail sensitivity must be one of NORMAL, PERSONAL, PRIVATE, or CONFIDENTIAL.', par_sensitivity USING ERRCODE := '50000';
    returncode := 18;
    RETURN;

  END IF;
  
  /* Message body cannot be null. Atleast one of message, subject, query, */
  /* attachments must be specified. */
  IF (par_body IS NULL AND par_query IS NULL AND par_file_attachments IS NULL AND par_subject IS NULL)
    OR
    (
      (LENGTH(par_body) IS NULL OR LENGTH(par_body) <= 0) AND
      (LENGTH(par_query) IS NULL OR LENGTH(par_query) <= 0) AND
      (LENGTH(par_file_attachments) IS NULL OR LENGTH(par_file_attachments) <= 0) AND
      (LENGTH(par_subject) IS NULL OR LENGTH(par_subject) <= 0)
    ) THEN

    RAISE 'At least one of the following parameters must be specified. "%".', 'body, query, file_attachments, subject' USING ERRCODE := '50000';
    returncode := 19;
    RETURN;

  ELSE

    IF par_subject IS NULL OR LENGTH(par_subject) <= 0 THEN

      par_subject := 'Database Message';

    END IF;

  END IF;
  
  /* Recipients cannot be empty. Atleast one of the To, Cc, Bcc must be specified */
  IF (
    (par_recipients IS NULL AND par_copy_recipients IS NULL AND par_blind_copy_recipients IS NULL) OR
    (
      (LENGTH(par_recipients) IS NULL OR LENGTH(par_recipients) <= 0) AND
      (LENGTH(par_copy_recipients) IS NULL OR LENGTH(par_copy_recipients) <= 0) AND
      (LENGTH(par_blind_copy_recipients) IS NULL OR LENGTH(par_blind_copy_recipients) <= 0)
    )
  ) THEN

    RAISE 'At least one of the following parameters must be specified. "%".', 'recipients, copy_recipients, blind_copy_recipients' USING ERRCODE := '50000';
    returncode := 20;
    RETURN;

  END IF;

  --[sysmail_OutMailAttachmentEncodingMustBeValid] CHECK [attachment_encoding] IN ['UUENCODE', 'BINHEX', 'S/MIME', 'MIME']

  SELECT t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_addressparams_sp
    (
      par_address := par_recipients
    , par_parameter_name := 'par_recipients'
    ) t
    INTO var_rc;

  IF var_rc <> 0 THEN

    returncode := var_rc;
    RETURN;

  END IF;

  SELECT t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_addressparams_sp
    (
      par_address := par_copy_recipients
    , par_parameter_name := 'par_copy_recipients'
    ) t
    INTO var_rc;

  IF var_rc <> 0 THEN

    returncode := var_rc;
    RETURN;

  END IF;

  SELECT t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_addressparams_sp
    (
      par_address => par_blind_copy_recipients
    , par_parameter_name => 'par_blind_copy_recipients'
    ) t
    INTO var_rc;

  IF var_rc <> 0 THEN

    returncode := var_rc;
    RETURN;

  END IF;

  SELECT t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_addressparams_sp
    (
      par_address := par_reply_to
    , par_parameter_name := 'par_reply_to'
    ) t
    INTO var_rc;

  IF var_rc <> 0 THEN

    returncode := var_rc;
    RETURN;

  END IF;
  
  /* If query is not specified, attach results and no header cannot be true. */
  IF (par_query IS NULL OR LENGTH(par_query) <= 0) AND par_attach_query_result_as_file = 1 THEN

    RAISE 'Parameter [attach_query_result_as_file] cannot be 1 (true) when no value is specified for parameter [query]. A query must be specified to attach the results of the query.' USING ERRCODE := '50000';
    returncode := 21;
    RETURN;

  END IF;
  
  /* BEGIN TRAN @procName */
  /* SET @tranStartedBool = 1 */
  /* Store complete mail message for history/status purposes */
  
  INSERT 
    INTO aws_sqlserver_ext.sysmail_mailitems
    (
         profile_id
       , recipients
       , copy_recipients
       , blind_copy_recipients
       , subject
       , body
       , body_format
       , importance
       , sensitivity
       , file_attachments
       , attachment_encoding
       , query
       , execute_query_database
       , attach_query_result_as_file
       , query_result_header
       , query_result_width
       , query_result_separator
       , exclude_query_output
       , append_query_error
       , send_request_date
       , from_address
       , reply_to
    )
    VALUES
    (
         var_profile_id
       , par_recipients
       , par_copy_recipients
       , par_blind_copy_recipients
       , par_subject
       , par_body
       , par_body_format
       , par_importance
       , par_sensitivity
       , par_file_attachments
       , 'MIME'
       , par_query
       , par_execute_query_database
       , par_attach_query_result_as_file
       , par_query_result_header
       , par_query_result_width
       , par_query_result_separator
       , par_exclude_query_output
       , par_append_query_error
       , now()
       , par_from_address
       , par_reply_to
    );

  SELECT 0 /* @@ERROR, */
       , LASTVAL() /* SCOPE_IDENTITY() */
    INTO var_rc
       , par_mailitem_id;

  SELECT par_mail_data, par_server_name
  FROM aws_sqlserver_ext.sysmail_dbmail_json(par_mailitem_id)
  INTO var_mail_data, var_server_name;

  var_sent_result := aws_sqlserver_ext.awslambda_fn
  (
    var_server_name,
    var_mail_data::JSON
  );

  PERFORM aws_sqlserver_ext.sp_set_dbmail
  (
    par_mailitem_id,
    1::INTEGER,
    var_sent_result::TEXT
  );
  
  /* ExitProc: */
  /* Always delete query and attactment transfer records. */
  /* Note: Query results can also be returned in the sysmail_attachments_transfer table */
  /* DELETE sysmail_attachments_transfer WHERE uid = @temp_table_uid */
  /* DELETE sysmail_query_transfer WHERE uid = @temp_table_uid */
  /* Raise an error it the query execution fails */
  /* This will only be the case when @append_query_error is set to 0 (false) */
  /* IF( (@RetErrorMsg IS NOT NULL) AND (@exclude_query_output=0) ) */
  /* BEGIN */
  /* RAISERROR('Query execution failed: %s', -1, -1, @RetErrorMsg) */
  /* END */
  
  returncode := var_rc;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="384d2ce3-4b2d-43e1-b599-6fe8fef564e2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="fb51df0b-ddec-4a2b-ad69-cc271619330b" name="sp_sequence_get_range" is-trigger-function="0" unique-function-name="sp_sequence_get_range" is-aggregate="f" language-name="plpgsql" context="sp_sequence_get_range" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,bigint,bigint,bigint,bigint,bigint,bigint,bigint" is-returning-set="f" ret-datatype="record" function-arguments="par_sequence_name text, par_range_size bigint, OUT par_range_first_value bigint, OUT par_range_last_value bigint, OUT par_range_cycle_count bigint, OUT par_sequence_increment bigint, OUT par_sequence_min_value bigint, OUT par_sequence_max_value bigint" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24002" volatility="VOLATILE" is-window="f" function-identity-arguments="par_sequence_name text, par_range_size bigint, OUT par_range_first_value bigint, OUT par_range_last_value bigint, OUT par_range_cycle_count bigint, OUT par_sequence_increment bigint, OUT par_sequence_min_value bigint, OUT par_sequence_max_value bigint" overload-function-count="1" proc-language="plpgsql" function-signature="sp_sequence_get_range(par_sequence_name text, par_range_size bigint, OUT par_range_first_value bigint, OUT par_range_last_value bigint, OUT par_range_cycle_count bigint, OUT par_sequence_increment bigint, OUT par_sequence_min_value bigint, OUT par_sequence_max_value bigint)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  v_is_cycle character varying(3);
  v_current_value bigint;
begin  
  select s.minimum_value, s.maximum_value, s.increment, s.cycle_option 
    from information_schema.sequences s 
    where s.sequence_name = $1 
    into par_sequence_min_value, par_sequence_max_value, par_sequence_increment, v_is_cycle; 
    
  par_range_first_value := aws_sqlserver_ext.get_sequence_value(par_sequence_name);

  if par_range_first_value > par_sequence_min_value then 
    par_range_first_value := par_range_first_value + 1;
  end if;

  if v_is_cycle = 'YES' then 
    par_range_cycle_count := 0;
  end if;
    
  for i in 1..$2 loop
    select nextval(par_sequence_name) into v_current_value;
    if (v_is_cycle = 'YES') and (v_current_value = par_sequence_min_value) and (par_range_first_value <> v_current_value) then 
      par_range_cycle_count := par_range_cycle_count + 1;
    end if;  
  end loop;

  par_range_last_value := aws_sqlserver_ext.get_sequence_value(par_sequence_name);
end;
]]></complex-attribute>
                        <category _I_D="2a8053cd-307d-4863-aa59-5ad4034b2bd5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c0fda78d-b650-4cc5-96a3-0f56212e03ad" name="sp_set_dbmail" is-trigger-function="0" unique-function-name="sp_set_dbmail" is-aggregate="f" language-name="plpgsql" context="sp_set_dbmail" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer,text" is-returning-set="f" ret-datatype="void" function-arguments="par_mail_id integer, par_sent_status integer, par_message text" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="24003" volatility="VOLATILE" is-window="f" function-identity-arguments="par_mail_id integer, par_sent_status integer, par_message text" overload-function-count="1" proc-language="plpgsql" function-signature="sp_set_dbmail(par_mail_id integer, par_sent_status integer, par_message text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  /* event_type
  3                           -- error
  2 AND @loggingLevelInt >= 2 -- warning with extended logging
  1 AND @loggingLevelInt >= 2 -- info with extended logging
  0 AND @loggingLevelInt >= 3 -- success with verbose logging
  */
  IF par_sent_status = 1 /* ok */ THEN

    UPDATE aws_sqlserver_ext.sysmail_mailitems
       SET sent_status = 2
         , sent_date = NOW()
     WHERE mailitem_id = par_mail_id;
     
     INSERT INTO aws_sqlserver_ext.sysmail_log (event_type, log_date, description, mailitem_id)
     VALUES (0, NOW(), par_message, par_mail_id);

  ELSE

    IF par_sent_status = 1 /* failed */ THEN

      UPDATE aws_sqlserver_ext.sysmail_mailitems
         SET sent_status = -1
           , sent_date = NOW()
       WHERE mailitem_id = par_mail_id;
       
      INSERT INTO aws_sqlserver_ext.sysmail_log (event_type, log_date, description, mailitem_id)
      VALUES (3, NOW(), par_message, par_mail_id);

    END IF;

  END IF;

END;
]]></complex-attribute>
                        <category _I_D="a15012d2-a247-4297-8572-4cff5c1eb5f7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a494f99c-a2d9-4ad4-83e5-9243b302a005" name="sp_set_next_run" is-trigger-function="0" unique-function-name="sp_set_next_run" is-aggregate="f" language-name="plpgsql" context="sp_set_next_run" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer" is-returning-set="f" ret-datatype="void" function-arguments="par_job_id integer, par_schedule_id integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24004" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_schedule_id integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_set_next_run(par_job_id integer, par_schedule_id integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_enabled INTEGER;
  var_freq_type INTEGER;
  var_freq_interval INTEGER;
  var_freq_subday_type INTEGER;
  var_freq_subday_interval INTEGER;
  var_freq_relative_interval INTEGER;
  var_freq_recurrence_factor INTEGER;
  var_active_start_date INTEGER;
  var_active_end_date INTEGER;
  var_active_start_time INTEGER;
  var_active_end_time INTEGER;

  var_next_run_date date;
  var_next_run_time time;
  var_next_run_dt timestamp;

  var_tmp_interval varchar(50);
  var_current_dt timestamp;
  var_next_dt timestamp;
BEGIN

  SELECT enabled
       , freq_type
       , freq_interval
       , freq_subday_type
       , freq_subday_interval
       , freq_relative_interval
       , freq_recurrence_factor
       , active_start_date
       , active_end_date
       , active_start_time
       , active_end_time
    FROM aws_sqlserver_ext.sysschedules
    INTO var_enabled
       , var_freq_type
       , var_freq_interval
       , var_freq_subday_type
       , var_freq_subday_interval
       , var_freq_relative_interval
       , var_freq_recurrence_factor
       , var_active_start_date
       , var_active_end_date
       , var_active_start_time
       , var_active_end_time
   WHERE schedule_id = par_schedule_id;

  SELECT next_run_date
       , next_run_time
    FROM aws_sqlserver_ext.sysjobschedules
    INTO var_next_run_date
       , var_next_run_time
   WHERE schedule_id = par_schedule_id
     AND job_id = par_job_id;

  /* if enabled = 0 return */
  CASE var_freq_type
    WHEN 1 THEN
      NULL;

    WHEN 4 THEN
    BEGIN
      /* NULL start date & time or now */
      /* start date + start time or now() */
      IF (var_next_run_date IS NULL OR var_next_run_time IS NULL)
      THEN
        var_current_dt := now()::timestamp;

        UPDATE aws_sqlserver_ext.sysjobschedules
           SET next_run_date = var_current_dt::date
             , next_run_time = var_current_dt::time
         WHERE schedule_id = par_schedule_id
           AND job_id = par_job_id;
        RETURN;
      ELSE
        var_tmp_interval :=
        CASE
          /* WHEN var_freq_subday_type = 1 THEN var_freq_subday_interval::character varying || ' At the specified time'  -- start time */
          WHEN var_freq_subday_type = 2 THEN var_freq_subday_interval::character varying || ' second'  /* ADD var_freq_subday_interval SECOND */
          WHEN var_freq_subday_type = 4 THEN var_freq_subday_interval::character varying || ' minute'  /* ADD var_freq_subday_interval MINUTE */
          WHEN var_freq_subday_type = 8 THEN var_freq_subday_interval::character varying || ' hour'    /* ADD var_freq_subday_interval HOUR */
          ELSE ''
        END;

        var_next_dt := (var_next_run_date::date + var_next_run_time::time)::timestamp + var_tmp_interval::INTERVAL;
        UPDATE aws_sqlserver_ext.sysjobschedules
           SET next_run_date = var_next_dt::date
             , next_run_time = var_next_dt::time
         WHERE schedule_id = par_schedule_id
           AND job_id = par_job_id;
        RETURN;
      END IF;
    END;

    WHEN 8 THEN
      NULL;

    WHEN 16 THEN
      NULL;

    WHEN 32 THEN
      NULL;

    WHEN 64 THEN
      NULL;

    WHEN 128 THEN
     NULL;
     
  END CASE;

END;
]]></complex-attribute>
                        <category _I_D="9dfd14c6-7285-46b8-9b8d-0bbc18ee58d2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="87a425f5-1b00-4743-a380-8159f529d37a" name="sp_update_job" is-trigger-function="0" unique-function-name="sp_update_job" is-aggregate="f" language-name="plpgsql" context="sp_update_job" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,character varying,smallint,character varying,integer,character varying,character varying,integer,integer,integer,integer,character varying,character varying,character varying,integer,smallint,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_new_name character varying DEFAULT NULL::character varying, par_enabled smallint DEFAULT NULL::smallint, par_description character varying DEFAULT NULL::character varying, par_start_step_id integer DEFAULT NULL::integer, par_category_name character varying DEFAULT NULL::character varying, par_owner_login_name character varying DEFAULT NULL::character varying, par_notify_level_eventlog integer DEFAULT NULL::integer, par_notify_level_email integer DEFAULT NULL::integer, par_notify_level_netsend integer DEFAULT NULL::integer, par_notify_level_page integer DEFAULT NULL::integer, par_notify_email_operator_name character varying DEFAULT NULL::character varying, par_notify_netsend_operator_name character varying DEFAULT NULL::character varying, par_notify_page_operator_name character varying DEFAULT NULL::character varying, par_delete_level integer DEFAULT NULL::integer, par_automatic_post smallint DEFAULT 1, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="17" function-id="24008" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_job_name character varying, par_new_name character varying, par_enabled smallint, par_description character varying, par_start_step_id integer, par_category_name character varying, par_owner_login_name character varying, par_notify_level_eventlog integer, par_notify_level_email integer, par_notify_level_netsend integer, par_notify_level_page integer, par_notify_email_operator_name character varying, par_notify_netsend_operator_name character varying, par_notify_page_operator_name character varying, par_delete_level integer, par_automatic_post smallint, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_update_job(par_job_id integer, par_job_name character varying, par_new_name character varying, par_enabled smallint, par_description character varying, par_start_step_id integer, par_category_name character varying, par_owner_login_name character varying, par_notify_level_eventlog integer, par_notify_level_email integer, par_notify_level_netsend integer, par_notify_level_page integer, par_notify_email_operator_name character varying, par_notify_netsend_operator_name character varying, par_notify_page_operator_name character varying, par_delete_level integer, par_automatic_post smallint, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    var_retval INT;
    var_category_id INT;
    var_notify_email_operator_id INT;
    var_notify_netsend_operator_id INT;
    var_notify_page_operator_id INT;
    var_owner_sid CHAR(85);
    var_alert_id INT;
    var_cached_attribute_modified INT;
    var_is_sysadmin INT;
    var_current_owner VARCHAR(128);
    var_enable_only_used INT;
    var_x_new_name VARCHAR(128);
    var_x_enabled SMALLINT;
    var_x_description VARCHAR(512);
    var_x_start_step_id INT;
    var_x_category_name VARCHAR(128);
    var_x_category_id INT;
    var_x_owner_sid CHAR(85);
    var_x_notify_level_eventlog INT;
    var_x_notify_level_email INT;
    var_x_notify_level_netsend INT;
    var_x_notify_level_page INT;
    var_x_notify_email_operator_name VARCHAR(128);
    var_x_notify_netsnd_operator_name VARCHAR(128);
    var_x_notify_page_operator_name VARCHAR(128);
    var_x_delete_level INT;
    var_x_originating_server_id INT;
    var_x_master_server SMALLINT;
BEGIN
    /* Not updatable */
    /* Remove any leading/trailing spaces from parameters (except @owner_login_name) */
    SELECT
        LTRIM(RTRIM(par_job_name))
        INTO par_job_name;
    SELECT
        LTRIM(RTRIM(par_new_name))
        INTO par_new_name;
    SELECT
        LTRIM(RTRIM(par_description))
        INTO par_description;
    SELECT
        LTRIM(RTRIM(par_category_name))
        INTO par_category_name;
    SELECT
        LTRIM(RTRIM(par_notify_email_operator_name))
        INTO par_notify_email_operator_name;
    SELECT
        LTRIM(RTRIM(par_notify_netsend_operator_name))
        INTO par_notify_netsend_operator_name;
    SELECT
        LTRIM(RTRIM(par_notify_page_operator_name))
        INTO par_notify_page_operator_name
    /* Are we modifying an attribute which SQLServerAgent caches? */;

    IF ((par_new_name IS NOT NULL) OR (par_enabled IS NOT NULL) OR (par_start_step_id IS NOT NULL) OR (par_owner_login_name IS NOT NULL) OR (par_notify_level_eventlog IS NOT NULL) OR (par_notify_level_email IS NOT NULL) OR (par_notify_level_netsend IS NOT NULL) OR (par_notify_level_page IS NOT NULL) OR (par_notify_email_operator_name IS NOT NULL) OR (par_notify_netsend_operator_name IS NOT NULL) OR (par_notify_page_operator_name IS NOT NULL) OR (par_delete_level IS NOT NULL)) THEN
        SELECT
            1
            INTO var_cached_attribute_modified;
    ELSE
        SELECT
            0
            INTO var_cached_attribute_modified;
    END IF
    /* Is @enable the only parameter used beside jobname and jobid? */;

    IF ((par_enabled IS NOT NULL) AND (par_new_name IS NULL) AND (par_description IS NULL) AND (par_start_step_id IS NULL) AND (par_category_name IS NULL) AND (par_owner_login_name IS NULL) AND (par_notify_level_eventlog IS NULL) AND (par_notify_level_email IS NULL) AND (par_notify_level_netsend IS NULL) AND (par_notify_level_page IS NULL) AND (par_notify_email_operator_name IS NULL) AND (par_notify_netsend_operator_name IS NULL) AND (par_notify_page_operator_name IS NULL) AND (par_delete_level IS NULL)) THEN
        SELECT
            1
            INTO var_enable_only_used;
    ELSE
        SELECT
            0
            INTO var_enable_only_used;
    END IF;

    IF (par_new_name = '') THEN
        SELECT
            NULL
            INTO par_new_name;
    END IF
    /* Fill out the values for all non-supplied parameters from the existing values */;

    IF (par_new_name IS NULL) THEN
        SELECT
            var_x_new_name
            INTO par_new_name;
    END IF;

    IF (par_enabled IS NULL) THEN
        SELECT
            var_x_enabled
            INTO par_enabled;
    END IF;

    IF (par_description IS NULL) THEN
        SELECT
            var_x_description
            INTO par_description;
    END IF;

    IF (par_start_step_id IS NULL) THEN
        SELECT
            var_x_start_step_id
            INTO par_start_step_id;
    END IF;

    IF (par_category_name IS NULL) THEN
        SELECT
            var_x_category_name
            INTO par_category_name;
    END IF;

    IF (var_owner_sid IS NULL) THEN
        SELECT
            var_x_owner_sid
            INTO var_owner_sid;
    END IF;

    IF (par_notify_level_eventlog IS NULL) THEN
        SELECT
            var_x_notify_level_eventlog
            INTO par_notify_level_eventlog;
    END IF;

    IF (par_notify_level_email IS NULL) THEN
        SELECT
            var_x_notify_level_email
            INTO par_notify_level_email;
    END IF;

    IF (par_notify_level_netsend IS NULL) THEN
        SELECT
            var_x_notify_level_netsend
            INTO par_notify_level_netsend;
    END IF;

    IF (par_notify_level_page IS NULL) THEN
        SELECT
            var_x_notify_level_page
            INTO par_notify_level_page;
    END IF;

    IF (par_notify_email_operator_name IS NULL) THEN
        SELECT
            var_x_notify_email_operator_name
            INTO par_notify_email_operator_name;
    END IF;

    IF (par_notify_netsend_operator_name IS NULL) THEN
        SELECT
            var_x_notify_netsnd_operator_name
            INTO par_notify_netsend_operator_name;
    END IF;

    IF (par_notify_page_operator_name IS NULL) THEN
        SELECT
            var_x_notify_page_operator_name
            INTO par_notify_page_operator_name;
    END IF;

    IF (par_delete_level IS NULL) THEN
        SELECT
            var_x_delete_level
            INTO par_delete_level;
    END IF
    /* Turn [nullable] empty string parameters into NULLs */;

    IF (LOWER(par_description) = LOWER('')) THEN
        SELECT
            NULL
            INTO par_description;
    END IF;

    IF (par_category_name = '') THEN
        SELECT
            NULL
            INTO par_category_name;
    END IF;

    IF (par_notify_email_operator_name = '') THEN
        SELECT
            NULL
            INTO par_notify_email_operator_name;
    END IF;

    IF (par_notify_netsend_operator_name = '') THEN
        SELECT
            NULL
            INTO par_notify_netsend_operator_name;
    END IF;

    IF (par_notify_page_operator_name = '') THEN
        SELECT
            NULL
            INTO par_notify_page_operator_name;
    END IF
    /* Check new values */;
    SELECT
        t.par_owner_sid, t.par_notify_level_email, t.par_notify_level_netsend, t.par_notify_level_page, 
        t.par_category_id, t.par_notify_email_operator_id, t.par_notify_netsend_operator_id, t.par_notify_page_operator_id, t.par_originating_server, t.ReturnCode
        FROM aws_sqlserver_ext.sp_verify_job(par_job_id, par_new_name, par_enabled, par_start_step_id, par_category_name, var_owner_sid, par_notify_level_eventlog, par_notify_level_email, par_notify_level_netsend, par_notify_level_page, par_notify_email_operator_name, par_notify_netsend_operator_name, par_notify_page_operator_name, par_delete_level, var_category_id, var_notify_email_operator_id, var_notify_netsend_operator_id, var_notify_page_operator_id, NULL) t
        INTO var_owner_sid, par_notify_level_email, par_notify_level_netsend, par_notify_level_page, var_category_id, var_notify_email_operator_id, var_notify_netsend_operator_id, var_notify_page_operator_id, var_retval;

    IF (var_retval <> 0) THEN
        ReturnCode := (1);
        RETURN;
    END IF
    /* Failure */
    /* BEGIN TRANSACTION */
    /* If the job is being re-assigned, modify sysjobsteps.database_user_name as necessary */;

    IF (par_owner_login_name IS NOT NULL) THEN
        IF (EXISTS (SELECT
            1
            FROM aws_sqlserver_ext.sysjobsteps
            WHERE (job_id = par_job_id) AND (LOWER(subsystem) = LOWER('TSQL')))) THEN
            /* The job is being re-assigned to an non-SA */
            UPDATE aws_sqlserver_ext.sysjobsteps
            SET database_user_name = NULL
                WHERE (job_id = par_job_id) AND (LOWER(subsystem) = LOWER('TSQL'));
        END IF;
    END IF;
    UPDATE aws_sqlserver_ext.sysjobs
    SET name = par_new_name, enabled = par_enabled, description = par_description, start_step_id = par_start_step_id, category_id = var_category_id
    /* Returned from sp_verify_job */, owner_sid = var_owner_sid, notify_level_eventlog = par_notify_level_eventlog, notify_level_email = par_notify_level_email, notify_level_netsend = par_notify_level_netsend, notify_level_page = par_notify_level_page, notify_email_operator_id = var_notify_email_operator_id
    /* Returned from sp_verify_job */, notify_netsend_operator_id = var_notify_netsend_operator_id
    /* Returned from sp_verify_job */, notify_page_operator_id = var_notify_page_operator_id
    /* Returned from sp_verify_job */, delete_level = par_delete_level, version_number = version_number + 1
    /* ,  -- Update the job's version */
    /* date_modified              = GETDATE()            -- Update the job's last-modified information */
        WHERE (job_id = par_job_id);
    SELECT
        0
        INTO var_retval
    /* @@error */
    /* COMMIT TRANSACTION */;
    ReturnCode := (var_retval);
    RETURN
    /* 0 means success */;
END;
]]></complex-attribute>
                        <category _I_D="4d601095-82cd-40ab-9f36-eb247e129b6a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d8656242-fbf1-48f0-b36d-105d3b6070d6" name="sp_update_jobschedule" is-trigger-function="0" unique-function-name="sp_update_jobschedule" is-aggregate="f" language-name="plpgsql" context="sp_update_jobschedule" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,character varying,character varying,smallint,integer,integer,integer,integer,integer,integer,integer,integer,integer,integer,smallint,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_name character varying DEFAULT NULL::character varying, par_new_name character varying DEFAULT NULL::character varying, par_enabled smallint DEFAULT NULL::smallint, par_freq_type integer DEFAULT NULL::integer, par_freq_interval integer DEFAULT NULL::integer, par_freq_subday_type integer DEFAULT NULL::integer, par_freq_subday_interval integer DEFAULT NULL::integer, par_freq_relative_interval integer DEFAULT NULL::integer, par_freq_recurrence_factor integer DEFAULT NULL::integer, par_active_start_date integer DEFAULT NULL::integer, par_active_end_date integer DEFAULT NULL::integer, par_active_start_time integer DEFAULT NULL::integer, par_active_end_time integer DEFAULT NULL::integer, par_automatic_post smallint DEFAULT 1, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="16" function-id="24006" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_job_name character varying, par_name character varying, par_new_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, par_automatic_post smallint, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_update_jobschedule(par_job_id integer, par_job_name character varying, par_name character varying, par_new_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, par_automatic_post smallint, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    var_retval INT;
    var_sched_count INT;
    var_schedule_id INT;
    var_job_owner_sid CHAR(85);
    var_enable_only_used INT;
    var_x_name VARCHAR(128);
    var_x_enabled SMALLINT;
    var_x_freq_type INT;
    var_x_freq_interval INT;
    var_x_freq_subday_type INT;
    var_x_freq_subday_interval INT;
    var_x_freq_relative_interval INT;
    var_x_freq_recurrence_factor INT;
    var_x_active_start_date INT;
    var_x_active_end_date INT;
    var_x_active_start_time INT;
    var_x_active_end_time INT;
    var_owner_sid CHAR(85);
BEGIN
    /* Remove any leading/trailing spaces from parameters */
    SELECT
        LTRIM(RTRIM(par_name))
        INTO par_name;
    SELECT
        LTRIM(RTRIM(par_new_name))
        INTO par_new_name
    /* Turn [nullable] empty string parameters into NULLs */;

    IF (par_new_name = '') THEN
        SELECT
            NULL
            INTO par_new_name;
    END IF
    /* Check that we can uniquely identify the job */;
    SELECT
        t.par_job_name, t.par_job_id, t.par_owner_sid, t.ReturnCode
        FROM aws_sqlserver_ext.sp_verify_job_identifiers('@job_name', '@job_id', par_job_name, par_job_id, 'TEST', var_job_owner_sid) t
        INTO par_job_name, par_job_id, var_job_owner_sid, var_retval;

    IF (var_retval <> 0) THEN
        ReturnCode := (1);
        RETURN;
    END IF
    /* Failure */
    /* Is @enable the only parameter used beside jobname and jobid? */;

    IF ((par_enabled IS NOT NULL) AND (par_name IS NULL) AND (par_new_name IS NULL) AND (par_freq_type IS NULL) AND (par_freq_interval IS NULL) AND (par_freq_subday_type IS NULL) AND (par_freq_subday_interval IS NULL) AND (par_freq_relative_interval IS NULL) AND (par_freq_recurrence_factor IS NULL) AND (par_active_start_date IS NULL) AND (par_active_end_date IS NULL) AND (par_active_start_time IS NULL) AND (par_active_end_time IS NULL)) THEN
        SELECT
            1
            INTO var_enable_only_used;
    ELSE
        SELECT
            0
            INTO var_enable_only_used;
    END IF;
    
    IF (par_new_name IS NULL) THEN
        SELECT
            var_x_name
            INTO par_new_name;
    END IF;

    IF (par_enabled IS NULL) THEN
        SELECT
            var_x_enabled
            INTO par_enabled;
    END IF;

    IF (par_freq_type IS NULL) THEN
        SELECT
            var_x_freq_type
            INTO par_freq_type;
    END IF;

    IF (par_freq_interval IS NULL) THEN
        SELECT
            var_x_freq_interval
            INTO par_freq_interval;
    END IF;

    IF (par_freq_subday_type IS NULL) THEN
        SELECT
            var_x_freq_subday_type
            INTO par_freq_subday_type;
    END IF;

    IF (par_freq_subday_interval IS NULL) THEN
        SELECT
            var_x_freq_subday_interval
            INTO par_freq_subday_interval;
    END IF;

    IF (par_freq_relative_interval IS NULL) THEN
        SELECT
            var_x_freq_relative_interval
            INTO par_freq_relative_interval;
    END IF;

    IF (par_freq_recurrence_factor IS NULL) THEN
        SELECT
            var_x_freq_recurrence_factor
            INTO par_freq_recurrence_factor;
    END IF;

    IF (par_active_start_date IS NULL) THEN
        SELECT
            var_x_active_start_date
            INTO par_active_start_date;
    END IF;

    IF (par_active_end_date IS NULL) THEN
        SELECT
            var_x_active_end_date
            INTO par_active_end_date;
    END IF;

    IF (par_active_start_time IS NULL) THEN
        SELECT
            var_x_active_start_time
            INTO par_active_start_time;
    END IF;

    IF (par_active_end_time IS NULL) THEN
        SELECT
            var_x_active_end_time
            INTO par_active_end_time;
    END IF
    /* Check schedule (frequency and owner) parameters */;
    SELECT
        t.par_freq_interval, t.par_freq_subday_type, t.par_freq_subday_interval, t.par_freq_relative_interval, t.par_freq_recurrence_factor, t.par_active_start_date, t.par_active_start_time, 
        t.par_active_end_date, t.par_active_end_time, t.ReturnCode
        FROM aws_sqlserver_ext.sp_verify_schedule(var_schedule_id
        /* @schedule_id */, par_new_name
        /* @name */, par_enabled
        /* @enabled */, par_freq_type
        /* @freq_type */, par_freq_interval
        /* @freq_interval */, par_freq_subday_type
        /* @freq_subday_type */, par_freq_subday_interval
        /* @freq_subday_interval */, par_freq_relative_interval
        /* @freq_relative_interval */, par_freq_recurrence_factor
        /* @freq_recurrence_factor */, par_active_start_date
        /* @active_start_date */, par_active_start_time
        /* @active_start_time */, par_active_end_date
        /* @active_end_date */, par_active_end_time
        /* @active_end_time */, var_owner_sid) t
        INTO par_freq_interval, par_freq_subday_type, par_freq_subday_interval, par_freq_relative_interval, par_freq_recurrence_factor, par_active_start_date, par_active_start_time, par_active_end_date, par_active_end_time, var_retval /* @owner_sid */;

    IF (var_retval <> 0) THEN
        ReturnCode := (1);
        RETURN;
    END IF
    /* Failure */
    /* Update the JobSchedule */;
    UPDATE aws_sqlserver_ext.sysschedules
    SET name = par_new_name, enabled = par_enabled, freq_type = par_freq_type, freq_interval = par_freq_interval, freq_subday_type = par_freq_subday_type, freq_subday_interval = par_freq_subday_interval, freq_relative_interval = par_freq_relative_interval, freq_recurrence_factor = par_freq_recurrence_factor, active_start_date = par_active_start_date, active_end_date = par_active_end_date, active_start_time = par_active_start_time, active_end_time = par_active_end_time
    /* date_modified          = GETDATE(), */, version_number = version_number + 1
        WHERE (schedule_id = var_schedule_id);
    SELECT
        0
        INTO var_retval
    /* @@error */
    /* Update the job's version/last-modified information */;
    UPDATE aws_sqlserver_ext.sysjobs
    SET version_number = version_number + 1
    /* date_modified = GETDATE() */
        WHERE (job_id = par_job_id);
    ReturnCode := (var_retval);
    RETURN
    /* 0 means success */;
END;
]]></complex-attribute>
                        <category _I_D="dec53be6-cf4b-485e-8a16-91fe117356dc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1db295be-f41e-45f0-8063-b9654f228de6" name="sp_update_jobstep" is-trigger-function="0" unique-function-name="sp_update_jobstep" is-aggregate="f" language-name="plpgsql" context="sp_update_jobstep" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,integer,character varying,character varying,text,text,integer,smallint,integer,smallint,integer,character varying,character varying,character varying,integer,integer,integer,character varying,integer,integer,character varying,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_job_id integer DEFAULT NULL::integer, par_job_name character varying DEFAULT NULL::character varying, par_step_id integer DEFAULT NULL::integer, par_step_name character varying DEFAULT NULL::character varying, par_subsystem character varying DEFAULT NULL::character varying, par_command text DEFAULT NULL::text, par_additional_parameters text DEFAULT NULL::text, par_cmdexec_success_code integer DEFAULT NULL::integer, par_on_success_action smallint DEFAULT NULL::smallint, par_on_success_step_id integer DEFAULT NULL::integer, par_on_fail_action smallint DEFAULT NULL::smallint, par_on_fail_step_id integer DEFAULT NULL::integer, par_server character varying DEFAULT NULL::character varying, par_database_name character varying DEFAULT NULL::character varying, par_database_user_name character varying DEFAULT NULL::character varying, par_retry_attempts integer DEFAULT NULL::integer, par_retry_interval integer DEFAULT NULL::integer, par_os_run_priority integer DEFAULT NULL::integer, par_output_file_name character varying DEFAULT NULL::character varying, par_flags integer DEFAULT NULL::integer, par_proxy_id integer DEFAULT NULL::integer, par_proxy_name character varying DEFAULT NULL::character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="22" function-id="24010" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_job_name character varying, par_step_id integer, par_step_name character varying, par_subsystem character varying, par_command text, par_additional_parameters text, par_cmdexec_success_code integer, par_on_success_action smallint, par_on_success_step_id integer, par_on_fail_action smallint, par_on_fail_step_id integer, par_server character varying, par_database_name character varying, par_database_user_name character varying, par_retry_attempts integer, par_retry_interval integer, par_os_run_priority integer, par_output_file_name character varying, par_flags integer, par_proxy_id integer, par_proxy_name character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_update_jobstep(par_job_id integer, par_job_name character varying, par_step_id integer, par_step_name character varying, par_subsystem character varying, par_command text, par_additional_parameters text, par_cmdexec_success_code integer, par_on_success_action smallint, par_on_success_step_id integer, par_on_fail_action smallint, par_on_fail_step_id integer, par_server character varying, par_database_name character varying, par_database_user_name character varying, par_retry_attempts integer, par_retry_interval integer, par_os_run_priority integer, par_output_file_name character varying, par_flags integer, par_proxy_id integer, par_proxy_name character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    var_retval INT;
    var_os_run_priority_code INT;
    var_step_id_as_char VARCHAR(10);
    var_new_step_name VARCHAR(128);
    var_x_step_name VARCHAR(128);
    var_x_subsystem VARCHAR(40);
    var_x_command TEXT;
    var_x_flags INT;
    var_x_cmdexec_success_code INT;
    var_x_on_success_action SMALLINT;
    var_x_on_success_step_id INT;
    var_x_on_fail_action SMALLINT;
    var_x_on_fail_step_id INT;
    var_x_server VARCHAR(128);
    var_x_database_name VARCHAR(128);
    var_x_database_user_name VARCHAR(128);
    var_x_retry_attempts INT;
    var_x_retry_interval INT;
    var_x_os_run_priority INT;
    var_x_output_file_name VARCHAR(200);
    var_x_proxy_id INT;
    var_x_last_run_outcome SMALLINT;
    var_x_last_run_duration INT;
    var_x_last_run_retries INT;
    var_x_last_run_date INT;
    var_x_last_run_time INT;
    var_new_proxy_id INT;
    var_subsystem_id INT;
    var_auto_proxy_name VARCHAR(128);
    var_job_owner_sid CHAR(85);
    var_step_uid CHAR(85);
BEGIN
    SELECT NULL INTO var_new_proxy_id;
    /* Remove any leading/trailing spaces from parameters */
    SELECT LTRIM(RTRIM(par_step_name)) INTO par_step_name;
    SELECT LTRIM(RTRIM(par_subsystem)) INTO par_subsystem;
    SELECT LTRIM(RTRIM(par_command)) INTO par_command;
    SELECT LTRIM(RTRIM(par_server)) INTO par_server;
    SELECT LTRIM(RTRIM(par_database_name)) INTO par_database_name;
    SELECT LTRIM(RTRIM(par_database_user_name)) INTO par_database_user_name;
    SELECT LTRIM(RTRIM(par_output_file_name)) INTO par_output_file_name;
    SELECT LTRIM(RTRIM(par_proxy_name)) INTO par_proxy_name;
    /* Make sure Dts is translated into new subsystem's name SSIS */
    /* IF (@subsystem IS NOT NULL AND UPPER(@subsystem collate SQL_Latin1_General_CP1_CS_AS) = N'DTS') */
    /* BEGIN */
    /* SET @subsystem = N'SSIS' */
    /* END */
    SELECT
        t.par_job_name, t.par_job_id, t.par_owner_sid, t.ReturnCode
        FROM aws_sqlserver_ext.sp_verify_job_identifiers('@job_name'
        /* @name_of_name_parameter */, '@job_id'
        /* @name_of_id_parameter */, par_job_name
        /* @job_name */, par_job_id
        /* @job_id */, 'TEST'
        /* @sqlagent_starting_test */, var_job_owner_sid)
        INTO par_job_name, par_job_id, var_job_owner_sid, var_retval
    /* @owner_sid */;

    IF (var_retval <> 0) THEN
        ReturnCode := (1);
        RETURN;
    END IF;
    /* Failure */
    /* Check that the step exists */

    IF (NOT EXISTS (SELECT
        *
        FROM aws_sqlserver_ext.sysjobsteps
        WHERE (job_id = par_job_id) AND (step_id = par_step_id))) THEN
        SELECT
            CAST (par_step_id AS VARCHAR(10))
            INTO var_step_id_as_char;
        RAISE 'Error %, severity %, state % was raised. Message: %. Argument: %. Argument: %', '50000', 0, 0, 'The specified %s ("%s") does not exist.', '@step_id', var_step_id_as_char USING ERRCODE := '50000';
        ReturnCode := (1);
        RETURN;
        /* Failure */
    END IF;
    /* Set the x_ (existing) variables */
    SELECT
        step_name, subsystem, command, flags, cmdexec_success_code, on_success_action, on_success_step_id, on_fail_action, on_fail_step_id, server, database_name, database_user_name, retry_attempts, retry_interval, os_run_priority, output_file_name, proxy_id, last_run_outcome, last_run_duration, last_run_retries, last_run_date, last_run_time
        INTO var_x_step_name, var_x_subsystem, var_x_command, var_x_flags, var_x_cmdexec_success_code, var_x_on_success_action, var_x_on_success_step_id, var_x_on_fail_action, var_x_on_fail_step_id, var_x_server, var_x_database_name, var_x_database_user_name, var_x_retry_attempts, var_x_retry_interval, var_x_os_run_priority, var_x_output_file_name, var_x_proxy_id, var_x_last_run_outcome, var_x_last_run_duration, var_x_last_run_retries, var_x_last_run_date, var_x_last_run_time
        FROM aws_sqlserver_ext.sysjobsteps
        WHERE (job_id = par_job_id) AND (step_id = par_step_id);

    IF ((par_step_name IS NOT NULL) AND (par_step_name <> var_x_step_name)) THEN
        SELECT
            par_step_name
            INTO var_new_step_name;
    END IF;
    /* Fill out the values for all non-supplied parameters from the existing values */

    IF (par_step_name IS NULL) THEN
        SELECT var_x_step_name INTO par_step_name;
    END IF;

    IF (par_subsystem IS NULL) THEN
        SELECT var_x_subsystem INTO par_subsystem;
    END IF;

    IF (par_command IS NULL) THEN
        SELECT var_x_command INTO par_command;
    END IF;

    IF (par_flags IS NULL) THEN
        SELECT var_x_flags INTO par_flags;
    END IF;

    IF (par_cmdexec_success_code IS NULL) THEN
        SELECT var_x_cmdexec_success_code INTO par_cmdexec_success_code;
    END IF;

    IF (par_on_success_action IS NULL) THEN
        SELECT var_x_on_success_action INTO par_on_success_action;
    END IF;

    IF (par_on_success_step_id IS NULL) THEN
        SELECT var_x_on_success_step_id INTO par_on_success_step_id;
    END IF;

    IF (par_on_fail_action IS NULL) THEN
        SELECT var_x_on_fail_action INTO par_on_fail_action;
    END IF;

    IF (par_on_fail_step_id IS NULL) THEN
        SELECT var_x_on_fail_step_id INTO par_on_fail_step_id;
    END IF;

    IF (par_server IS NULL) THEN
        SELECT var_x_server INTO par_server;
    END IF;

    IF (par_database_name IS NULL) THEN
        SELECT var_x_database_name INTO par_database_name;
    END IF;

    IF (par_database_user_name IS NULL) THEN
        SELECT var_x_database_user_name INTO par_database_user_name;
    END IF;

    IF (par_retry_attempts IS NULL) THEN
        SELECT var_x_retry_attempts INTO par_retry_attempts;
    END IF;

    IF (par_retry_interval IS NULL) THEN
        SELECT var_x_retry_interval INTO par_retry_interval;
    END IF;

    IF (par_os_run_priority IS NULL) THEN
        SELECT var_x_os_run_priority INTO par_os_run_priority;
    END IF;

    IF (par_output_file_name IS NULL) THEN
        SELECT var_x_output_file_name INTO par_output_file_name;
    END IF;

    IF (par_proxy_id IS NULL) THEN
        SELECT var_x_proxy_id INTO var_new_proxy_id;
    END IF;
    /* if an empty proxy_name is supplied the proxy is removed */

    IF par_proxy_name = '' THEN
        SELECT NULL INTO var_new_proxy_id;
    END IF;
    /* Turn [nullable] empty string parameters into NULLs */

    IF (LOWER(par_command) = LOWER('')) THEN
        SELECT NULL INTO par_command;
    END IF;

    IF (par_server = '') THEN
        SELECT NULL INTO par_server;
    END IF;

    IF (par_database_name = '') THEN
        SELECT NULL INTO par_database_name;
    END IF;

    IF (par_database_user_name = '') THEN
        SELECT NULL INTO par_database_user_name;
    END IF;

    IF (LOWER(par_output_file_name) = LOWER('')) THEN
        SELECT NULL INTO par_output_file_name;
    END IF
    /* Check new values */;
    SELECT
        t.par_database_name, t.par_database_user_name, t.ReturnCode
        FROM aws_sqlserver_ext.sp_verify_jobstep(par_job_id, par_step_id, var_new_step_name, par_subsystem, par_command, par_server, par_on_success_action, par_on_success_step_id, par_on_fail_action, par_on_fail_step_id, par_os_run_priority, par_database_name, par_database_user_name, par_flags, par_output_file_name, var_new_proxy_id) t
        INTO par_database_name, par_database_user_name, var_retval;

    IF (var_retval <> 0) THEN
        ReturnCode := (1);
        RETURN;
    END IF
    /* Failure */
    /* Update the job's version/last-modified information */;
    UPDATE aws_sqlserver_ext.sysjobs
    SET version_number = version_number + 1
    /* date_modified = GETDATE() */
        WHERE (job_id = par_job_id)
    /* Update the step */;
    UPDATE aws_sqlserver_ext.sysjobsteps
    SET step_name = par_step_name, subsystem = par_subsystem, command = par_command, flags = par_flags, additional_parameters = par_additional_parameters, cmdexec_success_code = par_cmdexec_success_code, on_success_action = par_on_success_action, on_success_step_id = par_on_success_step_id, on_fail_action = par_on_fail_action, on_fail_step_id = par_on_fail_step_id, server = par_server, database_name = par_database_name, database_user_name = par_database_user_name, retry_attempts = par_retry_attempts, retry_interval = par_retry_interval, os_run_priority = par_os_run_priority, output_file_name = par_output_file_name, last_run_outcome = var_x_last_run_outcome, last_run_duration = var_x_last_run_duration, last_run_retries = var_x_last_run_retries, last_run_date = var_x_last_run_date, last_run_time = var_x_last_run_time, proxy_id = var_new_proxy_id
        WHERE (job_id = par_job_id) AND (step_id = par_step_id);

    SELECT step_uid
    FROM aws_sqlserver_ext.sysjobsteps
    WHERE job_id = par_job_id AND step_id = par_step_id
    INTO var_step_uid;

    -- PERFORM aws_sqlserver_ext.sp_jobstep_create_proc (var_step_uid);

    ReturnCode := (0);
    RETURN
    /* Success */;
END;
]]></complex-attribute>
                        <category _I_D="baf43c62-d884-459a-b5f5-d07c9ed5763b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bbebff8b-7702-44bf-a6f3-a838100b6f44" name="sp_update_schedule" is-trigger-function="0" unique-function-name="sp_update_schedule" is-aggregate="f" language-name="plpgsql" context="sp_update_schedule" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,character varying,smallint,integer,integer,integer,integer,integer,integer,integer,integer,integer,integer,character varying,smallint,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_schedule_id integer DEFAULT NULL::integer, par_name character varying DEFAULT NULL::character varying, par_new_name character varying DEFAULT NULL::character varying, par_enabled smallint DEFAULT NULL::smallint, par_freq_type integer DEFAULT NULL::integer, par_freq_interval integer DEFAULT NULL::integer, par_freq_subday_type integer DEFAULT NULL::integer, par_freq_subday_interval integer DEFAULT NULL::integer, par_freq_relative_interval integer DEFAULT NULL::integer, par_freq_recurrence_factor integer DEFAULT NULL::integer, par_active_start_date integer DEFAULT NULL::integer, par_active_end_date integer DEFAULT NULL::integer, par_active_start_time integer DEFAULT NULL::integer, par_active_end_time integer DEFAULT NULL::integer, par_owner_login_name character varying DEFAULT NULL::character varying, par_automatic_post smallint DEFAULT 1, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="16" function-id="24012" volatility="VOLATILE" is-window="f" function-identity-arguments="par_schedule_id integer, par_name character varying, par_new_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, par_owner_login_name character varying, par_automatic_post smallint, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_update_schedule(par_schedule_id integer, par_name character varying, par_new_name character varying, par_enabled smallint, par_freq_type integer, par_freq_interval integer, par_freq_subday_type integer, par_freq_subday_interval integer, par_freq_relative_interval integer, par_freq_recurrence_factor integer, par_active_start_date integer, par_active_end_date integer, par_active_start_time integer, par_active_end_time integer, par_owner_login_name character varying, par_automatic_post smallint, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    var_retval INT;
    var_owner_sid CHAR(85);
    var_cur_owner_sid CHAR(85);
    var_x_name VARCHAR(128);
    var_enable_only_used INT;
    var_x_enabled SMALLINT;
    var_x_freq_type INT;
    var_x_freq_interval INT;
    var_x_freq_subday_type INT;
    var_x_freq_subday_interval INT;
    var_x_freq_relative_interval INT;
    var_x_freq_recurrence_factor INT;
    var_x_active_start_date INT;
    var_x_active_end_date INT;
    var_x_active_start_time INT;
    var_x_active_end_time INT;
    var_schedule_uid CHAR(38);
BEGIN
    /* Remove any leading/trailing spaces from parameters */
    SELECT
        LTRIM(RTRIM(par_name))
        INTO par_name;
    SELECT
        LTRIM(RTRIM(par_new_name))
        INTO par_new_name;
    SELECT
        LTRIM(RTRIM(par_owner_login_name))
        INTO par_owner_login_name
    /* Turn [nullable] empty string parameters into NULLs */;

    IF (par_new_name = '') THEN
        SELECT
            NULL
            INTO par_new_name;
    END IF
    /* Check that we can uniquely identify the schedule. This only returns a schedule that is visible to this user */;
    SELECT
        t.par_schedule_name, t.par_schedule_id, t.par_owner_sid, t.par_orig_server_id, t.ReturnCode
        FROM aws_sqlserver_ext.sp_verify_schedule_identifiers('@name'
        /* @name_of_name_parameter */, '@schedule_id'
        /* @name_of_id_parameter */, par_name
        /* @schedule_name */, par_schedule_id
        /* @schedule_id */, var_cur_owner_sid
        /* @owner_sid */, NULL
        /* @orig_server_id */, NULL) t
        INTO par_name, par_schedule_id, var_cur_owner_sid, var_retval
    /* @job_id_filter */;

    IF (var_retval <> 0) THEN
        ReturnCode := (1);
        RETURN;
    END IF
    /* Failure */
    /* Is @enable the only parameter used beside jobname and jobid? */;

    IF ((par_enabled IS NOT NULL) AND (par_new_name IS NULL) AND (par_freq_type IS NULL) AND (par_freq_interval IS NULL) AND (par_freq_subday_type IS NULL) AND (par_freq_subday_interval IS NULL) AND (par_freq_relative_interval IS NULL) AND (par_freq_recurrence_factor IS NULL) AND (par_active_start_date IS NULL) AND (par_active_end_date IS NULL) AND (par_active_start_time IS NULL) AND (par_active_end_time IS NULL) AND (par_owner_login_name IS NULL)) THEN
        SELECT
            1
            INTO var_enable_only_used;
    ELSE
        SELECT
            0
            INTO var_enable_only_used;
    END IF
    /* If the param @owner_login_name is null or doesn't get resolved by SUSER_SID() set it to the current owner of the schedule */;

    IF (var_owner_sid IS NULL) THEN
        SELECT
            var_cur_owner_sid
            INTO var_owner_sid;
    END IF
    /* Set the x_ (existing) variables */;
    SELECT
        name, enabled, freq_type, freq_interval, freq_subday_type, freq_subday_interval, freq_relative_interval, freq_recurrence_factor, active_start_date, active_end_date, active_start_time, active_end_time
        INTO var_x_name, var_x_enabled, var_x_freq_type, var_x_freq_interval, var_x_freq_subday_type, var_x_freq_subday_interval, var_x_freq_relative_interval, var_x_freq_recurrence_factor, var_x_active_start_date, var_x_active_end_date, var_x_active_start_time, var_x_active_end_time
        FROM aws_sqlserver_ext.sysschedules
        WHERE (schedule_id = par_schedule_id)
    /* Fill out the values for all non-supplied parameters from the existing values */;

    IF (par_new_name IS NULL) THEN
        SELECT
            var_x_name
            INTO par_new_name;
    END IF;

    IF (par_enabled IS NULL) THEN
        SELECT
            var_x_enabled
            INTO par_enabled;
    END IF;

    IF (par_freq_type IS NULL) THEN
        SELECT
            var_x_freq_type
            INTO par_freq_type;
    END IF;

    IF (par_freq_interval IS NULL) THEN
        SELECT
            var_x_freq_interval
            INTO par_freq_interval;
    END IF;

    IF (par_freq_subday_type IS NULL) THEN
        SELECT
            var_x_freq_subday_type
            INTO par_freq_subday_type;
    END IF;

    IF (par_freq_subday_interval IS NULL) THEN
        SELECT
            var_x_freq_subday_interval
            INTO par_freq_subday_interval;
    END IF;

    IF (par_freq_relative_interval IS NULL) THEN
        SELECT
            var_x_freq_relative_interval
            INTO par_freq_relative_interval;
    END IF;

    IF (par_freq_recurrence_factor IS NULL) THEN
        SELECT
            var_x_freq_recurrence_factor
            INTO par_freq_recurrence_factor;
    END IF;

    IF (par_active_start_date IS NULL) THEN
        SELECT
            var_x_active_start_date
            INTO par_active_start_date;
    END IF;

    IF (par_active_end_date IS NULL) THEN
        SELECT
            var_x_active_end_date
            INTO par_active_end_date;
    END IF;

    IF (par_active_start_time IS NULL) THEN
        SELECT
            var_x_active_start_time
            INTO par_active_start_time;
    END IF;

    IF (par_active_end_time IS NULL) THEN
        SELECT
            var_x_active_end_time
            INTO par_active_end_time;
    END IF
    /* Check schedule (frequency and owner) parameters */;
    SELECT
        t.par_freq_interval, t.par_freq_subday_type, t.par_freq_subday_interval, t.par_freq_relative_interval, t.par_freq_recurrence_factor, t.par_active_start_date, 
        t.par_active_start_time, t.par_active_end_date, t.par_active_end_time, t.ReturnCode
        FROM aws_sqlserver_ext.sp_verify_schedule(par_schedule_id
        /* @schedule_id */, par_new_name
        /* @name */, par_enabled
        /* @enabled */, par_freq_type
        /* @freq_type */, par_freq_interval
        /* @freq_interval */, par_freq_subday_type
        /* @freq_subday_type */, par_freq_subday_interval
        /* @freq_subday_interval */, par_freq_relative_interval
        /* @freq_relative_interval */, par_freq_recurrence_factor
        /* @freq_recurrence_factor */, par_active_start_date
        /* @active_start_date */, par_active_start_time
        /* @active_start_time */, par_active_end_date
        /* @active_end_date */, par_active_end_time
        /* @active_end_time */, var_owner_sid) t
        INTO par_freq_interval, par_freq_subday_type, par_freq_subday_interval, par_freq_relative_interval, par_freq_recurrence_factor, par_active_start_date, par_active_start_time, par_active_end_date, par_active_end_time, var_retval /* @owner_sid */;

    IF (var_retval <> 0) THEN
        ReturnCode := (1);
        RETURN;
    END IF
    /* Failure */
    /* Update the sysschedules table */;
    UPDATE aws_sqlserver_ext.sysschedules
    SET name = par_new_name, owner_sid = var_owner_sid, enabled = par_enabled, freq_type = par_freq_type, freq_interval = par_freq_interval, freq_subday_type = par_freq_subday_type, freq_subday_interval = par_freq_subday_interval, freq_relative_interval = par_freq_relative_interval, freq_recurrence_factor = par_freq_recurrence_factor, active_start_date = par_active_start_date, active_end_date = par_active_end_date, active_start_time = par_active_start_time, active_end_time = par_active_end_time
    /* date_modified          = GETDATE(), */, version_number = version_number + 1
        WHERE (schedule_id = par_schedule_id);
    SELECT
        0
        INTO var_retval;
    
    ReturnCode := (var_retval);
    RETURN
    /* 0 means success */;
END;
]]></complex-attribute>
                        <category _I_D="5fc2016f-5c13-4b8b-a9b3-c8eea2571120" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9c590769-288a-4b98-a935-42956daa7cb1" name="sp_verify_job" is-trigger-function="0" unique-function-name="sp_verify_job" is-aggregate="f" language-name="plpgsql" context="sp_verify_job" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,smallint,integer,character varying,character,integer,integer,integer,integer,character varying,character varying,character varying,integer,integer,integer,integer,integer,character varying,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_job_id integer, par_name character varying, par_enabled smallint, par_start_step_id integer, par_category_name character varying, INOUT par_owner_sid character, par_notify_level_eventlog integer, INOUT par_notify_level_email integer, INOUT par_notify_level_netsend integer, INOUT par_notify_level_page integer, par_notify_email_operator_name character varying, par_notify_netsend_operator_name character varying, par_notify_page_operator_name character varying, par_delete_level integer, INOUT par_category_id integer, INOUT par_notify_email_operator_id integer, INOUT par_notify_netsend_operator_id integer, INOUT par_notify_page_operator_id integer, INOUT par_originating_server character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="19" function-id="24016" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_name character varying, par_enabled smallint, par_start_step_id integer, par_category_name character varying, INOUT par_owner_sid character, par_notify_level_eventlog integer, INOUT par_notify_level_email integer, INOUT par_notify_level_netsend integer, INOUT par_notify_level_page integer, par_notify_email_operator_name character varying, par_notify_netsend_operator_name character varying, par_notify_page_operator_name character varying, par_delete_level integer, INOUT par_category_id integer, INOUT par_notify_email_operator_id integer, INOUT par_notify_netsend_operator_id integer, INOUT par_notify_page_operator_id integer, INOUT par_originating_server character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_verify_job(par_job_id integer, par_name character varying, par_enabled smallint, par_start_step_id integer, par_category_name character varying, INOUT par_owner_sid character, par_notify_level_eventlog integer, INOUT par_notify_level_email integer, INOUT par_notify_level_netsend integer, INOUT par_notify_level_page integer, par_notify_email_operator_name character varying, par_notify_netsend_operator_name character varying, par_notify_page_operator_name character varying, par_delete_level integer, INOUT par_category_id integer, INOUT par_notify_email_operator_id integer, INOUT par_notify_netsend_operator_id integer, INOUT par_notify_page_operator_id integer, INOUT par_originating_server character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_job_type INT;
  var_retval INT;
  var_current_date INT;
  var_res_valid_range VARCHAR(200);
  var_max_step_id INT;
  var_valid_range VARCHAR(50);
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_name)) INTO par_name;
  SELECT LTRIM(RTRIM(par_category_name)) INTO par_category_name;
  SELECT UPPER(LTRIM(RTRIM(par_originating_server))) INTO par_originating_server;
    
  IF (
    EXISTS (
      SELECT * 
        FROM aws_sqlserver_ext.sysjobs AS job
       WHERE (name = par_name)
      /* AND (job_id <> ISNULL(@job_id, 0x911)))) -- When adding a new job @job_id is NULL */
    )
  ) 
  THEN /* Failure */
    RAISE 'The specified % ("%") already exists.', 'par_name', par_name USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
  END IF;
    
  /* Check enabled state */
  IF (par_enabled <> 0) AND (par_enabled <> 1) THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', 'par_enabled', '0, 1' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
  END IF;
  
  /* Check start step */

  IF (par_job_id IS NULL) THEN /* New job */
    IF (par_start_step_id <> 1) THEN /* Failure */
      RAISE 'The specified "%" is invalid (valid values are: %).', 'par_start_step_id', '1' USING ERRCODE := '50000';
        returncode := 1;
        RETURN;
    END IF;
  ELSE /* Existing job */
    /* Get current maximum step id */
    SELECT COALESCE(MAX(step_id), 0)
      INTO var_max_step_id
      FROM aws_sqlserver_ext.sysjobsteps
     WHERE (job_id = par_job_id);

    IF (par_start_step_id < 1) OR (par_start_step_id > var_max_step_id + 1) THEN /* Failure */
      SELECT '1..' || CAST (var_max_step_id + 1 AS VARCHAR(1))
        INTO var_valid_range;
      RAISE 'The specified "%" is invalid (valid values are: %).', 'par_start_step_id', var_valid_range USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  END IF;
  
  /* Get the category_id, handling any special-cases as appropriate */
  SELECT NULL INTO par_category_id;

  IF (par_category_name = '[DEFAULT]') /* User wants to revert to the default job category */
  THEN
    SELECT 
      CASE COALESCE(var_job_type, 1)
        WHEN 1 THEN 0 /* [Uncategorized (Local)] */
        WHEN 2 THEN 2 /* [Uncategorized (Multi-Server)] */
      END
      INTO par_category_id;
  ELSE
    SELECT 0 INTO par_category_id;
  END IF;
  
  returncode := (0); /* Success */
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="dba3d0e9-5c4e-4b85-86d8-e97988afac0a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ed0c80fd-e8b6-453b-a8e0-983be1649813" name="sp_verify_job_date" is-trigger-function="0" unique-function-name="sp_verify_job_date" is-aggregate="f" language-name="plpgsql" context="sp_verify_job_date" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_date integer, par_date_name character varying DEFAULT 'date'::character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24014" volatility="VOLATILE" is-window="f" function-identity-arguments="par_date integer, par_date_name character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_verify_job_date(par_date integer, par_date_name character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_date_name)) INTO par_date_name;
  
  /* Success */
  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="329efdaa-57b8-4454-a696-9845b6ff890b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0f828a6d-3bf9-4826-aae9-37f7311cbee9" name="sp_verify_job_identifiers" is-trigger-function="0" unique-function-name="sp_verify_job_identifiers" is-aggregate="f" language-name="plpgsql" context="sp_verify_job_identifiers" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying,integer,character varying,character,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_name_of_name_parameter character varying, par_name_of_id_parameter character varying, INOUT par_job_name character varying, INOUT par_job_id integer, par_sqlagent_starting_test character varying DEFAULT 'TEST'::character varying, INOUT par_owner_sid character DEFAULT NULL::bpchar, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="6" function-id="24015" volatility="VOLATILE" is-window="f" function-identity-arguments="par_name_of_name_parameter character varying, par_name_of_id_parameter character varying, INOUT par_job_name character varying, INOUT par_job_id integer, par_sqlagent_starting_test character varying, INOUT par_owner_sid character, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_verify_job_identifiers(par_name_of_name_parameter character varying, par_name_of_id_parameter character varying, INOUT par_job_name character varying, INOUT par_job_id integer, par_sqlagent_starting_test character varying, INOUT par_owner_sid character, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_job_id_as_char VARCHAR(36);
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_name_of_name_parameter)) INTO par_name_of_name_parameter;
  SELECT LTRIM(RTRIM(par_name_of_id_parameter)) INTO par_name_of_id_parameter;
  SELECT LTRIM(RTRIM(par_job_name)) INTO par_job_name;

  IF (par_job_name = '') 
  THEN 
    SELECT NULL INTO par_job_name;
  END IF;

  IF ((par_job_name IS NULL) AND (par_job_id IS NULL)) OR ((par_job_name IS NOT NULL) AND (par_job_id IS NOT NULL)) 
  THEN /* Failure */
    RAISE 'Supply either % or % to identify the job.', par_name_of_id_parameter, par_name_of_name_parameter USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  /* Check job id */
  IF (par_job_id IS NOT NULL) 
  THEN
    SELECT name
         , owner_sid
      INTO par_job_name
         , par_owner_sid
      FROM aws_sqlserver_ext.sysjobs
     WHERE (job_id = par_job_id);
 
    /* the view would take care of all the permissions issues. */
    IF (par_job_name IS NULL) 
    THEN /* Failure */
      SELECT CAST (par_job_id AS VARCHAR(36))
        INTO var_job_id_as_char;
      
      RAISE 'The specified % ("%") does not exist.', 'job_id', var_job_id_as_char USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  ELSE
    /* Check job name */
    IF (par_job_name IS NOT NULL) 
    THEN
      /* Check if the job name is ambiguous */
      IF (SELECT COUNT(*) FROM aws_sqlserver_ext.sysjobs WHERE name = par_job_name) > 1
      THEN /* Failure */
        RAISE 'There are two or more jobs named "%". Specify % instead of % to uniquely identify the job.', par_job_name, par_name_of_id_parameter, par_name_of_name_parameter USING ERRCODE := '50000';
        returncode := 1;
        RETURN;
      END IF;
      
      /* The name is not ambiguous, so get the corresponding job_id (if the job exists) */      
      SELECT job_id
           , owner_sid
        INTO par_job_id
           , par_owner_sid
        FROM aws_sqlserver_ext.sysjobs
       WHERE (name = par_job_name);
       
      /* the view would take care of all the permissions issues. */
      IF (par_job_id IS NULL) 
      THEN /* Failure */
        RAISE 'The specified % ("%") does not exist.', 'job_name', par_job_name USING ERRCODE := '50000';
        returncode := 1;
        RETURN;
      END IF;
    END IF;
  END IF;

  /* Success */  
  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="f666ab45-0d54-4b20-b969-13cf6254b67b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="412a15a3-a531-41a7-8a28-e8248855bdcf" name="sp_verify_job_time" is-trigger-function="0" unique-function-name="sp_verify_job_time" is-aggregate="f" language-name="plpgsql" context="sp_verify_job_time" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_time integer, par_time_name character varying DEFAULT 'time'::character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24018" volatility="VOLATILE" is-window="f" function-identity-arguments="par_time integer, par_time_name character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_verify_job_time(par_time integer, par_time_name character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_hour INT;
  var_minute INT;
  var_second INT;
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_time_name)) INTO par_time_name;

  IF ((par_time < 0) OR (par_time > 235959)) 
  THEN
    RAISE 'The specified "%" is invalid (valid values are: %).', par_time_name, '000000..235959' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  SELECT (par_time / 10000) INTO var_hour;
  SELECT (par_time % 10000) / 100 INTO var_minute;
  SELECT (par_time % 100) INTO var_second;
   
  /* Check hour range */
  IF (var_hour > 23) THEN
    RAISE 'The "%" supplied has an invalid %.', par_time_name, 'hour' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Check minute range */
  IF (var_minute > 59) THEN
    RAISE 'The "%" supplied has an invalid %.', par_time_name, 'minute' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  /* Check second range */
  IF (var_second > 59) THEN
     RAISE 'The "%" supplied has an invalid %.', par_time_name, 'second' USING ERRCODE := '50000';
     returncode := 1;
     RETURN;
  END IF;
  
  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="a06701c8-cf56-41e9-ab26-9a0d11e61d5f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b4acabb0-2edb-4ca6-876a-cf2b5aa9ea02" name="sp_verify_jobstep" is-trigger-function="0" unique-function-name="sp_verify_jobstep" is-aggregate="f" language-name="plpgsql" context="sp_verify_jobstep" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer,character varying,character varying,text,character varying,smallint,integer,smallint,integer,integer,integer,character varying,integer,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_job_id integer, par_step_id integer, par_step_name character varying, par_subsystem character varying, par_command text, par_server character varying, par_on_success_action smallint, par_on_success_step_id integer, par_on_fail_action smallint, par_on_fail_step_id integer, par_os_run_priority integer, par_flags integer, par_output_file_name character varying, par_proxy_id integer, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="14" function-id="24017" volatility="VOLATILE" is-window="f" function-identity-arguments="par_job_id integer, par_step_id integer, par_step_name character varying, par_subsystem character varying, par_command text, par_server character varying, par_on_success_action smallint, par_on_success_step_id integer, par_on_fail_action smallint, par_on_fail_step_id integer, par_os_run_priority integer, par_flags integer, par_output_file_name character varying, par_proxy_id integer, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_verify_jobstep(par_job_id integer, par_step_id integer, par_step_name character varying, par_subsystem character varying, par_command text, par_server character varying, par_on_success_action smallint, par_on_success_step_id integer, par_on_fail_action smallint, par_on_fail_step_id integer, par_os_run_priority integer, par_flags integer, par_output_file_name character varying, par_proxy_id integer, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_max_step_id INT;
  var_retval INT;
  var_valid_values VARCHAR(50);
  var_database_name_temp VARCHAR(258);
  var_database_user_name_temp VARCHAR(256);
  var_temp_command TEXT;
  var_iPos INT;
  var_create_count INT;
  var_destroy_count INT;
  var_is_olap_subsystem SMALLINT;
  var_owner_sid CHAR(85);
  var_owner_name VARCHAR(128);
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_subsystem)) INTO par_subsystem;
  SELECT LTRIM(RTRIM(par_server)) INTO par_server;
  SELECT LTRIM(RTRIM(par_output_file_name)) INTO par_output_file_name;
  
  /* Get current maximum step id */
  SELECT COALESCE(MAX(step_id), 0)
    INTO var_max_step_id
    FROM aws_sqlserver_ext.sysjobsteps
   WHERE (job_id = par_job_id);
   
  /* Check step id */
  IF (par_step_id < 1) OR (par_step_id > var_max_step_id + 1)  /* Failure */
  THEN
    SELECT '1..' || CAST (var_max_step_id + 1 AS VARCHAR(1)) INTO var_valid_values;
      RAISE 'The specified "%" is invalid (valid values are: %).', '@step_id', var_valid_values USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
  END IF;
  
  /* Check step name */
  IF (
    EXISTS (
      SELECT *
        FROM aws_sqlserver_ext.sysjobsteps
       WHERE (job_id = par_job_id) AND (step_name = par_step_name)
    )
  ) 
  THEN /* Failure */
    RAISE 'The specified % ("%") already exists.', 'step_name', par_step_name USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Check on-success action/step */
  IF (par_on_success_action <> 1) /* Quit Qith Success */
    AND (par_on_success_action <> 2) /* Quit Qith Failure */
    AND (par_on_success_action <> 3) /* Goto Next Step */
    AND (par_on_success_action <> 4) /* Goto Step */
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', 'on_success_action', '1, 2, 3, 4' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  IF (par_on_success_action = 4) AND ((par_on_success_step_id < 1) OR (par_on_success_step_id = par_step_id)) 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are greater than 0 but excluding %ld).', 'on_success_step', par_step_id USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Check on-fail action/step */
  IF (par_on_fail_action <> 1) /* Quit With Success */
    AND (par_on_fail_action <> 2) /* Quit With Failure */
    AND (par_on_fail_action <> 3) /* Goto Next Step */
    AND (par_on_fail_action <> 4) /* Goto Step */
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', 'on_failure_action', '1, 2, 3, 4' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  IF (par_on_fail_action = 4) AND ((par_on_fail_step_id < 1) OR (par_on_fail_step_id = par_step_id)) 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are greater than 0 but excluding %).', 'on_failure_step', par_step_id USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Warn the user about forward references */
  IF ((par_on_success_action = 4) AND (par_on_success_step_id > var_max_step_id)) 
  THEN
    RAISE 'Warning: Non-existent step referenced by %.', 'on_success_step_id' USING ERRCODE := '50000';
  END IF;

  IF ((par_on_fail_action = 4) AND (par_on_fail_step_id > var_max_step_id)) 
  THEN
    RAISE 'Warning: Non-existent step referenced by %.', '@on_fail_step_id' USING ERRCODE := '50000';
  END IF;
  
  /* Check run priority: must be a valid value to pass to SetThreadPriority: */
  /* [-15 = IDLE, -1 = BELOW_NORMAL, 0 = NORMAL, 1 = ABOVE_NORMAL, 15 = TIME_CRITICAL] */
  IF (par_os_run_priority NOT IN (- 15, - 1, 0, 1, 15)) 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', '@os_run_priority', '-15, -1, 0, 1, 15' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Check flags */
  IF ((par_flags < 0) OR (par_flags > 114)) THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', '@flags', '0..114' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  IF (LOWER(UPPER(par_subsystem)) <> LOWER('TSQL')) THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', '@subsystem', 'TSQL' USING ERRCODE := '50000';
    returncode := (1);
    RETURN;
  END IF;
  
  /* Success */
  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="8e908344-8e2f-4c68-a9d7-2fcf8fe8e499" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f8fd9402-fc68-45df-ba71-231cecc4cc12" name="sp_verify_schedule" is-trigger-function="0" unique-function-name="sp_verify_schedule" is-aggregate="f" language-name="plpgsql" context="sp_verify_schedule" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,smallint,integer,integer,integer,integer,integer,integer,integer,integer,integer,integer,character,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_schedule_id integer, par_name character varying, par_enabled smallint, par_freq_type integer, INOUT par_freq_interval integer, INOUT par_freq_subday_type integer, INOUT par_freq_subday_interval integer, INOUT par_freq_relative_interval integer, INOUT par_freq_recurrence_factor integer, INOUT par_active_start_date integer, INOUT par_active_start_time integer, INOUT par_active_end_date integer, INOUT par_active_end_time integer, par_owner_sid character, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="14" function-id="24020" volatility="VOLATILE" is-window="f" function-identity-arguments="par_schedule_id integer, par_name character varying, par_enabled smallint, par_freq_type integer, INOUT par_freq_interval integer, INOUT par_freq_subday_type integer, INOUT par_freq_subday_interval integer, INOUT par_freq_relative_interval integer, INOUT par_freq_recurrence_factor integer, INOUT par_active_start_date integer, INOUT par_active_start_time integer, INOUT par_active_end_date integer, INOUT par_active_end_time integer, par_owner_sid character, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_verify_schedule(par_schedule_id integer, par_name character varying, par_enabled smallint, par_freq_type integer, INOUT par_freq_interval integer, INOUT par_freq_subday_type integer, INOUT par_freq_subday_interval integer, INOUT par_freq_relative_interval integer, INOUT par_freq_recurrence_factor integer, INOUT par_active_start_date integer, INOUT par_active_start_time integer, INOUT par_active_end_date integer, INOUT par_active_end_time integer, par_owner_sid character, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_return_code INT;
  var_isAdmin INT;
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_name)) INTO par_name;
  
  /* Make sure that NULL input/output parameters - if NULL - are initialized to 0 */
  SELECT COALESCE(par_freq_interval, 0) INTO par_freq_interval;
  SELECT COALESCE(par_freq_subday_type, 0) INTO par_freq_subday_type;
  SELECT COALESCE(par_freq_subday_interval, 0) INTO par_freq_subday_interval;
  SELECT COALESCE(par_freq_relative_interval, 0) INTO par_freq_relative_interval;
  SELECT COALESCE(par_freq_recurrence_factor, 0) INTO par_freq_recurrence_factor;
  SELECT COALESCE(par_active_start_date, 0) INTO par_active_start_date;
  SELECT COALESCE(par_active_start_time, 0) INTO par_active_start_time;
  SELECT COALESCE(par_active_end_date, 0) INTO par_active_end_date;
  SELECT COALESCE(par_active_end_time, 0) INTO par_active_end_time;
  
  /* Verify name (we disallow schedules called 'ALL' since this has special meaning in sp_delete_jobschedules) */
  SELECT 0 INTO var_isAdmin;

  IF (
    EXISTS (
      SELECT * 
        FROM aws_sqlserver_ext.sysschedules
       WHERE (name = par_name)
    )
  ) 
  THEN /* Failure */
    RAISE 'The specified % ("%") already exists.', 'par_name', par_name USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
  END IF;

  IF (UPPER(par_name) = 'ALL') 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid.', 'name' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Verify enabled state */
  IF (par_enabled <> 0) AND (par_enabled <> 1) 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', '@enabled', '0, 1' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Verify frequency type */
  IF (par_freq_type = 2) /* OnDemand is no longer supported */
  THEN /* Failure */
    RAISE 'Frequency Type 0x2 (OnDemand) is no longer supported.' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  IF (par_freq_type NOT IN (1, 4, 8, 16, 32, 64, 128)) 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', 'freq_type', '1, 4, 8, 16, 32, 64, 128' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  /* Verify frequency sub-day type */
  IF (par_freq_subday_type <> 0) AND (par_freq_subday_type NOT IN (1, 2, 4, 8)) 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', 'freq_subday_type', '1, 2, 4, 8' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  /* Default active start/end date/times (if not supplied, or supplied as NULLs or 0) */
  IF (par_active_start_date = 0) 
  THEN
    SELECT date_part('year', NOW()::TIMESTAMP) * 10000 + date_part('month', NOW()::TIMESTAMP) * 100 + date_part('day', NOW()::TIMESTAMP)
      INTO par_active_start_date;
  END IF;
  
  /* This is an ISO format: "yyyymmdd" */
  IF (par_active_end_date = 0) 
  THEN
    /* December 31st 9999 */
    SELECT 99991231 INTO par_active_end_date;
  END IF;
    
  IF (par_active_start_time = 0) 
  THEN 
    /* 12:00:00 am */
    SELECT 000000 INTO par_active_start_time;
  END IF;

  IF (par_active_end_time = 0) 
  THEN
    /* 11:59:59 pm */
    SELECT 235959 INTO par_active_end_time;
  END IF;
    
  /* Verify active start/end dates */
  IF (par_active_end_date = 0) 
  THEN
    SELECT 99991231 INTO par_active_end_date;
  END IF;

  SELECT t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_date(par_active_end_date, 'active_end_date') t
    INTO var_return_code;

  IF (var_return_code <> 0) 
  THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
  
  SELECT t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_date(par_active_start_date, '@active_start_date') t
    INTO var_return_code;

  IF (var_return_code <> 0) 
  THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;

  IF (par_active_end_date < par_active_start_date) 
  THEN /* Failure */
    RAISE '% cannot be before %.', 'active_end_date', 'active_start_date' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;
  
  SELECT t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_time(par_active_end_time, '@active_end_time') t
    INTO var_return_code;

  IF (var_return_code <> 0) 
  THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
  
  SELECT t.returncode
    FROM aws_sqlserver_ext.sp_verify_job_time(par_active_start_time, '@active_start_time') t
    INTO var_return_code;

  IF (var_return_code <> 0) 
  THEN /* Failure */
    returncode := 1;
    RETURN;
  END IF;
    
  IF (par_active_start_time = par_active_end_time AND (par_freq_subday_type IN (2, 4, 8))) 
  THEN /* Failure */
    RAISE 'The specified "%" is invalid (valid values are: %).', 'active_end_time', 'before or after active_start_time' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  IF ((par_freq_type = 1) /* FREQTYPE_ONETIME */
    OR (par_freq_type = 64) /* FREQTYPE_AUTOSTART */
    OR (par_freq_type = 128)) /* FREQTYPE_ONIDLE */
  THEN /* Set standard defaults for non-required parameters */
    SELECT 0 INTO par_freq_interval;
    SELECT 0 INTO par_freq_subday_type;
    SELECT 0 INTO par_freq_subday_interval;
    SELECT 0 INTO par_freq_relative_interval;
    SELECT 0 INTO par_freq_recurrence_factor;
    /* Success */
    returncode := 0;
    RETURN;
  END IF;

  IF (par_freq_subday_type = 0) /* FREQSUBTYPE_ONCE */ 
  THEN
    SELECT 1 INTO par_freq_subday_type;
  END IF;

  IF ((par_freq_subday_type <> 1) /* FREQSUBTYPE_ONCE */
    AND (par_freq_subday_type <> 2) /* FREQSUBTYPE_SECOND */
    AND (par_freq_subday_type <> 4) /* FREQSUBTYPE_MINUTE */
    AND (par_freq_subday_type <> 8)) /* FREQSUBTYPE_HOUR */
  THEN /* Failure */
    RAISE 'The schedule for this job is invalid (reason: The specified @freq_subday_type is invalid (valid values are: 0x1, 0x2, 0x4, 0x8).).' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  IF ((par_freq_subday_type <> 1) AND (par_freq_subday_interval < 1)) /* FREQSUBTYPE_ONCE and less than 1 interval */
    OR ((par_freq_subday_type = 2) AND (par_freq_subday_interval < 10)) /* FREQSUBTYPE_SECOND and less than 10 seconds (see MIN_SCHEDULE_GRANULARITY in SqlAgent source code) */
  THEN /* Failure */
    RAISE 'The schedule for this job is invalid (reason: The specified @freq_subday_interval is invalid).' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  IF (par_freq_type = 4) /* FREQTYPE_DAILY */
  THEN
    SELECT 0 INTO par_freq_recurrence_factor;
    
    IF (par_freq_interval < 1) THEN /* Failure */
      RAISE 'The schedule for this job is invalid (reason: @freq_interval must be at least 1 for a daily job.).' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  END IF;

  IF (par_freq_type = 8) /* FREQTYPE_WEEKLY */
  THEN
    IF (par_freq_interval < 1) OR (par_freq_interval > 127) /* (2^7)-1 [freq_interval is a bitmap (Sun=1..Sat=64)] */
    THEN /* Failure */
      RAISE 'The schedule for this job is invalid (reason: @freq_interval must be a valid day of the week bitmask [Sunday = 1 .. Saturday = 64] for a weekly job.).' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  END IF;

  IF (par_freq_type = 16) /* FREQTYPE_MONTHLY */
  THEN
    IF (par_freq_interval < 1) OR (par_freq_interval > 31) 
    THEN /* Failure */
      RAISE 'The schedule for this job is invalid (reason: @freq_interval must be between 1 and 31 for a monthly job.).' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  END IF;

  IF (par_freq_type = 32) /* FREQTYPE_MONTHLYRELATIVE */
  THEN
    IF (par_freq_relative_interval <> 1) /* RELINT_1ST */
      AND (par_freq_relative_interval <> 2) /* RELINT_2ND */
      AND (par_freq_relative_interval <> 4) /* RELINT_3RD */
      AND (par_freq_relative_interval <> 8) /* RELINT_4TH */
      AND (par_freq_relative_interval <> 16) /* RELINT_LAST */
    THEN /* Failure */
      RAISE 'The schedule for this job is invalid (reason: @freq_relative_interval must be one of 1st (0x1), 2nd (0x2), 3rd [0x4], 4th (0x8) or Last (0x10).).' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  END IF;

  IF (par_freq_type = 32) /* FREQTYPE_MONTHLYRELATIVE */
  THEN
    IF (par_freq_interval <> 1) /* RELATIVE_SUN */
      AND (par_freq_interval <> 2) /* RELATIVE_MON */
      AND (par_freq_interval <> 3) /* RELATIVE_TUE */
      AND (par_freq_interval <> 4) /* RELATIVE_WED */
      AND (par_freq_interval <> 5) /* RELATIVE_THU */
      AND (par_freq_interval <> 6) /* RELATIVE_FRI */
      AND (par_freq_interval <> 7) /* RELATIVE_SAT */
      AND (par_freq_interval <> 8) /* RELATIVE_DAY */
      AND (par_freq_interval <> 9) /* RELATIVE_WEEKDAY */
      AND (par_freq_interval <> 10) /* RELATIVE_WEEKENDDAY */
    THEN /* Failure */
      RAISE 'The schedule for this job is invalid (reason: @freq_interval must be between 1 and 10 (1 = Sunday .. 7 = Saturday, 8 = Day, 9 = Weekday, 10 = Weekend-day) for a monthly-relative job.).' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  END IF;

  IF ((par_freq_type = 8) /* FREQTYPE_WEEKLY */
    OR (par_freq_type = 16) /* FREQTYPE_MONTHLY */
    OR (par_freq_type = 32)) /* FREQTYPE_MONTHLYRELATIVE */
    AND (par_freq_recurrence_factor < 1) 
  THEN /* Failure */
    RAISE 'The schedule for this job is invalid (reason: @freq_recurrence_factor must be at least 1.).' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
  END IF;
  /* Success */
  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="e60319dc-8187-480b-8fbd-0791ba9e9a2f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="01967e54-5c7d-4d58-b525-7192f2ce9b4a" name="sp_verify_schedule_identifiers" is-trigger-function="0" unique-function-name="sp_verify_schedule_identifiers" is-aggregate="f" language-name="plpgsql" context="sp_verify_schedule_identifiers" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying,integer,character,integer,integer,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_name_of_name_parameter character varying, par_name_of_id_parameter character varying, INOUT par_schedule_name character varying, INOUT par_schedule_id integer, INOUT par_owner_sid character, INOUT par_orig_server_id integer, par_job_id_filter integer DEFAULT NULL::integer, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="7" function-id="24019" volatility="VOLATILE" is-window="f" function-identity-arguments="par_name_of_name_parameter character varying, par_name_of_id_parameter character varying, INOUT par_schedule_name character varying, INOUT par_schedule_id integer, INOUT par_owner_sid character, INOUT par_orig_server_id integer, par_job_id_filter integer, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_verify_schedule_identifiers(par_name_of_name_parameter character varying, par_name_of_id_parameter character varying, INOUT par_schedule_name character varying, INOUT par_schedule_id integer, INOUT par_owner_sid character, INOUT par_orig_server_id integer, par_job_id_filter integer, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_retval INT;
  var_schedule_id_as_char VARCHAR(36);
  var_sch_name_count INT;
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_name_of_name_parameter)) INTO par_name_of_name_parameter;
  SELECT LTRIM(RTRIM(par_name_of_id_parameter)) INTO par_name_of_id_parameter;
  SELECT LTRIM(RTRIM(par_schedule_name)) INTO par_schedule_name;
  SELECT 0 INTO var_sch_name_count;

  IF (par_schedule_name = '') 
  THEN
    SELECT NULL INTO par_schedule_name;
  END IF;

  IF ((par_schedule_name IS NULL) AND (par_schedule_id IS NULL)) OR ((par_schedule_name IS NOT NULL) AND (par_schedule_id IS NOT NULL)) 
  THEN /* Failure */
    RAISE 'Supply either % or % to identify the schedule.', par_name_of_id_parameter, par_name_of_name_parameter USING ERRCODE := '50000';
    returncode := 1;
    RETURN;
  END IF;

  /* Check schedule id */
  IF (par_schedule_id IS NOT NULL) 
  THEN
    /* Look at all schedules */
    SELECT name
         , owner_sid
         , originating_server_id
      INTO par_schedule_name
         , par_owner_sid
         , par_orig_server_id
      FROM aws_sqlserver_ext.sysschedules
     WHERE (schedule_id = par_schedule_id);

    IF (par_schedule_name IS NULL) 
    THEN /* Failure */
      SELECT CAST (par_schedule_id AS VARCHAR(36))
        INTO var_schedule_id_as_char;
        
      RAISE 'The specified % ("%") does not exist.', 'schedule_id', var_schedule_id_as_char USING ERRCODE := '50000';
      returncode := 1;
      RETURN;
    END IF;
  ELSE 
    IF (par_schedule_name IS NOT NULL)
    THEN
      /* Check if the schedule name is ambiguous */
      IF (SELECT COUNT(*) FROM aws_sqlserver_ext.sysschedules WHERE name = par_schedule_name) > 1 
      THEN /* Failure */
        RAISE 'There are two or more sysschedules named "%". Specify % instead of % to uniquely identify the sysschedules.', par_job_name, par_name_of_id_parameter, par_name_of_name_parameter USING ERRCODE := '50000';
        returncode := 1;
        RETURN;
      END IF;
    
      /* The name is not ambiguous, so get the corresponding job_id (if the job exists) */
      SELECT schedule_id
           , owner_sid
        INTO par_schedule_id, par_owner_sid
        FROM aws_sqlserver_ext.sysschedules
       WHERE (name = par_schedule_name);
     
      /* the view would take care of all the permissions issues. */
      IF (par_schedule_id IS NULL) 
      THEN /* Failure */
        RAISE 'The specified % ("%") does not exist.', 'par_schedule_name', par_schedule_name USING ERRCODE := '50000';
        returncode := 1;
        RETURN;
      END IF;
    END IF;
  END IF;
  
  /* Success */
  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="4efd688f-a24e-4dd8-b995-141216da2450" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="62ec8edf-e1a7-48e2-9894-2b05829679ce" name="sp_xml_preparedocument" is-trigger-function="0" unique-function-name="sp_xml_preparedocument" is-aggregate="f" language-name="plpgsql" context="sp_xml_preparedocument" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,bigint" is-returning-set="f" ret-datatype="int8" function-arguments="xmldocument text, OUT dochandle bigint" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="24247" volatility="VOLATILE" is-window="f" function-identity-arguments="xmldocument text, OUT dochandle bigint" overload-function-count="1" proc-language="plpgsql" function-signature="sp_xml_preparedocument(xmldocument text, OUT dochandle bigint)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE                       
   XmlDocument$data XML;
BEGIN
     /*Create temporary structure for xmldocument saving*/
     CREATE TEMPORARY SEQUENCE IF NOT EXISTS aws_sqlserver_ext$seq_openmxl_id MINVALUE 1 MAXVALUE 9223372036854775807 START WITH 1 INCREMENT BY 1 CACHE 5;
     
     CREATE TEMPORARY TABLE IF NOT EXISTS aws_sqlserver_ext$openxml
          (DocID BigInt NOT NULL DEFAULT NEXTVAL('aws_sqlserver_ext$seq_openmxl_id'),
           XmlData XML not NULL,
           CONSTRAINT pk_aws_sqlserver_ext$doc_id PRIMARY KEY(DocID)
          ) ON COMMIT PRESERVE ROWS;

     IF xml_is_well_formed(XmlDocument) THEN
       XmlDocument$data := XmlDocument::XML;      
     ELSE
       RAISE EXCEPTION '%','The XML parse error occurred';
     END IF;
     
     INSERT INTO aws_sqlserver_ext$openxml(XmlData)
          VALUES (XmlDocument$data)
       RETURNING DocID INTO DocHandle;	
END;
]]></complex-attribute>
                        <category _I_D="d1add09a-107d-4468-8f34-e363ff86fbc0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bc901b65-f54e-47e8-a8cb-39ef6dc7cd37" name="sp_xml_removedocument" is-trigger-function="0" unique-function-name="sp_xml_removedocument" is-aggregate="f" language-name="plpgsql" context="sp_xml_removedocument" subcategories-loading="none" object-loading="extended" arguments-datatypes="bigint" is-returning-set="f" ret-datatype="void" function-arguments="dochandle bigint" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="24248" volatility="VOLATILE" is-window="f" function-identity-arguments="dochandle bigint" overload-function-count="1" proc-language="plpgsql" function-signature="sp_xml_removedocument(dochandle bigint)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  lt_error_text TEXT := 'Could not find prepared statement with handle '||CASE 
                                                                            WHEN DocHandle IS NULL THEN 'null'
                                                                              ELSE DocHandle::TEXT
                                                                           END;
BEGIN
	DELETE FROM aws_sqlserver_ext$openxml t
	 WHERE t.DocID = DocHandle;
	
	IF NOT FOUND THEN
	     RAISE EXCEPTION '%', lt_error_text;  
	END IF;

	EXCEPTION
	  WHEN SQLSTATE '42P01' THEN 
	      RAISE EXCEPTION '%',lt_error_text;
END;
]]></complex-attribute>
                        <category _I_D="26885a95-f915-4fba-ac72-3a38c7232283" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="91d3b559-95fc-4814-8f3d-8b3bf7986ed2" name="strpos3" is-trigger-function="0" unique-function-name="strpos3" is-aggregate="f" language-name="plpgsql" context="strpos3" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,integer" is-returning-set="f" ret-datatype="int4" function-arguments="p_str text, p_substr text, p_loc integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="24024" volatility="VOLATILE" is-window="f" function-identity-arguments="p_str text, p_substr text, p_loc integer" overload-function-count="1" proc-language="plpgsql" function-signature="strpos3(p_str text, p_substr text, p_loc integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
	v_loc int := case when p_loc > 0 then p_loc else 1 end;
	v_cnt int := length(p_str) - v_loc + 1;
BEGIN
/***************************************************************
EXTENSION PACK function STRPOS3(x)
***************************************************************/
	if v_cnt > 0 then
		return case when 0!= strpos(substr(p_str, v_loc, v_cnt), p_substr)
		            then strpos(substr(p_str, v_loc, v_cnt), p_substr) + v_loc - 1
			          else strpos(substr(p_str, v_loc, v_cnt), p_substr)
		       end;
	else
		return 0;
	end if;
END;
]]></complex-attribute>
                        <category _I_D="97b60a64-2c36-46bc-91cd-b04bbec2a7af" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="920a9cb2-10fc-4817-812c-e2e266c6fd18" name="sysmail_add_account_sp" is-trigger-function="0" unique-function-name="sysmail_add_account_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_add_account_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying,character varying,character varying,character varying,character varying,integer,character varying,character varying,smallint,smallint,integer,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_account_name character varying, par_email_address character varying, par_display_name character varying DEFAULT NULL::character varying, par_replyto_address character varying DEFAULT NULL::character varying, par_description character varying DEFAULT NULL::character varying, par_mailserver_name character varying DEFAULT NULL::character varying, par_mailserver_type character varying DEFAULT 'SMTP'::character varying, par_port integer DEFAULT 25, par_username character varying DEFAULT NULL::character varying, par_password character varying DEFAULT NULL::character varying, par_use_default_credentials smallint DEFAULT 0, par_enable_ssl smallint DEFAULT 0, OUT par_account_id integer, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="12" function-id="24025" volatility="VOLATILE" is-window="f" function-identity-arguments="par_account_name character varying, par_email_address character varying, par_display_name character varying, par_replyto_address character varying, par_description character varying, par_mailserver_name character varying, par_mailserver_type character varying, par_port integer, par_username character varying, par_password character varying, par_use_default_credentials smallint, par_enable_ssl smallint, OUT par_account_id integer, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_add_account_sp(par_account_name character varying, par_email_address character varying, par_display_name character varying, par_replyto_address character varying, par_description character varying, par_mailserver_name character varying, par_mailserver_type character varying, par_port integer, par_username character varying, par_password character varying, par_use_default_credentials smallint, par_enable_ssl smallint, OUT par_account_id integer, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
BEGIN

  SELECT t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_addressparams_sp
    (
      par_address => par_replyto_address,
      par_parameter_name => '@replyto_address'
    ) t
    INTO var_rc;

  IF var_rc <> 0 THEN

    returncode := var_rc;
    RETURN;

  END IF;

  IF par_mailserver_name IS NULL THEN /* Failure */

    RAISE '% is not a valid mailserver_name', par_mailserver_name USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;

  IF par_mailserver_type IS NULL THEN /* Failure */

    RAISE '% is not a valid mailserver_type', par_mailserver_type USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;

  INSERT 
    INTO aws_sqlserver_ext.sysmail_account
    (
      name
    , description
    , email_address
    , display_name
    , replyto_address       
    )
  VALUES
  (
    par_account_name
  , par_description
  , par_email_address
  , par_display_name
  , par_replyto_address
  );
  
  SELECT account_id
    INTO par_account_id
    FROM aws_sqlserver_ext.sysmail_account
   WHERE name = par_account_name;

  returncode := 0;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="19ba6526-5742-4b7a-8f3c-a2b1822ded3f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f4484ecd-f4bb-4c6b-98e2-cd2aee6f2b99" name="sysmail_add_profile_sp" is-trigger-function="0" unique-function-name="sysmail_add_profile_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_add_profile_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,integer,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_profile_name character varying, par_description character varying DEFAULT NULL::character varying, OUT par_profile_id integer, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24027" volatility="VOLATILE" is-window="f" function-identity-arguments="par_profile_name character varying, par_description character varying, OUT par_profile_id integer, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_add_profile_sp(par_profile_name character varying, par_description character varying, OUT par_profile_id integer, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  /* insert new profile record, rely on primary key constraint to error out */
  INSERT INTO aws_sqlserver_ext.sysmail_profile (name, description)
  VALUES (par_profile_name, par_description);

  /* fetch back profile_id */
  SELECT profile_id
    INTO par_profile_id
    FROM aws_sqlserver_ext.sysmail_profile
   WHERE name = par_profile_name;
   
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="f3c53cc0-1651-4cec-8f06-a0769632190d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="eb352e0f-9350-4829-b69d-e9b0d4775086" name="sysmail_add_profileaccount_sp" is-trigger-function="0" unique-function-name="sysmail_add_profileaccount_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_add_profileaccount_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,integer,character varying,integer,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_profile_id integer DEFAULT NULL::integer, par_profile_name character varying DEFAULT NULL::character varying, par_account_id integer DEFAULT NULL::integer, par_account_name character varying DEFAULT NULL::character varying, par_sequence_number integer DEFAULT NULL::integer, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="5" function-id="24026" volatility="VOLATILE" is-window="f" function-identity-arguments="par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, par_sequence_number integer, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_add_profileaccount_sp(par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, par_sequence_number integer, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_profileid INTEGER;
  var_accountid INTEGER;
BEGIN

  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp
    (
      par_profile_id,
      par_profile_name,
      0::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_profileid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  SELECT t.par_accountid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_account_sp
    (
      par_account_id,
      par_account_name,
      0::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_accountid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 2;
    RETURN;

  END IF;

  /* insert new account record, rely on primary key constraint to error out */
  INSERT INTO aws_sqlserver_ext.sysmail_profileaccount (profile_id, account_id, sequence_number)
  VALUES (var_profileid, var_accountid, par_sequence_number);
  
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="9731310e-3591-45f9-9f89-1ef276650dcb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3ad49c2a-b090-40c5-a5fe-eb7ca1f00b69" name="sysmail_dbmail_json" is-trigger-function="0" unique-function-name="sysmail_dbmail_json" is-aggregate="f" language-name="plpgsql" context="sysmail_dbmail_json" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,text,character varying,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_mail_id integer, OUT par_mail_data text, OUT par_server_name character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="24028" volatility="VOLATILE" is-window="f" function-identity-arguments="par_mail_id integer, OUT par_mail_data text, OUT par_server_name character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_dbmail_json(par_mail_id integer, OUT par_mail_data text, OUT par_server_name character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_r VARCHAR(2);
  var_t1 VARCHAR(2) DEFAULT '';
  var_t2 VARCHAR(4) DEFAULT '';
  var_t3 VARCHAR(6) DEFAULT '';
  var_t4 VARCHAR(8) DEFAULT '';
  var_xml TEXT DEFAULT '';
  var_source VARCHAR(255);
  var_profile_id INTEGER;
  var_recipients TEXT;
  var_copy_recipients TEXT;
  var_blind_copy_recipients TEXT;
  var_subject VARCHAR(255);
  var_body_format VARCHAR(20);
  var_body TEXT;
  var_from_address TEXT;
  var_reply_to TEXT;
  var_importance VARCHAR(6);
  var_sensitivity VARCHAR(12);
  var_mailitem_id INTEGER;
BEGIN

  SELECT mailitem_id
       , profile_id
       , recipients
       , copy_recipients
       , blind_copy_recipients
       , subject
       , UPPER(body_format)
       , body
       , importance
       , sensitivity
        /* @file_attachments = file_attachments, */
        /* @attachment_encoding = attachment_encoding, */
        /* @query = query, */
        /* @execute_query_database = execute_query_database, */
        /* @attach_query_result_as_file = attach_query_result_as_file, */
        /* @query_result_header = query_result_header, */
        /* @query_result_width = query_result_width, */
        /* @query_result_separator = query_result_separator, */
        /* @exclude_query_output = exclude_query_output, */
        /* @append_query_error = append_query_error, */
        , from_address
        , reply_to
    INTO var_mailitem_id
       , var_profile_id
       , var_recipients
       , var_copy_recipients
       , var_blind_copy_recipients
       , var_subject
       , var_body_format
       , var_body
       , var_importance
       , var_sensitivity
       , var_from_address
       , var_reply_to
    FROM aws_sqlserver_ext.sysmail_mailitems
   WHERE mailitem_id = par_mail_id
   ORDER BY mailitem_id ASC NULLS FIRST
   LIMIT 1;

  IF var_mailitem_id IS NULL THEN

    RAISE 'E-mail messages are missing.' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;

  SELECT CASE
           WHEN LENGTH(a.display_name) = 0 THEN a.email_address
           ELSE CONCAT(a.display_name, ' <', a.email_address, '>')
         END
    INTO var_source
    FROM aws_sqlserver_ext.sysmail_profile AS p
   INNER JOIN aws_sqlserver_ext.sysmail_profileaccount AS pa
      ON pa.profile_id = p.profile_id
   INNER JOIN aws_sqlserver_ext.sysmail_account AS a
      ON a.account_id = pa.account_id
   WHERE p.profile_id = var_profile_id
   LIMIT 1;

  SELECT servername
    INTO par_server_name
    FROM aws_sqlserver_ext.sysmail_server
   WHERE account_id = 0
     AND servertype = 'AWSLAMBDA'
   LIMIT 1;

  IF par_server_name IS NULL THEN

    RAISE 'ARN are missing.' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;

  var_xml := CONCAT(var_xml, '{', var_r);
  var_xml := CONCAT(var_xml, var_t1, '"service": "ses",', var_r);
  var_xml := CONCAT(var_xml, var_t1, '"args": {', var_r);
  /* set source */
  var_xml := CONCAT(var_xml, var_t2, '"source": "', var_source, '",', var_r);
  /* recipients */
  var_xml := CONCAT(var_xml, var_t2, '"recipients": [', var_r);
  var_xml := CONCAT(var_xml, var_t3, '"', var_recipients, '"', var_r);     /* !!!!!!!!!! */
  /* SET @xml = CONCAT(@xml, @t3, '"address": "sample <sample@sample.info>",', @r);    !!!!!!!!!! */
  /* SET @xml = CONCAT(@xml, @t3, '"address": "sample@sample.info"', @r);    !!!!!!!!!! */
  var_xml := CONCAT(var_xml, var_t2, '],', var_r);
  
  /* copy_recipients */
  var_xml := CONCAT(var_xml, var_t2, '"copyrecipients": [', var_r);

  IF var_copy_recipients IS NOT NULL AND LENGTH(var_copy_recipients) > 0 THEN

    var_xml := CONCAT(var_xml, var_t3, '"', var_copy_recipients, '",', var_r);         /* !!!!!!!!!! */
    /* SET @xml = CONCAT(@xml, @t3, '"address": "sample <sample@sample.info>",', @r);    !!!!!!!!!! */
    /* SET @xml = CONCAT(@xml, @t3, '"address": "sample@sample.info"', @r);    !!!!!!!!!! */

  END IF;

  var_xml := CONCAT(var_xml, var_t2, '],', var_r);

  /* blind_copy_recipients */
  var_xml := CONCAT(var_xml, var_t2, '"blindcopyrecipients": [', var_r);

  IF var_blind_copy_recipients IS NOT NULL AND LENGTH(var_blind_copy_recipients) > 0 THEN

    var_xml := CONCAT(var_xml, var_t3, '"', var_blind_copy_recipients, '",', var_r);         /* !!!!!!!!!! */
    /* SET @xml = CONCAT(@xml, @t3, '"address": "sample <sample@sample.info>",', @r);   -- !!!!!!!!!! */
    /* SET @xml = CONCAT(@xml, @t3, '"address": "sample@sample.info"', @r);   -- !!!!!!!!!! */

  END IF;

  var_xml := CONCAT(var_xml, var_t2, '],', var_r);

  var_xml := CONCAT(var_xml, var_t2, '"importance": "', var_importance, '",', var_r);
  var_xml := CONCAT(var_xml, var_t2, '"sensitivity": "', var_sensitivity, '",', var_r);
  var_xml := CONCAT(var_xml, var_t2, '"subject": "', var_subject, '",', var_r);
  var_xml := CONCAT(var_xml, var_t2, '"format": "', var_body_format, '",', var_r);
  var_xml := CONCAT(var_xml, var_t2, '"body": {', var_r);
  var_xml := CONCAT(var_xml, var_t3, '"data": "', var_body, '"', var_r);
  var_xml := CONCAT(var_xml, var_t2, '}', var_r);
  var_xml := CONCAT(var_xml, var_t1, '}', var_r);
  var_xml := CONCAT(var_xml, '}');
  
  par_mail_data := var_xml;

END;
]]></complex-attribute>
                        <category _I_D="006a48e1-0a9c-452c-8ad9-ed5c96cea4e1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="62fc8b9b-5bc9-4e83-81ab-70d5ed9e1865" name="sysmail_dbmail_xml" is-trigger-function="0" unique-function-name="sysmail_dbmail_xml" is-aggregate="f" language-name="plpgsql" context="sysmail_dbmail_xml" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,text,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_mail_id integer, OUT par_mail_data text, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="24029" volatility="VOLATILE" is-window="f" function-identity-arguments="par_mail_id integer, OUT par_mail_data text, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_dbmail_xml(par_mail_id integer, OUT par_mail_data text, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_r VARCHAR(2); /* DEFAULT aws_sqlserver_ext.CHAR(10) || aws_sqlserver_ext.CHAR(13);*/
  var_t1 VARCHAR(2) DEFAULT ''; --'  ';
  var_t2 VARCHAR(4) DEFAULT ''; --'    ';
  var_t3 VARCHAR(6) DEFAULT ''; --'      ';
  var_t4 VARCHAR(8) DEFAULT ''; --'        ';
  var_xml TEXT DEFAULT '';
  var_source VARCHAR(255);
  var_profile_id INT;
  var_recipients TEXT;
  var_copy_recipients TEXT;
  var_blind_copy_recipients TEXT;
  var_subject VARCHAR(255);
  var_body_format VARCHAR(20);
  var_body TEXT;
  var_from_address TEXT;
  var_reply_to TEXT;
  var_importance VARCHAR(6);
  var_sensitivity VARCHAR(12);
  var_mailitem_id INTEGER;
BEGIN

  SELECT mailitem_id
       , profile_id
       , recipients
       , copy_recipients
       , blind_copy_recipients
       , subject
       , UPPER(body_format)
       , body
       , importance
       , sensitivity
        /* @file_attachments = file_attachments, */
        /* @attachment_encoding = attachment_encoding, */
        /* @query = query, */
        /* @execute_query_database = execute_query_database, */
        /* @attach_query_result_as_file = attach_query_result_as_file, */
        /* @query_result_header = query_result_header, */
        /* @query_result_width = query_result_width, */
        /* @query_result_separator = query_result_separator, */
        /* @exclude_query_output = exclude_query_output, */
        /* @append_query_error = append_query_error, */, from_address, reply_to
    INTO var_mailitem_id
       , var_profile_id
       , var_recipients
       , var_copy_recipients
       , var_blind_copy_recipients
       , var_subject
       , var_body_format
       , var_body
       , var_importance
       , var_sensitivity
       , var_from_address
       , var_reply_to
    FROM aws_sqlserver_ext.sysmail_mailitems
   WHERE mailitem_id = par_mail_id /* sent_status = 0 */
   ORDER BY mailitem_id ASC NULLS FIRST
   LIMIT 1;

  IF var_mailitem_id IS NULL THEN

    RAISE 'E-mail messages are missing.' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;

  SELECT CASE
           WHEN LENGTH(a.display_name) = 0 THEN a.email_address
           ELSE CONCAT(a.display_name, ' <', a.email_address, '>')
         END
    INTO var_source
    FROM aws_sqlserver_ext.sysmail_profile AS p
   INNER JOIN aws_sqlserver_ext.sysmail_profileaccount AS pa
      ON pa.profile_id = p.profile_id
   INNER JOIN aws_sqlserver_ext.sysmail_account AS a
      ON a.account_id = pa.account_id
   WHERE p.profile_id = var_profile_id
   LIMIT 1;
   
  var_xml := CONCAT(var_xml, '<mail>', var_r);
  /* set source */
  var_xml := CONCAT(var_xml, var_t1, '<source>', var_source, '</source>', var_r);
  /* set destination */
  var_xml := CONCAT(var_xml, var_t1, '<destination>', var_r);
  var_xml := CONCAT(var_xml, var_t2, '<to_addresses>', var_r);
  var_xml := CONCAT(var_xml, var_t3, '<address>', var_recipients, '</address>', var_r);
  /* SET @xml = CONCAT(@xml, @t3, '<address>', @destination2, '</address>', @r); */
  var_xml := CONCAT(var_xml, var_t2, '</to_addresses>', var_r);
  var_xml := CONCAT(var_xml, var_t1, '</destination>', var_r);
  /* set message */
  var_xml := CONCAT(var_xml, var_t1, '<message>', var_r);
  var_xml := CONCAT(var_xml, var_t2, '<subject>', var_r);
  var_xml := CONCAT(var_xml, var_t3, '<data>', var_subject, '</data>', var_r);
  var_xml := CONCAT(var_xml, var_t3, '<charset>UTF-8</charset>', var_r);
  var_xml := CONCAT(var_xml, var_t2, '</subject>', var_r);
  var_xml := CONCAT(var_xml, var_t2, '<body>', var_r);

  IF LOWER(var_body_format) = LOWER('TEXT') THEN

    var_xml := CONCAT(var_xml, var_t3, '<text>', var_r);
    var_xml := CONCAT(var_xml, var_t4, '<data>', var_body, '</data>', var_r);
    var_xml := CONCAT(var_xml, var_t4, '<charset>UTF-8</charset>', var_r);
    var_xml := CONCAT(var_xml, var_t3, '</text>', var_r);
  /* 'HTML' */

  ELSE

    var_xml := CONCAT(var_xml, var_t3, '<html>', var_r);
    var_xml := CONCAT(var_xml, var_t4, '<data>', var_body, '</data>', var_r);
    var_xml := CONCAT(var_xml, var_t4, '<charset>UTF-8</charset>', var_r);
    var_xml := CONCAT(var_xml, var_t3, '</html>', var_r);

  END IF;

  var_xml := CONCAT(var_xml, var_t2, '</body>', var_r);
  var_xml := CONCAT(var_xml, var_t1, '</message>', var_r);
  /* reply to */
  var_xml := CONCAT(var_xml, var_t1, '<reply_to_addresses>', var_r);
  var_xml := CONCAT(var_xml, var_t2, '<address>', var_source, '</address>', var_r);
  /* SET @xml = CONCAT(@xml, @t2, '<address>',@reply_to_addresses2,'</address>', @r); */
  var_xml := CONCAT(var_xml, var_t1, '</reply_to_addresses>', var_r);
  var_xml := CONCAT(var_xml, '</mail>');
  
  par_mail_data := var_xml;

END;
]]></complex-attribute>
                        <category _I_D="2142349a-d318-48d0-ae47-d1178e0d68e8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7d357c96-cb8a-4d63-aeec-afa1cea515bd" name="sysmail_delete_account_sp" is-trigger-function="0" unique-function-name="sysmail_delete_account_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_delete_account_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_account_id integer DEFAULT NULL::integer, par_account_name character varying DEFAULT NULL::character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24030" volatility="VOLATILE" is-window="f" function-identity-arguments="par_account_id integer, par_account_name character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_delete_account_sp(par_account_id integer, par_account_name character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_accountid INTEGER;
  var_credential_name CHARACTER VARYING(128);
BEGIN

  SELECT t.par_accountid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_account_sp
  (
    par_account_id,
    par_account_name,
    0::SMALLINT,
    0::SMALLINT
  ) t
    INTO var_accountid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;
  
  DELETE 
    FROM aws_sqlserver_ext.sysmail_account
   WHERE account_id = var_accountid;
   
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="58f1265b-92f9-48b0-81ac-543465ebeff8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c4865dff-56d2-4c13-9fca-4994d3f98815" name="sysmail_delete_mailitems_sp" is-trigger-function="0" unique-function-name="sysmail_delete_mailitems_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_delete_mailitems_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone,character varying,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_sent_before timestamp without time zone DEFAULT NULL::timestamp without time zone, par_sent_status character varying DEFAULT NULL::character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24031" volatility="VOLATILE" is-window="f" function-identity-arguments="par_sent_before timestamp without time zone, par_sent_status character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_delete_mailitems_sp(par_sent_before timestamp without time zone, par_sent_status character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  vsentstatus TEXT;
BEGIN

  vsentstatus := TRIM(par_sent_status);

  IF vsentstatus = '' THEN

    vsentstatus := NULL;

  END IF;

  IF vsentstatus IS NOT NULL AND LOWER(vsentstatus) NOT IN ('unsent', 'sent', 'failed', 'retrying') THEN /* Failure */

    RAISE 'The specified "%" is invalid (valid values are: %).', 'sent_status', 'unsent, sent, failed, retrying' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;

  IF par_sent_before IS NULL AND vsentstatus IS NULL THEN /* Failure */

    RAISE 'Either % or % parameter needs to be supplied', 'sent_before', 'sent_status' USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;
  
  DELETE 
    FROM aws_sqlserver_ext.sysmail_mailitems
   WHERE (par_sent_before IS NULL OR send_request_date < par_sent_before) 
     AND (vsentstatus IS NULL OR sent_status = vsentstatus);

END;
]]></complex-attribute>
                        <category _I_D="4bfd59fb-1999-4039-8302-ca5f343a7187" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="adff2dcc-a80c-4b16-96a3-012e361f54e7" name="sysmail_delete_profile_sp" is-trigger-function="0" unique-function-name="sysmail_delete_profile_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_delete_profile_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,smallint,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_profile_id integer DEFAULT NULL::integer, par_profile_name character varying DEFAULT NULL::character varying, par_force_delete smallint DEFAULT 1, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="24033" volatility="VOLATILE" is-window="f" function-identity-arguments="par_profile_id integer, par_profile_name character varying, par_force_delete smallint, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_delete_profile_sp(par_profile_id integer, par_profile_name character varying, par_force_delete smallint, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_profileid INTEGER;
BEGIN
  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp
  (
    par_profile_id,
    par_profile_name,
    0::SMALLINT,
    0::SMALLINT
  ) t
    INTO var_profileid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  IF (
    EXISTS 
    (
      SELECT 1 
        FROM aws_sqlserver_ext.sysmail_mailitems m
       WHERE m.profile_id = var_profileid
         AND m.sent_status IN (0,3)
    )
    AND par_force_delete <> 1
  ) 
  THEN

    IF par_profile_name IS NULL THEN

      SELECT name INTO par_profile_name
        FROM aws_sqlserver_ext.sysmail_profile
       WHERE profile_id = var_profileid;

    END IF;
    
    RAISE 'Deleting profile %s failed because there are some unsent emails associated with this profile, use force_delete option to force the deletion of the profile.', par_profile_name USING ERRCODE := '50000';
    
    returncode := 1;
    RETURN;

  END IF;
  
  UPDATE aws_sqlserver_ext.sysmail_mailitems
     SET sent_status = 2
       , sent_date = NOW()
   WHERE profile_id = var_profileid 
     AND sent_status <> 1;
   
  DELETE FROM aws_sqlserver_ext.sysmail_profile
   WHERE profile_id = var_profileid;
   
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="59713bb4-52b4-474b-a88c-6f1e43e0032d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c5c2ed9e-626f-4cff-9530-3a3da7192036" name="sysmail_delete_profileaccount_sp" is-trigger-function="0" unique-function-name="sysmail_delete_profileaccount_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_delete_profileaccount_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,integer,character varying,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_profile_id integer DEFAULT NULL::integer, par_profile_name character varying DEFAULT NULL::character varying, par_account_id integer DEFAULT NULL::integer, par_account_name character varying DEFAULT NULL::character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="4" function-id="24032" volatility="VOLATILE" is-window="f" function-identity-arguments="par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_delete_profileaccount_sp(par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_profileid INTEGER;
  var_accountid INTEGER;
BEGIN

  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp
  (
    par_profile_id,
    par_profile_name,
    1::SMALLINT,
    0::SMALLINT
  ) t
    INTO var_profileid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  SELECT t.par_accountid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_account_sp
    (
      par_account_id,
      par_account_name,
      1::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_accountid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 2;
    RETURN;

  END IF;

  IF var_profileid IS NOT NULL AND var_accountid IS NOT NULL /* both parameters supplied for deletion */ THEN

    DELETE 
      FROM aws_sqlserver_ext.sysmail_profileaccount
     WHERE profile_id = var_profileid 
       AND account_id = var_accountid;

  ELSE

    IF var_profileid IS NOT NULL /* profile id is supplied */ THEN

      DELETE 
        FROM aws_sqlserver_ext.sysmail_profileaccount
       WHERE profile_id = var_profileid;

    ELSE

      IF var_accountid IS NOT NULL /* account id is supplied */ THEN

        DELETE 
          FROM aws_sqlserver_ext.sysmail_profileaccount
         WHERE account_id = var_accountid;

      ELSE /* no parameters are supplied for deletion */

        RAISE 'Either % or % parameter needs to be supplied', 'profile', 'account' USING ERRCODE := '50000';
        returncode := 3;
        RETURN;

      END IF;

    END IF;

  END IF;
  
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="984f0968-6fdd-46d4-bc9a-2f7c33f528e7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3fae29df-bf5b-4b99-b6a8-f95f0d89c37d" name="sysmail_help_account_sp" is-trigger-function="0" unique-function-name="sysmail_help_account_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_help_account_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_account_id integer DEFAULT NULL::integer, par_account_name character varying DEFAULT NULL::character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24034" volatility="VOLATILE" is-window="f" function-identity-arguments="par_account_id integer, par_account_name character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_help_account_sp(par_account_id integer, par_account_name character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_accountid INTEGER;
  curs1 REFCURSOR;

  var_c_account_id INTEGER;
  var_c_name VARCHAR(128);
  var_c_description VARCHAR(256);
  var_c_email_address VARCHAR(128);
  var_c_display_name VARCHAR(128);
  var_c_replyto_address VARCHAR(128);

  var_c_servertype VARCHAR(128);-- NOT NULL
  var_c_servername VARCHAR(128);-- NOT NULL
BEGIN

  SELECT t.par_accountid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_account_sp
    (
      par_account_id,
      par_account_name,
      1::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_accountid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;
  
  IF var_accountid IS NOT NULL THEN

    OPEN curs1 FOR EXECUTE 
      'SELECT a.account_id, a.name, a.description, a.email_address, a.display_name, a.replyto_address
            , s.servertype, s.servername          
         FROM aws_sqlserver_ext.sysmail_account AS a 
         JOIN aws_sqlserver_ext.sysmail_server AS s
           ON s.account_id = a.account_id
        WHERE a.account_id = $1' USING var_accountid;

  ELSE

    OPEN curs1 FOR EXECUTE 
      'SELECT a.account_id, a.name, a.description, a.email_address, a.display_name, a.replyto_address
            , s.servertype, s.servername          
         FROM aws_sqlserver_ext.sysmail_account AS a 
         JOIN aws_sqlserver_ext.sysmail_server AS s
           ON s.account_id = a.account_id';

  END IF;

  LOOP

    FETCH curs1 INTO var_c_account_id, var_c_name, var_c_description, var_c_email_address, var_c_display_name, var_c_replyto_address, var_c_servertype, var_c_servername;         
    EXIT WHEN NOT FOUND;
    RAISE NOTICE '%', '|--------------------------------------------------------------------------------------------|';
    RAISE NOTICE '%', '| ' || RPAD('ID                  :' || var_c_account_id::character varying, 90) || ' |';
    RAISE NOTICE '%', '| ' || RPAD('Account Name        :' || var_c_name, 90) || ' | ';
    RAISE NOTICE '%', '| ' || RPAD('Account Description :' || COALESCE(var_c_description,' '), 90) || ' | ';
    RAISE NOTICE '%', '| ' || RPAD('E-mail Address      :' || var_c_email_address, 90) || ' | ';
    RAISE NOTICE '%', '| ' || RPAD('Display Name        :' || COALESCE(var_c_display_name,' '), 90) || ' | ';
    RAISE NOTICE '%', '| ' || RPAD('Reply-to Address    :' || COALESCE(var_c_replyto_address,' '), 90) || ' | ';
    RAISE NOTICE '%', '| ' || RPAD('Server Type         :' || COALESCE(var_c_servertype,' '), 90) || ' | ';
    RAISE NOTICE '%', '| ' || RPAD('Server Name         :' || COALESCE(var_c_servername,' '), 90) || ' | ';
    RAISE NOTICE '%', '|--------------------------------------------------------------------------------------------|';

  END LOOP;          
    
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="db84e370-9fea-408a-aa36-3e4cac41c140" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="112383df-f204-4f26-8e4c-7c526f9d9065" name="sysmail_help_profile_sp" is-trigger-function="0" unique-function-name="sysmail_help_profile_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_help_profile_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_profile_id integer DEFAULT NULL::integer, par_profile_name character varying DEFAULT NULL::character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24036" volatility="VOLATILE" is-window="f" function-identity-arguments="par_profile_id integer, par_profile_name character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_help_profile_sp(par_profile_id integer, par_profile_name character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_profileid INTEGER;
  curs1 REFCURSOR;

  var_c_profile_id INTEGER;
  var_c_name CHARACTER VARYING(128);
  var_c_description CHARACTER VARYING;
BEGIN

  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp
    (
      par_profile_id,
      par_profile_name,
      1::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_profileid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  RAISE NOTICE '%', '|-------|--------------------------------|----------------------------------------------------| ';    
  RAISE NOTICE '%', '|  ID   |        Profile Name            |                Profile Description                 | ';
  RAISE NOTICE '%', '|-------|--------------------------------|----------------------------------------------------| ';    
  
  IF var_profileid IS NOT NULL THEN

    OPEN curs1 FOR EXECUTE 'SELECT profile_id, name, description FROM aws_sqlserver_ext.sysmail_profile WHERE profile_id = $1' USING var_profileid;

    LOOP

      FETCH curs1 INTO var_c_profile_id, var_c_name, var_c_description;         
      EXIT WHEN NOT FOUND;
      RAISE NOTICE '%', '| ' || LPAD(var_c_profile_id::TEXT, 5) || ' | ' || LPAD(var_c_name, 30) || ' | ' || LPAD(COALESCE(var_c_description,' '), 50) || ' | ';

    END LOOP;

  ELSE

    OPEN curs1 FOR EXECUTE 'SELECT profile_id, name, description FROM aws_sqlserver_ext.sysmail_profile';

    LOOP

      FETCH curs1 INTO var_c_profile_id, var_c_name, var_c_description;
      EXIT WHEN NOT FOUND;
      RAISE NOTICE '%', '| ' || LPAD(var_c_profile_id::TEXT, 5) || ' | ' || LPAD(var_c_name, 30) || ' | ' || LPAD(COALESCE(var_c_description,' '), 50) || ' | ';

    END LOOP;

  END IF;
    
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="d4617ce4-f51a-4a22-ad63-213e4be1765b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c55d80a8-ed03-407c-9e5e-73ee8d04c78d" name="sysmail_help_profileaccount_sp" is-trigger-function="0" unique-function-name="sysmail_help_profileaccount_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_help_profileaccount_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,integer,character varying,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_profile_id integer DEFAULT NULL::integer, par_profile_name character varying DEFAULT NULL::character varying, par_account_id integer DEFAULT NULL::integer, par_account_name character varying DEFAULT NULL::character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="4" function-id="24035" volatility="VOLATILE" is-window="f" function-identity-arguments="par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_help_profileaccount_sp(par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_profileid INTEGER;
  var_accountid INTEGER;
  curs1 refcursor;
  
  var_c_account_id INTEGER;        -- NOT NULL
  var_c_account_name VARCHAR(128); -- NOT NULL
  var_c_profile_id INTEGER;        -- NOT NULL
  var_c_profile_name VARCHAR(128); -- NOT NULL
  var_c_sequence_number INTEGER;   -- NULL  
BEGIN

  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp(par_profile_id, par_profile_name, 1::smallint, 0::smallint) t
    INTO var_profileid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  SELECT t.par_accountid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_account_sp(par_account_id, par_account_name, 1::smallint, 0::smallint) t
    INTO var_accountid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 2;
    RETURN;

  END IF;

  RAISE NOTICE '%', '|--------|----------------------|-------|----------------------|------------|';
  RAISE NOTICE '%', '| Acc ID |     Account Name     | Pr ID |     Profile Name     |   Seq #    |';
  RAISE NOTICE '%', '|--------|----------------------|-------|----------------------|------------|';


  IF var_profileid IS NOT NULL AND var_accountid IS NOT NULL THEN

    OPEN curs1 FOR EXECUTE 
      'SELECT a.account_id, a.name AS account_name
            , p.profile_id, p.name AS profile_name
            , pa.sequence_number
         FROM aws_sqlserver_ext.sysmail_profileaccount AS pa
         JOIN aws_sqlserver_ext.sysmail_profile AS p ON p.profile_id = pa.profile_id
         JOIN aws_sqlserver_ext.sysmail_account AS a ON a.account_id = pa.account_id
        WHERE pa.profile_id = $1
          AND pa.account_id = $2' USING var_profileid, var_accountid;

  ELSE

    IF var_profileid IS NOT NULL THEN

      OPEN curs1 FOR EXECUTE 
        'SELECT a.account_id, a.name AS account_name
              , p.profile_id, p.name AS profile_name
              , pa.sequence_number
           FROM aws_sqlserver_ext.sysmail_profileaccount AS pa
           JOIN aws_sqlserver_ext.sysmail_profile AS p ON p.profile_id = pa.profile_id
           JOIN aws_sqlserver_ext.sysmail_account AS a ON a.account_id = pa.account_id
          WHERE pa.profile_id = $1' USING var_profileid;

    ELSE

      IF var_accountid IS NOT NULL THEN

        OPEN curs1 FOR EXECUTE 
          'SELECT a.account_id, a.name AS account_name
                , p.profile_id, p.name AS profile_name
                , pa.sequence_number
             FROM aws_sqlserver_ext.sysmail_profileaccount AS pa
             JOIN aws_sqlserver_ext.sysmail_profile AS p ON p.profile_id = pa.profile_id
             JOIN aws_sqlserver_ext.sysmail_account AS a ON a.account_id = pa.account_id
            WHERE pa.account_id = $1' USING var_accountid;

      ELSE

        OPEN curs1 FOR EXECUTE 
          'SELECT a.account_id, a.name AS account_name
                , p.profile_id, p.name AS profile_name
                , pa.sequence_number
             FROM aws_sqlserver_ext.sysmail_profileaccount AS pa
             JOIN aws_sqlserver_ext.sysmail_profile AS p ON p.profile_id = pa.profile_id
             JOIN aws_sqlserver_ext.sysmail_account AS a ON a.account_id = pa.account_id';

      END IF;

    END IF;

  END IF;
  
  LOOP

    FETCH curs1 INTO var_c_account_id, var_c_account_name, var_c_profile_id, var_c_profile_name, var_c_sequence_number;
    EXIT WHEN NOT FOUND;
    RAISE NOTICE '%', '| '
      || LPAD(var_c_account_id::character varying, 6) || ' | '
      || LPAD(var_c_account_name, 20) || ' | '
      || LPAD(var_c_profile_id::character varying, 5) || ' | '
      || LPAD(var_c_profile_name, 20) || ' | '
      || LPAD(COALESCE(var_c_sequence_number::character varying,' '), 10) || ' | ';

  END LOOP;          

  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="2031e1bc-54b1-43e8-88c7-218646e188be" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c9c7491e-8a2b-4e4b-aff2-fe1a5b90e73f" name="sysmail_set_arn_sp" is-trigger-function="0" unique-function-name="sysmail_set_arn_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_set_arn_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_mailserver_name character varying DEFAULT NULL::character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="24037" volatility="VOLATILE" is-window="f" function-identity-arguments="par_mailserver_name character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_set_arn_sp(par_mailserver_name character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

  IF par_mailserver_name IS NULL THEN /* Failure */

    RAISE '% is not a valid mailserver_name', par_mailserver_name USING ERRCODE := '50000';
    returncode := 1;
    RETURN;

  END IF;

  DELETE FROM aws_sqlserver_ext.sysmail_server;

  INSERT INTO aws_sqlserver_ext.sysmail_server
  (
    account_id
  , servertype
  , servername
  ) 
  VALUES
  (
    0
  , 'AWSLAMBDA'
  , par_mailserver_name
  );

  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="14274473-9496-482e-96c6-d165dfe2cfa6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3b5536fd-a371-4793-979e-ae1bd65e6599" name="sysmail_update_account_sp" is-trigger-function="0" unique-function-name="sysmail_update_account_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_update_account_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,character varying,character varying,character varying,character varying,character varying,character varying,integer,character varying,character varying,smallint,smallint,integer,smallint,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_account_id integer DEFAULT NULL::integer, par_account_name character varying DEFAULT NULL::character varying, par_email_address character varying DEFAULT NULL::character varying, par_display_name character varying DEFAULT NULL::character varying, par_replyto_address character varying DEFAULT NULL::character varying, par_description character varying DEFAULT NULL::character varying, par_mailserver_name character varying DEFAULT NULL::character varying, par_mailserver_type character varying DEFAULT NULL::character varying, par_port integer DEFAULT NULL::integer, par_username character varying DEFAULT NULL::character varying, par_password character varying DEFAULT NULL::character varying, par_use_default_credentials smallint DEFAULT NULL::smallint, par_enable_ssl smallint DEFAULT NULL::smallint, par_timeout integer DEFAULT NULL::integer, par_no_credential_change smallint DEFAULT NULL::smallint, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="15" function-id="24038" volatility="VOLATILE" is-window="f" function-identity-arguments="par_account_id integer, par_account_name character varying, par_email_address character varying, par_display_name character varying, par_replyto_address character varying, par_description character varying, par_mailserver_name character varying, par_mailserver_type character varying, par_port integer, par_username character varying, par_password character varying, par_use_default_credentials smallint, par_enable_ssl smallint, par_timeout integer, par_no_credential_change smallint, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_update_account_sp(par_account_id integer, par_account_name character varying, par_email_address character varying, par_display_name character varying, par_replyto_address character varying, par_description character varying, par_mailserver_name character varying, par_mailserver_type character varying, par_port integer, par_username character varying, par_password character varying, par_use_default_credentials smallint, par_enable_ssl smallint, par_timeout integer, par_no_credential_change smallint, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_accountid INTEGER;
BEGIN

  SELECT t.par_accountid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_account_sp
    (
      par_account_id,
      par_account_name,
      0::SMALLINT,
      1::SMALLINT
    ) t
    INTO var_accountid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  IF par_email_address IS NULL THEN

    SELECT email_address
      INTO par_email_address
      FROM aws_sqlserver_ext.sysmail_account
     WHERE account_id = var_accountid;

  END IF;

  IF par_display_name IS NULL THEN

    SELECT display_name
      INTO par_display_name
      FROM aws_sqlserver_ext.sysmail_account
     WHERE account_id = var_accountid;

  END IF;

  IF par_replyto_address IS NULL THEN

    SELECT replyto_address
      INTO par_replyto_address
      FROM aws_sqlserver_ext.sysmail_account
     WHERE account_id = var_accountid;

  END IF;

  IF par_description IS NULL THEN

    SELECT description
      INTO par_description
      FROM aws_sqlserver_ext.sysmail_account
     WHERE account_id = var_accountid;

  END IF;
  
  /* update account table */
  IF par_account_name IS NOT NULL THEN

    IF par_email_address IS NOT NULL THEN

      UPDATE aws_sqlserver_ext.sysmail_account
         SET name = par_account_name
           , description = par_description
           , email_address = par_email_address
           , display_name = par_display_name
           , replyto_address = par_replyto_address
       WHERE account_id = var_accountid;

    ELSE

      UPDATE aws_sqlserver_ext.sysmail_account
         SET name = par_account_name
           , description = par_description
           , display_name = par_display_name
           , replyto_address = par_replyto_address
       WHERE account_id = var_accountid;

    END IF;

  ELSE

    IF par_email_address IS NOT NULL THEN

      UPDATE aws_sqlserver_ext.sysmail_account
         SET description = par_description
           , email_address = par_email_address
           , display_name = par_display_name
           , replyto_address = par_replyto_address
       WHERE account_id = var_accountid;

    ELSE

      UPDATE aws_sqlserver_ext.sysmail_account
         SET description = par_description
           , display_name = par_display_name
           , replyto_address = par_replyto_address
       WHERE account_id = var_accountid;

    END IF;

  END IF;

  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="40906810-dd39-414c-bdcb-3d8674ef3ad4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e2bb61e9-17e4-4784-a663-ce6dc4ed39aa" name="sysmail_update_profile_sp" is-trigger-function="0" unique-function-name="sysmail_update_profile_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_update_profile_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,character varying,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_profile_id integer DEFAULT NULL::integer, par_profile_name character varying DEFAULT NULL::character varying, par_description character varying DEFAULT NULL::character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="24040" volatility="VOLATILE" is-window="f" function-identity-arguments="par_profile_id integer, par_profile_name character varying, par_description character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_update_profile_sp(par_profile_id integer, par_profile_name character varying, par_description character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_profileid INTEGER;
BEGIN

  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp
    (
      par_profile_id,
      par_profile_name,
      0::SMALLINT,
      1::SMALLINT
    ) t
    INTO var_profileid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  IF par_profile_name IS NOT NULL AND par_description IS NOT NULL THEN

    UPDATE aws_sqlserver_ext.sysmail_profile
       SET name = par_profile_name
         , description = par_description
     WHERE profile_id = var_profileid;

  ELSE

    IF par_profile_name IS NOT NULL THEN

      UPDATE aws_sqlserver_ext.sysmail_profile
         SET name = par_profile_name
       WHERE profile_id = var_profileid;

    ELSE

      IF par_description IS NOT NULL THEN

        UPDATE aws_sqlserver_ext.sysmail_profile
           SET description = par_description
         WHERE profile_id = var_profileid;

      ELSE

        RAISE 'Either par_profile_name or par_description parameter needs to be specified for update' USING ERRCODE := '50000';
        returncode := 1;
        RETURN;

      END IF;

    END IF;

  END IF;
  
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="da79974f-59f4-468a-9cae-92bb5b3c8c61" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b36bf0aa-aeca-4442-bc1d-0bf495e306dc" name="sysmail_update_profileaccount_sp" is-trigger-function="0" unique-function-name="sysmail_update_profileaccount_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_update_profileaccount_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,integer,character varying,integer,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_profile_id integer DEFAULT NULL::integer, par_profile_name character varying DEFAULT NULL::character varying, par_account_id integer DEFAULT NULL::integer, par_account_name character varying DEFAULT NULL::character varying, par_sequence_number integer DEFAULT NULL::integer, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="5" function-id="24039" volatility="VOLATILE" is-window="f" function-identity-arguments="par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, par_sequence_number integer, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_update_profileaccount_sp(par_profile_id integer, par_profile_name character varying, par_account_id integer, par_account_name character varying, par_sequence_number integer, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_rc INTEGER;
  var_profileid INTEGER;
  var_accountid INTEGER;
BEGIN

  SELECT t.par_profileid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_profile_sp
    (
      par_profile_id,
      par_profile_name,
      0::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_profileid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 1;
    RETURN;

  END IF;

  SELECT t.par_accountid, t.returncode
    FROM aws_sqlserver_ext.sysmail_verify_account_sp
    (
      par_account_id,
      par_account_name,
      0::SMALLINT,
      0::SMALLINT
    ) t
    INTO var_accountid, var_rc;

  IF var_rc <> 0 THEN

    returncode := 2;
    RETURN;

  END IF;

  IF par_sequence_number IS NULL THEN

    RAISE 'Account sequence number must be supplied for update' USING ERRCODE := '50000';
    returncode := 3;
    RETURN;

  END IF;
  
  UPDATE aws_sqlserver_ext.sysmail_profileaccount
     SET sequence_number = par_sequence_number
   WHERE profile_id = var_profileid 
     AND account_id = var_accountid;
     
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="5adb18b8-b2c3-4e7d-96f2-aea0b6746a1e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8662b257-f3a2-4982-a189-2200ff577aa0" name="sysmail_verify_account_sp" is-trigger-function="0" unique-function-name="sysmail_verify_account_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_verify_account_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,smallint,smallint,integer,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_account_id integer, par_account_name character varying, par_allow_both_nulls smallint, par_allow_id_name_mismatch smallint, OUT par_accountid integer, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="4" function-id="24041" volatility="VOLATILE" is-window="f" function-identity-arguments="par_account_id integer, par_account_name character varying, par_allow_both_nulls smallint, par_allow_id_name_mismatch smallint, OUT par_accountid integer, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_verify_account_sp(par_account_id integer, par_account_name character varying, par_allow_both_nulls smallint, par_allow_id_name_mismatch smallint, OUT par_accountid integer, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

  /* at least one parameter must be supplied */
  IF par_allow_both_nulls = 0 THEN

    IF par_account_id IS NULL AND par_account_name IS NULL THEN

      RAISE 'Both % parameters (id and name) cannot be NULL', 'account' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;

    END IF;

  END IF;

  /* use both parameters */
  IF (par_allow_id_name_mismatch = 0) AND (par_account_id IS NOT NULL AND par_account_name IS NOT NULL) THEN

    SELECT account_id
      INTO par_accountid
      FROM aws_sqlserver_ext.sysmail_account
     WHERE account_id = par_account_id
     AND name = par_account_name;

    IF par_accountid IS NULL /* id and name do not match */ THEN

      RAISE 'Both % parameters (id and name) do not point to the same object', 'account' USING ERRCODE := '50000';
      returncode := 2;
      RETURN;

    END IF;

  ELSE

    IF par_account_id IS NOT NULL /* use id */ THEN

      SELECT account_id
        INTO par_accountid
        FROM aws_sqlserver_ext.sysmail_account
       WHERE account_id = par_account_id;
    
      IF par_accountid IS NULL /* id is invalid */ THEN

        RAISE '% id is not valid', 'account' USING ERRCODE := '50000';
        returncode := 3;
        RETURN;

      END IF;

    ELSE

      IF par_account_name IS NOT NULL /* use name */ THEN

        SELECT account_id
          INTO par_accountid
          FROM aws_sqlserver_ext.sysmail_account
         WHERE name = par_account_name;

        IF par_accountid IS NULL /* name is invalid */ THEN

          RAISE '% name is not valid', 'account' USING ERRCODE := '50000';
          returncode := 4;
          RETURN;

        END IF;

      END IF;

    END IF;

  END IF;

  /* SUCCESS */  
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="562920c4-cc53-440a-8125-c6feb49a0632" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ad1b7960-282e-475e-9a95-534f55fb2393" name="sysmail_verify_addressparams_sp" is-trigger-function="0" unique-function-name="sysmail_verify_addressparams_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_verify_addressparams_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,character varying,integer" is-returning-set="f" ret-datatype="int4" function-arguments="par_address text, par_parameter_name character varying, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24042" volatility="VOLATILE" is-window="f" function-identity-arguments="par_address text, par_parameter_name character varying, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_verify_addressparams_sp(par_address text, par_parameter_name character varying, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_commaIndex INTEGER;
BEGIN

  IF par_address IS NOT NULL AND LOWER(par_address) != LOWER('') THEN

    var_commaIndex := STRPOS(par_address, ',');

    IF var_commaIndex > 0 THEN

      RAISE 'The specified "%" cannot use commas (,) to separate addresses: "%". To continue, use semicolons (;) to separate addresses.', par_parameter_name, par_address USING ERRCODE := '50000';
      returncode := 1;
      RETURN;

    END IF;

  END IF;
  
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="d55919c5-b344-4cb8-b40b-3e23ff3577f6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f60f7dba-98c1-4820-92c9-52b5a1257c3e" name="sysmail_verify_profile_sp" is-trigger-function="0" unique-function-name="sysmail_verify_profile_sp" is-aggregate="f" language-name="plpgsql" context="sysmail_verify_profile_sp" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,smallint,smallint,integer,integer" is-returning-set="f" ret-datatype="record" function-arguments="par_profile_id integer, par_profile_name character varying, par_allow_both_nulls smallint, par_allow_id_name_mismatch smallint, OUT par_profileid integer, OUT returncode integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="4" function-id="24043" volatility="VOLATILE" is-window="f" function-identity-arguments="par_profile_id integer, par_profile_name character varying, par_allow_both_nulls smallint, par_allow_id_name_mismatch smallint, OUT par_profileid integer, OUT returncode integer" overload-function-count="1" proc-language="plpgsql" function-signature="sysmail_verify_profile_sp(par_profile_id integer, par_profile_name character varying, par_allow_both_nulls smallint, par_allow_id_name_mismatch smallint, OUT par_profileid integer, OUT returncode integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

  IF par_allow_both_nulls = 0
  THEN /* at least one parameter must be supplied */

    IF par_profile_id IS NULL AND par_profile_name IS NULL THEN

      RAISE 'Both % parameters (id and name) cannot be NULL', 'profile' USING ERRCODE := '50000';
      returncode := 1;
      RETURN;

    END IF;

  END IF;

  /* use both parameters */
  IF (par_allow_id_name_mismatch = 0) AND (par_profile_id IS NOT NULL AND par_profile_name IS NOT NULL) THEN

    SELECT profile_id
      INTO par_profileid
      FROM aws_sqlserver_ext.sysmail_profile
     WHERE profile_id = par_profile_id
     AND name = par_profile_name;

    IF (par_profileid IS NULL) /* id and name do not match */
    THEN

      RAISE 'Both % parameters (id and name) do not point to the same object', 'profile' USING ERRCODE := '50000';
      returncode := 2;
      RETURN;

    END IF;

  ELSE 

    IF par_profile_id IS NOT NULL /* use id */ THEN

      SELECT profile_id
        INTO par_profileid
        FROM aws_sqlserver_ext.sysmail_profile
       WHERE profile_id = par_profile_id;

      IF par_profileid IS NULL /* id is invalid */ THEN

        RAISE '% id is not valid', 'profile' USING ERRCODE := '50000';
        returncode := 3;
        RETURN;

      END IF;

    ELSE

      IF par_profile_name IS NOT NULL /* use name */ THEN

        SELECT profile_id
          INTO par_profileid
          FROM aws_sqlserver_ext.sysmail_profile
         WHERE name = par_profile_name;

        IF par_profileid IS NULL /* name is invalid */ THEN

          RAISE '% name is not valid', 'profile' USING ERRCODE := '50000';
          returncode := 4;
          RETURN;

        END IF;

      END IF;

    END IF;

  END IF;
  
  returncode := 0;
  RETURN;

END;
]]></complex-attribute>
                        <category _I_D="b7a0c20f-07b0-49c8-b2b9-e7c5d3c0b1b7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6ba5e696-96e3-4b8d-9364-dff6e43a79e6" name="timefromparts" is-trigger-function="0" unique-function-name="timefromparts(p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)" is-aggregate="f" language-name="plpgsql" context="timefromparts(p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric,numeric,numeric,numeric" comment="This function returns a fully initialized TIME value, constructed from separate time parts." unique-suffix="(p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)" routine-number="23938" is-returning-set="f" ret-datatype="time" function-arguments="p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric" schema-id="23774" function-type="RET_SCALAR" count-arguments="5" function-id="23938" volatility="VOLATILE" is-window="f" function-identity-arguments="p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric" overload-function-count="2" proc-language="plpgsql" function-signature="timefromparts(p_hour numeric, p_minute numeric, p_seconds numeric, p_fractions numeric, p_precision numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_fractions VARCHAR;
    v_precision SMALLINT;
    v_err_message VARCHAR;
    v_calc_seconds NUMERIC;
BEGIN
    v_fractions := floor(p_fractions)::INTEGER::VARCHAR;
    v_precision := p_precision::SMALLINT;

    IF (scale(p_precision) > 0) THEN
        RAISE most_specific_type_mismatch;
    ELSIF ((p_hour NOT BETWEEN 0 AND 23) OR
           (p_minute NOT BETWEEN 0 AND 59) OR
           (p_seconds NOT BETWEEN 0 AND 59) OR
           (p_fractions NOT BETWEEN 0 AND 9999999) OR
           (p_fractions != 0 AND char_length(v_fractions) > p_precision))
    THEN
        RAISE invalid_datetime_format;
    ELSIF (v_precision NOT BETWEEN 0 AND 7) THEN
        RAISE numeric_value_out_of_range;
    END IF;

    v_calc_seconds := format('%s.%s',
                             floor(p_seconds)::SMALLINT,
                             substring(rpad(lpad(v_fractions, v_precision, '0'), 7, '0'), 1, 6))::NUMERIC;

    RETURN make_time(floor(p_hour)::SMALLINT,
                     floor(p_minute)::SMALLINT,
                     v_calc_seconds);
EXCEPTION
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Scale argument is not valid. Valid expressions for data type DATETIME2 scale argument are integer constants and integer constant expressions.',
                    DETAIL := 'Use of incorrect "precision" parameter value during conversion process.',
                    HINT := 'Change "precision" parameter to the proper value and try again.';

    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := format('Specified scale %s is invalid.', v_precision),
                    DETAIL := 'Use of incorrect "precision" parameter value during conversion process.',
                    HINT := 'Change "precision" parameter to the proper value and try again.';

    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := 'Cannot construct data type time, some of the arguments have values which are not valid.',
                    DETAIL := 'Possible use of incorrect value of time part (which lies outside of valid range).',
                    HINT := 'Check each input argument belongs to the valid range and try again.';

    WHEN numeric_value_out_of_range THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := upper(split_part(v_err_message, ' ', 1));

        RAISE USING MESSAGE := format('Error while trying to cast to %s data type.', v_err_message),
                    DETAIL := format('Source value is out of %s data type range.', v_err_message),
                    HINT := format('Correct the source value you are trying to cast to %s data type and try again.',
                                   v_err_message);
END;
]]></complex-attribute>
                        <category _I_D="119fb39b-73ba-4f82-944f-dc291907de0e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a4fe6efc-82d4-4810-90d4-496bf4df507c" name="timefromparts" is-trigger-function="0" unique-function-name="timefromparts(p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)" is-aggregate="f" language-name="plpgsql" context="timefromparts(p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" comment="This function returns a fully initialized TIME value, constructed from separate time parts." unique-suffix="(p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)" routine-number="23939" is-returning-set="f" ret-datatype="time" function-arguments="p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text" schema-id="23774" function-type="RET_SCALAR" count-arguments="5" function-id="23939" volatility="VOLATILE" is-window="f" function-identity-arguments="p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text" overload-function-count="2" proc-language="plpgsql" function-signature="timefromparts(p_hour text, p_minute text, p_seconds text, p_fractions text, p_precision text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_err_message VARCHAR;
BEGIN
    RETURN aws_sqlserver_ext.timefromparts(p_hour::NUMERIC, p_minute::NUMERIC,
                                           p_seconds::NUMERIC, p_fractions::NUMERIC,
                                           p_precision::NUMERIC);
EXCEPTION
    WHEN invalid_text_representation THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;
        v_err_message := substring(lower(v_err_message), 'numeric\:\s\"(.*)\"');

        RAISE USING MESSAGE := format('Error while trying to convert "%s" value to NUMERIC data type.', v_err_message),
                    DETAIL := 'Supplied string value contains illegal characters.',
                    HINT := 'Correct supplied value, remove all illegal characters and try again.';
END;
]]></complex-attribute>
                        <category _I_D="2e0e8fa1-9c37-46b8-893e-027f276ed51d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0004fafb-32a5-4a87-91af-d09db271d2af" name="tomsbit" is-trigger-function="0" unique-function-name="tomsbit(in_str character varying)" is-aggregate="f" language-name="plpgsql" context="tomsbit(in_str character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" unique-suffix="(in_str character varying)" routine-number="24045" is-returning-set="f" ret-datatype="int2" function-arguments="in_str character varying" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="24045" volatility="VOLATILE" is-window="f" function-identity-arguments="in_str character varying" overload-function-count="2" proc-language="plpgsql" function-signature="tomsbit(in_str character varying)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  CASE
    WHEN LOWER(in_str) = 'true' OR in_str = '1' THEN RETURN 1;
    WHEN LOWER(in_str) = 'false' OR in_str = '0' THEN RETURN 0;
    ELSE RETURN 0;
  END CASE;
END;
]]></complex-attribute>
                        <category _I_D="6e3ae5e3-0cfd-404d-a2f2-38c1e54c26b5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9c6ac0dd-8aee-4c1d-a31b-923d0b665f1e" name="tomsbit" is-trigger-function="0" unique-function-name="tomsbit(in_str numeric)" is-aggregate="f" language-name="plpgsql" context="tomsbit(in_str numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" unique-suffix="(in_str numeric)" routine-number="24044" is-returning-set="f" ret-datatype="int2" function-arguments="in_str numeric" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="24044" volatility="VOLATILE" is-window="f" function-identity-arguments="in_str numeric" overload-function-count="2" proc-language="plpgsql" function-signature="tomsbit(in_str numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  CASE
    WHEN in_str < 0 OR in_str > 0 THEN RETURN 1;
    ELSE RETURN 0;
  END CASE;
END;
]]></complex-attribute>
                        <category _I_D="e78fe216-7ece-47d8-a3a4-bce123b6f7ec" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="548d7a97-e1cd-4259-9ce5-e30bd79f3154" name="try_conv_date_to_string" is-trigger-function="0" unique-function-name="try_conv_date_to_string" is-aggregate="f" language-name="plpgsql" context="try_conv_date_to_string" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,date,numeric" comment="This function converts the DATE value into a character string, according to specified style (conversion mask). &amp;#x000a;If the conversion not successful, the function returns NULL." is-returning-set="f" ret-datatype="text" function-arguments="p_datatype text, p_dateval date, p_style numeric DEFAULT 20" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23956" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datatype text, p_dateval date, p_style numeric" overload-function-count="1" proc-language="plpgsql" function-signature="try_conv_date_to_string(p_datatype text, p_dateval date, p_style numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_date_to_string(p_datatype,
                                                 p_dateval,
                                                 p_style);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="afe36262-b1c7-487a-9e0a-7b6bbb5d5a19" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0bd49a99-e7be-45c9-af5e-5179aaf4da5d" name="try_conv_datetime_to_string" is-trigger-function="0" unique-function-name="try_conv_datetime_to_string" is-aggregate="f" language-name="plpgsql" context="try_conv_datetime_to_string" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,timestamp without time zone,numeric" comment="This function converts the DATETIME value into a character string, according to specified style (conversion mask). &amp;#x000a;If the conversion not successful, the function returns NULL." is-returning-set="f" ret-datatype="text" function-arguments="p_datatype text, p_src_datatype text, p_datetimeval timestamp without time zone, p_style numeric DEFAULT '-1'::integer" schema-id="23774" function-type="RET_SCALAR" count-arguments="4" function-id="23957" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datatype text, p_src_datatype text, p_datetimeval timestamp without time zone, p_style numeric" overload-function-count="1" proc-language="plpgsql" function-signature="try_conv_datetime_to_string(p_datatype text, p_src_datatype text, p_datetimeval timestamp without time zone, p_style numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_datetime_to_string(p_datatype,
                                                     p_src_datatype,
                                                     p_datetimeval,
                                                     p_style);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="fd602f8e-2c2e-4595-a3a6-fcde22afc30c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a47c2577-c46b-42a8-9684-9c84b5e035c0" name="try_conv_string_to_date" is-trigger-function="0" unique-function-name="try_conv_string_to_date" is-aggregate="f" language-name="plpgsql" context="try_conv_string_to_date" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric" comment="This function parses the TEXT string and converts it into a DATE value, according to specified style (conversion mask). &amp;#x000a;If the conversion not successful, the function returns NULL." is-returning-set="f" ret-datatype="date" function-arguments="p_datestring text, p_style numeric DEFAULT 0" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="23959" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datestring text, p_style numeric" overload-function-count="1" proc-language="plpgsql" function-signature="try_conv_string_to_date(p_datestring text, p_style numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_string_to_date(p_datestring,
                                                 p_style);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="3d1b272c-338e-4c7a-ae0c-09d38448a823" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bd3d9f1d-5662-4262-8a94-7cca37827118" name="try_conv_string_to_datetime" is-trigger-function="0" unique-function-name="try_conv_string_to_datetime" is-aggregate="f" language-name="plpgsql" context="try_conv_string_to_datetime" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,numeric" comment="This function parses the TEXT string and converts it into a DATETIME value, according to specified style (conversion mask). &amp;#x000a;If the conversion not successfull, the function returns NULL." is-returning-set="f" ret-datatype="timestamp" function-arguments="p_datatype text, p_datetimestring text, p_style numeric DEFAULT 0" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23960" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datatype text, p_datetimestring text, p_style numeric" overload-function-count="1" proc-language="plpgsql" function-signature="try_conv_string_to_datetime(p_datatype text, p_datetimestring text, p_style numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_string_to_datetime(p_datatype,
                                                     p_datetimestring ,
                                                     p_style);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="24708cfe-d780-4a73-b1fe-f0cd5cce447b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="171efd86-dd55-4b00-b851-50b0b21ae753" name="try_conv_string_to_time" is-trigger-function="0" unique-function-name="try_conv_string_to_time" is-aggregate="f" language-name="plpgsql" context="try_conv_string_to_time" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,numeric" comment="This function parses the TEXT string and converts it into a TIME value, according to specified style (conversion mask). &amp;#x000a;If the conversion not successfull, the function returns NULL." is-returning-set="f" ret-datatype="time" function-arguments="p_datatype text, p_timestring text, p_style numeric DEFAULT 0" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23961" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datatype text, p_timestring text, p_style numeric" overload-function-count="1" proc-language="plpgsql" function-signature="try_conv_string_to_time(p_datatype text, p_timestring text, p_style numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_string_to_time(p_datatype,
                                                 p_timestring,
                                                 p_style);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="3de40488-4bdf-440f-a667-c266642e8158" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="cb3fcf8b-3dbd-4dd5-ad95-3fc1fb83120d" name="try_conv_time_to_string" is-trigger-function="0" unique-function-name="try_conv_time_to_string" is-aggregate="f" language-name="plpgsql" context="try_conv_time_to_string" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,time without time zone,numeric" comment="This function converts the TIME value into a character string, according to specified style (conversion mask). &amp;#x000a;If the conversion not successful, the function returns NULL." is-returning-set="f" ret-datatype="text" function-arguments="p_datatype text, p_src_datatype text, p_timeval time without time zone, p_style numeric DEFAULT 25" schema-id="23774" function-type="RET_SCALAR" count-arguments="4" function-id="23958" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datatype text, p_src_datatype text, p_timeval time without time zone, p_style numeric" overload-function-count="1" proc-language="plpgsql" function-signature="try_conv_time_to_string(p_datatype text, p_src_datatype text, p_timeval time without time zone, p_style numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.conv_time_to_string(p_datatype,
                                                 p_src_datatype,
                                                 p_timeval,
                                                 p_style);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="03ddcd20-4f52-4414-ba0f-d1eb230787fa" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="07211654-13b3-4d23-be00-a11b660bddb2" name="try_parse_to_date" is-trigger-function="0" unique-function-name="try_parse_to_date" is-aggregate="f" language-name="plpgsql" context="try_parse_to_date" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" comment="This function parses the TEXT string and translate it into a DATE value, according to specified culture (conversion mask). &amp;#x000a;If the conversion not successful, the function returns NULL." is-returning-set="f" ret-datatype="date" function-arguments="p_datestring text, p_culture text DEFAULT NULL::text" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="23968" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datestring text, p_culture text" overload-function-count="1" proc-language="plpgsql" function-signature="try_parse_to_date(p_datestring text, p_culture text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.parse_to_date(p_datestring,
                                           p_culture);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="575704ca-c73b-49d0-af44-7954b48711ed" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="295a4f54-7174-46b7-bd2c-d8e78ae89a0c" name="try_parse_to_datetime" is-trigger-function="0" unique-function-name="try_parse_to_datetime" is-aggregate="f" language-name="plpgsql" context="try_parse_to_datetime" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" comment="This function parses the TEXT string and translate it into a DATETIME value, according to specified culture (conversion mask). &amp;#x000a;If the conversion not successful, the function returns NULL." is-returning-set="f" ret-datatype="timestamp" function-arguments="p_datatype text, p_datetimestring text, p_culture text DEFAULT ''::text" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23969" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datatype text, p_datetimestring text, p_culture text" overload-function-count="1" proc-language="plpgsql" function-signature="try_parse_to_datetime(p_datatype text, p_datetimestring text, p_culture text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.try_parse_to_datetime(p_datatype,
                                                   p_datestring,
                                                   p_culture);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="c29513a6-0c5c-4ac0-a21c-fa1dbe51432f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="82c4c379-1e2c-453a-b19f-90cc46865038" name="try_parse_to_time" is-trigger-function="0" unique-function-name="try_parse_to_time" is-aggregate="f" language-name="plpgsql" context="try_parse_to_time" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" comment="This function parses the TEXT string and translate it into a TIME value, according to specified culture (conversion mask). &amp;#x000a;If the conversion not successful, the function returns NULL." is-returning-set="f" ret-datatype="timestamp" function-arguments="p_datatype text, p_srctimestring text, p_culture text DEFAULT ''::text" schema-id="23774" function-type="RET_SCALAR" count-arguments="3" function-id="23970" volatility="VOLATILE" is-window="f" function-identity-arguments="p_datatype text, p_srctimestring text, p_culture text" overload-function-count="1" proc-language="plpgsql" function-signature="try_parse_to_time(p_datatype text, p_srctimestring text, p_culture text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_sqlserver_ext.parse_to_time(p_datatype,
                                           p_srctimestring,
                                           p_culture);
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="5e057b57-3ece-4ccf-a512-1183eb2d7077" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d25ce270-5285-43bb-9050-fd51de1e9a04" name="update_job" is-trigger-function="0" unique-function-name="update_job" is-aggregate="f" language-name="plpgsql" context="update_job" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying" is-returning-set="f" ret-datatype="void" function-arguments="p_job integer, p_error_message character varying" schema-id="23774" function-type="RET_SCALAR" count-arguments="2" function-id="24046" volatility="VOLATILE" is-window="f" function-identity-arguments="p_job integer, p_error_message character varying" overload-function-count="1" proc-language="plpgsql" function-signature="update_job(p_job integer, p_error_message character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  var_enabled smallint;
  var_freq_type integer;
  var_freq_interval integer;
  var_freq_subday_type integer;
  var_freq_subday_interval integer;
  var_freq_relative_interval integer;
  var_freq_recurrence_factor integer;
  var_tmp_interval varchar(50);
  var_job_id integer;
  var_schedule_id integer;
  var_job_step_id integer;
  var_step_id integer;
  var_step_name VARCHAR(128);
BEGIN
  /*
  var_job_step_id := p_job;

  SELECT jst.job_id, jsc.schedule_id, jst.step_name, jst.step_id 
    FROM aws_sqlserver_ext.sysjobsteps jst
   INNER JOIN aws_sqlserver_ext.sysjobschedules jsc
      ON jsc.job_id = jst.job_id
    INTO var_job_id, var_schedule_id, var_step_name, var_step_id  
   WHERE jst.job_step_id = var_job_step_id;
  */
  INSERT 
    INTO aws_sqlserver_ext.sysjobhistory (
         job_id
       , step_id
       , step_name
       , sql_message_id
       , sql_severity
       , message
       , run_status
       , run_date
       , run_time
       , run_duration
       , operator_id_emailed
       , operator_id_netsent
       , operator_id_paged
       , retries_attempted
       , server)
  VALUES (
         p_job
       , 0 -- var_step_id
       , ''--var_step_name
       , 0
       , 0
       , p_error_message
       , 0
       , now()::date
       , now()::time
       , 0
       , 0
       , 0
       , 0
       , 0
       , ''::character varying);
  
  -- PERFORM aws_sqlserver_ext.sp_set_next_run (var_job_id, var_schedule_id);

END;
]]></complex-attribute>
                        <category _I_D="58455ab8-c12c-40ba-af46-5b790a0d693e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9521b996-1af3-409f-8597-6cf9cb70e022" name="waitfor_delay" is-trigger-function="0" unique-function-name="waitfor_delay(time_to_pass text)" is-aggregate="f" language-name="sql" context="waitfor_delay(time_to_pass text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" unique-suffix="(time_to_pass text)" routine-number="24250" is-returning-set="f" ret-datatype="void" function-arguments="time_to_pass text" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="24250" volatility="VOLATILE" is-window="f" function-identity-arguments="time_to_pass text" overload-function-count="2" proc-language="sql" function-signature="waitfor_delay(time_to_pass text)">
                        <complex-attribute name="sql"><![CDATA[
  SELECT pg_sleep(EXTRACT(HOUR FROM $1::time)*60*60 +
                  EXTRACT(MINUTE FROM $1::time)*60 +
                  TRUNC(EXTRACT(SECOND FROM $1::time)) +
                  aws_sqlserver_ext.round_fractseconds(
                                                        (
                                                          EXTRACT(MILLISECONDS FROM $1::time)
                                                          - TRUNC(EXTRACT(SECOND FROM $1::time)) * 1000
                                                        )::numeric
                                                      )/1000::numeric);
]]></complex-attribute>
                        <category _I_D="ac6137f1-c160-4306-b0f3-696fed9cfd62" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f93f7f80-0442-4761-8609-c56800a04d2a" name="waitfor_delay" is-trigger-function="0" unique-function-name="waitfor_delay(time_to_pass timestamp without time zone)" is-aggregate="f" language-name="sql" context="waitfor_delay(time_to_pass timestamp without time zone)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone" unique-suffix="(time_to_pass timestamp without time zone)" routine-number="24249" is-returning-set="f" ret-datatype="void" function-arguments="time_to_pass timestamp without time zone" schema-id="23774" function-type="RET_SCALAR" count-arguments="1" function-id="24249" volatility="VOLATILE" is-window="f" function-identity-arguments="time_to_pass timestamp without time zone" overload-function-count="2" proc-language="sql" function-signature="waitfor_delay(time_to_pass timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
  SELECT pg_sleep(EXTRACT(HOUR FROM $1::time)*60*60 +
                  EXTRACT(MINUTE FROM $1::time)*60 +
                  TRUNC(EXTRACT(SECOND FROM $1::time)) +
                  aws_sqlserver_ext.round_fractseconds(
                                                        (
                                                          EXTRACT(MILLISECONDS FROM $1::time)
                                                          - TRUNC(EXTRACT(SECOND FROM $1::time)) * 1000
                                                        )::numeric
                                                      )/1000::numeric);
]]></complex-attribute>
                        <category _I_D="ee6f70ca-a929-49f8-b956-bf42797e7c60" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                </category>
                <category _I_D="9fd300f6-2eda-44f5-9718-3ff21e43fdef" name="Trigger functions" order-num="9" objects-loading="extended" subcategories-loading="none" child-type="function">
                    <function _I_D="5ce27e5b-b20a-4070-a11c-9095013e6d7e" name="set_up_rows" is-trigger-function="1" unique-function-name="set_up_rows" is-aggregate="f" language-name="plpgsql" context="set_up_rows" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="trigger" schema-id="23774" function-type="RET_SCALAR" count-arguments="0" function-id="24053" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="set_up_rows()">
                        <complex-attribute name="sql"><![CDATA[
DECLARE 
  TabInserted VARCHAR(100);
  TabDeleted VARCHAR(100);
BEGIN
  TabInserted := 'inserted_' || TG_TABLE_NAME;
  TabDeleted := 'deleted_' || TG_TABLE_NAME;
  EXECUTE 'DROP TABLE IF EXISTS ' || TabInserted;
  EXECUTE 'DROP TABLE IF EXISTS ' || TabDeleted;  
  EXECUTE 'CREATE TEMPORARY TABLE ' || TabInserted || ' ON COMMIT DROP AS TABLE ' || TG_TABLE_SCHEMA || '.' || TG_TABLE_NAME || ' WITH NO DATA';
  EXECUTE 'CREATE TEMPORARY TABLE ' || TabDeleted || ' ON COMMIT DROP AS TABLE ' || TG_TABLE_SCHEMA || '.' || TG_TABLE_NAME || ' WITH NO DATA';
  -- EXECUTE 'CREATE TEMPORARY TABLE IF NOT EXISTS ' || TabInserted || ' ON COMMIT DROP AS TABLE ' || TG_TABLE_SCHEMA || '.' || TG_TABLE_NAME || ' WITH NO DATA';
  -- EXECUTE 'CREATE TEMPORARY TABLE IF NOT EXISTS ' || TabDeleted || ' ON COMMIT DROP AS TABLE ' || TG_TABLE_SCHEMA || '.' || TG_TABLE_NAME || ' WITH NO DATA'; 
  -- EXECUTE 'TRUNCATE TABLE ' || TabInserted;
  -- EXECUTE 'TRUNCATE TABLE ' || TabDeleted; 
  RETURN NULL;
END;
]]></complex-attribute>
                        <category _I_D="971bb941-1e55-4eb7-a273-cc391d65564e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ce3b97f3-8777-4466-a4f5-86111e94d4c8" name="sp_jobstep_create_proc" is-trigger-function="1" unique-function-name="sp_jobstep_create_proc" is-aggregate="f" language-name="plpgsql" context="sp_jobstep_create_proc" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="trigger" schema-id="23774" function-type="RET_SCALAR" count-arguments="0" function-id="24055" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_jobstep_create_proc()">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  retval INT;
  proc_name_mask VARCHAR(100);
  proc_name VARCHAR(100);
  proc_body_mask VARCHAR(200);
  command_text TEXT;
  proc_body TEXT;
  
BEGIN
  proc_name_mask := 'sql_agent$job_%s_step_%s';
  proc_body_mask := 'create or replace function aws_sqlserver_ext_data.%s() returns void as $$ begin %s end $$ language plpgsql;';

  SELECT format(proc_name_mask, job_id, step_id) 
       , command  
    FROM aws_sqlserver_ext.sysjobsteps 
   WHERE step_uid = NEW.step_uid
    INTO proc_name, command_text; 

  proc_body := format(proc_body_mask, proc_name, command_text);
  EXECUTE proc_body;
  
  RETURN NEW;
END;
]]></complex-attribute>
                        <category _I_D="4bc87ed2-5033-4043-a187-b50740eb68be" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1c33c667-a6fb-4bef-85f3-fad8a15d8ce4" name="sp_jobstep_drop_proc" is-trigger-function="1" unique-function-name="sp_jobstep_drop_proc" is-aggregate="f" language-name="plpgsql" context="sp_jobstep_drop_proc" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="trigger" schema-id="23774" function-type="RET_SCALAR" count-arguments="0" function-id="24056" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="sp_jobstep_drop_proc()">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  retval INT;
  proc_name_mask VARCHAR(100);
  proc_name VARCHAR(100);
  drop_mask VARCHAR(200);
  drop_cmd TEXT;
BEGIN
  proc_name_mask := 'sql_agent$job_%s_step_%s';
  drop_mask := 'drop function aws_sqlserver_ext_data.%s();';

  SELECT format(proc_name_mask, job_id, step_id) 
    FROM aws_sqlserver_ext.sysjobsteps 
   WHERE step_uid = OLD.step_uid
    INTO proc_name; 

  drop_cmd := format(drop_mask, proc_name);
  EXECUTE drop_cmd;
  
  RETURN OLD;
END;
]]></complex-attribute>
                        <category _I_D="3075d627-4666-4309-809d-0ccbe8273456" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9160d258-e108-487b-b052-6c52a871db42" name="stash_row_deltas" is-trigger-function="1" unique-function-name="stash_row_deltas" is-aggregate="f" language-name="plpgsql" context="stash_row_deltas" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="trigger" schema-id="23774" function-type="RET_SCALAR" count-arguments="0" function-id="24054" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="stash_row_deltas()">
                        <complex-attribute name="sql"><![CDATA[
DECLARE 
  TabInserted VARCHAR(100);
  TabDeleted VARCHAR(100);
BEGIN
  TabInserted := 'inserted_' || TG_TABLE_NAME;
  TabDeleted := 'deleted_' || TG_TABLE_NAME;

  IF TG_OP = 'INSERT' THEN
	EXECUTE 'INSERT INTO ' || TabInserted || ' SELECT * FROM (SELECT $1.*) AS t' USING NEW;
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
	EXECUTE 'INSERT INTO ' || TabInserted || ' SELECT * FROM (SELECT $1.*) AS t' USING NEW;  
    EXECUTE 'INSERT INTO ' || TabDeleted || ' SELECT * FROM (SELECT $1.*) AS t' USING OLD;  	
    RETURN NEW;	
  ELSE 
	EXECUTE 'INSERT INTO ' || TabDeleted || ' SELECT * FROM (SELECT $1.*) AS t' USING OLD;  
    RETURN OLD;	      
  END IF;
END;
]]></complex-attribute>
                        <category _I_D="e785712b-22b7-4ba2-b252-b315ef29d13a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                </category>
                <category _I_D="c2a44ed4-9910-49e5-8a2a-3016f7ba8e3c" name="Procedures" order-num="10" objects-loading="empty" subcategories-loading="full" child-type="procedure"/>
                <category _I_D="1e10d4dd-44fc-47f6-87aa-b5d147d0c3de" name="Sequences" order-num="11" objects-loading="extended" subcategories-loading="full" child-type="sequence">
                    <sequence _I_D="ca7bcaed-b973-4ddf-932d-01efa6d38214" name="sysjobhistory_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysjobhistory_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="b7a9ead9-b7ff-46b0-a168-508dfb0d730f" name="sysjobs_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysjobs_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="52addca7-fa13-4cdb-bd99-8b519fc2b76e" name="sysjobsteps_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysjobsteps_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="972c93f4-77f8-4759-91c1-5ab050e1a2af" name="sysmail_account_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysmail_account_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="c82c2d14-c6e7-4272-8188-6ff8fe99afae" name="sysmail_attachments_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysmail_attachments_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="5e0d78d6-f4bf-463c-99ba-af81dce688d6" name="sysmail_log_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysmail_log_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="e5df4504-783e-47a9-9338-7c6eff4a93dc" name="sysmail_mailitems_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysmail_mailitems_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="5627527e-2c55-44e8-bf27-85f4865dc348" name="sysmail_profile_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysmail_profile_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="2f981aa6-2f27-4ad1-a3ae-62025d43a2ec" name="sysschedules_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sysschedules_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                </category>
                <category _I_D="a6a94edf-1bc0-4947-8eb3-fdd789f37e3b" name="User defined types" order-num="12" objects-loading="empty" subcategories-loading="full" child-type="type"/>
                <category _I_D="33978f03-bd61-4bd6-8ad9-75d8db520fb3" name="Domains" order-num="13" objects-loading="empty" subcategories-loading="full" child-type="domain"/>
                <category _I_D="7bba29f4-f99c-4210-984f-22411879d6ef" name="Materialized Views" order-num="14" objects-loading="empty" subcategories-loading="full" child-type="materialized-view"/>
                <category _I_D="42fe2aee-7943-429b-9121-b55a85841e96" name="Aggregates" order-num="15" objects-loading="empty" subcategories-loading="full" child-type="aggregate"/>
            </schema>
            <schema _I_D="009d56f8-cbbc-450a-9f3a-46f9f87560c0" name="information_schema" is-empty="N" context="information_schema" subcategories-loading="none" object-loading="extended" schema-owner="postgres" is-system="Y">
                <category _I_D="b513e58b-86e7-48e2-8800-ab1d7ca88f10" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="7a20ef93-bc14-4808-9407-02a38e0b003f" name="Foreign tables" order-num="1" objects-loading="none" subcategories-loading="none" child-type="foreigntable"/>
                <category _I_D="5f7a9e34-b0a4-49f8-b886-52ab5b024c7a" name="Views" order-num="2" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="77bcbddd-2a0a-4228-845e-40508dd18ab1" name="Collations" order-num="3" objects-loading="none" subcategories-loading="none" child-type="collation"/>
                <category _I_D="2d34ff93-14db-4f51-95d4-40182122ce81" name="Operators" order-num="4" objects-loading="none" subcategories-loading="none" child-type="operator"/>
                <category _I_D="e15fc438-96b9-41cf-9f8d-b4fe8cd224c0" name="Rules" order-num="5" objects-loading="none" subcategories-loading="none" child-type="rule"/>
                <category _I_D="32d4989a-8257-4c60-b3f3-82ecffba20bb" name="FTS Configurations" order-num="6" objects-loading="none" subcategories-loading="none" child-type="ftsconfiguration"/>
                <category _I_D="b8c59714-5e5d-4ff5-9cdf-0be3b16b181e" name="FTS Dictionaries" order-num="7" objects-loading="none" subcategories-loading="none" child-type="ftsdictionary"/>
                <category _I_D="3d665070-020a-4373-a3e7-4b0facc49cf4" name="Functions" order-num="8" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="9cc52598-023e-4e43-9dd6-321fbf09f32b" name="Trigger functions" order-num="9" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="5fa2e551-2f9b-4d61-bcb2-95d1800b3164" name="Procedures" order-num="10" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="9135a497-285e-4742-9209-73b137cc86c4" name="Sequences" order-num="11" objects-loading="none" subcategories-loading="none" child-type="sequence"/>
                <category _I_D="70a24d65-9087-4342-bc4e-d5f44614e8da" name="User defined types" order-num="12" objects-loading="none" subcategories-loading="none" child-type="type"/>
                <category _I_D="68ccb82e-8b8f-4734-8b05-f04a70a309fa" name="Domains" order-num="13" objects-loading="none" subcategories-loading="none" child-type="domain"/>
                <category _I_D="47e0bc0d-0ce5-4416-aa66-6c7383d2c328" name="Materialized Views" order-num="14" objects-loading="none" subcategories-loading="none" child-type="materialized-view"/>
                <category _I_D="335032cc-7303-494c-b904-cd3bdcab83aa" name="Aggregates" order-num="15" objects-loading="none" subcategories-loading="none" child-type="aggregate"/>
            </schema>
            <schema _I_D="119e910e-9ee4-4d35-afd4-4afa4a2a2c9d" name="pg_catalog" is-empty="N" context="pg_catalog" subcategories-loading="none" object-loading="extended" schema-owner="postgres" is-system="Y">
                <category _I_D="a933c467-8ee5-47a1-8c63-633498eb3fe3" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="2df47e87-70d2-42ec-afc8-78d50e4f2a5e" name="Foreign tables" order-num="1" objects-loading="none" subcategories-loading="none" child-type="foreigntable"/>
                <category _I_D="0e2c1461-aaec-4821-9ee2-4a6fc7568fef" name="Views" order-num="2" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="bf54de6b-0da5-4661-903b-62a432719077" name="Collations" order-num="3" objects-loading="none" subcategories-loading="none" child-type="collation"/>
                <category _I_D="2cd2d2bd-8abe-4e4a-8570-0c71379bbc0d" name="Operators" order-num="4" objects-loading="none" subcategories-loading="none" child-type="operator"/>
                <category _I_D="e55da2ef-8e9e-4d7c-8a6e-e64d13e78b12" name="Rules" order-num="5" objects-loading="none" subcategories-loading="none" child-type="rule"/>
                <category _I_D="50182c1b-9c97-48d8-a685-24469747431e" name="FTS Configurations" order-num="6" objects-loading="none" subcategories-loading="none" child-type="ftsconfiguration"/>
                <category _I_D="348e10ed-8f40-434e-b632-38d6d2cde0df" name="FTS Dictionaries" order-num="7" objects-loading="none" subcategories-loading="none" child-type="ftsdictionary"/>
                <category _I_D="d03afa30-38fa-4829-bf34-d8f7bccdd881" name="Functions" order-num="8" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="133f8117-5d6c-4ee2-b3b7-a7455105a462" name="Trigger functions" order-num="9" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="e07b69e2-c626-4b97-a825-aea81db4a7b8" name="Procedures" order-num="10" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="6e76404d-320e-4da3-a230-094e04f279d0" name="Sequences" order-num="11" objects-loading="none" subcategories-loading="none" child-type="sequence"/>
                <category _I_D="990deb73-3b40-47b0-8483-8bc1b2e123e1" name="User defined types" order-num="12" objects-loading="none" subcategories-loading="none" child-type="type"/>
                <category _I_D="d0f6ebf9-2f8c-46b2-82ee-f8c789377ae2" name="Domains" order-num="13" objects-loading="none" subcategories-loading="none" child-type="domain"/>
                <category _I_D="1e6c9e18-f572-4a64-a2fb-d11bf5eebd31" name="Materialized Views" order-num="14" objects-loading="none" subcategories-loading="none" child-type="materialized-view"/>
                <category _I_D="3047d560-254f-4ff1-aea2-b5a2539d5f54" name="Aggregates" order-num="15" objects-loading="none" subcategories-loading="none" child-type="aggregate"/>
            </schema>
            <schema _I_D="60f5c8c9-da7b-4cd1-86eb-ce61111835ca" name="pg_toast" is-empty="N" context="pg_toast" subcategories-loading="none" object-loading="extended" schema-owner="postgres" is-system="Y">
                <category _I_D="010ccedb-13ae-40e3-b1c1-cdaa1571787e" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="afc177fb-6504-4f5f-8f2e-ba5ecfa19629" name="Foreign tables" order-num="1" objects-loading="none" subcategories-loading="none" child-type="foreigntable"/>
                <category _I_D="ede81232-a329-45f5-a78e-4383274faad6" name="Views" order-num="2" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="6a3470d3-fdc3-4427-8a54-52f18af067ff" name="Collations" order-num="3" objects-loading="none" subcategories-loading="none" child-type="collation"/>
                <category _I_D="51db2bac-858f-4bab-bad3-13e20a3eb9d5" name="Operators" order-num="4" objects-loading="none" subcategories-loading="none" child-type="operator"/>
                <category _I_D="527e2296-e83c-4be4-a61a-80e70c637952" name="Rules" order-num="5" objects-loading="none" subcategories-loading="none" child-type="rule"/>
                <category _I_D="7d7ad401-a1fa-4092-bfeb-01af8e9c2034" name="FTS Configurations" order-num="6" objects-loading="none" subcategories-loading="none" child-type="ftsconfiguration"/>
                <category _I_D="37a8daf0-c8ab-4385-aced-39a6a35086f7" name="FTS Dictionaries" order-num="7" objects-loading="none" subcategories-loading="none" child-type="ftsdictionary"/>
                <category _I_D="74293cd5-617c-4d98-9d8d-b64e11543e8e" name="Functions" order-num="8" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="89ae1a05-ef81-474a-8db1-46219c01f749" name="Trigger functions" order-num="9" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="448a1da5-b5d7-4105-b5bd-392323ca26cf" name="Procedures" order-num="10" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="557a36fb-aa0e-457c-b457-7887c9242007" name="Sequences" order-num="11" objects-loading="none" subcategories-loading="none" child-type="sequence"/>
                <category _I_D="14f966a7-4279-4fa0-856d-5a0a9f28847b" name="User defined types" order-num="12" objects-loading="none" subcategories-loading="none" child-type="type"/>
                <category _I_D="c48ce390-1da3-4bf3-b0da-3ac12c6779ac" name="Domains" order-num="13" objects-loading="none" subcategories-loading="none" child-type="domain"/>
                <category _I_D="90889e2a-f997-48ae-8bf3-2ec07cadf990" name="Materialized Views" order-num="14" objects-loading="none" subcategories-loading="none" child-type="materialized-view"/>
                <category _I_D="a5c88d7d-7023-41c6-9513-11e9c5c8229a" name="Aggregates" order-num="15" objects-loading="none" subcategories-loading="none" child-type="aggregate"/>
            </schema>
            <schema _I_D="a2ab9db2-ec66-4ed5-bc26-32815b2da830" name="public" is-empty="Y" context="public" subcategories-loading="none" object-loading="extended" schema-owner="pg_database_owner" is-system="N">
                <category _I_D="7d80412a-b07a-4405-9013-104181172077" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="93fd9a60-d42b-4d79-ba80-566d4b8cc511" name="Foreign tables" order-num="1" objects-loading="none" subcategories-loading="none" child-type="foreigntable"/>
                <category _I_D="1dcb66ce-2c53-4c63-b202-9c40321ea89c" name="Views" order-num="2" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="85384670-56bf-401d-b03d-b80ddc0bf961" name="Collations" order-num="3" objects-loading="none" subcategories-loading="none" child-type="collation"/>
                <category _I_D="9b1fa36e-33e2-444a-81e1-4b16e599b47c" name="Operators" order-num="4" objects-loading="none" subcategories-loading="none" child-type="operator"/>
                <category _I_D="9c10d5f4-5109-43bf-82dd-1da9cf000967" name="Rules" order-num="5" objects-loading="none" subcategories-loading="none" child-type="rule"/>
                <category _I_D="d113e20a-f9ab-46bc-b1c4-6819415b0d42" name="FTS Configurations" order-num="6" objects-loading="none" subcategories-loading="none" child-type="ftsconfiguration"/>
                <category _I_D="a9be80f0-6fb2-409a-b5b2-bb2130b8c1f6" name="FTS Dictionaries" order-num="7" objects-loading="none" subcategories-loading="none" child-type="ftsdictionary"/>
                <category _I_D="a3a3d376-10c0-421f-b3e8-44ff1f876b08" name="Functions" order-num="8" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="e090e690-2f35-4e38-bed2-ef03a1c43e74" name="Trigger functions" order-num="9" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="0572c391-861a-43bb-b636-7ef4a66f16f8" name="Procedures" order-num="10" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="10405648-3313-4f25-a9d5-e5fcd8f77cfa" name="Sequences" order-num="11" objects-loading="none" subcategories-loading="none" child-type="sequence"/>
                <category _I_D="d1b3e596-479d-493c-92d8-fdcd735acde9" name="User defined types" order-num="12" objects-loading="none" subcategories-loading="none" child-type="type"/>
                <category _I_D="66107282-4c54-4d31-a585-21e6a2328c04" name="Domains" order-num="13" objects-loading="none" subcategories-loading="none" child-type="domain"/>
                <category _I_D="43a7fbf4-7116-4403-9b88-69f7e008d453" name="Materialized Views" order-num="14" objects-loading="none" subcategories-loading="none" child-type="materialized-view"/>
                <category _I_D="5370c2d4-38ff-4943-91f8-018ef8d5f966" name="Aggregates" order-num="15" objects-loading="none" subcategories-loading="none" child-type="aggregate"/>
            </schema>
            <schema _I_D="8fe43064-8f36-4231-b2b5-15c1c8dc1a2d" name="chinook_dbo" is-empty="N" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:30">
                <category _I_D="fbdc1614-e6a8-4e9f-86e1-b766e711dd02" name="Tables" order-num="0" child-type="table" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables" conversion-version="15">
                    <table _I_D="ca4d3c50-7cf2-4f8d-b8c2-1673abe70664" name="album" transformed="2024-08-26 00:08:49" partitioned="NO" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:30">
                        <category _I_D="2524bb58-4226-4116-8b84-e3232f9a7fad" name="Columns" order-num="0" child-type="column" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Columns" conversion-version="15">
                            <column _I_D="288eb74a-c92d-49e9-b6db-1628438d5e73" name="albumid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Columns,column AlbumId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="cbe0f654-b243-47cc-87ba-09943bcd2b0e" name="title" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="nvarchar" is-xml-document="N" dt-attr-1="160" character-maximum-length="320" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Columns,column Title" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="4026db82-ed54-401b-8e82-433df5122956" name="artistid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Columns,column ArtistId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="72acbb7b-7fda-41d3-a217-0e1160794bc5" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Constraints" conversion-version="15">
                            <constraint _I_D="503da0d7-b9db-4aff-8738-f447ef0eae77" name="fk_albumartistid_1253579504" constraint-type-desc="FOREIGN KEY" transformed="2024-08-26 00:08:49" referenced-table-name="artist" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" referenced-constraint-name="PK_Artist" referenced-table-schema="chinook_dbo" constraint-schema="chinook_dbo" update-rule="NO ACTION" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Constraints,constraint FK_AlbumArtistId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="d27dd3d1-8539-41e4-85e4-edf0093b4a5c" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Constraints,constraint FK_AlbumArtistId,category Columns" conversion-version="15">
                                    <column _I_D="cc59ee1a-a8ae-4108-b472-dd7b02a6cde5" name="artistid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Constraints,constraint FK_AlbumArtistId,category Columns,column ArtistId" conversion-version="15" source-vendor="MSSQL" column-in-referenced-unique-constraint="artistid" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                            <constraint _I_D="5235b512-c7e8-4f26-880b-8b3dc05cf871" name="pk_album_917578307" constraint-type-desc="PRIMARY KEY" transformed="2024-08-26 00:08:49" constraint-type="PRIMARY KEY" constraint-schema="dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Constraints,constraint PK_Album" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="6b9ff429-9079-485f-820a-9895b301945c" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Constraints,constraint PK_Album,category Columns" conversion-version="15">
                                    <column _I_D="bec1bd57-0861-4d55-b2c4-60c7f646bc45" name="albumid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Constraints,constraint PK_Album,category Columns,column AlbumId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="b7262618-56cc-4a94-9353-013df16cc64a" name="Indexes" order-num="2" child-type="index" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Indexes" conversion-version="15">
                            <index _I_D="12f80782-0823-4709-906f-22bdf5c4dd93" name="ix_album_ifk_albumartistid" is-unique="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Indexes,index IFK_AlbumArtistId" conversion-version="15" source-vendor="MSSQL" index-type="BTREE" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="59ed9a9f-888b-464a-b477-f6415592df15" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Indexes,index IFK_AlbumArtistId,category Columns" conversion-version="15">
                                    <column _I_D="6c6bc478-4226-4b18-aede-9b32fc2f26a9" name="artistid" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Indexes,index IFK_AlbumArtistId,category Columns,column ArtistId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" order-column="1" included-column="0" mdl-applying-result="applying-success"/>
                                </category>
                            </index>
                        </category>
                        <category _I_D="648e1d7b-3c55-434c-86c3-3abcdbcecad7" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Triggers" conversion-version="15"/>
                        <category _I_D="292ba8d5-2e13-41ac-9031-913898f18ee9" name="Partitions" order-num="4" child-type="partition" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="db663325-c09f-4cbd-a38c-ec1b8de7e570" name="artist" transformed="2024-08-26 00:08:49" partitioned="NO" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:30">
                        <category _I_D="6e06a932-f608-4e18-9e68-6883a30aaf4a" name="Columns" order-num="0" child-type="column" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Columns" conversion-version="15">
                            <column _I_D="bb46f358-2e9b-4540-93e4-19a36b3574f6" name="artistid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Columns,column ArtistId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="5ff01e49-7818-4bd0-975c-23bf6371373c" name="name" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="120" character-maximum-length="240" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Columns,column Name" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="04110223-d9aa-4f05-b2ba-05e808fbdd88" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Constraints" conversion-version="15">
                            <constraint _I_D="f40014b9-26ea-433c-a190-3056f7894716" name="pk_artist_949578421" constraint-type-desc="PRIMARY KEY" transformed="2024-08-26 00:08:49" constraint-type="PRIMARY KEY" constraint-schema="dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Constraints,constraint PK_Artist" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="60d6df70-d5a5-4779-b279-aeeb197211f3" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Constraints,constraint PK_Artist,category Columns" conversion-version="15">
                                    <column _I_D="6afc94d5-a565-4bcd-8962-ae1adbcf950b" name="artistid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Constraints,constraint PK_Artist,category Columns,column ArtistId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="c479393a-70f5-482b-a02b-b4d77c92b8d6" name="Indexes" order-num="2" child-type="index" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Indexes" conversion-version="15"/>
                        <category _I_D="264aad27-3d2d-4ea6-88e3-4fa8c413ba32" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Triggers" conversion-version="15"/>
                        <category _I_D="a63fd767-9401-46b5-a4af-79b1c550f10a" name="Partitions" order-num="4" child-type="partition" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="3c24212d-6ae2-42dc-a61a-365389ca94b4" name="customer" transformed="2024-08-26 00:08:49" partitioned="NO" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:30">
                        <category _I_D="a12800ca-5a5a-47d6-9866-98ff374632f1" name="Columns" order-num="0" child-type="column" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns" conversion-version="15">
                            <column _I_D="93ccfedb-0a6c-4062-a384-341d713377b8" name="customerid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column CustomerId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="8534b6aa-429d-4877-80e5-aa3448837737" name="firstname" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="nvarchar" is-xml-document="N" dt-attr-1="40" character-maximum-length="80" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column FirstName" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="f7e014b2-54c7-4b83-8ebb-7962360303ea" name="lastname" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="nvarchar" is-xml-document="N" dt-attr-1="20" character-maximum-length="40" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column LastName" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="7707d164-ab0d-4b72-b77a-19eba9a820f3" name="company" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="80" character-maximum-length="160" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column Company" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="95b7107d-4e59-486c-a6b9-99720c497651" name="address" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="70" character-maximum-length="140" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column Address" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="ea66809b-27a0-43ef-8a04-a662e1c7caef" name="city" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="40" character-maximum-length="80" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column City" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="f92ab8a1-cb16-47d8-a576-1c55ec0f99ae" name="state" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="40" character-maximum-length="80" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column State" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="f45b7107-7323-4bfd-9ab3-44a2d5c356c8" name="country" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="40" character-maximum-length="80" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column Country" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="ccc74b2a-25d9-4fc3-a7ca-0a9d9fe7de9d" name="postalcode" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="10" character-maximum-length="20" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column PostalCode" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="67ffc3fd-0fe9-4f92-8d45-24b5e45ddf70" name="phone" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="24" character-maximum-length="48" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column Phone" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="a6dac297-f242-45d3-a9bc-28e8031974b6" name="fax" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="24" character-maximum-length="48" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column Fax" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="95680a2d-accc-4829-8c69-a4fa9993f588" name="email" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="nvarchar" is-xml-document="N" dt-attr-1="60" character-maximum-length="120" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column Email" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="756c6861-0db6-4691-9c44-10d7def80012" name="supportrepid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column SupportRepId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="69fc7af3-411e-4dde-9308-ffa87226c351" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Constraints" conversion-version="15">
                            <constraint _I_D="ef42db72-90c5-4e8e-95df-98637d7addbf" name="fk_customersupportrepid_1269579561" constraint-type-desc="FOREIGN KEY" transformed="2024-08-26 00:08:49" referenced-table-name="employee" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" referenced-constraint-name="PK_Employee" referenced-table-schema="chinook_dbo" constraint-schema="chinook_dbo" update-rule="NO ACTION" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Constraints,constraint FK_CustomerSupportRepId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="2dd79f72-706d-49ff-b864-d8e23b9847f0" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Constraints,constraint FK_CustomerSupportRepId,category Columns" conversion-version="15">
                                    <column _I_D="013c487d-939b-4d7b-8369-e11569505856" name="supportrepid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Constraints,constraint FK_CustomerSupportRepId,category Columns,column SupportRepId" conversion-version="15" source-vendor="MSSQL" column-in-referenced-unique-constraint="employeeid" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                            <constraint _I_D="b300e5c7-0e7b-4f40-acbd-6feac57e1aef" name="pk_customer_981578535" constraint-type-desc="PRIMARY KEY" transformed="2024-08-26 00:08:49" constraint-type="PRIMARY KEY" constraint-schema="dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Constraints,constraint PK_Customer" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="ad378c5c-b020-462c-a185-0ca9cc0986f2" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Constraints,constraint PK_Customer,category Columns" conversion-version="15">
                                    <column _I_D="94f76be9-00dc-4630-adcc-d7b46aee74a7" name="customerid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Constraints,constraint PK_Customer,category Columns,column CustomerId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="184abac9-d114-41e7-8f57-9f745a1ace2d" name="Indexes" order-num="2" child-type="index" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Indexes" conversion-version="15">
                            <index _I_D="b1d1206f-9ccc-46f5-ab3e-5e46c1fe27c4" name="ix_customer_ifk_customersupportrepid" is-unique="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Indexes,index IFK_CustomerSupportRepId" conversion-version="15" source-vendor="MSSQL" index-type="BTREE" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="dfb361c9-6525-45d7-aa46-ff6a86904843" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Indexes,index IFK_CustomerSupportRepId,category Columns" conversion-version="15">
                                    <column _I_D="fe818dc9-609f-4eff-ab9e-2342322b9405" name="supportrepid" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Indexes,index IFK_CustomerSupportRepId,category Columns,column SupportRepId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" order-column="1" included-column="0" mdl-applying-result="applying-success"/>
                                </category>
                            </index>
                        </category>
                        <category _I_D="7a79b11c-f9ee-4de1-bfca-cb536d44a258" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Triggers" conversion-version="15"/>
                        <category _I_D="b140313b-80c3-438c-8cc4-b05ca5002c86" name="Partitions" order-num="4" child-type="partition" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="4693e0b3-a6a2-4f3b-b16a-2a6745977a3d" name="employee" transformed="2024-08-26 00:08:49" partitioned="NO" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:30">
                        <category _I_D="de3f920d-c5da-4258-8bfd-65347d983306" name="Columns" order-num="0" child-type="column" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns" conversion-version="15">
                            <column _I_D="eb92461b-0856-479d-bafc-fac692b69c0f" name="employeeid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column EmployeeId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="0a1e00c7-defb-4aff-bab7-3c024071b154" name="lastname" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="nvarchar" is-xml-document="N" dt-attr-1="20" character-maximum-length="40" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column LastName" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="bac0dabe-410c-4cec-aac8-9a3ce2a62699" name="firstname" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="nvarchar" is-xml-document="N" dt-attr-1="20" character-maximum-length="40" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column FirstName" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="99910263-181c-4206-8929-59bb56933fcc" name="title" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="30" character-maximum-length="60" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column Title" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="c0889c95-079d-4f11-adf9-a3e564ed10bc" name="reportsto" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column ReportsTo" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="f26cde61-3d27-4d9d-8251-9a14ca960064" name="birthdate" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="datetime" is-xml-document="N" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column BirthDate" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="fe56e7f8-f088-470b-b639-7a1e9db96d65" name="hiredate" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="datetime" is-xml-document="N" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column HireDate" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="1a71c57c-afb6-41b8-bec0-f5c11d728307" name="address" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="70" character-maximum-length="140" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column Address" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="cbc8ba75-8431-45f8-98a4-0999f5449239" name="city" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="40" character-maximum-length="80" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column City" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="a12f47be-bc41-4c02-9c38-36b614190b92" name="state" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="40" character-maximum-length="80" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column State" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="5d3fa837-c026-46c7-add9-4e4cb460a17c" name="country" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="40" character-maximum-length="80" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column Country" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="8ab27d1e-590f-4231-b8a6-a3e3c3cba4fd" name="postalcode" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="10" character-maximum-length="20" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column PostalCode" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="813786df-d611-478a-a17d-f30339cd3938" name="phone" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="24" character-maximum-length="48" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column Phone" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="63bbbc23-a780-406d-b8b3-5a3282e6ec3e" name="fax" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="24" character-maximum-length="48" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column Fax" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="4ffb045d-4f66-48ae-b2cc-d5d87ec39dc2" name="email" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="60" character-maximum-length="120" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column Email" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="29f9c0ce-52fd-4c34-b567-ec2c3cc4860d" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Constraints" conversion-version="15">
                            <constraint _I_D="1cfd8449-8f62-4d20-9e22-60e9e811feff" name="fk_employeereportsto_1285579618" constraint-type-desc="FOREIGN KEY" transformed="2024-08-26 00:08:49" referenced-table-name="employee" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" referenced-constraint-name="PK_Employee" referenced-table-schema="chinook_dbo" constraint-schema="chinook_dbo" update-rule="NO ACTION" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Constraints,constraint FK_EmployeeReportsTo" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="1534ba95-5fd5-4cbf-8724-789dd216d12f" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Constraints,constraint FK_EmployeeReportsTo,category Columns" conversion-version="15">
                                    <column _I_D="53af9dfb-7c42-4911-8990-d8fd28d44b41" name="reportsto" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Constraints,constraint FK_EmployeeReportsTo,category Columns,column ReportsTo" conversion-version="15" source-vendor="MSSQL" column-in-referenced-unique-constraint="employeeid" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                            <constraint _I_D="361a12a3-3c2f-4324-94e0-5609d3d6bc9c" name="pk_employee_1013578649" constraint-type-desc="PRIMARY KEY" transformed="2024-08-26 00:08:49" constraint-type="PRIMARY KEY" constraint-schema="dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Constraints,constraint PK_Employee" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="5706ae1a-1256-4b3f-9f31-db35ff9523bb" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Constraints,constraint PK_Employee,category Columns" conversion-version="15">
                                    <column _I_D="4d21b6a7-7b73-4e6a-ab0c-fe6195f94237" name="employeeid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Constraints,constraint PK_Employee,category Columns,column EmployeeId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="52105aed-e77f-474a-ab61-970ebd42f340" name="Indexes" order-num="2" child-type="index" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Indexes" conversion-version="15">
                            <index _I_D="f36297de-5948-4da8-b00c-a38e1a94f613" name="ix_employee_ifk_employeereportsto" is-unique="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Indexes,index IFK_EmployeeReportsTo" conversion-version="15" source-vendor="MSSQL" index-type="BTREE" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="25614ee8-6f8a-4615-b002-aee9ba27462b" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Indexes,index IFK_EmployeeReportsTo,category Columns" conversion-version="15">
                                    <column _I_D="60b3a6ce-a65d-4d03-81f1-7568ae68650e" name="reportsto" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Indexes,index IFK_EmployeeReportsTo,category Columns,column ReportsTo" conversion-version="15" source-vendor="MSSQL" descasc="ASC" order-column="1" included-column="0" mdl-applying-result="applying-success"/>
                                </category>
                            </index>
                        </category>
                        <category _I_D="e5f6d533-d53c-48dd-9010-24f6fb4383a0" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Triggers" conversion-version="15"/>
                        <category _I_D="ce8c8b13-6f53-41b4-a5ec-616cdbd6e1d4" name="Partitions" order-num="4" child-type="partition" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="c1eacd8e-cb81-4cf3-a5a0-fe0b2cae3efe" name="genre" transformed="2024-08-26 00:08:49" partitioned="NO" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:30">
                        <category _I_D="ac63827d-2c8f-4401-a9e2-7c51f0ca53b2" name="Columns" order-num="0" child-type="column" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Columns" conversion-version="15">
                            <column _I_D="486f0f4b-d4f3-4ecd-9bc3-84bab761f910" name="genreid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Columns,column GenreId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="20aeb0d8-7540-489e-a489-5e6202c87f21" name="name" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="120" character-maximum-length="240" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Columns,column Name" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="14bbadcd-76f8-42bb-b0e1-e5b4b50d73f1" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Constraints" conversion-version="15">
                            <constraint _I_D="4714cb9c-a7fd-4bfd-9bc7-d63df4c657a6" name="pk_genre_1045578763" constraint-type-desc="PRIMARY KEY" transformed="2024-08-26 00:08:49" constraint-type="PRIMARY KEY" constraint-schema="dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Constraints,constraint PK_Genre" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="53631f5d-0da5-496d-803a-510aee92da18" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Constraints,constraint PK_Genre,category Columns" conversion-version="15">
                                    <column _I_D="1cf8418c-1684-4162-a8c2-310a61047713" name="genreid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Constraints,constraint PK_Genre,category Columns,column GenreId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="e6f62e5f-5d1c-4973-a351-c250e515248e" name="Indexes" order-num="2" child-type="index" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Indexes" conversion-version="15"/>
                        <category _I_D="45d0a066-20b2-4166-bd15-720109a3ee0d" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Triggers" conversion-version="15"/>
                        <category _I_D="4b796174-0a96-4aa0-8adb-e44f6ba921ab" name="Partitions" order-num="4" child-type="partition" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="9fdacf99-f853-4cc3-a646-0e3ad6a751d0" name="invoice" transformed="2024-08-26 00:08:49" partitioned="NO" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:30">
                        <category _I_D="603c13ab-0938-42d3-8ba8-d53f30fbec35" name="Columns" order-num="0" child-type="column" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns" conversion-version="15">
                            <column _I_D="9a0f605c-52cd-4da2-917e-ac46c56f1f17" name="invoiceid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column InvoiceId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="c9dc07bf-d409-4c63-97cf-2107ff38688d" name="customerid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column CustomerId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="c3e5b8d2-e18c-48bc-9ccd-4ec61724b16e" name="invoicedate" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="datetime" is-xml-document="N" character-maximum-length="8" numeric-precision="23" numeric-scale="3" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column InvoiceDate" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="fd4714b0-b921-400c-b135-ace30bc38c55" name="billingaddress" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="70" character-maximum-length="140" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column BillingAddress" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="ac95a74b-2e06-4cf8-8578-ee67219325ef" name="billingcity" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="40" character-maximum-length="80" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column BillingCity" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="d422d1cf-e052-410c-86e2-9d2d37963927" name="billingstate" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="40" character-maximum-length="80" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column BillingState" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="3ecd7a92-0a34-477b-802d-db6a3ef3573c" name="billingcountry" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="40" character-maximum-length="80" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column BillingCountry" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="d001c75d-c207-46d3-941e-6100b049ffb2" name="billingpostalcode" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="10" character-maximum-length="20" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column BillingPostalCode" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="5031a72e-c1cf-4d53-8cde-55d1fecc02e5" name="total" dt-name="NUMERIC" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="numeric" is-xml-document="N" dt-attr-1="10" dt-attr-2="2" character-maximum-length="9" numeric-precision="10" numeric-scale="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column Total" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="e7061755-c015-4b4e-8c39-ff175579be37" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Constraints" conversion-version="15">
                            <constraint _I_D="ac8945e9-0f29-44e9-8d4c-f2c5a89204b4" name="fk_invoicecustomerid_1301579675" constraint-type-desc="FOREIGN KEY" transformed="2024-08-26 00:08:49" referenced-table-name="customer" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" referenced-constraint-name="PK_Customer" referenced-table-schema="chinook_dbo" constraint-schema="chinook_dbo" update-rule="NO ACTION" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Constraints,constraint FK_InvoiceCustomerId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="b8411677-2007-4c6a-9aae-f62b601fea8f" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Constraints,constraint FK_InvoiceCustomerId,category Columns" conversion-version="15">
                                    <column _I_D="7a1b3dff-f989-48ad-bdfa-98057e0af1a0" name="customerid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Constraints,constraint FK_InvoiceCustomerId,category Columns,column CustomerId" conversion-version="15" source-vendor="MSSQL" column-in-referenced-unique-constraint="customerid" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                            <constraint _I_D="445c09a3-5c60-4a28-ace4-65efb1467f49" name="pk_invoice_1077578877" constraint-type-desc="PRIMARY KEY" transformed="2024-08-26 00:08:49" constraint-type="PRIMARY KEY" constraint-schema="dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Constraints,constraint PK_Invoice" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="7454690f-7acc-4617-b6a4-3ec18b31462b" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Constraints,constraint PK_Invoice,category Columns" conversion-version="15">
                                    <column _I_D="eafb48ed-a926-4bd6-aa69-298d0c9d4211" name="invoiceid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Constraints,constraint PK_Invoice,category Columns,column InvoiceId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="82d93541-0799-4f4f-900b-66c38bd2799f" name="Indexes" order-num="2" child-type="index" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Indexes" conversion-version="15">
                            <index _I_D="f43085fa-c8b5-4fd3-b26a-246944388cbc" name="ix_invoice_ifk_invoicecustomerid" is-unique="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Indexes,index IFK_InvoiceCustomerId" conversion-version="15" source-vendor="MSSQL" index-type="BTREE" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="bb9487d2-a80a-47bf-b871-603fe52ab22f" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Indexes,index IFK_InvoiceCustomerId,category Columns" conversion-version="15">
                                    <column _I_D="b040ba17-a0d2-4466-b9a0-c3e8ba5a3c25" name="customerid" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Indexes,index IFK_InvoiceCustomerId,category Columns,column CustomerId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" order-column="1" included-column="0" mdl-applying-result="applying-success"/>
                                </category>
                            </index>
                        </category>
                        <category _I_D="2ae70489-6edd-4788-9bae-2ead2442c7aa" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Triggers" conversion-version="15"/>
                        <category _I_D="097dcf44-8745-48a2-a7d1-b582645286da" name="Partitions" order-num="4" child-type="partition" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="2284285a-9cc0-49ba-975c-e8523f8865c1" name="invoiceline" transformed="2024-08-26 00:08:49" partitioned="NO" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:30">
                        <category _I_D="fb353a47-1841-45d4-94e5-6096a6e1fc5c" name="Columns" order-num="0" child-type="column" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Columns" conversion-version="15">
                            <column _I_D="5d22a456-1c46-406a-b2e4-5dd73d1ab303" name="invoicelineid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Columns,column InvoiceLineId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="fc11af5b-51a0-42e3-9c93-d8c732ef21f4" name="invoiceid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Columns,column InvoiceId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="53e5d865-101b-44f8-aa92-11fbc9d95622" name="trackid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Columns,column TrackId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="e8b9bac8-697e-4c30-9ba3-a306aa12828a" name="unitprice" dt-name="NUMERIC" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="numeric" is-xml-document="N" dt-attr-1="10" dt-attr-2="2" character-maximum-length="9" numeric-precision="10" numeric-scale="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Columns,column UnitPrice" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="fd0a524b-21e0-4f89-bc94-c9d8896edaf0" name="quantity" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Columns,column Quantity" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="65fc40a5-c1bd-4479-b491-2960219816dd" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints" conversion-version="15">
                            <constraint _I_D="87c4dee7-b224-4142-a343-2534d6fa8e94" name="fk_invoicelineinvoiceid_1317579732" constraint-type-desc="FOREIGN KEY" transformed="2024-08-26 00:08:49" referenced-table-name="invoice" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" referenced-constraint-name="PK_Invoice" referenced-table-schema="chinook_dbo" constraint-schema="chinook_dbo" update-rule="NO ACTION" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint FK_InvoiceLineInvoiceId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="c6150758-6e17-4679-90c9-6e947e3fc325" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint FK_InvoiceLineInvoiceId,category Columns" conversion-version="15">
                                    <column _I_D="6067b6e8-d6f1-4a2a-87d2-a48ccc19d65b" name="invoiceid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint FK_InvoiceLineInvoiceId,category Columns,column InvoiceId" conversion-version="15" source-vendor="MSSQL" column-in-referenced-unique-constraint="invoiceid" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                            <constraint _I_D="42293109-6f5c-40a2-9ffe-3814fbaab478" name="fk_invoicelinetrackid_1333579789" constraint-type-desc="FOREIGN KEY" transformed="2024-08-26 00:08:49" referenced-table-name="track" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" referenced-constraint-name="PK_Track" referenced-table-schema="chinook_dbo" constraint-schema="chinook_dbo" update-rule="NO ACTION" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint FK_InvoiceLineTrackId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="7a912df8-32fe-4b0c-8dfa-3c80c2ddee8c" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint FK_InvoiceLineTrackId,category Columns" conversion-version="15">
                                    <column _I_D="2b9aebde-306f-4bf0-ab38-63f515653f44" name="trackid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint FK_InvoiceLineTrackId,category Columns,column TrackId" conversion-version="15" source-vendor="MSSQL" column-in-referenced-unique-constraint="trackid" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                            <constraint _I_D="dc38a126-0ceb-44bb-a65e-55f1a319d388" name="pk_invoiceline_1109578991" constraint-type-desc="PRIMARY KEY" transformed="2024-08-26 00:08:49" constraint-type="PRIMARY KEY" constraint-schema="dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint PK_InvoiceLine" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="7a67180d-e970-496d-a21e-cd129f6f305a" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint PK_InvoiceLine,category Columns" conversion-version="15">
                                    <column _I_D="030b30c8-41f8-4309-a77b-9fffc1c4574b" name="invoicelineid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint PK_InvoiceLine,category Columns,column InvoiceLineId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="db3e6ab1-943e-4b0d-991f-3695569b55c1" name="Indexes" order-num="2" child-type="index" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Indexes" conversion-version="15">
                            <index _I_D="926d6f31-e601-4dc5-87d4-9c25dc20df39" name="ix_invoiceline_ifk_invoicelineinvoiceid" is-unique="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Indexes,index IFK_InvoiceLineInvoiceId" conversion-version="15" source-vendor="MSSQL" index-type="BTREE" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="5ac34db0-dc41-4b6c-8d9a-50149d67871f" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Indexes,index IFK_InvoiceLineInvoiceId,category Columns" conversion-version="15">
                                    <column _I_D="a33f0608-d618-45cc-a95c-70ab95947055" name="invoiceid" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Indexes,index IFK_InvoiceLineInvoiceId,category Columns,column InvoiceId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" order-column="1" included-column="0" mdl-applying-result="applying-success"/>
                                </category>
                            </index>
                            <index _I_D="11396e76-f28d-4f84-94d3-00e9d31dcf64" name="ix_invoiceline_ifk_invoicelinetrackid" is-unique="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Indexes,index IFK_InvoiceLineTrackId" conversion-version="15" source-vendor="MSSQL" index-type="BTREE" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="69c0f77f-6240-40a7-bf4b-d7ffb174037e" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Indexes,index IFK_InvoiceLineTrackId,category Columns" conversion-version="15">
                                    <column _I_D="ada11cc7-bc76-41d4-a4a1-ef7226e5ed37" name="trackid" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Indexes,index IFK_InvoiceLineTrackId,category Columns,column TrackId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" order-column="1" included-column="0" mdl-applying-result="applying-success"/>
                                </category>
                            </index>
                        </category>
                        <category _I_D="4b547039-69cb-4243-b178-3aaa52ff6a18" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Triggers" conversion-version="15"/>
                        <category _I_D="a180c474-39bc-45d0-85ee-e1d1807c5cc6" name="Partitions" order-num="4" child-type="partition" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="d9f625f2-7998-4add-bf0e-12b50fc1520d" name="mediatype" transformed="2024-08-26 00:08:49" partitioned="NO" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:30">
                        <category _I_D="f681225e-5570-4f25-8df5-655d51bb4344" name="Columns" order-num="0" child-type="column" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Columns" conversion-version="15">
                            <column _I_D="50d13050-da46-470d-ba41-a91ce5a5d74d" name="mediatypeid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Columns,column MediaTypeId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="0f8dd5bd-363f-45cd-8cad-7ce0629df25e" name="name" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="120" character-maximum-length="240" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Columns,column Name" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="f7ba6ce2-c2bb-4f68-848d-097f9c05e22e" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Constraints" conversion-version="15">
                            <constraint _I_D="f3bf5321-efb8-442e-9a51-2b13d92281c9" name="pk_mediatype_1141579105" constraint-type-desc="PRIMARY KEY" transformed="2024-08-26 00:08:49" constraint-type="PRIMARY KEY" constraint-schema="dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Constraints,constraint PK_MediaType" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="64eca792-fe24-4dec-a830-2d6290cb8233" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Constraints,constraint PK_MediaType,category Columns" conversion-version="15">
                                    <column _I_D="ad9294b8-bb0e-4e80-93f9-bd55637fe884" name="mediatypeid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Constraints,constraint PK_MediaType,category Columns,column MediaTypeId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="9af98f49-49f8-44c8-a859-43959823f604" name="Indexes" order-num="2" child-type="index" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Indexes" conversion-version="15"/>
                        <category _I_D="69e4ff3c-7b96-4a9a-9c7c-cfaffa68407a" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Triggers" conversion-version="15"/>
                        <category _I_D="47801955-6083-4d98-ab74-e0ad272d43ff" name="Partitions" order-num="4" child-type="partition" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="0b1aa0d5-d7cc-4f94-bb42-13130f66b0b7" name="playlist" transformed="2024-08-26 00:08:49" partitioned="NO" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:30">
                        <category _I_D="d4c712bd-0bf1-4884-aeae-256530b4a712" name="Columns" order-num="0" child-type="column" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Columns" conversion-version="15">
                            <column _I_D="08c82500-070b-42f1-8804-9d079aecd286" name="playlistid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Columns,column PlaylistId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="a78008f5-5906-43bd-85fb-a58213b74672" name="name" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="120" character-maximum-length="240" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Columns,column Name" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="14108fbb-c193-49fd-9c3d-d9074907b8ea" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Constraints" conversion-version="15">
                            <constraint _I_D="4515b918-7946-4c8b-be14-0407384608f0" name="pk_playlist_1173579219" constraint-type-desc="PRIMARY KEY" transformed="2024-08-26 00:08:49" constraint-type="PRIMARY KEY" constraint-schema="dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Constraints,constraint PK_Playlist" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="0738b594-6ba2-4204-bf8f-8394add99c9b" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Constraints,constraint PK_Playlist,category Columns" conversion-version="15">
                                    <column _I_D="186e7e5a-3db5-49c8-973c-fd0fc8a7ef2d" name="playlistid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Constraints,constraint PK_Playlist,category Columns,column PlaylistId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="4684e361-bed8-4fff-ad64-aeffd974a63b" name="Indexes" order-num="2" child-type="index" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Indexes" conversion-version="15"/>
                        <category _I_D="55f54e15-f03f-4228-bec5-4292d00f39fd" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Triggers" conversion-version="15"/>
                        <category _I_D="f37a6189-181f-4144-ab80-64e99a13d725" name="Partitions" order-num="4" child-type="partition" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="9d7e15c4-8619-4f9e-9aac-eb0f3f4a6c36" name="playlisttrack" transformed="2024-08-26 00:08:49" partitioned="NO" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                        <category _I_D="c8db07c1-7e47-4f8d-bf5e-59e41a7a5300" name="Columns" order-num="0" child-type="column" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Columns" conversion-version="15">
                            <column _I_D="cc9d317c-bac9-4c83-b330-d21120047a79" name="playlistid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Columns,column PlaylistId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="391d5907-e57f-4755-9670-38103115195b" name="trackid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Columns,column TrackId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="94da6b89-0fdf-4db6-a1b7-fed69641207e" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints" conversion-version="15">
                            <constraint _I_D="18bda8b5-6327-441e-846b-2d9cd2afdb22" name="fk_playlisttrackplaylistid_1349579846" constraint-type-desc="FOREIGN KEY" transformed="2024-08-26 00:08:49" referenced-table-name="playlist" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" referenced-constraint-name="PK_Playlist" referenced-table-schema="chinook_dbo" constraint-schema="chinook_dbo" update-rule="NO ACTION" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint FK_PlaylistTrackPlaylistId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="1aa641db-f58a-4f3d-879a-a0e2700a2391" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint FK_PlaylistTrackPlaylistId,category Columns" conversion-version="15">
                                    <column _I_D="fb3343be-594a-4760-a2db-5818a0cae33c" name="playlistid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint FK_PlaylistTrackPlaylistId,category Columns,column PlaylistId" conversion-version="15" source-vendor="MSSQL" column-in-referenced-unique-constraint="playlistid" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                            <constraint _I_D="c6415af8-9c87-4162-b55f-29f63d7010fd" name="fk_playlisttracktrackid_1365579903" constraint-type-desc="FOREIGN KEY" transformed="2024-08-26 00:08:49" referenced-table-name="track" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" referenced-constraint-name="PK_Track" referenced-table-schema="chinook_dbo" constraint-schema="chinook_dbo" update-rule="NO ACTION" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint FK_PlaylistTrackTrackId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="96468e8a-4504-45d8-90cd-f1e06a729411" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint FK_PlaylistTrackTrackId,category Columns" conversion-version="15">
                                    <column _I_D="67e08717-e097-400c-8ecc-dc7a0395bfee" name="trackid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint FK_PlaylistTrackTrackId,category Columns,column TrackId" conversion-version="15" source-vendor="MSSQL" column-in-referenced-unique-constraint="trackid" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                            <constraint _I_D="ba013558-5817-4e8f-ae2b-ac163bbeb611" name="pk_playlisttrack_1205579333" constraint-type-desc="PRIMARY KEY" transformed="2024-08-26 00:08:49" constraint-type="PRIMARY KEY" constraint-schema="dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint PK_PlaylistTrack" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="a279f558-295b-4da5-9351-03ad749062e0" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint PK_PlaylistTrack,category Columns" conversion-version="15">
                                    <column _I_D="8307b5b8-9237-4a09-9670-276589c6efca" name="playlistid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint PK_PlaylistTrack,category Columns,column PlaylistId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" mdl-applying-result="applying-success"/>
                                    <column _I_D="e153e49b-a5f0-4def-86f7-2a396cea827d" name="trackid" transformed="2024-08-26 00:08:49" ordinal-position="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint PK_PlaylistTrack,category Columns,column TrackId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="d0663cbf-5a83-43a2-9d39-2e083c61be5a" name="Indexes" order-num="2" child-type="index" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Indexes" conversion-version="15">
                            <index _I_D="386e6893-82df-49f4-a433-d9e4555ac7eb" name="ix_playlisttrack_ifk_playlisttrackplaylistid" is-unique="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Indexes,index IFK_PlaylistTrackPlaylistId" conversion-version="15" source-vendor="MSSQL" index-type="BTREE" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="f992fb09-d6ac-4d10-b31e-a0ef800ee8ac" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Indexes,index IFK_PlaylistTrackPlaylistId,category Columns" conversion-version="15">
                                    <column _I_D="899ec0f8-51c7-461a-9261-6251d4d1c3f2" name="playlistid" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Indexes,index IFK_PlaylistTrackPlaylistId,category Columns,column PlaylistId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" order-column="1" included-column="0" mdl-applying-result="applying-success"/>
                                </category>
                            </index>
                            <index _I_D="77850924-3c3c-4817-b53f-d50710ce8324" name="ix_playlisttrack_ifk_playlisttracktrackid" is-unique="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Indexes,index IFK_PlaylistTrackTrackId" conversion-version="15" source-vendor="MSSQL" index-type="BTREE" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="057b3c40-c813-4ce8-af40-0e897b1dba0d" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Indexes,index IFK_PlaylistTrackTrackId,category Columns" conversion-version="15">
                                    <column _I_D="1f8df8b7-7bb4-4567-8ed5-17d4c9063e59" name="trackid" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Indexes,index IFK_PlaylistTrackTrackId,category Columns,column TrackId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" order-column="1" included-column="0" mdl-applying-result="applying-success"/>
                                </category>
                            </index>
                        </category>
                        <category _I_D="4c0626fb-318d-4b63-80e3-2d52d518b602" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Triggers" conversion-version="15"/>
                        <category _I_D="70343610-65f8-492d-8877-1261b080fe7b" name="Partitions" order-num="4" child-type="partition" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="ab15f877-b310-40fb-80ef-9b2713103443" name="track" transformed="2024-08-26 00:08:49" partitioned="NO" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                        <category _I_D="1eecbd62-c210-4f08-a2ee-10f1cc3aee3e" name="Columns" order-num="0" child-type="column" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns" conversion-version="15">
                            <column _I_D="adbfc702-52d9-4b92-95a5-2378d01e6a16" name="trackid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column TrackId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="a8e6fcea-9bbf-405e-8f91-58db172df847" name="name" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="nvarchar" is-xml-document="N" dt-attr-1="200" character-maximum-length="400" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column Name" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="f5ff8258-780a-4bf6-8156-553d867745df" name="albumid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column AlbumId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="7d72cfe4-d262-4acf-affe-773072afffb9" name="mediatypeid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column MediaTypeId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="143e0a1b-b3ad-4957-a89d-7d9766af6d0e" name="genreid" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column GenreId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="fb65e70a-26ae-4c22-be92-535c7ea9d156" name="composer" dt-name="VARCHAR" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="nvarchar" is-xml-document="N" dt-attr-1="220" character-maximum-length="440" numeric-precision="0" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column Composer" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="403a3eb8-cf43-4c7d-87e4-d00a80fdaf18" name="milliseconds" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column Milliseconds" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="65f2b153-ba74-4b02-931a-8ec9fba4608a" name="bytes" dt-name="INTEGER" transformed="2024-08-26 00:08:49" is-nullable="Y" type-name="int" is-xml-document="N" character-maximum-length="4" numeric-precision="10" numeric-scale="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column Bytes" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="81b1bd5c-5d0a-4ef6-abf5-74ba085249b4" name="unitprice" dt-name="NUMERIC" transformed="2024-08-26 00:08:49" is-nullable="N" type-name="numeric" is-xml-document="N" dt-attr-1="10" dt-attr-2="2" character-maximum-length="9" numeric-precision="10" numeric-scale="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column UnitPrice" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="7c3c4458-f1ad-4b63-abf3-af0f70ecfab0" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints" conversion-version="15">
                            <constraint _I_D="3308f76d-dd7e-4f05-a4e0-7b0b9e727f13" name="fk_trackalbumid_1381579960" constraint-type-desc="FOREIGN KEY" transformed="2024-08-26 00:08:49" referenced-table-name="album" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" referenced-constraint-name="PK_Album" referenced-table-schema="chinook_dbo" constraint-schema="chinook_dbo" update-rule="NO ACTION" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackAlbumId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="8755b5b4-4c18-4b2b-bd16-0e99f0dfc1b7" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackAlbumId,category Columns" conversion-version="15">
                                    <column _I_D="245268e3-7bfd-4052-b525-e55fd848665d" name="albumid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackAlbumId,category Columns,column AlbumId" conversion-version="15" source-vendor="MSSQL" column-in-referenced-unique-constraint="albumid" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                            <constraint _I_D="7484c34e-50c6-4ec9-b4a1-bc0a1c32d44d" name="fk_trackgenreid_1397580017" constraint-type-desc="FOREIGN KEY" transformed="2024-08-26 00:08:49" referenced-table-name="genre" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" referenced-constraint-name="PK_Genre" referenced-table-schema="chinook_dbo" constraint-schema="chinook_dbo" update-rule="NO ACTION" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackGenreId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="488f473a-59e8-4c41-8f3d-841a6360728d" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackGenreId,category Columns" conversion-version="15">
                                    <column _I_D="e065a469-cd08-4123-9bac-76f9b6b26331" name="genreid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackGenreId,category Columns,column GenreId" conversion-version="15" source-vendor="MSSQL" column-in-referenced-unique-constraint="genreid" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                            <constraint _I_D="6daa8aef-a058-4415-a47f-b00f2a80a3ba" name="fk_trackmediatypeid_1413580074" constraint-type-desc="FOREIGN KEY" transformed="2024-08-26 00:08:49" referenced-table-name="mediatype" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" referenced-constraint-name="PK_MediaType" referenced-table-schema="chinook_dbo" constraint-schema="chinook_dbo" update-rule="NO ACTION" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackMediaTypeId" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="b2a395f3-4e99-48e9-97d4-d5990697e885" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackMediaTypeId,category Columns" conversion-version="15">
                                    <column _I_D="998f0155-2f9c-491c-9abc-e8ff9fc60680" name="mediatypeid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackMediaTypeId,category Columns,column MediaTypeId" conversion-version="15" source-vendor="MSSQL" column-in-referenced-unique-constraint="mediatypeid" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                            <constraint _I_D="5eb0b0e3-b63f-478f-b1e6-8456a2418dec" name="pk_track_1237579447" constraint-type-desc="PRIMARY KEY" transformed="2024-08-26 00:08:49" constraint-type="PRIMARY KEY" constraint-schema="dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint PK_Track" conversion-version="15" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="827e72ba-3700-47a1-82ae-457bae70c9b4" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint PK_Track,category Columns" conversion-version="15">
                                    <column _I_D="98a302c2-c3ce-41be-a0ab-400f32152b40" name="trackid" transformed="2024-08-26 00:08:49" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint PK_Track,category Columns,column TrackId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="7faaffe9-037a-4632-b512-3db1d78e9c35" name="Indexes" order-num="2" child-type="index" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes" conversion-version="15">
                            <index _I_D="52627b4f-4649-415d-8327-b63ac57e7f66" name="ix_track_ifk_trackalbumid" is-unique="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackAlbumId" conversion-version="15" source-vendor="MSSQL" index-type="BTREE" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="e447da81-df46-4132-b52c-e0c886a42f79" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackAlbumId,category Columns" conversion-version="15">
                                    <column _I_D="134eeb58-0ca6-450d-85a1-2f70595f5460" name="albumid" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackAlbumId,category Columns,column AlbumId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" order-column="1" included-column="0" mdl-applying-result="applying-success"/>
                                </category>
                            </index>
                            <index _I_D="7ce5b1d0-845d-453f-bffa-d48b43e9a37b" name="ix_track_ifk_trackgenreid" is-unique="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackGenreId" conversion-version="15" source-vendor="MSSQL" index-type="BTREE" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="71874fab-c4ad-4147-bec3-fba51e54010c" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackGenreId,category Columns" conversion-version="15">
                                    <column _I_D="e4899501-edf1-4718-95e7-c7b0d5eb0475" name="genreid" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackGenreId,category Columns,column GenreId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" order-column="1" included-column="0" mdl-applying-result="applying-success"/>
                                </category>
                            </index>
                            <index _I_D="5c47864f-5bb5-472b-86f0-933996d80062" name="ix_track_ifk_trackmediatypeid" is-unique="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackMediaTypeId" conversion-version="15" source-vendor="MSSQL" index-type="BTREE" mdl-applying-result="applying-success" mdl-applied="2024-08-26 00:11:31">
                                <category _I_D="4c15496e-946c-472c-90a1-025aa7614f18" name="Columns" order-num="0" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackMediaTypeId,category Columns" conversion-version="15">
                                    <column _I_D="4fd97385-9cbb-4a1d-9585-0da87744d80b" name="mediatypeid" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackMediaTypeId,category Columns,column MediaTypeId" conversion-version="15" source-vendor="MSSQL" descasc="ASC" order-column="1" included-column="0" mdl-applying-result="applying-success"/>
                                </category>
                            </index>
                        </category>
                        <category _I_D="1b90a79f-ac88-4f29-92a4-d18fa415c361" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Triggers" conversion-version="15"/>
                        <category _I_D="dcfb171d-0644-48bc-9c63-8a23591dc150" name="Partitions" order-num="4" child-type="partition" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Partitions" conversion-version="15"/>
                    </table>
                </category>
                <category _I_D="454b6ff0-dd47-4a13-b3dd-eb05109833c5" name="Views" order-num="3" child-type="view" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Views" conversion-version="15"/>
                <category _I_D="3e42b56c-3b81-4f72-b378-c0e47766391e" name="Procedures" order-num="4" child-type="procedure" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Procedures" conversion-version="15"/>
                <category _I_D="46fbf7ba-7b9a-4da1-a616-f6114af54df5" name="Functions" order-num="5" child-type="function" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category SQL scalar functions" conversion-version="15"/>
                <category _I_D="129b356f-eb00-4ef5-b9c6-1885492cb3db" name="Sequences" order-num="10" child-type="sequence" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Sequences" conversion-version="15"/>
                <category _I_D="e8c8464b-6e6f-45b1-ad2d-c847b49183a7" name="Domains" order-num="11" child-type="domain" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Types" conversion-version="15"/>
                <category _I_D="c5b704a5-a991-46be-be33-adb8eb310f09" name="User defined types" order-num="12" child-type="table-type" transformed="2024-08-26 00:08:49" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Table types" conversion-version="15"/>
            </schema>
        </category>
        <category _I_D="26bc89be-01b2-4bcc-a295-0dfd6d5ed6cc" name="Foreign Servers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="foreign-server"/>
        <category-group _I_D="2d553589-8d45-4eb5-87cf-8342cdeab843" name="Server Level Objects" order-num="2" objects-loading="empty" subcategories-loading="full">
            <category _I_D="880bfcd0-6098-47e4-b908-f98a5fb40ada" name="Contexts" order-num="0" objects-loading="empty" subcategories-loading="full" child-type="context"/>
        </category-group>
        <category _I_D="82bcd8fb-2a19-4ac6-b6ad-22f3fdca7851" name="SQL Scripts" script-root="true" disable-autocommit="true" data-format="DD-MON-RR" sql-plus-settings="{&quot;tnsAliases&quot;:[]}"/>
    </metadata>
</tree>