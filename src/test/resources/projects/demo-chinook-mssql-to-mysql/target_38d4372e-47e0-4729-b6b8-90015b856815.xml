<?xml version="1.0" encoding="UTF-8"?>
<tree>
    <complex-attributes>
        <type name="view">
            <attr name="sql"></attr>
        </type>
        <type name="function">
            <attr name="comment"></attr>
            <attr name="sql"></attr>
        </type>
        <type name="trigger">
            <attr name="sql"></attr>
        </type>
        <type name="procedure">
            <attr name="comment"></attr>
            <attr name="sql"></attr>
        </type>
    </complex-attributes>
    <metadata _I_D="147dbe72-637c-4112-beca-c98143e4043f" vendor="MYSQL" name="Chinook (MySQL)" metaStorageUuid="38d4372e-47e0-4729-b6b8-90015b856815" nonquoted-case="specified" allow-similarly-named-objects="y" quoted-case="specified" connection-data="root@192.168.0.5:3306" product-version="9.0.1.0" vendor-engine-version="9.0.1" mdl-waiting-complex-attributes="" connection-identifier="51b549d2adc9 3306" vendor-engine="MySQL Community Server - GPL 9.0.1" max-identifier-length="64">
        <category _I_D="a0a76b8f-f322-40f1-8094-bbed44292408" name="Schemas" order-num="0" objects-loading="extended" subcategories-loading="none" child-type="schema">
            <schema _I_D="986a61a8-f394-4d14-a22b-56e609dc4bff" name="aws_oracle_ext" is-empty="N" context="aws_oracle_ext" subcategories-loading="none" object-loading="extended" is-system="N" default-character-set-name="utf8mb4" default-collation="utf8mb4_0900_ai_ci" bytelen="4">
                <category _I_D="08a2df11-5c55-41c9-8f7b-1b65f8dfb81c" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="e69778be-5d90-4e37-98c3-53951da8aa40" name="Views" order-num="1" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="56b77b90-3794-4810-97fc-9c8beb06e5c3" name="Procedures" order-num="2" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="fe4ec9ae-c839-4513-aa74-046ec0ce005d" name="Functions" order-num="3" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="a4580727-7799-4aed-bdd4-13dd691f0ac9" name="Events" order-num="4" objects-loading="none" subcategories-loading="none" child-type="event"/>
            </schema>
            <schema _I_D="46c7132a-a7a6-48f0-80f4-31b51cf7ad07" name="aws_sqlserver_ext" is-empty="N" context="aws_sqlserver_ext" subcategories-loading="none" object-loading="extended" is-system="N" default-character-set-name="utf8mb4" default-collation="utf8mb4_0900_ai_ci" bytelen="4">
                <category _I_D="91bf24a4-6bfd-4f38-bb0e-56074a824f3a" name="Tables" order-num="0" objects-loading="extended" subcategories-loading="none" child-type="table">
                    <table _I_D="5fd3636c-2061-47d5-a14b-6c63c1914eff" name="sys_languages" context="sys_languages" subcategories-loading="none" object-loading="extended" comment="This table contains complete info about languages present in the instance of MS SQL Server." engine="InnoDB" collation="utf8mb4_0900_ai_ci" row-format="Dynamic" create-options="">
                        <category _I_D="8363c302-ad0c-4259-a336-2db314119f7a" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="a4078e45-8c78-4975-adc3-db87a9268165" name="Constraints" order-num="1" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="3"/>
                        <category _I_D="d056e859-193f-4b64-b99a-70e9f014241e" name="Indexes" order-num="2" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="1021a257-72d4-46b6-9a73-e4c169da115d" name="Triggers" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="2712d85f-a601-49f0-86c6-c1933c67f934" name="Partitions" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="d5880bea-de80-41fe-a53c-03f561d9429a" name="sysjobhistory" context="sysjobhistory" subcategories-loading="none" object-loading="extended" comment="" engine="InnoDB" collation="utf8mb3_general_ci" row-format="Dynamic" create-options="" auto-increment="1">
                        <category _I_D="11705a7c-934d-4672-9187-24d1b0e5d82d" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="1596a96d-cc14-49ab-9ce3-bbfcd4c3fcb2" name="Constraints" order-num="1" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="f864d35d-62e2-4956-aae4-589025f76578" name="Indexes" order-num="2" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="9eedfea3-ca3f-4449-a134-a05cd6eb0d0f" name="Triggers" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="8f8d7c77-0928-4326-8f81-bd153107fa66" name="Partitions" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="f339b325-9a87-4450-a611-358f3a2863f8" name="sysjobs" context="sysjobs" subcategories-loading="none" object-loading="extended" comment="" engine="InnoDB" collation="utf8mb3_general_ci" row-format="Dynamic" create-options="" auto-increment="1">
                        <category _I_D="2853c42a-b3f6-4a26-a5b0-b238f879e061" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="b6d2978a-efe5-498b-baa6-74f62587d210" name="Constraints" order-num="1" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="f6de75d6-7850-4d8e-b87b-c837a3dd8621" name="Indexes" order-num="2" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="f6bffba0-2233-4c62-a418-3e7271096444" name="Triggers" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="b6703e39-0977-44ba-b16d-f9c313ecd5f9" name="Partitions" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="969f25e6-386b-492b-a6ee-60a949410705" name="sysjobschedules" context="sysjobschedules" subcategories-loading="none" object-loading="extended" comment="" engine="InnoDB" collation="utf8mb3_general_ci" row-format="Dynamic" create-options="">
                        <category _I_D="a3cc2f3e-c91e-43f7-a3fa-97b7551511dd" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="a35c1186-81b8-4fab-8795-399fbfd162f7" name="Constraints" order-num="1" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="7ec12367-1617-45a4-87d5-cbe77f53f91b" name="Indexes" order-num="2" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="32759d24-5daa-4e95-961d-82890b08beff" name="Triggers" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="e24e6534-4daa-4775-a2dc-dd8af627cd58" name="Partitions" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="9593e66f-5a8d-4a50-85dd-6589aa69b695" name="sysjobsteps" context="sysjobsteps" subcategories-loading="none" object-loading="extended" comment="" engine="InnoDB" collation="utf8mb3_general_ci" row-format="Dynamic" create-options="" auto-increment="1">
                        <category _I_D="3b814d40-009c-4e34-b518-214f9554a136" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="f453921d-268e-4b34-b3b7-618432da2f01" name="Constraints" order-num="1" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="77737091-02f4-411b-960b-dc35fe975edd" name="Indexes" order-num="2" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="41111a8e-49d9-410e-ac8a-7de2661d11d7" name="Triggers" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="8bb87c72-86c0-4b7d-bd8a-cca5c00c0cca" name="Partitions" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="50bc8547-a2bb-4ac4-9ecf-cd7ca02140d3" name="sysmail_account" context="sysmail_account" subcategories-loading="none" object-loading="extended" comment="" engine="InnoDB" collation="utf8mb3_general_ci" row-format="Dynamic" create-options="" auto-increment="1">
                        <category _I_D="a08438dc-fd83-48cd-8bde-277a24354f56" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="48f317e4-a5dc-4b29-8b03-6083220ba329" name="Constraints" order-num="1" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="458c4d95-0139-4cf0-aca1-47c9f521c0d5" name="Indexes" order-num="2" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="5bfd6617-be76-4898-899f-78508019820f" name="Triggers" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="462e3688-0fc8-487f-9107-bb130faaeacb" name="Partitions" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="3b7b29ed-afa8-46f1-96f4-30ddca31c82b" name="sysmail_attachments" context="sysmail_attachments" subcategories-loading="none" object-loading="extended" comment="" engine="InnoDB" collation="utf8mb3_general_ci" row-format="Dynamic" create-options="" auto-increment="1">
                        <category _I_D="46623adf-cb2e-4679-b6b4-a184f9756cf5" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="5556636a-a765-4206-b2dd-a19933628f58" name="Constraints" order-num="1" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="e27a2fbc-7eb4-4876-9dfa-e400e586175a" name="Indexes" order-num="2" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="c32dd5fd-1bca-4cf5-9226-baa9cc02de08" name="Triggers" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="1878adbf-ae02-46d5-9d1d-a3066b0b0a94" name="Partitions" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="222f4c66-684f-45ce-96ba-5399c54fa4a4" name="sysmail_log" context="sysmail_log" subcategories-loading="none" object-loading="extended" comment="" engine="InnoDB" collation="utf8mb3_general_ci" row-format="Dynamic" create-options="" auto-increment="1">
                        <category _I_D="dc432c82-3670-4a61-b661-19bda6108f20" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="055f0ec2-69f8-492b-bb43-59b53dc8468d" name="Constraints" order-num="1" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="bb51bcc7-9de1-425a-b0fc-462e89c5f57f" name="Indexes" order-num="2" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="e4159e1d-fd0b-479c-bfe3-c8f44b0d165f" name="Triggers" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="f99f87eb-c032-4036-be82-66e70b972520" name="Partitions" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="b17a42f0-e884-41eb-9970-fb93a45cc63f" name="sysmail_mailitems" context="sysmail_mailitems" subcategories-loading="none" object-loading="extended" comment="" engine="InnoDB" collation="utf8mb3_general_ci" row-format="Dynamic" create-options="" auto-increment="1">
                        <category _I_D="e3ae1081-deaa-40f6-8697-3e59a238eb50" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="858f968f-9b77-4973-aafb-c423df9b826c" name="Constraints" order-num="1" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="a1cdb782-7f29-40ae-9810-0a426b4b2d75" name="Indexes" order-num="2" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="76bde8ac-4586-4851-b70d-861a951800be" name="Triggers" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="94a2f2d3-26a6-4be9-807b-e0afa79c0b51" name="Partitions" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="90b42dc4-5bdd-4882-914a-86456f278980" name="sysmail_profile" context="sysmail_profile" subcategories-loading="none" object-loading="extended" comment="" engine="InnoDB" collation="utf8mb3_general_ci" row-format="Dynamic" create-options="" auto-increment="1">
                        <category _I_D="4619d323-6a85-49ca-bfa2-ad267967424d" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="ca679486-3d53-4e39-8829-16b332cd49c1" name="Constraints" order-num="1" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="65d91210-5881-4b6e-b156-259a40743912" name="Indexes" order-num="2" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="eb48a454-9b64-4641-a23d-cf34dc726157" name="Triggers" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="363bfb36-6f4a-4787-844d-08fbf7f94499" name="Partitions" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="a20d50f6-e49e-43bd-a53e-74643d000d61" name="sysmail_profileaccount" context="sysmail_profileaccount" subcategories-loading="none" object-loading="extended" comment="" engine="InnoDB" collation="utf8mb3_general_ci" row-format="Dynamic" create-options="">
                        <category _I_D="1b2e790d-d8aa-467b-aca1-2a6792019574" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="fb55f80a-b07d-41b1-b2a8-1845ea690d29" name="Constraints" order-num="1" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="28bf9d08-a06c-4a98-aa80-cebc1c265cae" name="Indexes" order-num="2" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="0f075261-9af0-4361-bf10-1478950858a3" name="Triggers" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="b881fb86-4c29-456b-8437-1878a57e9466" name="Partitions" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="3a65d384-e19b-4577-833b-e8a13c9ab5fc" name="sysschedules" context="sysschedules" subcategories-loading="none" object-loading="extended" comment="" engine="InnoDB" collation="utf8mb3_general_ci" row-format="Dynamic" create-options="" auto-increment="1">
                        <category _I_D="22454dc9-bf14-4ddb-9ff2-a53b577d71f5" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="0ada3324-a822-4983-bd25-9cd2a9a04ab7" name="Constraints" order-num="1" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="642cac5c-ae7a-482a-bd44-ad71b0c9ca15" name="Indexes" order-num="2" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="9515bebd-28c9-4a54-9037-6d4795c8064d" name="Triggers" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="6679863d-97a4-4da8-a304-db1821d1658d" name="Partitions" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="9ef0a739-13d0-416b-8902-12c70f6624a8" name="versions" context="versions" subcategories-loading="none" object-loading="extended" comment="" engine="InnoDB" collation="utf8mb4_0900_ai_ci" row-format="Dynamic" create-options="">
                        <category _I_D="fbaa2881-be01-4210-b8dc-1ab24f3f1df7" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="859decb3-7bea-4945-b8cc-750110dbb496" name="Constraints" order-num="1" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="8b64ad5b-4386-49a7-a044-ee3e6e6cc82b" name="Indexes" order-num="2" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="e805fd7a-7dc8-41a7-a82c-ffcfd171fb53" name="Triggers" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="44c6824a-0e48-427a-bf72-d09428759b97" name="Partitions" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                </category>
                <category _I_D="2a999734-59a5-48b3-b69d-0af1126f126d" name="Views" order-num="1" objects-loading="extended" subcategories-loading="none" child-type="view">
                    <view _I_D="6358a69b-1685-43f1-9b06-86e6c2a93344" name="INFORMATION_SCHEMA_COLUMNS" context="INFORMATION_SCHEMA_COLUMNS" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `information_schema`.`c`.`TABLE_CATALOG` AS `TABLE_CATALOG`,`information_schema`.`c`.`TABLE_SCHEMA` AS `TABLE_SCHEMA`,`information_schema`.`c`.`TABLE_NAME` AS `TABLE_NAME`,`information_schema`.`c`.`COLUMN_NAME` AS `COLUMN_NAME`,`information_schema`.`c`.`ORDINAL_POSITION` AS `ORDINAL_POSITION`,NULL AS `COLUMN_DEFAULT`,`information_schema`.`c`.`IS_NULLABLE` AS `IS_NULLABLE`,`information_schema`.`c`.`DATA_TYPE` AS `DATA_TYPE`,`information_schema`.`c`.`CHARACTER_MAXIMUM_LENGTH` AS `CHARACTER_MAXIMUM_LENGTH`,`information_schema`.`c`.`CHARACTER_OCTET_LENGTH` AS `CHARACTER_OCTET_LENGTH`,`information_schema`.`c`.`NUMERIC_PRECISION` AS `NUMERIC_PRECISION`,(case when (`information_schema`.`c`.`NUMERIC_PRECISION` is not null) then 10 else NULL end) AS `NUMERIC_PRECISION_RADIX`,`information_schema`.`c`.`NUMERIC_SCALE` AS `NUMERIC_SCALE`,NULL AS `DATETIME_PRECISION`,NULL AS `CHARACTER_SET_CATALOG`,NULL AS `CHARACTER_SET_SCHEMA`,`information_schema`.`c`.`CHARACTER_SET_NAME` AS `CHARACTER_SET_NAME`,NULL AS `COLLATION_CATALOG`,NULL AS `COLLATION_SCHEMA`,`information_schema`.`c`.`COLLATION_NAME` AS `COLLATION_NAME`,NULL AS `DOMAIN_CATALOG`,NULL AS `DOMAIN_SCHEMA`,NULL AS `DOMAIN_NAME` from `information_schema`.`COLUMNS` `c`]]></complex-attribute>
                        <category _I_D="5f84b1e6-0636-4b65-a823-92057c9b9165" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                    <view _I_D="da680eab-c322-477f-9234-91a50d8a97ae" name="INFORMATION_SCHEMA_CONSTRAINT_TABLE_USAGE" context="INFORMATION_SCHEMA_CONSTRAINT_TABLE_USAGE" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `information_schema`.`tc`.`CONSTRAINT_CATALOG` AS `TABLE_CATALOG`,`information_schema`.`tc`.`TABLE_SCHEMA` AS `TABLE_SCHEMA`,`information_schema`.`tc`.`TABLE_NAME` AS `TABLE_NAME`,`information_schema`.`tc`.`CONSTRAINT_CATALOG` AS `CONSTRAINT_CATALOG`,`information_schema`.`tc`.`CONSTRAINT_SCHEMA` AS `CONSTRAINT_SCHEMA`,`information_schema`.`tc`.`CONSTRAINT_NAME` AS `CONSTRAINT_NAME` from `information_schema`.`TABLE_CONSTRAINTS` `tc`]]></complex-attribute>
                        <category _I_D="57597290-c031-4ba0-a5d0-f44c87195001" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                    <view _I_D="c870ba23-b305-4225-9ba8-e1f60ebdf41c" name="INFORMATION_SCHEMA_KEY_COLUMN_USAGE" context="INFORMATION_SCHEMA_KEY_COLUMN_USAGE" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `information_schema`.`kcu`.`CONSTRAINT_CATALOG` AS `CONSTRAINT_CATALOG`,`information_schema`.`kcu`.`CONSTRAINT_SCHEMA` AS `CONSTRAINT_SCHEMA`,`information_schema`.`kcu`.`CONSTRAINT_NAME` AS `CONSTRAINT_NAME`,`information_schema`.`kcu`.`TABLE_CATALOG` AS `TABLE_CATALOG`,`information_schema`.`kcu`.`TABLE_SCHEMA` AS `TABLE_SCHEMA`,`information_schema`.`kcu`.`TABLE_NAME` AS `TABLE_NAME`,`information_schema`.`kcu`.`COLUMN_NAME` AS `COLUMN_NAME`,`information_schema`.`kcu`.`ORDINAL_POSITION` AS `ORDINAL_POSITION` from `information_schema`.`KEY_COLUMN_USAGE` `kcu`]]></complex-attribute>
                        <category _I_D="163bd6d7-1b39-4420-ad61-31dafc82b07d" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                    <view _I_D="70a2f72f-aa9b-463c-945f-0975d3c6c8d2" name="INFORMATION_SCHEMA_PARAMETERS" context="INFORMATION_SCHEMA_PARAMETERS" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `information_schema`.`p`.`SPECIFIC_CATALOG` AS `SPECIFIC_CATALOG`,`information_schema`.`p`.`SPECIFIC_SCHEMA` AS `SPECIFIC_SCHEMA`,`information_schema`.`p`.`SPECIFIC_NAME` AS `SPECIFIC_NAME`,`information_schema`.`p`.`ORDINAL_POSITION` AS `ORDINAL_POSITION`,`information_schema`.`p`.`PARAMETER_MODE` AS `PARAMETER_MODE`,(case when (`information_schema`.`p`.`ROUTINE_TYPE` = 'FUNCTION') then 'YES' else 'NO' end) AS `IS_RESULT`,'NO' AS `AS_LOCATOR`,`information_schema`.`p`.`PARAMETER_NAME` AS `PARAMETER_NAME`,`information_schema`.`p`.`DATA_TYPE` AS `DATA_TYPE`,`information_schema`.`p`.`CHARACTER_MAXIMUM_LENGTH` AS `CHARACTER_MAXIMUM_LENGTH`,`information_schema`.`p`.`CHARACTER_OCTET_LENGTH` AS `CHARACTER_OCTET_LENGTH`,NULL AS `COLLATION_CATALOG`,NULL AS `COLLATION_SCHEMA`,`information_schema`.`p`.`COLLATION_NAME` AS `COLLATION_NAME`,NULL AS `CHARACTER_SET_CATALOG`,NULL AS `CHARACTER_SET_SCHEMA`,`information_schema`.`p`.`COLLATION_NAME` AS `CHARACTER_SET_NAME`,`information_schema`.`p`.`NUMERIC_PRECISION` AS `NUMERIC_PRECISION`,(case when (`information_schema`.`p`.`NUMERIC_PRECISION` is not null) then 10 else NULL end) AS `NUMERIC_PRECISION_RADIX`,`information_schema`.`p`.`NUMERIC_SCALE` AS `NUMERIC_SCALE`,NULL AS `DATETIME_PRECISION`,NULL AS `INTERVAL_TYPE`,NULL AS `INTERVAL_PRECISION`,NULL AS `USER_DEFINED_TYPE_CATALOG`,NULL AS `USER_DEFINED_TYPE_SCHEMA`,NULL AS `USER_DEFINED_TYPE_NAME`,NULL AS `SCOPE_CATALOG`,NULL AS `SCOPE_SCHEMA`,NULL AS `SCOPE_NAME` from `information_schema`.`PARAMETERS` `p`]]></complex-attribute>
                        <category _I_D="b96dad38-9c9a-49c6-a814-bc54eed13457" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                    <view _I_D="5b3d555c-55c0-4872-bf79-3ce32378e221" name="INFORMATION_SCHEMA_REFERENTIAL_CONSTRAINTS" context="INFORMATION_SCHEMA_REFERENTIAL_CONSTRAINTS" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `information_schema`.`rc`.`CONSTRAINT_CATALOG` AS `CONSTRAINT_CATALOG`,`information_schema`.`rc`.`CONSTRAINT_SCHEMA` AS `CONSTRAINT_SCHEMA`,`information_schema`.`rc`.`CONSTRAINT_NAME` AS `CONSTRAINT_NAME`,`information_schema`.`rc`.`UNIQUE_CONSTRAINT_CATALOG` AS `UNIQUE_CONSTRAINT_CATALOG`,`information_schema`.`rc`.`UNIQUE_CONSTRAINT_SCHEMA` AS `UNIQUE_CONSTRAINT_SCHEMA`,`information_schema`.`rc`.`UNIQUE_CONSTRAINT_NAME` AS `UNIQUE_CONSTRAINT_NAME`,`information_schema`.`rc`.`MATCH_OPTION` AS `MATCH_OPTION`,`information_schema`.`rc`.`UPDATE_RULE` AS `UPDATE_RULE`,`information_schema`.`rc`.`DELETE_RULE` AS `DELETE_RULE` from `information_schema`.`REFERENTIAL_CONSTRAINTS` `rc`]]></complex-attribute>
                        <category _I_D="f714d324-52fc-46f4-bc1b-ff0c8478a83e" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                    <view _I_D="22e83908-176d-42b7-81fc-f045c5be59f6" name="INFORMATION_SCHEMA_ROUTINES" context="INFORMATION_SCHEMA_ROUTINES" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `information_schema`.`r`.`ROUTINE_SCHEMA` AS `SPECIFIC_CATALOG`,`information_schema`.`r`.`ROUTINE_SCHEMA` AS `SPECIFIC_SCHEMA`,`information_schema`.`r`.`ROUTINE_NAME` AS `SPECIFIC_NAME`,`information_schema`.`r`.`ROUTINE_SCHEMA` AS `ROUTINE_CATALOG`,`information_schema`.`r`.`ROUTINE_SCHEMA` AS `ROUTINE_SCHEMA`,`information_schema`.`r`.`ROUTINE_NAME` AS `ROUTINE_NAME`,`information_schema`.`r`.`ROUTINE_TYPE` AS `ROUTINE_TYPE`,NULL AS `MODULE_CATALOG`,NULL AS `MODULE_SCHEMA`,NULL AS `MODULE_NAME`,NULL AS `UDT_CATALOG`,NULL AS `UDT_SCHEMA`,NULL AS `UDT_NAME`,`information_schema`.`r`.`DATA_TYPE` AS `DATA_TYPE`,`information_schema`.`r`.`CHARACTER_MAXIMUM_LENGTH` AS `CHARACTER_MAXIMUM_LENGTH`,`information_schema`.`r`.`CHARACTER_OCTET_LENGTH` AS `CHARACTER_OCTET_LENGTH`,`information_schema`.`r`.`DATABASE_COLLATION` AS `COLLATION_CATALOG`,NULL AS `COLLATION_SCHEMA`,`information_schema`.`r`.`COLLATION_NAME` AS `COLLATION_NAME`,NULL AS `CHARACTER_SET_CATALOG`,NULL AS `CHARACTER_SET_SCHEMA`,`information_schema`.`r`.`CHARACTER_SET_NAME` AS `CHARACTER_SET_NAME`,`information_schema`.`r`.`NUMERIC_PRECISION` AS `NUMERIC_PRECISION`,(case when (`information_schema`.`r`.`NUMERIC_PRECISION` is not null) then 10 else NULL end) AS `NUMERIC_PRECISION_RADIX`,`information_schema`.`r`.`NUMERIC_SCALE` AS `NUMERIC_SCALE`,NULL AS `DATETIME_PRECISION`,NULL AS `INTERVAL_TYPE`,NULL AS `INTERVAL_PRECISION`,NULL AS `TYPE_UDT_CATALOG`,NULL AS `TYPE_UDT_SCHEMA`,NULL AS `TYPE_UDT_NAME`,NULL AS `SCOPE_CATALOG`,NULL AS `SCOPE_SCHEMA`,NULL AS `SCOPE_NAME`,NULL AS `MAXIMUM_CARDINALITY`,NULL AS `DTD_IDENTIFIER`,`information_schema`.`r`.`ROUTINE_BODY` AS `ROUTINE_BODY`,`information_schema`.`r`.`ROUTINE_DEFINITION` AS `ROUTINE_DEFINITION`,NULL AS `EXTERNAL_NAME`,NULL AS `EXTERNAL_LANGUAGE`,NULL AS `PARAMETER_STYLE`,`information_schema`.`r`.`IS_DETERMINISTIC` AS `IS_DETERMINISTIC`,`information_schema`.`r`.`SQL_DATA_ACCESS` AS `SQL_DATA_ACCESS`,NULL AS `IS_NULL_CALL`,NULL AS `SQL_PATH`,'YES' AS `SCHEMA_LEVEL_ROUTINE`,(case when (`information_schema`.`r`.`ROUTINE_TYPE` = 'FUNCTION') then 0 else -(1) end) AS `MAX_DYNAMIC_RESULT_SETS`,'NO' AS `IS_USER_DEFINED_CAST`,'NO' AS `IS_IMPLICITLY_INVOCABLE`,`information_schema`.`r`.`CREATED` AS `CREATED`,`information_schema`.`r`.`LAST_ALTERED` AS `LAST_ALTERED` from `information_schema`.`ROUTINES` `r`]]></complex-attribute>
                        <category _I_D="8076f576-3aae-4274-8006-ad809c8e39b6" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                    <view _I_D="9cfdab12-c3b3-4109-a767-bf0562edf2d3" name="INFORMATION_SCHEMA_SCHEMATA" context="INFORMATION_SCHEMA_SCHEMATA" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `information_schema`.`s`.`CATALOG_NAME` AS `CATALOG_NAME`,`information_schema`.`s`.`SCHEMA_NAME` AS `SCHEMA_NAME`,`information_schema`.`s`.`SCHEMA_NAME` AS `SCHEMA_OWNER`,NULL AS `DEFAULT_CHARACTER_SET_CATALOG`,NULL AS `DEFAULT_CHARACTER_SET_SCHEMA`,`information_schema`.`s`.`DEFAULT_CHARACTER_SET_NAME` AS `DEFAULT_CHARACTER_SET_NAME` from `information_schema`.`SCHEMATA` `s`]]></complex-attribute>
                        <category _I_D="41b4d5f6-544c-4758-88dc-a03e67347ac8" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                    <view _I_D="bd189acf-77a6-442a-99ad-0af65acbf3c6" name="INFORMATION_SCHEMA_TABLES" context="INFORMATION_SCHEMA_TABLES" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `information_schema`.`s`.`TABLE_CATALOG` AS `TABLE_CATALOG`,`information_schema`.`s`.`TABLE_SCHEMA` AS `TABLE_SCHEMA`,`information_schema`.`s`.`TABLE_NAME` AS `TABLE_NAME`,`information_schema`.`s`.`TABLE_TYPE` AS `TABLE_TYPE` from `information_schema`.`TABLES` `s` where (`information_schema`.`s`.`TABLE_TYPE` in ('BASE TABLE','VIEW'))]]></complex-attribute>
                        <category _I_D="8c36732f-6cc7-42b0-bb19-1ac208859609" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                    <view _I_D="e92a1053-aeee-4cd3-a2db-9e5ab4eaa68b" name="INFORMATION_SCHEMA_TABLE_CONSTRAINTS" context="INFORMATION_SCHEMA_TABLE_CONSTRAINTS" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `information_schema`.`tc`.`CONSTRAINT_CATALOG` AS `CONSTRAINT_CATALOG`,`information_schema`.`tc`.`CONSTRAINT_SCHEMA` AS `CONSTRAINT_SCHEMA`,`information_schema`.`tc`.`CONSTRAINT_NAME` AS `CONSTRAINT_NAME`,`information_schema`.`tc`.`CONSTRAINT_CATALOG` AS `TABLE_CATALOG`,`information_schema`.`tc`.`TABLE_SCHEMA` AS `TABLE_SCHEMA`,`information_schema`.`tc`.`TABLE_NAME` AS `TABLE_NAME`,`information_schema`.`tc`.`CONSTRAINT_TYPE` AS `CONSTRAINT_TYPE`,'NO' AS `IS_DEFERRABLE`,'NO' AS `INITIALLY_DEFERRED` from `information_schema`.`TABLE_CONSTRAINTS` `tc`]]></complex-attribute>
                        <category _I_D="e1764008-c640-4cd9-9995-a7773506c239" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                    <view _I_D="74052aa3-be52-454a-ae16-7435744c96ca" name="INFORMATION_SCHEMA_VIEWS" context="INFORMATION_SCHEMA_VIEWS" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `information_schema`.`v`.`TABLE_CATALOG` AS `TABLE_CATALOG`,`information_schema`.`v`.`TABLE_SCHEMA` AS `TABLE_SCHEMA`,`information_schema`.`v`.`TABLE_NAME` AS `TABLE_NAME`,`information_schema`.`v`.`VIEW_DEFINITION` AS `VIEW_DEFINITION`,`information_schema`.`v`.`CHECK_OPTION` AS `CHECK_OPTION`,`information_schema`.`v`.`IS_UPDATABLE` AS `IS_UPDATABLE` from `information_schema`.`VIEWS` `v`]]></complex-attribute>
                        <category _I_D="c931d49b-d9c6-4bf5-a4cb-d2c880f9e1d3" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                    <view _I_D="6571d570-541d-451d-a03c-3bd7c9c6e02d" name="sysmail_allitems" context="sysmail_allitems" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `sa`.`mailitem_id` AS `mailitem_id`,`sa`.`profile_id` AS `profile_id`,`sa`.`recipients` AS `recipients`,`sa`.`copy_recipients` AS `copy_recipients`,`sa`.`blind_copy_recipients` AS `blind_copy_recipients`,`sa`.`subject` AS `subject`,`sa`.`body` AS `body`,`sa`.`body_format` AS `body_format`,`sa`.`importance` AS `importance`,`sa`.`sensitivity` AS `sensitivity`,`sa`.`file_attachments` AS `file_attachments`,`sa`.`attachment_encoding` AS `attachment_encoding`,`sa`.`query` AS `query`,`sa`.`execute_query_database` AS `execute_query_database`,`sa`.`attach_query_result_as_file` AS `attach_query_result_as_file`,`sa`.`query_result_header` AS `query_result_header`,`sa`.`query_result_width` AS `query_result_width`,`sa`.`query_result_separator` AS `query_result_separator`,`sa`.`exclude_query_output` AS `exclude_query_output`,`sa`.`append_query_error` AS `append_query_error`,`sa`.`sent_account_id` AS `sent_account_id`,(case `sa`.`sent_status` when 0 then 'unsent' when 1 then 'sent' when 3 then 'retrying' else 'failed' end) AS `sent_status`,`sa`.`sent_date` AS `sent_date` from `aws_sqlserver_ext`.`sysmail_mailitems` `sa`]]></complex-attribute>
                        <category _I_D="817226e6-83ca-4f3b-a1d5-b71f77ca40f9" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                    <view _I_D="8a3cba89-bfca-40f7-9ec5-80772424a36d" name="sysmail_faileditems" context="sysmail_faileditems" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `aws_sqlserver_ext`.`sa`.`mailitem_id` AS `mailitem_id`,`aws_sqlserver_ext`.`sa`.`profile_id` AS `profile_id`,`aws_sqlserver_ext`.`sa`.`recipients` AS `recipients`,`aws_sqlserver_ext`.`sa`.`copy_recipients` AS `copy_recipients`,`aws_sqlserver_ext`.`sa`.`blind_copy_recipients` AS `blind_copy_recipients`,`aws_sqlserver_ext`.`sa`.`subject` AS `subject`,`aws_sqlserver_ext`.`sa`.`body` AS `body`,`aws_sqlserver_ext`.`sa`.`body_format` AS `body_format`,`aws_sqlserver_ext`.`sa`.`importance` AS `importance`,`aws_sqlserver_ext`.`sa`.`sensitivity` AS `sensitivity`,`aws_sqlserver_ext`.`sa`.`file_attachments` AS `file_attachments`,`aws_sqlserver_ext`.`sa`.`attachment_encoding` AS `attachment_encoding`,`aws_sqlserver_ext`.`sa`.`query` AS `query`,`aws_sqlserver_ext`.`sa`.`execute_query_database` AS `execute_query_database`,`aws_sqlserver_ext`.`sa`.`attach_query_result_as_file` AS `attach_query_result_as_file`,`aws_sqlserver_ext`.`sa`.`query_result_header` AS `query_result_header`,`aws_sqlserver_ext`.`sa`.`query_result_width` AS `query_result_width`,`aws_sqlserver_ext`.`sa`.`query_result_separator` AS `query_result_separator`,`aws_sqlserver_ext`.`sa`.`exclude_query_output` AS `exclude_query_output`,`aws_sqlserver_ext`.`sa`.`append_query_error` AS `append_query_error`,`aws_sqlserver_ext`.`sa`.`sent_account_id` AS `sent_account_id`,`aws_sqlserver_ext`.`sa`.`sent_status` AS `sent_status`,`aws_sqlserver_ext`.`sa`.`sent_date` AS `sent_date` from `aws_sqlserver_ext`.`sysmail_allitems` `sa` where (`aws_sqlserver_ext`.`sa`.`sent_status` = 'failed')]]></complex-attribute>
                        <category _I_D="45bd5fb1-9ac5-409d-afba-504c0213205e" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                    <view _I_D="b9cb28b5-0266-4629-b83a-9bcbcebc1c5a" name="sysmail_mailattachments" context="sysmail_mailattachments" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `sa`.`attachment_id` AS `attachment_id`,`sa`.`mailitem_id` AS `mailitem_id`,`sa`.`filename` AS `filename`,`sa`.`filesize` AS `filesize`,`sa`.`attachment` AS `attachment` from (`aws_sqlserver_ext`.`sysmail_attachments` `sa` join `aws_sqlserver_ext`.`sysmail_mailitems` `sm` on((`sa`.`mailitem_id` = `sm`.`mailitem_id`)))]]></complex-attribute>
                        <category _I_D="16865e80-4795-4e35-8a2e-0dc902f4efa6" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                    <view _I_D="ddb5bc34-0b94-4bdd-a0b9-4774804a8f85" name="sysmail_sentitems" context="sysmail_sentitems" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `aws_sqlserver_ext`.`sa`.`mailitem_id` AS `mailitem_id`,`aws_sqlserver_ext`.`sa`.`profile_id` AS `profile_id`,`aws_sqlserver_ext`.`sa`.`recipients` AS `recipients`,`aws_sqlserver_ext`.`sa`.`copy_recipients` AS `copy_recipients`,`aws_sqlserver_ext`.`sa`.`blind_copy_recipients` AS `blind_copy_recipients`,`aws_sqlserver_ext`.`sa`.`subject` AS `subject`,`aws_sqlserver_ext`.`sa`.`body` AS `body`,`aws_sqlserver_ext`.`sa`.`body_format` AS `body_format`,`aws_sqlserver_ext`.`sa`.`importance` AS `importance`,`aws_sqlserver_ext`.`sa`.`sensitivity` AS `sensitivity`,`aws_sqlserver_ext`.`sa`.`file_attachments` AS `file_attachments`,`aws_sqlserver_ext`.`sa`.`attachment_encoding` AS `attachment_encoding`,`aws_sqlserver_ext`.`sa`.`query` AS `query`,`aws_sqlserver_ext`.`sa`.`execute_query_database` AS `execute_query_database`,`aws_sqlserver_ext`.`sa`.`attach_query_result_as_file` AS `attach_query_result_as_file`,`aws_sqlserver_ext`.`sa`.`query_result_header` AS `query_result_header`,`aws_sqlserver_ext`.`sa`.`query_result_width` AS `query_result_width`,`aws_sqlserver_ext`.`sa`.`query_result_separator` AS `query_result_separator`,`aws_sqlserver_ext`.`sa`.`exclude_query_output` AS `exclude_query_output`,`aws_sqlserver_ext`.`sa`.`append_query_error` AS `append_query_error`,`aws_sqlserver_ext`.`sa`.`sent_account_id` AS `sent_account_id`,`aws_sqlserver_ext`.`sa`.`sent_status` AS `sent_status`,`aws_sqlserver_ext`.`sa`.`sent_date` AS `sent_date` from `aws_sqlserver_ext`.`sysmail_allitems` `sa` where (`aws_sqlserver_ext`.`sa`.`sent_status` = 'sent')]]></complex-attribute>
                        <category _I_D="f55669bb-117e-4291-b841-75318d945596" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                    <view _I_D="2502d35f-e11c-4ac5-8a07-1d509bb845b5" name="sysmail_unsentitems" context="sysmail_unsentitems" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" definer="root@%" security-type="DEFINER">
                        <complex-attribute name="sql"><![CDATA[select `aws_sqlserver_ext`.`sa`.`mailitem_id` AS `mailitem_id`,`aws_sqlserver_ext`.`sa`.`profile_id` AS `profile_id`,`aws_sqlserver_ext`.`sa`.`recipients` AS `recipients`,`aws_sqlserver_ext`.`sa`.`copy_recipients` AS `copy_recipients`,`aws_sqlserver_ext`.`sa`.`blind_copy_recipients` AS `blind_copy_recipients`,`aws_sqlserver_ext`.`sa`.`subject` AS `subject`,`aws_sqlserver_ext`.`sa`.`body` AS `body`,`aws_sqlserver_ext`.`sa`.`body_format` AS `body_format`,`aws_sqlserver_ext`.`sa`.`importance` AS `importance`,`aws_sqlserver_ext`.`sa`.`sensitivity` AS `sensitivity`,`aws_sqlserver_ext`.`sa`.`file_attachments` AS `file_attachments`,`aws_sqlserver_ext`.`sa`.`attachment_encoding` AS `attachment_encoding`,`aws_sqlserver_ext`.`sa`.`query` AS `query`,`aws_sqlserver_ext`.`sa`.`execute_query_database` AS `execute_query_database`,`aws_sqlserver_ext`.`sa`.`attach_query_result_as_file` AS `attach_query_result_as_file`,`aws_sqlserver_ext`.`sa`.`query_result_header` AS `query_result_header`,`aws_sqlserver_ext`.`sa`.`query_result_width` AS `query_result_width`,`aws_sqlserver_ext`.`sa`.`query_result_separator` AS `query_result_separator`,`aws_sqlserver_ext`.`sa`.`exclude_query_output` AS `exclude_query_output`,`aws_sqlserver_ext`.`sa`.`append_query_error` AS `append_query_error`,`aws_sqlserver_ext`.`sa`.`sent_account_id` AS `sent_account_id`,`aws_sqlserver_ext`.`sa`.`sent_status` AS `sent_status`,`aws_sqlserver_ext`.`sa`.`sent_date` AS `sent_date` from `aws_sqlserver_ext`.`sysmail_allitems` `sa` where ((`aws_sqlserver_ext`.`sa`.`sent_status` = 'unsent') or (`aws_sqlserver_ext`.`sa`.`sent_status` = 'retrying'))]]></complex-attribute>
                        <category _I_D="246e6753-0edc-40bb-ac6b-624fde391528" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                    </view>
                </category>
                <category _I_D="d2654436-a8b9-4b4f-9537-bc5d178498df" name="Procedures" order-num="2" objects-loading="extended" subcategories-loading="none" child-type="procedure">
                    <procedure _I_D="ef8081a3-33a2-4f26-8ccf-cdbaf49d0660" name="FOR_XML" context="FOR_XML" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[block: BEGIN
  SET SESSION group_concat_max_len = 1073741824;
  SET @int_table_name = CONCAT('T_',REPLACE(UUID(), '-', ''));

  IF row_name = '' THEN
    SET @t_row_name = 'row';
  ELSE
    SET @t_row_name = row_name;
  END IF;

  IF root_name <> '' THEN
    SET @row_indent = '  ';
    SET @element_indent = '    ';
  ELSE
    SET @row_indent = '';
    SET @element_indent = '  ';
  END IF;

  SET @a = CONCAT('CREATE TABLE ', @int_table_name, ' ENGINE=InnoDB AS SELECT * FROM ', CONCAT(database_name,'.',table_name),' WHERE 1=0');
  PREPARE stmt FROM @a;
  EXECUTE stmt;

  SET @cols_element_centric = 'CONCAT_WS('','CONCAT_WS(\'\',\'$row_indent$<$row_name$>\n\',',GROUP_CONCAT('\'$element_indent$<',column_name,'>\',',column_name,',\'</',column_name,'>\n\''),',','\'$row_indent$</$row_name$>\')')';
  SET @cols_element = 'CONCAT_WS('','CONCAT_WS(\'\',\'$row_indent$<$row_name$ \',',GROUP_CONCAT('\'',column_name,'="\',',column_name,',\'" \''),',','\' />\')')';
  SET @from_element = CONCAT('INTO @columns FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name = '',@int_table_name,'' AND table_schema = schema() ORDER BY ordinal_position');

  /* &lt; row &gt; */

  IF xml_mode = 'RAW' OR xml_mode = 'AUTO' THEN
    IF is_element_centric = 1 THEN
      SET @meta_query = CONCAT('SELECT ', @cols_element_centric, @from_element);
    ELSEIF is_element_centric = 0 THEN
      SET @meta_query = CONCAT('SELECT ', @cols_element, @from_element);
    ELSE
      SET out_xml = 'Incorrect is_element_centric option';
      LEAVE block;
    END IF;
  ELSEIF xml_mode = 'PATH' THEN
    SET @meta_query = CONCAT('SELECT ', @cols_element_centric, @from_element);
  ELSEIF xml_mode = 'EXPLICIT' THEN
    SET out_xml = 'EXPLICIT mode error';
    LEAVE block;
  ELSE
    SET out_xml = 'Incorrect mode';
    LEAVE block;
  END IF;

  SET @meta_query = REPLACE(@meta_query, '$row_indent$', @row_indent);
  SET @meta_query = REPLACE(@meta_query, '$element_indent$', @element_indent);
  SET @meta_query = REPLACE(@meta_query, '$row_name$', @t_row_name);

  PREPARE stmt FROM @meta_query;
  EXECUTE stmt;
  SET @main_query = CONCAT('SELECT GROUP_CONCAT(', @columns, ' SEPARATOR '
') INTO @tmp_xml FROM ', CONCAT(database_name,'.',table_name));
  PREPARE stmt FROM @main_query;
  EXECUTE stmt;

  IF root_name <> '' THEN
    SET out_xml = CONCAT('<',root_name,'>','
',@tmp_xml,'
','</',root_name,'>');
  ELSE
    SET out_xml = @tmp_xml;
  END IF;

  SET @drop_t = CONCAT('DROP TABLE IF EXISTS ', @int_table_name);
  PREPARE stmt FROM @drop_t;
  EXECUTE stmt;
END]]></complex-attribute>
                        <category _I_D="d96ddc86-3614-43ce-a9fa-fb7dea7adb8e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="3c86c8ca-8d3d-4255-8d72-f8a1637c54aa" name="get_jobs" context="get_jobs" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[BEGIN
  DECLARE var_job integer;
  DECLARE var_what text;
  DECLARE var_search_path varchar(255);

  SELECT js.job_step_id, js.command, ''
    INTO var_job, var_what, var_search_path 
    FROM aws_sqlserver_ext.sysjobschedules s
   INNER JOIN aws_sqlserver_ext.sysjobs j on j.job_id = s.job_id
   INNER JOIN aws_sqlserver_ext.sysjobsteps js ON js.job_id = j.job_id
   WHERE DATE_ADD(s.next_run_date, INTERVAL TIME_TO_SEC(s.next_run_time) SECOND) <= now()
     AND j.enabled = 1
   ORDER BY DATE_ADD(s.next_run_date, INTERVAL TIME_TO_SEC(s.next_run_time) SECOND) ASC
   LIMIT 1;

  IF var_job > 0
  THEN
    SELECT var_job as job, var_what as what, var_search_path as search_path;
  END IF;

  /* SELECT 1 as job, 'EXECUTE [dbo].[PROC_TEST_JOB_STEP1];' as what, '' as search_path; */
  
END]]></complex-attribute>
                        <category _I_D="cd2b35c2-928b-4baa-b010-f1652a7eb59b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="63eaf856-1319-4d2d-9b88-f4e9beb58d06" name="inc_seq_rowversion" context="inc_seq_rowversion" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[BEGIN
  DELETE FROM aws_sqlserver_ext_data.seq_rowversion;
  INSERT INTO aws_sqlserver_ext_data.seq_rowversion (seq_value) VALUES (NULL);
END]]></complex-attribute>
                        <category _I_D="0d65b0ea-5996-4f8c-9460-2e609f27801d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="0cea95f1-75c4-43e1-870f-278b7d7170b5" name="print" context="print" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[BEGIN
  DECLARE i INT;
  SET i = 0;
END]]></complex-attribute>
                        <category _I_D="7a4f6487-c337-4fe2-862c-2f2f9233510b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="51d86d32-6110-4563-b3b3-e8ba784bb508" name="sequence$create" context="sequence$create" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="comment"><![CDATA[Add sequence to storage]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
  DECLARE l_start_with DECIMAL(65);
  DECLARE l_increment_by DECIMAL(65);
  DECLARE l_max_value DECIMAL(65);
  DECLARE l_min_value DECIMAL(65);
  DECLARE l_is_cycle  TINYINT(1) ZEROFILL;

  DECLARE c_max_value DECIMAL(65);
  DECLARE c_min_value DECIMAL(65);
  SET c_max_value := 9223372036854775807;
  SET c_min_value := -9223372036854775808;

    CREATE TABLE IF NOT EXISTS aws_sqlserver_ext_data.sequences (
      name VARCHAR(60) NOT NULL COMMENT 'Unique name of Sequence',
      schema_name VARCHAR(50) NOT NULL COMMENT 'Schema name',
      start_with DECIMAL(65) NOT NULL COMMENT 'First sequence number to be generated. For ascending sequences, the default value is the minimum value of the sequence. For descending sequences, the default value is the maximum value of the sequence',
      increment_by DECIMAL(65) NOT NULL DEFAULT 1 COMMENT 'Interval between sequence numbers. Value can be any positive or negative integer, but it cannot be 0. If this value is negative, then the sequence descends. If the value is positive, then the sequence ascends',
      min_value DECIMAL(65) NOT NULL COMMENT 'Minimum value of the sequence',
      max_value DECIMAL(65) NOT NULL COMMENT 'Maximum value the sequence can generate',
      is_cycle TINYINT(1) ZEROFILL NOT NULL DEFAULT 0 COMMENT 'Indicate that the sequence continues to generate values after reaching either its maximum or minimum value. 1 - continues to generate, 0 - not continues',
      curr_val DECIMAL(65) DEFAULT NULL COMMENT 'Sequence current value',
      CONSTRAINT pk_sequences PRIMARY KEY (name,schema_name)
  )
  COMMENT='Sequences storage';
  
  /* Check of all input parameters on correctness */
  /* Check parameter "seq_max_value" and "seq_min_value" on NULLS values */
  IF seq_max_value IS NULL THEN
     SET l_max_value := c_max_value;
  ELSE 
     SET l_max_value := seq_max_value;
  END IF;
  IF seq_min_value IS NULL THEN
     SET l_min_value := c_min_value;
  ELSE
     SET l_min_value := seq_min_value;
  END IF;
  
  /*Parameter "seq_increment_by" can not be 0*/  
  IF seq_increment_by IS NULL THEN
     SET l_increment_by := 1;
  ELSEIF seq_increment_by = 0 THEN
    BEGIN
      SIGNAL SQLSTATE VALUE '45001'
      SET MESSAGE_TEXT = 'Parameter "Increment by" can't be 0 ';
    END;     
  ELSE
    SET l_increment_by := seq_increment_by;
  END IF;
  
  /*Check parameter "seq_start_with"*/  
  IF seq_start_with IS NULL AND l_increment_by > 0 THEN  
    SET l_start_with := l_min_value;
  ELSEIF seq_start_with IS NULL AND l_increment_by < 0 THEN  
    SET l_start_with := l_max_value;
  ELSEIF l_increment_by < 0 AND seq_start_with > l_max_value THEN
    BEGIN
      SIGNAL SQLSTATE VALUE '45002'
      SET MESSAGE_TEXT = 'For descending sequence "Start with" must be less than "Max value"';
    END;     
  ELSEIF l_increment_by > 0 AND seq_start_with < l_min_value THEN
    BEGIN
      SIGNAL SQLSTATE VALUE '45003'
      SET MESSAGE_TEXT = 'For ascending sequence "Start with" must be greater than "Min value"';
    END; 
  ELSE 
    SET l_start_with := seq_start_with;    
  END IF;    
  
  /*Check parameter "seq_max_value" greater than "min_value" and NULLS values*/    
  IF l_max_value < l_min_value THEN
    BEGIN
      SIGNAL SQLSTATE VALUE '45004'
      SET MESSAGE_TEXT = 'Parameter "Max Value" must be greater than "Min Value"';
    END;   
  END IF;
  /*Check parameter "seq_is_cycle" IN (0,1)*/  
  IF seq_is_cycle IS NULL THEN 
     SET l_is_cycle := 0;
  ELSEIF seq_is_cycle NOT IN (0,1) THEN
    BEGIN
      SIGNAL SQLSTATE VALUE '45005'
      SET MESSAGE_TEXT = 'Parameter "Is Cycle" must be 0(nocycle) or 1(cycle)';
    END;
  ELSE
    SET l_is_cycle := seq_is_cycle;
  END IF;
    
  INSERT IGNORE INTO aws_sqlserver_ext_data.sequences(name,schema_name,increment_by,start_with,max_value,min_value,is_cycle)
  VALUES(seq_name,seq_schema_name,l_increment_by,l_start_with,l_max_value,l_min_value,l_is_cycle);

END]]></complex-attribute>
                        <category _I_D="d3b3f233-40d9-4fce-81f0-7540caa02448" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="4c93d359-0c23-4241-9051-8d684ed4a25a" name="sequence$drop" context="sequence$drop" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="comment"><![CDATA[Drop sequence from storage]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN   
   DECLARE l_null VARCHAR(1);
   DECLARE CONTINUE HANDLER FOR 1146 SET l_null := '';
   
   DELETE FROM aws_sqlserver_ext_data.sequences
   WHERE name = seq_name AND schema_name = seq_schema_name;
END]]></complex-attribute>
                        <category _I_D="cf1a47f8-ee7f-4f27-9d8c-2f91d556e39d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="e44dcbcd-6bd3-47a5-8bec-4dfbc724fdff" name="set_service_setting" context="set_service_setting" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[begin
  insert into aws_sqlserver_ext_data.service_settings(service, setting, value)
  values( p_service, p_setting, p_value )
  on duplicate key update value = values( value );

  if p_service = 'MAIL' then
  call aws_sqlserver_ext.sysmail_set_arn_sp(p_value, @rc);
  end if;

end]]></complex-attribute>
                        <category _I_D="4c8ec880-37b4-4de6-8e7c-c38afb6385ab" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="d5ef2f36-852a-4004-b0ec-43bd8f33afb5" name="set_version" context="set_version" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[BEGIN
	
   UPDATE aws_sqlserver_ext.versions	   
      SET componentversion = pComponentVersion
    WHERE extpackcomponentname = pComponentName;
    
   IF ROW_COUNT() < 1 THEN     
     INSERT INTO aws_sqlserver_ext.versions(extpackcomponentname,componentversion)
          VALUES (pComponentName,pComponentVersion);   
   END IF;
 

END]]></complex-attribute>
                        <category _I_D="cab8fccd-9790-46c1-a204-a4984488412f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="3a5863d6-84ae-4791-8897-b226cc09dbc1" name="sp_add_job" context="sp_add_job" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_retval INT DEFAULT 0;
  DECLARE var_notify_email_operator_id INT DEFAULT 0;
  DECLARE var_notify_netsend_operator_id INT DEFAULT 0;
  DECLARE var_notify_email_operator_name VARCHAR(128);
  DECLARE var_notify_page_operator_id INT DEFAULT 0;
  DECLARE var_owner_sid CHAR (85);
  DECLARE var_originating_server_id INT DEFAULT 0;

 
  /* Remove any leading/trailing spaces from parameters (except @owner_login_name) */
  SELECT UPPER(LTRIM(RTRIM(par_originating_server))) INTO par_originating_server;
  SELECT LTRIM(RTRIM(par_job_name)) INTO par_job_name;
  SELECT LTRIM(RTRIM(par_description)) INTO par_description;
  SELECT '[Uncategorized (Local)]' INTO par_category_name;
  SELECT 0 INTO par_category_id;
  SELECT LTRIM(RTRIM(par_notify_email_operator_name)) INTO par_notify_email_operator_name;
  SELECT LTRIM(RTRIM(par_notify_netsend_operator_name)) INTO par_notify_netsend_operator_name;
  SELECT LTRIM(RTRIM(par_notify_page_operator_name)) INTO par_notify_page_operator_name;
  SELECT NULL INTO var_originating_server_id; /* Turn [nullable] empty string parameters into NULLs */
  SELECT NULL INTO par_job_id;

  IF (par_originating_server = '') 
  THEN
    SELECT NULL INTO par_originating_server;
  END IF;

  IF (par_description = '') 
  THEN
    SELECT NULL INTO par_description;
  END IF;

  IF (par_category_name = '') 
  THEN
    SELECT NULL INTO par_category_name;
  END IF;

  IF (par_notify_email_operator_name = '') 
  THEN
    SELECT NULL INTO par_notify_email_operator_name;
  END IF;

  IF (par_notify_netsend_operator_name = '') 
  THEN
    SELECT NULL INTO par_notify_netsend_operator_name;
  END IF;

  IF (par_notify_page_operator_name = '') 
  THEN
    SELECT NULL INTO par_notify_page_operator_name;
  END IF;
  
  /* Check parameters */
  CALL aws_sqlserver_ext.sp_verify_job (
      par_job_id
    , par_job_name
    , par_enabled
    , par_start_step_id
    , par_category_name
    , var_owner_sid
    , par_notify_level_eventlog
    , par_notify_level_email
    , par_notify_level_netsend
    , par_notify_level_page
    , par_notify_email_operator_name
    , par_notify_netsend_operator_name
    , par_notify_page_operator_name
    , par_delete_level
    , par_category_id
    , var_notify_email_operator_id
    , var_notify_netsend_operator_id
    , var_notify_page_operator_id
    , par_originating_server
    , var_retval
  );

  IF (var_retval <> 0) 
  THEN /* Failure */
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  SET var_notify_email_operator_name := par_notify_email_operator_name;
    
  /* Default the description (if not supplied) */
  IF (par_description IS NULL) 
  THEN
    SELECT 'No description available.' INTO par_description;
  END IF;
  
  SET var_originating_server_id := 0;
  SET var_owner_sid := '';
  /*
  IF (@job_id IS NULL) 
  BEGIN 
    Assign the GUID 
    SELECT @job_id = NEWID(); 
  END;
  */



  INSERT 
    INTO sysjobs (
         originating_server_id
       , name
       , enabled
       , description
       , start_step_id
       , category_id
       , owner_sid
       , notify_level_eventlog
       , notify_level_email
       , notify_level_netsend
       , notify_level_page
       , notify_email_operator_id
       , notify_email_operator_name
       , notify_netsend_operator_id
       , notify_page_operator_id
       , delete_level
       , version_number
     )
  VALUES (
         var_originating_server_id
       , par_job_name
       , par_enabled
       , par_description
       , par_start_step_id
       , par_category_id
       , var_owner_sid
       , par_notify_level_eventlog
       , par_notify_level_email
       , par_notify_level_netsend
       , par_notify_level_page
       , var_notify_email_operator_id
       , var_notify_email_operator_name
       , var_notify_netsend_operator_id
       , var_notify_page_operator_id
       , par_delete_level
       , 1);

  /* scope_identity(); */
  SELECT LAST_INSERT_ID() INTO par_job_id;
    
  /* Version number 1 */
  /* SELECT @retval = @@error */
  /* 0 means success */
  SET ReturnCode := var_retval;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="ed3d677e-8564-42dd-8c15-131f49373564" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="f6118e72-9929-4f6f-88b9-f802c0035a10" name="sp_add_jobschedule" context="sp_add_jobschedule" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_retval INT;
  DECLARE var_owner_login_name VARCHAR (128);
  DECLARE var_job_owner_sid CHAR (85);
  
  -- Check that we can uniquely identify the job
  CALL aws_sqlserver_ext.sp_verify_job_identifiers ('@job_name', '@job_id', par_job_name, par_job_id, 'TEST', var_job_owner_sid, var_retval);
  
  IF (var_retval <> 0) 
  THEN /* Failure */
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;  
  
  /* Add the schedule first */
  CALL aws_sqlserver_ext.sp_add_schedule (par_name, par_enabled, par_freq_type, par_freq_interval, par_freq_subday_type, par_freq_subday_interval, par_freq_relative_interval, par_freq_recurrence_factor, par_active_start_date, par_active_end_date, par_active_start_time, par_active_end_time, var_owner_login_name, par_schedule_uid, par_schedule_id, NULL, var_retval);

  IF (var_retval <> 0) 
  THEN /* Failure */
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  CALL aws_sqlserver_ext.sp_attach_schedule(par_job_id, NULL, par_schedule_id, NULL, par_automatic_post, var_retval);

  IF (var_retval <> 0) 
  THEN /* Failure */
    SET ReturnCode := (1);
    LEAVE return_label;
  END IF;

  CALL aws_sqlserver_ext.sp_aws_add_jobschedule(par_job_id, par_schedule_id, var_retval);

  IF (var_retval <> 0) THEN /* Failure */
    SET returncode := 1;
    LEAVE return_label;
  END IF;
  
  /* 0 means success */
  SET ReturnCode := var_retval;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="8d91d3bf-ee4c-4614-9da8-b92a7466061b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="f74f7c79-a59c-4267-a717-3691321080a2" name="sp_add_jobstep" context="sp_add_jobstep" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_retval INT;
  DECLARE var_max_step_id INT;
  DECLARE var_step_id INT;  
  DECLARE var_job_owner_sid CHAR (85);

  CALL aws_sqlserver_ext.sp_verify_job_identifiers ('@job_name', '@job_id', par_job_name, par_job_id, 'TEST', var_job_owner_sid, var_retval);
  
  IF (var_retval <> 0) THEN
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;  
  
  -- Default step id (if not supplied)
  IF (par_step_id IS NULL) 
  THEN
     SELECT COALESCE(MAX(step_id), 0) + 1
        INTO var_step_id
       FROM sysjobsteps
      WHERE (job_id = par_job_id);
  ELSE 
    SET var_step_id := par_step_id; 
  END IF;

  SELECT COALESCE(MAX(step_id), 0)
    INTO var_max_step_id
    FROM sysjobsteps
   WHERE (job_id = par_job_id);
   
  /* Check parameters */
  CALL aws_sqlserver_ext.sp_verify_jobstep (
       par_job_id
     , var_step_id
     , par_step_name
     , par_subsystem
     , par_command
     , par_server
     , par_on_success_action
     , par_on_success_step_id
     , par_on_fail_action
     , par_on_fail_step_id
     , par_os_run_priority
     -- , par_database_name
     -- , par_database_user_name
     , par_flags
     , par_output_file_name
     , par_proxy_id
     , var_retval
  );

  IF (var_retval <> 0) 
  THEN /* Failure */
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
    
  /* Modify database. */
  /* Update the job's version/last-modified information */
  UPDATE aws_sqlserver_ext.sysjobs
     SET version_number = version_number + 1
       /*, date_modified = GETDATE() */
   WHERE (job_id = par_job_id);
   
  /* Adjust step id's (unless the new step is being inserted at the 'end') */
  /* NOTE: We MUST do this before inserting the step. */
  IF (par_step_id <= var_max_step_id) 
  THEN
    UPDATE aws_sqlserver_ext.sysjobsteps
       SET step_id = step_id + 1
     WHERE (step_id >= par_step_id) AND (job_id = par_job_id);
     
    /* Clean up OnSuccess/OnFail references */
    UPDATE aws_sqlserver_ext.sysjobsteps
       SET on_success_step_id = on_success_step_id + 1
     WHERE (on_success_step_id >= par_step_id) AND (job_id = par_job_id);
     
    UPDATE aws_sqlserver_ext.sysjobsteps
       SET on_fail_step_id = on_fail_step_id + 1
     WHERE (on_fail_step_id >= par_step_id) AND (job_id = par_job_id);
     
    UPDATE aws_sqlserver_ext.sysjobsteps
       SET on_success_step_id = 0
         , on_success_action = 1  /* Quit With Success */
     WHERE (on_success_step_id = par_step_id) AND (job_id = par_job_id);
     
     UPDATE aws_sqlserver_ext.sysjobsteps
        SET on_fail_step_id = 0
          , on_fail_action = 2 /* Quit With Failure */
      WHERE (on_fail_step_id = par_step_id) 
        AND (job_id = par_job_id);
  END IF;
  
  SELECT uuid() INTO par_step_uid; /* NEWID() */
  
  /* Insert the step */
  INSERT 
    INTO aws_sqlserver_ext.sysjobsteps (job_id, step_id, step_name, subsystem, command, flags, additional_parameters, cmdexec_success_code, on_success_action, on_success_step_id, on_fail_action, on_fail_step_id, server, database_name, database_user_name, retry_attempts, retry_interval, os_run_priority, output_file_name, last_run_outcome, last_run_duration, last_run_retries, last_run_date, last_run_time, proxy_id, step_uid)
  VALUES (par_job_id, var_step_id, par_step_name, par_subsystem, par_command, par_flags, par_additional_parameters, par_cmdexec_success_code, par_on_success_action, par_on_success_step_id, par_on_fail_action, par_on_fail_step_id, par_server, par_database_name, par_database_user_name, par_retry_attempts, par_retry_interval, par_os_run_priority, par_output_file_name, 0, 0, 0, 0, 0, par_proxy_id, par_step_uid);
  
  SET ReturnCode := var_retval;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="b84022a3-db3a-468b-ba75-cc388c121290" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="c2e23c9b-dba8-4868-857a-ebadfdb78ca2" name="sp_add_schedule" context="sp_add_schedule" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_retval INT;
  DECLARE var_owner_sid CHAR (85);
  DECLARE var_orig_server_id INT;
  
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_schedule_name))
       , LTRIM(RTRIM(par_owner_login_name))
       , UPPER(LTRIM(RTRIM(par_originating_server)))
       , 0
    INTO par_schedule_name
       , par_owner_login_name
       , par_originating_server
       , par_schedule_id;
       
  /* Check schedule (frequency and owner) parameters */
  CALL aws_sqlserver_ext.sp_verify_schedule (
       NULL /* @schedule_id  -- schedule_id does not exist for the new schedule */
     , par_schedule_name /* @name */
     , par_enabled /* @enabled */
     , par_freq_type /* @freq_type */
     , par_freq_interval /* @freq_interval */
     , par_freq_subday_type /* @freq_subday_type */
     , par_freq_subday_interval /* @freq_subday_interval */
     , par_freq_relative_interval /* @freq_relative_interval */
     , par_freq_recurrence_factor /* @freq_recurrence_factor */
     , par_active_start_date /* @active_start_date */
     , par_active_start_time /* @active_start_time */
     , par_active_end_date /* @active_end_date */
     , par_active_end_time /* @active_end_time */
     , var_owner_sid /* @owner_sid */
     , var_retval 
  );

  IF (var_retval <> 0) 
  THEN /* Failure */
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF (par_schedule_uid IS NULL) 
  THEN /* Assign the GUID */
    SELECT 'ZZZZ' INTO par_schedule_uid; /* NEWID() */
  END IF;
  
  SET var_orig_server_id := 0;
  SET var_owner_sid := 'ZZZZ';
  
  INSERT INTO sysschedules (schedule_uid, originating_server_id, name, owner_sid, enabled, freq_type, freq_interval, freq_subday_type, freq_subday_interval, freq_relative_interval, freq_recurrence_factor, active_start_date, active_end_date, active_start_time, active_end_time)
  VALUES ( par_schedule_uid, var_orig_server_id, par_schedule_name, var_owner_sid, par_enabled, par_freq_type, par_freq_interval, par_freq_subday_type, par_freq_subday_interval, par_freq_relative_interval, par_freq_recurrence_factor, par_active_start_date, par_active_end_date, par_active_start_time, par_active_end_time);

  SELECT 0 /* @@ERROR, */, LAST_INSERT_ID()
    INTO var_retval, par_schedule_id;
    
  /* 0 means success */    
  SET ReturnCode := var_retval;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="6cdf36da-b9c3-4782-bc81-9fcde1cee8f8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="3259a79d-b665-46c3-880f-141258c91835" name="sp_attach_schedule" context="sp_attach_schedule" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_retval INT;
  DECLARE var_sched_owner_sid CHAR (85);
  DECLARE var_job_owner_sid CHAR (85);
  DECLARE var_orig_server_id INT;
  
  /* Check that we can uniquely identify the job */
  
  CALL aws_sqlserver_ext.sp_verify_job_identifiers ('@job_name', '@job_id', par_job_name, par_job_id, 'TEST', var_job_owner_sid, var_retval);

  IF (var_retval <> 0) 
  THEN /* Failure */
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
    
  /* Check that we can uniquely identify the schedule */
  CALL aws_sqlserver_ext.sp_verify_schedule_identifiers (
      '@schedule_name' /* IN par_name_of_name_parameter VARCHAR(60), */
    , '@schedule_id'   /* IN par_name_of_id_parameter VARCHAR(60), */
    , par_schedule_name    /* INOUT par_schedule_name VARCHAR(128), */
    , par_schedule_id      /* INOUT par_schedule_id INTEGER, */
    , var_sched_owner_sid  /* INOUT par_owner_sid CHAR(85), */
    , var_orig_server_id   /* INOUT par_orig_server_id INTEGER, */
    , NULL                 /* IN par_job_id_filter INTEGER, */
    , var_retval           /* OUT ReturnCode INTEGER */
  ) /* @job_id_filter */;


  IF (var_retval <> 0) 
  THEN /* Failure */
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
    
  /* If the record doesn't already exist create it */

  IF (
    NOT EXISTS (
      SELECT *
        FROM aws_sqlserver_ext.sysjobschedules
       WHERE (schedule_id = par_schedule_id) AND (job_id = par_job_id))) 
  THEN
    INSERT 
      INTO sysjobschedules (schedule_id, job_id)
    VALUES (par_schedule_id, par_job_id);
    
    SELECT 0 INTO var_retval; /* @@ERROR */
  END IF;
  
  CALL aws_sqlserver_ext.sp_set_next_run (par_job_id, par_schedule_id);

  /* 0 means success */
  SET ReturnCode := var_retval;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="b2a911f2-8008-4944-8c0f-416e0b45ce1e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="a5e8c396-dbed-4612-9323-3d3f140f6c4e" name="sp_aws_add_jobschedule" context="sp_aws_add_jobschedule" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[BEGIN

DECLARE var_retval INT;
DECLARE proc_name_mask VARCHAR(100);
DECLARE var_owner_login_name VARCHAR(128);
DECLARE var_xml TEXT DEFAULT '';
DECLARE var_cron_expression VARCHAR(50); 
DECLARE var_job_cmd VARCHAR(255); 
DECLARE lambda_arn VARCHAR(255);  
DECLARE return_message text;
DECLARE var_schedule_name VARCHAR(255);

DECLARE var_job_name VARCHAR(128);
DECLARE var_start_step_id INTEGER;
DECLARE var_notify_level_email INTEGER;
DECLARE var_notify_email_operator_id INTEGER;
DECLARE var_notify_email_operator_name VARCHAR(128);
DECLARE notify_email_sender VARCHAR(128);
DECLARE var_delete_level INTEGER;
DECLARE var_step_uid CHAR(38);

  IF (EXISTS (
      SELECT 1 
        FROM aws_sqlserver_ext.sysjobschedules
       WHERE (schedule_id = par_schedule_id) 
         AND (job_id = par_job_id))) 
  THEN
    SELECT aws_sqlserver_ext.sp_schedule_to_cron (par_job_id, par_schedule_id) 
      INTO var_cron_expression;
      
    SELECT name 
      FROM aws_sqlserver_ext.sysschedules
     WHERE schedule_id = par_schedule_id 
      INTO var_schedule_name;

    SELECT name
         , start_step_id
         , COALESCE(notify_level_email,0)
         , COALESCE(notify_email_operator_id,0)
         , COALESCE(notify_email_operator_name,'')
         , COALESCE(delete_level,0) 
      FROM aws_sqlserver_ext.sysjobs
     WHERE job_id = par_job_id
      INTO var_job_name
         , var_start_step_id 
         , var_notify_level_email 
         , var_notify_email_operator_id 
         , var_notify_email_operator_name 
         , var_delete_level;

    SELECT step_uid
      FROM aws_sqlserver_ext.sysjobsteps 
     WHERE job_id = par_job_id
       AND step_id = var_start_step_id 
      INTO var_step_uid; 

    -- proc_name_mask := 'aws_sqlserver_ext_data.sql_agent$job_%s_step_%s';
    -- var_job_cmd := format(proc_name_mask, par_job_id, '1');   
    -- SET var_job_cmd := CONCAT('call aws_sqlserver_ext.sp_jobstep_exec(',CHAR(39),var_step_uid,CHAR(39),');');
    SET var_job_cmd := 'aws_sqlserver_ext.sp_jobstep_exec';
    SET notify_email_sender := 'aws_test_email_sender@dbbest.com';

    SET var_xml := CONCAT(var_xml, '{');
    SET var_xml := CONCAT(var_xml, '"mode": "add_job",');
    SET var_xml := CONCAT(var_xml, '"parameters": {');
    SET var_xml := CONCAT(var_xml, '"vendor": "mysql",');
    SET var_xml := CONCAT(var_xml, '"job_name": "',var_schedule_name,'",');
    SET var_xml := CONCAT(var_xml, '"job_frequency": "',var_cron_expression,'",');
    SET var_xml := CONCAT(var_xml, '"job_cmd": "',var_job_cmd,'",');
    SET var_xml := CONCAT(var_xml, '"job_uid": "',var_step_uid,'",');
    SET var_xml := CONCAT(var_xml, '"notify_level_email": ',var_notify_level_email,',');
    SET var_xml := CONCAT(var_xml, '"delete_level": ',var_delete_level,',');
    SET var_xml := CONCAT(var_xml, '"uid": "',par_job_id,'",');
    SET var_xml := CONCAT(var_xml, '"callback": "aws_sqlserver_ext.sp_job_log",');
    SET var_xml := CONCAT(var_xml, '"notification": {');
    SET var_xml := CONCAT(var_xml, '"notify_email_sender": "',notify_email_sender,'",');
    SET var_xml := CONCAT(var_xml, '"notify_email_recipient": "',var_notify_email_operator_name,'"');
    SET var_xml := CONCAT(var_xml, '}');
    SET var_xml := CONCAT(var_xml, '}');
    SET var_xml := CONCAT(var_xml, '}');

    -- RAISE NOTICE '%', var_xml;

    SELECT aws_sqlserver_ext.get_service_setting ('JOB', 'LAMBDA_ARN') 
      INTO lambda_arn;

    SELECT lambda_sync(lambda_arn, var_xml) INTO return_message;

    SET returncode := 0; 
--  ELSE 
--    SET  returncode := 1;
    -- RAISE 'Job not fount' USING ERRCODE := '50000';
  END IF;

END]]></complex-attribute>
                        <category _I_D="eb420238-e9e6-454b-80f9-d5bc4f0483cd" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="50631d33-8213-48c3-9ae4-8f18a8c0fc0d" name="sp_aws_del_jobschedule" context="sp_aws_del_jobschedule" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[BEGIN
  DECLARE var_retval INT;
  DECLARE proc_name_mask VARCHAR(100);
  DECLARE var_owner_login_name VARCHAR(128);
  DECLARE var_xml TEXT DEFAULT '';
  DECLARE var_cron_expression VARCHAR(50); 
  DECLARE var_job_cmd VARCHAR(255); 
  DECLARE lambda_arn VARCHAR(255);  
  DECLARE return_message text;
  DECLARE var_schedule_name VARCHAR(255);

  IF (EXISTS (
      SELECT 1 
        FROM aws_sqlserver_ext.sysjobschedules
       WHERE (schedule_id = par_schedule_id) 
         AND (job_id = par_job_id))) 
  THEN
    SELECT name 
      FROM aws_sqlserver_ext.sysschedules
     WHERE schedule_id = par_schedule_id 
      INTO var_schedule_name;

    SET var_xml := CONCAT(var_xml, '{');
    SET var_xml := CONCAT(var_xml, '"mode": "del_schedule",');
    SET var_xml := CONCAT(var_xml, '"parameters": {');
    SET var_xml := CONCAT(var_xml, '"schedule_name": "',var_schedule_name,'",');
    SET var_xml := CONCAT(var_xml, '"force_delete": "TRUE"');
    SET var_xml := CONCAT(var_xml, '}');
    SET var_xml := CONCAT(var_xml, '}');

    SELECT aws_sqlserver_ext.get_service_setting ('JOB', 'LAMBDA_ARN') 
      INTO lambda_arn;

    SELECT lambda_sync (lambda_arn, var_xml) INTO return_message;

    SET returncode := 0; 
  -- ELSE 
  --  returncode := 1;
  --  RAISE 'Job not fount' USING ERRCODE := '50000';
  END IF;
END]]></complex-attribute>
                        <category _I_D="9a563c29-25dc-49f5-b9e5-f5fd9e57954b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="76e25721-743c-4995-9749-24d90372f133" name="sp_delete_job" context="sp_delete_job" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
    DECLARE var_current_msx_server VARCHAR (128);
    DECLARE var_bMSX_job TINYINT UNSIGNED;
    DECLARE var_retval INT;
    DECLARE var_local_machine_name VARCHAR (128);
    DECLARE var_category_id INT;
    DECLARE var_job_owner_sid CHAR (85);
    DECLARE var_err INT;
    DECLARE var_schedule_id INT;

  IF ((par_job_id IS NOT NULL) OR (par_job_name IS NOT NULL)) 
  THEN
    CALL aws_sqlserver_ext.sp_verify_job_identifiers ('@job_name', '@job_id', par_job_name, par_job_id, 'TEST', var_job_owner_sid, var_retval);
    IF (var_retval <> 0) THEN /* Failure */
      SET returncode := (1);
      LEAVE return_label;
    END IF;
  END IF;
  
  /* Get category to see if it is a misc. replication agent. @category_id will be */
  /* NULL if there is no @job_id. */
  
  SELECT category_id
    INTO var_category_id
    FROM aws_sqlserver_ext.sysjobs
   WHERE job_id = par_job_id;
   
  /* Do the delete (for a specific job) */
  IF (par_job_id IS NOT NULL) 
  THEN
    -- CREATE TEMPORARY TABLE "#temp_schedules_to_delete" (schedule_id INT NOT NULL);
     
    -- Delete all traces of the job 
    -- BEGIN TRANSACTION 
    -- Get the schedules to delete before deleting records from sysjobschedules 



    -- IF (par_delete_unused_schedule = 1) 
    -- THEN
      -- ZZZ optimize 
      -- Get the list of schedules to delete 
      -- INSERT INTO "#temp_schedules_to_delete"
      -- SELECT DISTINCT schedule_id 
      --  FROM aws_sqlserver_ext.sysschedules
      -- WHERE schedule_id IN (SELECT schedule_id
      --                         FROM aws_sqlserver_ext.sysjobschedules
      --                         WHERE job_id = par_job_id);
      -- INSERT INTO "#temp_schedules_to_delete"
      SELECT schedule_id
    	FROM aws_sqlserver_ext.sysjobschedules
       WHERE job_id = par_job_id
        INTO var_schedule_id;

    -- PERFORM aws_sqlserver_ext.sp_aws_del_jobschedule (par_job_id := par_job_id, par_schedule_id := var_schedule_id);  
    CALL aws_sqlserver_ext.sp_aws_del_jobschedule(par_job_id, var_schedule_id, var_retval);


--    END IF;


    -- DELETE FROM aws_sqlserver_ext.sysschedules
    -- WHERE schedule_id IN (SELECT schedule_id FROM aws_sqlserver_ext.sysjobschedules WHERE job_id = par_job_id);
  
    DELETE FROM aws_sqlserver_ext.sysjobschedules
     WHERE job_id = par_job_id;
     
    DELETE FROM aws_sqlserver_ext.sysjobsteps
     WHERE job_id = par_job_id;
     
    DELETE FROM aws_sqlserver_ext.sysjobs
     WHERE job_id = par_job_id;
     
    SELECT 0 /* @@ERROR */ INTO var_err;
          
    /* Delete the schedule(s) if requested to and it isn't being used by other jobs */
    IF (par_delete_unused_schedule = 1) 
    THEN
      /* Now OK to delete the schedule */
      DELETE FROM aws_sqlserver_ext.sysschedules
       WHERE schedule_id = var_schedule_id; -- IN (SELECT schedule_id FROM "#temp_schedules_to_delete");

      -- DELETE FROM aws_sqlserver_ext.sysschedules
      -- WHERE schedule_id IN (SELECT schedule_id
      --                         FROM "#temp_schedules_to_delete" AS sdel
      --                        WHERE NOT EXISTS (SELECT *
      --                                            FROM aws_sqlserver_ext.sysjobschedules AS js
      --                                           WHERE js.schedule_id = sdel.schedule_id));
    END IF;
    
    /* Delete the job history if requested */
    IF (par_delete_history = 1)
    THEN
      DELETE FROM aws_sqlserver_ext.sysjobhistory
      WHERE job_id = par_job_id;
    END IF;

    /* All done */
    /* COMMIT TRANSACTION */
    -- DROP TABLE "#temp_schedules_to_delete";
  END IF;
  
  /* 0 means success */
  SET returncode := 0;
  -- RETURN;

END]]></complex-attribute>
                        <category _I_D="7ec22f87-a2a0-48c7-9923-aa9beb85b0f3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="315270f0-4eaa-403e-bcc2-9ff11ddb6074" name="sp_delete_jobschedule" context="sp_delete_jobschedule" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
    DECLARE var_retval INT;
    DECLARE var_sched_count INT;
    DECLARE var_schedule_id INT;
    DECLARE var_job_owner_sid CHAR (85)
    /* Remove any leading/trailing spaces from parameters */;
    SELECT
        LTRIM(RTRIM(par_name))
        INTO par_name
    /* Check that we can uniquely identify the job */;
    CALL aws_sqlserver_ext.sp_verify_job_identifiers ('@job_name', '@job_id', par_job_name, par_job_id, 'TEST', var_job_owner_sid, var_retval);

    IF (var_retval <> 0) THEN
        SET ReturnCode := (1);
        LEAVE return_label;
    END IF
    /* Failure */
    /* IF (UPPER(@name collate SQL_Latin1_General_CP1_CS_AS) = N'ALL') */;

    IF (UPPER(par_name) = 'ALL') THEN
        SELECT
            - 1
            INTO var_schedule_id
        /* We use this in the call to sp_sqlagent_notify */
        /* Delete the schedule(s) if it isn't being used by other jobs */;
        CREATE TEMPORARY TABLE `#temp_schedules_to_delete`
            (schedule_id INT NOT NULL)
        /* If user requests that the schedules be removed (the legacy behavoir) */
        /* make sure it isnt being used by other jobs */;

        IF (par_keep_schedule = 0) THEN
            /* Get the list of schedules to delete */
            INSERT INTO `#temp_schedules_to_delete`
                SELECT DISTINCT
                    schedule_id
                    FROM aws_sqlserver_ext.sysschedules
                    WHERE (schedule_id IN (SELECT
                        schedule_id
                        FROM aws_sqlserver_ext.sysjobschedules
                        WHERE (job_id = par_job_id)))
            /* make sure no other jobs use these schedules */;

            IF (EXISTS (SELECT
                *
                FROM aws_sqlserver_ext.sysjobschedules
                WHERE (job_id <> par_job_id) AND (schedule_id IN (SELECT
                    schedule_id
                    FROM `#temp_schedules_to_delete`)))) THEN
                SIGNAL SQLSTATE VALUE '50000'
                    SET MESSAGE_TEXT = 'Error 50000, severity 0, state 0 was raised. Message: One or more schedules were not deleted because they are being used by at least one other job. Use "sp_detach_schedule" to remove schedules from a job.';
                SET ReturnCode := (1);
                LEAVE return_label
                /* Failure */;
            END IF;
        END IF
        /* OK to delete the jobschedule */;
        DELETE
            FROM aws_sqlserver_ext.sysjobschedules
            WHERE (job_id = par_job_id)
        /* OK to delete the schedule - temp_schedules_to_delete is empty if @keep_schedule <> 0 */;
        DELETE
            FROM aws_sqlserver_ext.sysschedules
            WHERE schedule_id IN (SELECT
                schedule_id
                FROM `#temp_schedules_to_delete`);
    ELSE
        /* Delete the job schedule link first */
        DELETE
            FROM aws_sqlserver_ext.sysjobschedules
            WHERE (job_id = par_job_id) AND (schedule_id = var_schedule_id)
        /* Delete schedule if required */;

        IF (par_keep_schedule = 0) THEN
            /* Now delete the schedule if required */
            DELETE
                FROM aws_sqlserver_ext.sysschedules
                WHERE (schedule_id = var_schedule_id);
        END IF;
    END IF
    /* Update the job's version/last-modified information */;
    UPDATE aws_sqlserver_ext.sysjobs
        SET version_number = version_number + 1
        /* date_modified = GETDATE() */
        WHERE (job_id = par_job_id);
    SET ReturnCode := (var_retval);
    LEAVE return_label
    /* 0 means success */;
END]]></complex-attribute>
                        <category _I_D="6d5cfd3d-89cd-402f-96eb-1d3747e65327" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="91cc9384-40b1-42ae-b65c-3c06391022a0" name="sp_delete_jobstep" context="sp_delete_jobstep" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
    DECLARE var_retval INT;
    DECLARE var_max_step_id INT;
    DECLARE var_valid_range VARCHAR (50);
    DECLARE var_job_owner_sid CHAR (85);
    DECLARE _messageText VARCHAR (255);

    CALL aws_sqlserver_ext.sp_verify_job_identifiers ('@job_name', '@job_id', par_job_name, par_job_id, 'TEST', var_job_owner_sid, var_retval);

    IF (var_retval <> 0) THEN
        SET ReturnCode := (1);
        LEAVE return_label;
    END IF
    /* Failure */
    /* Get current maximum step id */;
    SELECT
        COALESCE(MAX(step_id), 0)
        INTO var_max_step_id
        FROM aws_sqlserver_ext.sysjobsteps
        WHERE (job_id = par_job_id)
    /* Check step id */;

    IF (par_step_id < 0) OR (par_step_id > var_max_step_id) THEN
        SELECT
            CONCAT('0 (all steps) ..', CONVERT (var_max_step_id, CHAR))
            INTO var_valid_range;
        SET _messageText := CONCAT('Error 50000, severity 0, state 0 was raised. Message: The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@step_id', '. Argument: ', var_valid_range);
        SIGNAL SQLSTATE VALUE '50000'
            SET MESSAGE_TEXT = _messageText;
        SET ReturnCode := (1);
        LEAVE return_label
        /* Failure */;
    END IF
    /* BEGIN TRANSACTION */
    /* Delete either the specified step or ALL the steps (if step id is 0) */;

    IF (par_step_id = 0) THEN
        DELETE
            FROM aws_sqlserver_ext.sysjobsteps
            WHERE (job_id = par_job_id);
    ELSE
        DELETE
            FROM aws_sqlserver_ext.sysjobsteps
            WHERE (job_id = par_job_id) AND (step_id = par_step_id);
    END IF;

    IF (par_step_id <> 0) THEN
        /* Adjust step id's */
        UPDATE aws_sqlserver_ext.sysjobsteps
            SET step_id = step_id - 1
            WHERE (step_id > par_step_id) AND (job_id = par_job_id)
        /* Clean up OnSuccess/OnFail references */;
        UPDATE aws_sqlserver_ext.sysjobsteps
            SET on_success_step_id = on_success_step_id - 1
            WHERE (on_success_step_id > par_step_id) AND (job_id = par_job_id);
        UPDATE aws_sqlserver_ext.sysjobsteps
            SET on_fail_step_id = on_fail_step_id - 1
            WHERE (on_fail_step_id > par_step_id) AND (job_id = par_job_id);
        UPDATE aws_sqlserver_ext.sysjobsteps
            SET on_success_step_id = 0, on_success_action = 1
            /* Quit With Success */
            WHERE (on_success_step_id = par_step_id) AND (job_id = par_job_id);
        UPDATE aws_sqlserver_ext.sysjobsteps
            SET on_fail_step_id = 0, on_fail_action = 2
            /* Quit With Failure */
            WHERE (on_fail_step_id = par_step_id) AND (job_id = par_job_id);
    END IF
    /* Update the job's version/last-modified information */;
    UPDATE aws_sqlserver_ext.sysjobs
        SET version_number = version_number + 1
        /* date_modified = GETDATE() */
        WHERE (job_id = par_job_id)
    /* COMMIT TRANSACTION */;
    SET ReturnCode := (0);
    LEAVE return_label
    /* Success */;
END]]></complex-attribute>
                        <category _I_D="4aecee54-26a4-4652-8594-301fbc5830f6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="5d3f262e-ccca-49c1-a611-2e93fa05598a" name="sp_delete_schedule" context="sp_delete_schedule" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
    DECLARE var_retval INT;
    DECLARE var_owner_sid CHAR (85);
    DECLARE var_job_count INT;
    DECLARE var_targ_server_id INT
    /* Get the owners sid */;
    SELECT
        0
        INTO var_job_count
    /* check if there are jobs using this schedule */;
    SELECT
        COUNT(*)
        INTO var_job_count
        FROM sysjobschedules
        WHERE (schedule_id = par_schedule_id)
    /* If we aren't force deleting the schedule make sure no jobs are using it */;

    IF ((par_force_delete = 0) AND (var_job_count > 0)) THEN
        SIGNAL SQLSTATE VALUE '50000'
            SET MESSAGE_TEXT = 'Error 50000, severity 0, state 0 was raised. Message: The schedule was not deleted because it is being used by one or more jobs.';
        SET ReturnCode := (1);
        LEAVE return_label
        /* Failure */;
    END IF
    /* OK to delete the job - schedule link */;
    DELETE
        FROM sysjobschedules
        WHERE schedule_id = par_schedule_id
    /* OK to delete the schedule */;
    DELETE
        FROM sysschedules
        WHERE schedule_id = par_schedule_id;
    SET ReturnCode := (var_retval);
    LEAVE return_label
    /* 0 means success */;
END]]></complex-attribute>
                        <category _I_D="cb933ae1-3d76-4e0a-b8c6-df6c4397f02a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="716c0178-8c88-4046-9613-64c968388498" name="sp_detach_schedule" context="sp_detach_schedule" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
    DECLARE var_retval INT;
    DECLARE var_sched_owner_sid CHAR (85);
    DECLARE var_job_owner_sid CHAR (85);
    DECLARE _messageText VARCHAR (255)
    /* Check that we can uniquely identify the job */;
    CALL aws_sqlserver_ext.sp_verify_job_identifiers ('@job_name', '@job_id', par_job_name, par_job_id, 'TEST', var_job_owner_sid, var_retval);

    IF (var_retval <> 0) THEN
        SET ReturnCode := (1);
        LEAVE return_label;
    END IF
    /* Failure */
    /* Check that we can uniquely identify the schedule */;
    CALL aws_sqlserver_ext.sp_verify_schedule_identifiers ('@schedule_name', '@schedule_id', par_schedule_name, par_schedule_id, var_sched_owner_sid, NULL, par_job_id, var_retval)
    /* @job_id_filter */;

    IF (var_retval <> 0) THEN
        SET ReturnCode := (1);
        LEAVE return_label;
    END IF
    /* Failure */
    /* If the record doesn't exist raise an error */;

    IF (NOT EXISTS (SELECT
        *
        FROM aws_sqlserver_ext.sysjobschedules
        WHERE (schedule_id = par_schedule_id) AND (job_id = par_job_id))) THEN
        SET _messageText := CONCAT('Error 50000, severity 0, state 1 was raised. Message: The specified schedule name "%s" is not associated with the job "%s".', '. Argument: ', par_schedule_name, '. Argument: ', par_job_name);
        SIGNAL SQLSTATE VALUE '50000'
            SET MESSAGE_TEXT = _messageText;
        SET ReturnCode := (1);
        LEAVE return_label
        /* Failure */;
    END IF;
    DELETE
        FROM aws_sqlserver_ext.sysjobschedules
        WHERE (job_id = par_job_id) AND (schedule_id = par_schedule_id);
    SELECT
        0
        INTO var_retval
    /* @@ERROR */
    /* delete the schedule if requested and it isn't referenced */;

    IF (var_retval = 0 AND par_delete_unused_schedule = 1) THEN
        IF (NOT EXISTS (SELECT
            *
            FROM aws_sqlserver_ext.sysjobschedules
            WHERE (schedule_id = par_schedule_id))) THEN
            DELETE
                FROM aws_sqlserver_ext.sysschedules
                WHERE (schedule_id = par_schedule_id);
        END IF;
    END IF
    /* Update the job's version/last-modified information */;
    UPDATE aws_sqlserver_ext.sysjobs
        SET version_number = version_number + 1
        /* date_modified = GETDATE() */
        WHERE (job_id = par_job_id);
    SET ReturnCode := (var_retval);
    LEAVE return_label
    /* 0 means success */;
END]]></complex-attribute>
                        <category _I_D="67470fb2-dcb8-4a98-8ec4-ede395a6504f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="c90920cd-0f18-4eb9-bb17-2bc9b5432a3c" name="sp_get_dbmail" context="sp_get_dbmail" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_mailitem_id INT;
  DECLARE var_xml LONGTEXT DEFAULT '';
  DECLARE var_rc INT;
  DECLARE var_server_name VARCHAR (255);
      
  SELECT mailitem_id
    INTO var_mailitem_id
    FROM aws_sqlserver_ext.sysmail_mailitems
   WHERE sent_status = 0
   ORDER BY mailitem_id ASC
   LIMIT 1;

  IF (var_mailitem_id IS NULL) 
  THEN
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'E-mail messages are missing.';
    LEAVE return_label;
  END IF;

  UPDATE aws_sqlserver_ext.sysmail_mailitems
     SET sent_status = 1
   WHERE mailitem_id = var_mailitem_id;
   /* AND sent_status = 0; */
  
  CALL aws_sqlserver_ext.sysmail_dbmail_xml (var_mailitem_id, var_xml, var_server_name, var_rc);

  IF (var_rc <> 0) 
  THEN
    LEAVE return_label;
  END IF;

  SET par_mail_id := var_mailitem_id;
  SET par_mail_data := var_xml;
END]]></complex-attribute>
                        <category _I_D="50a8c032-7db4-4e5a-b2b1-e876da1f7835" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="72b87e62-0d36-4410-9db8-847fe6312611" name="sp_jobstep_exec" context="sp_jobstep_exec" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[BEGIN
  SELECT command
    FROM aws_sqlserver_ext.sysjobsteps 
   WHERE step_uid = pstep_uid
    INTO @command; 

  PREPARE stmt FROM @command;
  EXECUTE stmt;
END]]></complex-attribute>
                        <category _I_D="4dcedf3a-fd3e-4851-bafb-483837cbacb3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="f1244f81-e0e2-4902-9480-fdcb12230fa4" name="sp_job_log" context="sp_job_log" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[BEGIN
  CALL aws_sqlserver_ext.update_job (pid, pmessage);
  -- INSERT INTO ms_test.jobs_log(id, t, status, message)
  -- VALUES (pid, CURRENT_TIMESTAMP, pstatus, pmessage);
END]]></complex-attribute>
                        <category _I_D="29448a4f-6013-4daa-b82a-d59942d14cb6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="bd9e6c6b-cac1-43d3-9647-c0a885b90e0a" name="sp_send_dbmail" context="sp_send_dbmail" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_profile_id INT; /* uniqueidentifier */
  /* @trancountSave      INT, */
  /* @tranStartedBool    INT, */
  /* @send_request_user  sysname, */
  DECLARE var_temp_table_uid CHAR (38);
  DECLARE var_mail_data LONGTEXT;
  DECLARE var_CR_str VARCHAR (2);
  DECLARE var_localmessage VARCHAR (255);
  DECLARE var_QueryResultsExist INT;
  DECLARE var_AttachmentsExist INT;
  DECLARE var_RetErrorMsg VARCHAR (4000);
  DECLARE var_rc INT;
  DECLARE var_procName VARCHAR (128);
  DECLARE var_is_sysadmin TINYINT UNSIGNED;
  DECLARE var_database_user_id INT;
  DECLARE var_sid BLOB;
  DECLARE _messageText VARCHAR (255);
  DECLARE var_sent_result LONGTEXT;
  DECLARE var_server_name VARCHAR(255);
  
  SET var_rc := 0;
  SET var_QueryResultsExist := 0; 
  SET var_AttachmentsExist := 0;
  SET var_temp_table_uid :=  'ZZZZ';
  SET var_procName := 'sp_send_dbmail';
  SET var_sid :=  NULL;
  
  /* Get primary account if profile name is supplied */
  CALL aws_sqlserver_ext.sysmail_verify_profile_sp (NULL, par_profile_name, 0, 0, var_profile_id, var_rc);

  IF (var_rc <> 0) 
  THEN
    SET ReturnCode := var_rc;
    LEAVE return_label;
  END IF;

  /* Attach results must be specified */
  IF par_attach_query_result_as_file IS NULL 
  THEN
    SET _messageText := 'Parameter "attach_query_result_as_file" must be specified. This parameter cannot be NULL.';
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 2;
    LEAVE return_label;
  END IF;
  
  /* No output must be specified */
  IF par_exclude_query_output IS NULL 
  THEN
    SET _messageText := 'Parameter "exclude_query_output" must be specified. This parameter cannot be NULL.';    
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 3;
    LEAVE return_label;
  END IF;
  
  /* No header must be specified */
  IF par_query_result_header IS NULL 
  THEN
    SET _messageText := 'Parameter "query_result_header" must be specified. This parameter cannot be NULL.';        
    SIGNAL SQLSTATE VALUE '50000'             SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 4;
    LEAVE return_label;
  END IF;
  
  /* Check if query_result_separator is specifed */
  /* IF par_query_result_separator IS NULL OR DATALENGTH(par_query_result_separator) = 0 THEN */
  IF par_query_result_separator IS NULL OR CHAR_LENGTH(par_query_result_separator) = 0 
  THEN 
    SET _messageText := CONCAT('Parameter "query_result_separator" must be specified. This parameter cannot be NULL.');        
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 5;
    LEAVE return_label;
  END IF;

  /* Echo error must be specified */
  IF par_append_query_error IS NULL 
  THEN
    SET _messageText := 'Parameter "append_query_error" must be specified. This parameter cannot be NULL.';        
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 6;
    LEAVE return_label;
  END IF;
  
  /* @body_format can be TEXT (default) or HTML */
  IF (par_body_format IS NULL) 
  THEN
    SET par_body_format := 'TEXT';
  ELSE
    SET par_body_format := UPPER(par_body_format);

    IF par_body_format NOT IN ('TEXT', 'HTML') 
    THEN
      SET _messageText := CONCAT('Parameter par_mailformat does not support the value "%s". The mail format must be TEXT or HTML.', '. Argument: ', par_body_format);
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
      SET ReturnCode := 13;
      LEAVE return_label;
    END IF;
  END IF;
  
  /* Importance must be specified */
  IF par_importance IS NULL 
  THEN
    SET _messageText := 'Parameter "par_importance" must be specified. This parameter cannot be NULL.';        
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 15;
    LEAVE return_label;
  END IF;
  SET par_importance := UPPER(par_importance);
  
  /* Importance must be one of the predefined values */
  IF par_importance NOT IN ('LOW', 'NORMAL', 'HIGH') 
  THEN
    SET _messageText := CONCAT('Parameter par_importance does not support the value "%s". Mail importance must be one of LOW, NORMAL, or HIGH.', '. Argument: ', par_importance);
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 16;
    LEAVE return_label;
  END IF;
  
  /* Sensitivity must be specified */
  IF par_sensitivity IS NULL 
  THEN
    SET _messageText := 'Parameter "par_sensitivity" must be specified. This parameter cannot be NULL.';        
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 17;
    LEAVE return_label;
  END IF;
  SET par_sensitivity := UPPER(par_sensitivity);
  
  /* Sensitivity must be one of predefined values */
  IF par_sensitivity NOT IN ('NORMAL', 'PERSONAL', 'PRIVATE', 'CONFIDENTIAL') 
  THEN
    SET _messageText := CONCAT('Parameter par_sensitivity does not support the value "%s". Mail sensitivity must be one of NORMAL, PERSONAL, PRIVATE, or CONFIDENTIAL.', '. Argument: ', par_sensitivity);
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 18;
    LEAVE return_label;
  END IF;
  
  /* Message body cannot be null. Atleast one of message, subject, query, */
  /* attachments must be specified. */
  IF ((par_body IS NULL AND par_query IS NULL AND par_file_attachments IS NULL AND par_subject IS NULL) OR ((CHAR_LENGTH(par_body) IS NULL OR CHAR_LENGTH(par_body) <= 0) AND (CHAR_LENGTH(par_query) IS NULL OR CHAR_LENGTH(par_query) <= 0) AND (CHAR_LENGTH(par_file_attachments) IS NULL OR CHAR_LENGTH(par_file_attachments) <= 0) AND (CHAR_LENGTH(par_subject) IS NULL OR CHAR_LENGTH(par_subject) <= 0))) 
  THEN
    SET _messageText := CONCAT('At least one of the following parameters must be specified. "%s".', '. Argument: ', 'par_body, par_query, par_file_attachments, par_subject');
    SIGNAL SQLSTATE VALUE '50000'             SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 19;
    LEAVE return_label;
  ELSE
    IF par_subject IS NULL OR CHAR_LENGTH(par_subject) <= 0 
    THEN
      SET par_subject := 'Database Message';
    END IF;
  END IF;
  
  /* Recipients cannot be empty. Atleast one of the To, Cc, Bcc must be specified */
  IF ((par_recipients IS NULL AND par_copy_recipients IS NULL AND par_blind_copy_recipients IS NULL) OR ((CHAR_LENGTH(par_recipients) IS NULL OR CHAR_LENGTH(par_recipients) <= 0) AND (CHAR_LENGTH(par_copy_recipients) IS NULL OR CHAR_LENGTH(par_copy_recipients) <= 0) AND (CHAR_LENGTH(par_blind_copy_recipients) IS NULL OR CHAR_LENGTH(par_blind_copy_recipients) <= 0))) 
  THEN
    SET _messageText := CONCAT('At least one of the following parameters must be specified. "%s".', '. Argument: ', 'par_recipients, par_copy_recipients, par_blind_copy_recipients');
    SIGNAL SQLSTATE VALUE '50000'             SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 20;
    LEAVE return_label;
  END IF;
  
  /*
  ZZZZZ
  [sysmail_OutMailAttachmentEncodingMustBeValid] CHECK [attachment_encoding] IN ['UUENCODE', 'BINHEX', 'S/MIME', 'MIME']
  */
  
  CALL aws_sqlserver_ext.sysmail_verify_addressparams_sp (par_recipients, 'par_recipients', var_rc);
  
  IF (var_rc <> 0) 
  THEN
     SET ReturnCode := var_rc;
     LEAVE return_label;
  END IF;
  
  CALL aws_sqlserver_ext.sysmail_verify_addressparams_sp (par_copy_recipients, 'par_copy_recipients', var_rc);

  IF (var_rc <> 0) 
  THEN
    SET ReturnCode := var_rc;
    LEAVE return_label;
  END IF;
  
  CALL aws_sqlserver_ext.sysmail_verify_addressparams_sp (par_blind_copy_recipients, 'par_blind_copy_recipients', var_rc);

  IF (var_rc <> 0) 
  THEN
    SET ReturnCode := var_rc;
    LEAVE return_label;
  END IF;
  
  CALL aws_sqlserver_ext.sysmail_verify_addressparams_sp (par_reply_to, 'par_reply_to', var_rc);

  IF (var_rc <> 0) 
  THEN
    SET ReturnCode := var_rc;
    LEAVE return_label;
  END IF;
  
  /* If query is not specified, attach results and no header cannot be true. */
  IF ((par_query IS NULL OR CHAR_LENGTH(par_query) <= 0) AND par_attach_query_result_as_file = 1) 
  THEN
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'Parameter par_attach_query_result_as_file cannot be 1 (true) when no value is specified for parameter par_query. A query must be specified to attach the results of the query.';
    SET ReturnCode := 21;
    LEAVE return_label;
  END IF;
  
  /* BEGIN TRAN @procName */
  /* SET @tranStartedBool = 1 */
  /* Store complete mail message for history/status purposes */
  INSERT 
    INTO aws_sqlserver_ext.sysmail_mailitems(
         profile_id
       , recipients
       , copy_recipients
       , blind_copy_recipients
       , subject
       , body
       , body_format
       , importance
       , sensitivity
       , file_attachments
       , attachment_encoding
       , query
       , execute_query_database
       , attach_query_result_as_file
       , query_result_header
       , query_result_width
       , query_result_separator
       , exclude_query_output
       , append_query_error
       , send_request_date
       /* , send_request_user */
       , from_address
       , reply_to)
  VALUES (
         var_profile_id
       , par_recipients
       , par_copy_recipients
       , par_blind_copy_recipients
       , par_subject
       , par_body
       , par_body_format
       , par_importance
       , par_sensitivity
       , par_file_attachments
       , 'MIME'
       , par_query
       , par_execute_query_database
       , par_attach_query_result_as_file
       , par_query_result_header
       , par_query_result_width
       , par_query_result_separator
       , par_exclude_query_output
       , par_append_query_error
       , now()
       /* , @send_request_user */
       , par_from_address
       , par_reply_to);

  SELECT 0 /* @@ERROR, */
       , LAST_INSERT_ID() /* SCOPE_IDENTITY() */
    INTO var_rc
       , par_mailitem_id;

  CALL aws_sqlserver_ext.sysmail_dbmail_json (
      par_mailitem_id   /* IN par_mailitem_id */
    , var_mail_data     /* OUT par_mail_data */
    , var_server_name   /* OUT par_server_name */
    , var_rc            /* OUT ReturnCode */
  );
  
  SELECT lambda_sync( var_server_name, var_mail_data ) INTO var_sent_result; 
  /* SELECT awslambda_fn( 'arn:aws:lambda:us-west-2:468131460318:function:pg_v3', var_mail_data ) INTO var_sent_result; */
  CALL aws_sqlserver_ext.sp_set_dbmail(
      par_mailitem_id /* par_mail_id */
    , 1               /* par_sent_status */
    , var_sent_result /* par_message */
  );
    
  SET ReturnCode := var_rc;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="292786d9-baaf-423a-9d27-4630b76196d0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="ea0b8dc2-5e04-4a7c-8c3a-9d054b20b3cb" name="sp_sequence_get_range" context="sp_sequence_get_range" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[begin
declare v_is_cycle tinyint;
declare v_current_value decimal(65);
declare v_seq_schema text;
declare v_seq_name text;
declare i integer;
declare l_msg varchar(200);

  set v_seq_schema = substring(par_sequence_name, 1, instr(par_sequence_name, '.') - 1);
  set v_seq_name = substring(par_sequence_name, instr(par_sequence_name, '.') + 1, char_length(par_sequence_name));  
  
  select s.min_value, s.max_value, s.increment_by, s.is_cycle, s.curr_val 
    from aws_sqlserver_ext_data.sequences s 
    where s.name = v_seq_name and s.schema_name = v_seq_schema 
    into par_sequence_min_value, par_sequence_max_value, par_sequence_increment, v_is_cycle, v_current_value; 

   if ROW_COUNT()=0 then
     set l_msg := CONCAT('The sequence "',v_seq_schema,'"."',v_seq_name,'" does not exist');
         SIGNAL SQLSTATE VALUE '45007'
         set MESSAGE_TEXT = l_msg;
   end if;

    
  set par_range_first_value = v_current_value;

  if par_range_first_value > par_sequence_min_value then 
    set par_range_first_value = par_range_first_value + 1;
  end if;

  if v_is_cycle = 1 then 
    set par_range_cycle_count = 0;
  end if;
    
  set i = 1;
  do_range: loop
    set v_current_value = aws_sqlserver_ext.sequence$nextval(v_seq_name, v_seq_schema);
    set i = i + 1;

    if (v_is_cycle = 1) and (v_current_value >= par_sequence_min_value) and (par_range_first_value <> v_current_value) then 
      set par_range_cycle_count := par_range_cycle_count + 1;
    end if;
    
    if i <= par_range_size then
      iterate do_range;
    end if;  
    
    leave do_range;
    
  end loop do_range;
  
  select s.curr_val 
    from aws_sqlserver_ext_data.sequences s 
    where s.name = v_seq_name and s.schema_name = v_seq_schema 
    into par_range_last_value; 
end]]></complex-attribute>
                        <category _I_D="5247d412-cefb-4cc7-85ec-c80d6b42b51b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="50903278-a708-4a07-80ab-f0194aa79336" name="sp_set_dbmail" context="sp_set_dbmail" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[BEGIN
  /* event_type
  3                           -- error
  2 AND @loggingLevelInt >= 2 -- warning with extended logging
  1 AND @loggingLevelInt >= 2 -- info with extended logging
  0 AND @loggingLevelInt >= 3 -- success with verbose logging
  */
  
  IF (par_sent_status = 1) /* ok */
  THEN
    UPDATE aws_sqlserver_ext.sysmail_mailitems
       SET sent_status = 2
         , sent_date = NOW()
     WHERE mailitem_id = par_mail_id;
     
    INSERT INTO aws_sqlserver_ext.sysmail_log (event_type, log_date, description, mailitem_id)
    VALUES (0, NOW(), par_message, par_mail_id);
  ELSE
    IF (par_sent_status = -1) /* failed */
    THEN
      UPDATE aws_sqlserver_ext.sysmail_mailitems
         SET sent_status = -1
           , sent_date = NOW()
       WHERE mailitem_id = par_mail_id;
       
      INSERT INTO aws_sqlserver_ext.sysmail_log(event_type, log_date, description, mailitem_id)
      VALUES (3, NOW(), par_message, par_mail_id);
    END IF;
  END IF;
END]]></complex-attribute>
                        <category _I_D="d9606fba-2cf2-49d0-9e76-7e97d4d68d07" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="26fe2bbd-ad85-49b0-97db-39d4cf81f31e" name="sp_set_next_run" context="sp_set_next_run" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_enabled INTEGER;
  DECLARE var_freq_type INTEGER;
  DECLARE var_freq_interval INTEGER;
  DECLARE var_freq_subday_type INTEGER;
  DECLARE var_freq_subday_interval INTEGER;
  DECLARE var_freq_relative_interval INTEGER;
  DECLARE var_freq_recurrence_factor INTEGER;
  DECLARE var_active_start_date INTEGER;
  DECLARE var_active_end_date INTEGER;
  DECLARE var_active_start_time INTEGER;
  DECLARE var_active_end_time INTEGER;

  DECLARE var_next_run_date date;
  DECLARE var_next_run_time time;
  DECLARE var_next_run_dt timestamp;

  DECLARE var_tmp_interval varchar(50);
  DECLARE var_current_dt timestamp;
  DECLARE var_next_dt timestamp;

  SELECT enabled
       , freq_type
       , freq_interval
       , freq_subday_type
       , freq_subday_interval
       , freq_relative_interval
       , freq_recurrence_factor
       , active_start_date
       , active_end_date
       , active_start_time
       , active_end_time
    INTO var_enabled
       , var_freq_type
       , var_freq_interval
       , var_freq_subday_type
       , var_freq_subday_interval
       , var_freq_relative_interval
       , var_freq_recurrence_factor
       , var_active_start_date
       , var_active_end_date
       , var_active_start_time
       , var_active_end_time
    FROM aws_sqlserver_ext.sysschedules
   WHERE schedule_id = par_schedule_id;

  SELECT next_run_date
       , next_run_time
    INTO var_next_run_date
       , var_next_run_time
    FROM aws_sqlserver_ext.sysjobschedules
   WHERE schedule_id = par_schedule_id
     AND job_id = par_job_id;

  /* if enabled = 0 return */
  CASE var_freq_type
    WHEN 1 THEN
    BEGIN
      LEAVE return_label;
      /* start date + start time or now() */
      /*
      UPDATE aws_sqlserver_ext.sysjobschedules
         SET next_run_date = var_current_dt::date
           , next_run_time = var_current_dt::time
       WHERE schedule_id = par_schedule_id
         AND job_id = par_job_id;
      */
    END;
    
    WHEN 4 THEN
    BEGIN
      /* NULL start date & time or now */
      /* start date + start time or now() */
      IF (var_next_run_date IS NULL OR var_next_run_time IS NULL)
      THEN
        SET var_current_dt = now(); /* ::timestamp; */

        UPDATE aws_sqlserver_ext.sysjobschedules
           SET next_run_date = DATE(var_current_dt) /* ::date */
             , next_run_time = TIME(var_current_dt) /* ::time */
         WHERE schedule_id = par_schedule_id
           AND job_id = par_job_id;
        LEAVE return_label;
      ELSE
        SET var_next_dt = 
        CASE
          /* WHEN var_freq_subday_type = 1 THEN var_freq_subday_interval::character varying || ' At the specified time'  -- start time */
          WHEN var_freq_subday_type = 2 THEN DATE_ADD(DATE_ADD(var_next_run_date, INTERVAL TIME_TO_SEC(var_next_run_time) SECOND), INTERVAL var_freq_subday_interval SECOND)  
          WHEN var_freq_subday_type = 4 THEN DATE_ADD(DATE_ADD(var_next_run_date, INTERVAL TIME_TO_SEC(var_next_run_time) SECOND), INTERVAL var_freq_subday_interval MINUTE)  
          WHEN var_freq_subday_type = 8 THEN DATE_ADD(DATE_ADD(var_next_run_date, INTERVAL TIME_TO_SEC(var_next_run_time) SECOND), INTERVAL var_freq_subday_interval HOUR)  
          ELSE NULL
        END;
        /* SET var_next_dt = (var_next_run_date::date + var_next_run_time::time)::timestamp + var_tmp_interval::INTERVAL; */
        UPDATE aws_sqlserver_ext.sysjobschedules
           SET next_run_date = DATE(var_next_dt)
             , next_run_time = TIME(var_next_dt)
         WHERE schedule_id = par_schedule_id
           AND job_id = par_job_id;
        LEAVE return_label;
      END IF;
    END;

    WHEN 8 THEN
    BEGIN
      LEAVE return_label;
    END;

    WHEN 16 THEN
    BEGIN
      LEAVE return_label;    
    END;

    WHEN 32 THEN
    BEGIN
      LEAVE return_label;    
    END;

    WHEN 64 THEN
    BEGIN
      LEAVE return_label;    
    END;

    WHEN 128 THEN
    BEGIN
      LEAVE return_label;    
    END;
  END CASE;
END]]></complex-attribute>
                        <category _I_D="aa852ab1-8bff-4bae-97d2-ffcd2cb82cdb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="addd171c-4b9a-419e-af0a-34a11164b64d" name="sp_update_job" context="sp_update_job" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
    DECLARE var_retval INT;
    DECLARE var_category_id INT;
    DECLARE var_notify_email_operator_id INT;
    DECLARE var_notify_netsend_operator_id INT;
    DECLARE var_notify_page_operator_id INT;
    DECLARE var_owner_sid CHAR (85);
    DECLARE var_alert_id INT;
    DECLARE var_cached_attribute_modified INT;
    DECLARE var_is_sysadmin INT;
    DECLARE var_current_owner VARCHAR (128);
    DECLARE var_enable_only_used INT;
    DECLARE var_x_new_name VARCHAR (128);
    DECLARE var_x_enabled TINYINT UNSIGNED;
    DECLARE var_x_description VARCHAR (512);
    DECLARE var_x_start_step_id INT;
    DECLARE var_x_category_name VARCHAR (128);
    DECLARE var_x_category_id INT;
    DECLARE var_x_owner_sid CHAR (85);
    DECLARE var_x_notify_level_eventlog INT;
    DECLARE var_x_notify_level_email INT;
    DECLARE var_x_notify_level_netsend INT;
    DECLARE var_x_notify_level_page INT;
    DECLARE var_x_notify_email_operator_name VARCHAR (128);
    DECLARE var_x_notify_netsnd_operator_name VARCHAR (128);
    DECLARE var_x_notify_page_operator_name VARCHAR (128);
    DECLARE var_x_delete_level INT;
    DECLARE var_x_originating_server_id INT;
    DECLARE var_x_master_server TINYINT UNSIGNED
    /* Not updatable */
    /* Remove any leading/trailing spaces from parameters (except @owner_login_name) */;
    SELECT
        LTRIM(RTRIM(par_job_name))
        INTO par_job_name;
    SELECT
        LTRIM(RTRIM(par_new_name))
        INTO par_new_name;
    SELECT
        LTRIM(RTRIM(par_description))
        INTO par_description;
    SELECT
        LTRIM(RTRIM(par_category_name))
        INTO par_category_name;
    SELECT
        LTRIM(RTRIM(par_notify_email_operator_name))
        INTO par_notify_email_operator_name;
    SELECT
        LTRIM(RTRIM(par_notify_netsend_operator_name))
        INTO par_notify_netsend_operator_name;
    SELECT
        LTRIM(RTRIM(par_notify_page_operator_name))
        INTO par_notify_page_operator_name
    /* Are we modifying an attribute which SQLServerAgent caches? */;

    IF ((par_new_name IS NOT NULL) OR (par_enabled IS NOT NULL) OR (par_start_step_id IS NOT NULL) OR (par_owner_login_name IS NOT NULL) OR (par_notify_level_eventlog IS NOT NULL) OR (par_notify_level_email IS NOT NULL) OR (par_notify_level_netsend IS NOT NULL) OR (par_notify_level_page IS NOT NULL) OR (par_notify_email_operator_name IS NOT NULL) OR (par_notify_netsend_operator_name IS NOT NULL) OR (par_notify_page_operator_name IS NOT NULL) OR (par_delete_level IS NOT NULL)) THEN
        SELECT
            1
            INTO var_cached_attribute_modified;
    ELSE
        SELECT
            0
            INTO var_cached_attribute_modified;
    END IF
    /* Is @enable the only parameter used beside jobname and jobid? */;

    IF ((par_enabled IS NOT NULL) AND (par_new_name IS NULL) AND (par_description IS NULL) AND (par_start_step_id IS NULL) AND (par_category_name IS NULL) AND (par_owner_login_name IS NULL) AND (par_notify_level_eventlog IS NULL) AND (par_notify_level_email IS NULL) AND (par_notify_level_netsend IS NULL) AND (par_notify_level_page IS NULL) AND (par_notify_email_operator_name IS NULL) AND (par_notify_netsend_operator_name IS NULL) AND (par_notify_page_operator_name IS NULL) AND (par_delete_level IS NULL)) THEN
        SELECT
            1
            INTO var_enable_only_used;
    ELSE
        SELECT
            0
            INTO var_enable_only_used;
    END IF;

    IF (par_new_name = '') THEN
        SELECT
            NULL
            INTO par_new_name;
    END IF
    /* Fill out the values for all non-supplied parameters from the existing values */;

    IF (par_new_name IS NULL) THEN
        SELECT
            var_x_new_name
            INTO par_new_name;
    END IF;

    IF (par_enabled IS NULL) THEN
        SELECT
            var_x_enabled
            INTO par_enabled;
    END IF;

    IF (par_description IS NULL) THEN
        SELECT
            var_x_description
            INTO par_description;
    END IF;

    IF (par_start_step_id IS NULL) THEN
        SELECT
            var_x_start_step_id
            INTO par_start_step_id;
    END IF;

    IF (par_category_name IS NULL) THEN
        SELECT
            var_x_category_name
            INTO par_category_name;
    END IF;

    IF (var_owner_sid IS NULL) THEN
        SELECT
            var_x_owner_sid
            INTO var_owner_sid;
    END IF;

    IF (par_notify_level_eventlog IS NULL) THEN
        SELECT
            var_x_notify_level_eventlog
            INTO par_notify_level_eventlog;
    END IF;

    IF (par_notify_level_email IS NULL) THEN
        SELECT
            var_x_notify_level_email
            INTO par_notify_level_email;
    END IF;

    IF (par_notify_level_netsend IS NULL) THEN
        SELECT
            var_x_notify_level_netsend
            INTO par_notify_level_netsend;
    END IF;

    IF (par_notify_level_page IS NULL) THEN
        SELECT
            var_x_notify_level_page
            INTO par_notify_level_page;
    END IF;

    IF (par_notify_email_operator_name IS NULL) THEN
        SELECT
            var_x_notify_email_operator_name
            INTO par_notify_email_operator_name;
    END IF;

    IF (par_notify_netsend_operator_name IS NULL) THEN
        SELECT
            var_x_notify_netsnd_operator_name
            INTO par_notify_netsend_operator_name;
    END IF;

    IF (par_notify_page_operator_name IS NULL) THEN
        SELECT
            var_x_notify_page_operator_name
            INTO par_notify_page_operator_name;
    END IF;

    IF (par_delete_level IS NULL) THEN
        SELECT
            var_x_delete_level
            INTO par_delete_level;
    END IF
    /* Turn [nullable] empty string parameters into NULLs */;

    IF (par_description = '') THEN
        SELECT
            NULL
            INTO par_description;
    END IF;

    IF (par_category_name = '') THEN
        SELECT
            NULL
            INTO par_category_name;
    END IF;

    IF (par_notify_email_operator_name = '') THEN
        SELECT
            NULL
            INTO par_notify_email_operator_name;
    END IF;

    IF (par_notify_netsend_operator_name = '') THEN
        SELECT
            NULL
            INTO par_notify_netsend_operator_name;
    END IF;

    IF (par_notify_page_operator_name = '') THEN
        SELECT
            NULL
            INTO par_notify_page_operator_name;
    END IF
    /* Check new values */;
    CALL aws_sqlserver_ext.sp_verify_job (par_job_id, par_new_name, par_enabled, par_start_step_id, par_category_name, var_owner_sid, par_notify_level_eventlog, par_notify_level_email, par_notify_level_netsend, par_notify_level_page, par_notify_email_operator_name, par_notify_netsend_operator_name, par_notify_page_operator_name, par_delete_level, var_category_id, var_notify_email_operator_id, var_notify_netsend_operator_id, var_notify_page_operator_id, NULL, var_retval);

    IF (var_retval <> 0) THEN
        SET ReturnCode := (1);
        LEAVE return_label;
    END IF
    /* Failure */
    /* BEGIN TRANSACTION */
    /* If the job is being re-assigned, modify sysjobsteps.database_user_name as necessary */;

    IF (par_owner_login_name IS NOT NULL) THEN
        IF (EXISTS (SELECT
            *
            FROM aws_sqlserver_ext.sysjobsteps
            WHERE (job_id = par_job_id) AND (subsystem = 'TSQL'))) THEN
            /* The job is being re-assigned to an non-SA */
            UPDATE aws_sqlserver_ext.sysjobsteps
                SET database_user_name = NULL
                WHERE (job_id = par_job_id) AND (subsystem = 'TSQL');
        END IF;
    END IF;
    UPDATE aws_sqlserver_ext.sysjobs
        SET name = par_new_name, enabled = par_enabled, description = par_description, start_step_id = par_start_step_id, category_id = var_category_id
        /* Returned from sp_verify_job */, owner_sid = var_owner_sid, notify_level_eventlog = par_notify_level_eventlog, notify_level_email = par_notify_level_email, notify_level_netsend = par_notify_level_netsend, notify_level_page = par_notify_level_page, notify_email_operator_id = var_notify_email_operator_id
        /* Returned from sp_verify_job */, notify_netsend_operator_id = var_notify_netsend_operator_id
        /* Returned from sp_verify_job */, notify_page_operator_id = var_notify_page_operator_id
        /* Returned from sp_verify_job */, delete_level = par_delete_level, version_number = version_number + 1
        /* ,  -- Update the job's version */
        /* date_modified              = GETDATE()            -- Update the job's last-modified information */
        WHERE (job_id = par_job_id);
    SELECT
        0
        INTO var_retval
    /* @@error */
    /* COMMIT TRANSACTION */;
    SET ReturnCode := (var_retval);
    LEAVE return_label
    /* 0 means success */;
END]]></complex-attribute>
                        <category _I_D="9b9f77ea-946f-482b-94ab-edb8a6ab0ce6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="c0c44241-e829-451c-9d86-080ab4f1f777" name="sp_update_jobschedule" context="sp_update_jobschedule" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
    DECLARE var_retval INT;
    DECLARE var_sched_count INT;
    DECLARE var_schedule_id INT;
    DECLARE var_job_owner_sid CHAR (85);
    DECLARE var_enable_only_used INT;
    DECLARE var_x_name VARCHAR (128);
    DECLARE var_x_enabled TINYINT UNSIGNED;
    DECLARE var_x_freq_type INT;
    DECLARE var_x_freq_interval INT;
    DECLARE var_x_freq_subday_type INT;
    DECLARE var_x_freq_subday_interval INT;
    DECLARE var_x_freq_relative_interval INT;
    DECLARE var_x_freq_recurrence_factor INT;
    DECLARE var_x_active_start_date INT;
    DECLARE var_x_active_end_date INT;
    DECLARE var_x_active_start_time INT;
    DECLARE var_x_active_end_time INT;
    DECLARE var_owner_sid CHAR (85)
    /* Remove any leading/trailing spaces from parameters */;
    SELECT
        LTRIM(RTRIM(par_name))
        INTO par_name;
    SELECT
        LTRIM(RTRIM(par_new_name))
        INTO par_new_name
    /* Turn [nullable] empty string parameters into NULLs */;

    IF (par_new_name = '') THEN
        SELECT
            NULL
            INTO par_new_name;
    END IF
    /* Check that we can uniquely identify the job */;
    CALL aws_sqlserver_ext.sp_verify_job_identifiers ('@job_name', '@job_id', par_job_name, par_job_id, 'TEST', var_job_owner_sid, var_retval);

    IF (var_retval <> 0) THEN
        SET ReturnCode := (1);
        LEAVE return_label;
    END IF
    /* Failure */
    /* Is @enable the only parameter used beside jobname and jobid? */;

    IF ((par_enabled IS NOT NULL) AND (par_name IS NULL) AND (par_new_name IS NULL) AND (par_freq_type IS NULL) AND (par_freq_interval IS NULL) AND (par_freq_subday_type IS NULL) AND (par_freq_subday_interval IS NULL) AND (par_freq_relative_interval IS NULL) AND (par_freq_recurrence_factor IS NULL) AND (par_active_start_date IS NULL) AND (par_active_end_date IS NULL) AND (par_active_start_time IS NULL) AND (par_active_end_time IS NULL)) THEN
        SELECT
            1
            INTO var_enable_only_used;
    ELSE
        SELECT
            0
            INTO var_enable_only_used;
    END IF
    /* Fill out the values for all non-supplied parameters from the existing values */;

    IF (par_new_name IS NULL) THEN
        SELECT
            var_x_name
            INTO par_new_name;
    END IF;

    IF (par_enabled IS NULL) THEN
        SELECT
            var_x_enabled
            INTO par_enabled;
    END IF;

    IF (par_freq_type IS NULL) THEN
        SELECT
            var_x_freq_type
            INTO par_freq_type;
    END IF;

    IF (par_freq_interval IS NULL) THEN
        SELECT
            var_x_freq_interval
            INTO par_freq_interval;
    END IF;

    IF (par_freq_subday_type IS NULL) THEN
        SELECT
            var_x_freq_subday_type
            INTO par_freq_subday_type;
    END IF;

    IF (par_freq_subday_interval IS NULL) THEN
        SELECT
            var_x_freq_subday_interval
            INTO par_freq_subday_interval;
    END IF;

    IF (par_freq_relative_interval IS NULL) THEN
        SELECT
            var_x_freq_relative_interval
            INTO par_freq_relative_interval;
    END IF;

    IF (par_freq_recurrence_factor IS NULL) THEN
        SELECT
            var_x_freq_recurrence_factor
            INTO par_freq_recurrence_factor;
    END IF;

    IF (par_active_start_date IS NULL) THEN
        SELECT
            var_x_active_start_date
            INTO par_active_start_date;
    END IF;

    IF (par_active_end_date IS NULL) THEN
        SELECT
            var_x_active_end_date
            INTO par_active_end_date;
    END IF;

    IF (par_active_start_time IS NULL) THEN
        SELECT
            var_x_active_start_time
            INTO par_active_start_time;
    END IF;

    IF (par_active_end_time IS NULL) THEN
        SELECT
            var_x_active_end_time
            INTO par_active_end_time;
    END IF
    /* Check schedule (frequency and owner) parameters */;
    CALL aws_sqlserver_ext.sp_verify_schedule (var_schedule_id
    /* @schedule_id */, par_new_name
    /* @name */, par_enabled
    /* @enabled */, par_freq_type
    /* @freq_type */, par_freq_interval
    /* @freq_interval */, par_freq_subday_type
    /* @freq_subday_type */, par_freq_subday_interval
    /* @freq_subday_interval */, par_freq_relative_interval
    /* @freq_relative_interval */, par_freq_recurrence_factor
    /* @freq_recurrence_factor */, par_active_start_date
    /* @active_start_date */, par_active_start_time
    /* @active_start_time */, par_active_end_date
    /* @active_end_date */, par_active_end_time
    /* @active_end_time */, var_owner_sid, var_retval) /* @owner_sid */;

    IF (var_retval <> 0) THEN
        SET ReturnCode := (1);
        LEAVE return_label;
    END IF
    /* Failure */
    /* Update the JobSchedule */;
    UPDATE aws_sqlserver_ext.sysschedules
        SET name = par_new_name, enabled = par_enabled, freq_type = par_freq_type, freq_interval = par_freq_interval, freq_subday_type = par_freq_subday_type, freq_subday_interval = par_freq_subday_interval, freq_relative_interval = par_freq_relative_interval, freq_recurrence_factor = par_freq_recurrence_factor, active_start_date = par_active_start_date, active_end_date = par_active_end_date, active_start_time = par_active_start_time, active_end_time = par_active_end_time
        /* date_modified          = GETDATE(), */, version_number = version_number + 1
        WHERE (schedule_id = var_schedule_id);
    SELECT
        0
        INTO var_retval
    /* @@error */
    /* Update the job's version/last-modified information */;
    UPDATE aws_sqlserver_ext.sysjobs
        SET version_number = version_number + 1
        /* date_modified = GETDATE() */
        WHERE (job_id = par_job_id);
    SET ReturnCode := (var_retval);
    LEAVE return_label
    /* 0 means success */;
END]]></complex-attribute>
                        <category _I_D="f352db7e-fe9c-45b8-999f-bb06ab289055" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="eb172e5b-e34f-434d-b53c-7b1a02c0f5a9" name="sp_update_jobstep" context="sp_update_jobstep" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
    DECLARE var_retval INT;
    DECLARE var_os_run_priority_code INT;
    DECLARE var_step_id_as_char VARCHAR (10);
    DECLARE var_new_step_name VARCHAR (128);
    DECLARE var_x_step_name VARCHAR (128);
    DECLARE var_x_subsystem VARCHAR (40);
    DECLARE var_x_command LONGTEXT;
    DECLARE var_x_flags INT;
    DECLARE var_x_cmdexec_success_code INT;
    DECLARE var_x_on_success_action TINYINT UNSIGNED;
    DECLARE var_x_on_success_step_id INT;
    DECLARE var_x_on_fail_action TINYINT UNSIGNED;
    DECLARE var_x_on_fail_step_id INT;
    DECLARE var_x_server VARCHAR (128);
    DECLARE var_x_database_name VARCHAR (128);
    DECLARE var_x_database_user_name VARCHAR (128);
    DECLARE var_x_retry_attempts INT;
    DECLARE var_x_retry_interval INT;
    DECLARE var_x_os_run_priority INT;
    DECLARE var_x_output_file_name VARCHAR (200);
    DECLARE var_x_proxy_id INT;
    DECLARE var_x_last_run_outcome TINYINT UNSIGNED;
    DECLARE var_x_last_run_duration INT;
    DECLARE var_x_last_run_retries INT;
    DECLARE var_x_last_run_date INT;
    DECLARE var_x_last_run_time INT;
    DECLARE var_new_proxy_id INT;
    DECLARE var_subsystem_id INT;
    DECLARE var_auto_proxy_name VARCHAR (128);
    DECLARE var_job_owner_sid CHAR (85);
    DECLARE _messageText VARCHAR (255)
    /* Not updatable (but may be in future) */
    /* Not updatable (but may be in future) */
    /* Not updatable (but may be in future) */
    /* Not updatable (but may be in future) */
    /* Not updatable (but may be in future) */;
    SELECT
        NULL
        INTO var_new_proxy_id
    /* Remove any leading/trailing spaces from parameters */;
    SELECT
        LTRIM(RTRIM(par_step_name))
        INTO par_step_name;
    SELECT
        LTRIM(RTRIM(par_subsystem))
        INTO par_subsystem;
    SELECT
        LTRIM(RTRIM(par_command))
        INTO par_command;
    SELECT
        LTRIM(RTRIM(par_server))
        INTO par_server;
    SELECT
        LTRIM(RTRIM(par_database_name))
        INTO par_database_name;
    SELECT
        LTRIM(RTRIM(par_database_user_name))
        INTO par_database_user_name;
    SELECT
        LTRIM(RTRIM(par_output_file_name))
        INTO par_output_file_name;
    SELECT
        LTRIM(RTRIM(par_proxy_name))
        INTO par_proxy_name
    /* Make sure Dts is translated into new subsystem's name SSIS */
    /* IF (@subsystem IS NOT NULL AND UPPER(@subsystem collate SQL_Latin1_General_CP1_CS_AS) = N'DTS') */
    /* BEGIN */
    /* SET @subsystem = N'SSIS' */
    /* END */;
    CALL aws_sqlserver_ext.sp_verify_job_identifiers ('@job_name', '@job_id', par_job_name, par_job_id, 'TEST', var_job_owner_sid, var_retval)
    /* @owner_sid */;

    IF (var_retval <> 0) THEN
        SET ReturnCode := (1);
        LEAVE return_label;
    END IF
    /* Failure */
    /* Check that the step exists */;

    IF (NOT EXISTS (SELECT
        *
        FROM aws_sqlserver_ext.sysjobsteps
        WHERE (job_id = par_job_id) AND (step_id = par_step_id))) THEN
        SELECT
            CONVERT (par_step_id, CHAR)
            INTO var_step_id_as_char;
        SET _messageText := CONCAT('Error 50000, severity 0, state 0 was raised. Message: The specified %s ("%s") does not exist.', '. Argument: ', '@step_id', '. Argument: ', var_step_id_as_char);
        SIGNAL SQLSTATE VALUE '50000'
            SET MESSAGE_TEXT = _messageText;
        SET ReturnCode := (1);
        LEAVE return_label
        /* Failure */;
    END IF
    /* Set the x_ (existing) variables */;
    SELECT
        step_name, subsystem, command, flags, cmdexec_success_code, on_success_action, on_success_step_id, on_fail_action, on_fail_step_id, server, database_name, database_user_name, retry_attempts, retry_interval, os_run_priority, output_file_name, proxy_id, last_run_outcome, last_run_duration, last_run_retries, last_run_date, last_run_time
        INTO var_x_step_name, var_x_subsystem, var_x_command, var_x_flags, var_x_cmdexec_success_code, var_x_on_success_action, var_x_on_success_step_id, var_x_on_fail_action, var_x_on_fail_step_id, var_x_server, var_x_database_name, var_x_database_user_name, var_x_retry_attempts, var_x_retry_interval, var_x_os_run_priority, var_x_output_file_name, var_x_proxy_id, var_x_last_run_outcome, var_x_last_run_duration, var_x_last_run_retries, var_x_last_run_date, var_x_last_run_time
        FROM aws_sqlserver_ext.sysjobsteps
        WHERE (job_id = par_job_id) AND (step_id = par_step_id);

    IF ((par_step_name IS NOT NULL) AND (par_step_name <> var_x_step_name)) THEN
        SELECT
            par_step_name
            INTO var_new_step_name;
    END IF
    /* Fill out the values for all non-supplied parameters from the existing values */;

    IF (par_step_name IS NULL) THEN
        SELECT
            var_x_step_name
            INTO par_step_name;
    END IF;

    IF (par_subsystem IS NULL) THEN
        SELECT
            var_x_subsystem
            INTO par_subsystem;
    END IF;

    IF (par_command IS NULL) THEN
        SELECT
            var_x_command
            INTO par_command;
    END IF;

    IF (par_flags IS NULL) THEN
        SELECT
            var_x_flags
            INTO par_flags;
    END IF;

    IF (par_cmdexec_success_code IS NULL) THEN
        SELECT
            var_x_cmdexec_success_code
            INTO par_cmdexec_success_code;
    END IF;

    IF (par_on_success_action IS NULL) THEN
        SELECT
            var_x_on_success_action
            INTO par_on_success_action;
    END IF;

    IF (par_on_success_step_id IS NULL) THEN
        SELECT
            var_x_on_success_step_id
            INTO par_on_success_step_id;
    END IF;

    IF (par_on_fail_action IS NULL) THEN
        SELECT
            var_x_on_fail_action
            INTO par_on_fail_action;
    END IF;

    IF (par_on_fail_step_id IS NULL) THEN
        SELECT
            var_x_on_fail_step_id
            INTO par_on_fail_step_id;
    END IF;

    IF (par_server IS NULL) THEN
        SELECT
            var_x_server
            INTO par_server;
    END IF;

    IF (par_database_name IS NULL) THEN
        SELECT
            var_x_database_name
            INTO par_database_name;
    END IF;

    IF (par_database_user_name IS NULL) THEN
        SELECT
            var_x_database_user_name
            INTO par_database_user_name;
    END IF;

    IF (par_retry_attempts IS NULL) THEN
        SELECT
            var_x_retry_attempts
            INTO par_retry_attempts;
    END IF;

    IF (par_retry_interval IS NULL) THEN
        SELECT
            var_x_retry_interval
            INTO par_retry_interval;
    END IF;

    IF (par_os_run_priority IS NULL) THEN
        SELECT
            var_x_os_run_priority
            INTO par_os_run_priority;
    END IF;

    IF (par_output_file_name IS NULL) THEN
        SELECT
            var_x_output_file_name
            INTO par_output_file_name;
    END IF;

    IF (par_proxy_id IS NULL) THEN
        SELECT
            var_x_proxy_id
            INTO var_new_proxy_id;
    END IF
    /* if an empty proxy_name is supplied the proxy is removed */;

    IF par_proxy_name = '' THEN
        SELECT
            NULL
            INTO var_new_proxy_id;
    END IF
    /* Turn [nullable] empty string parameters into NULLs */;

    IF (par_command = '') THEN
        SELECT
            NULL
            INTO par_command;
    END IF;

    IF (par_server = '') THEN
        SELECT
            NULL
            INTO par_server;
    END IF;

    IF (par_database_name = '') THEN
        SELECT
            NULL
            INTO par_database_name;
    END IF;

    IF (par_database_user_name = '') THEN
        SELECT
            NULL
            INTO par_database_user_name;
    END IF;

    IF (par_output_file_name = '') THEN
        SELECT
            NULL
            INTO par_output_file_name;
    END IF
    /* Check new values */;
    CALL aws_sqlserver_ext.sp_verify_jobstep(par_job_id, par_step_id, var_new_step_name, par_subsystem, par_command, par_server, par_on_success_action, par_on_success_step_id, par_on_fail_action, par_on_fail_step_id, par_os_run_priority, par_database_name, par_database_user_name, par_flags, par_output_file_name, var_new_proxy_id, var_retval);

    IF (var_retval <> 0) THEN
        SET ReturnCode := (1);
        LEAVE return_label;
    END IF
    /* Failure */
    /* Update the job's version/last-modified information */;
    UPDATE aws_sqlserver_ext.sysjobs
        SET version_number = version_number + 1
        /* date_modified = GETDATE() */
        WHERE (job_id = par_job_id)
    /* Update the step */;
    UPDATE aws_sqlserver_ext.sysjobsteps
        SET step_name = par_step_name, subsystem = par_subsystem, command = par_command, flags = par_flags, additional_parameters = par_additional_parameters, cmdexec_success_code = par_cmdexec_success_code, on_success_action = par_on_success_action, on_success_step_id = par_on_success_step_id, on_fail_action = par_on_fail_action, on_fail_step_id = par_on_fail_step_id, server = par_server, database_name = par_database_name, database_user_name = par_database_user_name, retry_attempts = par_retry_attempts, retry_interval = par_retry_interval, os_run_priority = par_os_run_priority, output_file_name = par_output_file_name, last_run_outcome = var_x_last_run_outcome, last_run_duration = var_x_last_run_duration, last_run_retries = var_x_last_run_retries, last_run_date = var_x_last_run_date, last_run_time = var_x_last_run_time, proxy_id = var_new_proxy_id
        WHERE (job_id = par_job_id) AND (step_id = par_step_id);
    SET ReturnCode := (0);
    LEAVE return_label
    /* Success */;
END]]></complex-attribute>
                        <category _I_D="47adb776-44b8-45cb-917b-cec4957e76ab" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="b24390ee-ffb7-43e1-bffd-073b5c8f1e47" name="sp_update_schedule" context="sp_update_schedule" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
    DECLARE var_retval INT;
    DECLARE var_owner_sid CHAR (85);
    DECLARE var_cur_owner_sid CHAR (85);
    DECLARE var_x_name VARCHAR (128);
    DECLARE var_enable_only_used INT;
    DECLARE var_x_enabled TINYINT UNSIGNED;
    DECLARE var_x_freq_type INT;
    DECLARE var_x_freq_interval INT;
    DECLARE var_x_freq_subday_type INT;
    DECLARE var_x_freq_subday_interval INT;
    DECLARE var_x_freq_relative_interval INT;
    DECLARE var_x_freq_recurrence_factor INT;
    DECLARE var_x_active_start_date INT;
    DECLARE var_x_active_end_date INT;
    DECLARE var_x_active_start_time INT;
    DECLARE var_x_active_end_time INT;
    DECLARE var_schedule_uid CHAR (38)
    /* Remove any leading/trailing spaces from parameters */;
    SELECT
        LTRIM(RTRIM(par_name))
        INTO par_name;
    SELECT
        LTRIM(RTRIM(par_new_name))
        INTO par_new_name;
    SELECT
        LTRIM(RTRIM(par_owner_login_name))
        INTO par_owner_login_name
    /* Turn [nullable] empty string parameters into NULLs */;

    IF (par_new_name = '') THEN
        SELECT
            NULL
            INTO par_new_name;
    END IF
    /* Check that we can uniquely identify the schedule. This only returns a schedule that is visible to this user */;
    CALL aws_sqlserver_ext.sp_verify_schedule_identifiers ('@name', '@schedule_id', par_name, par_schedule_id, var_cur_owner_sid, NULL, NULL, var_retval)
    /* @job_id_filter */;

    IF (var_retval <> 0) THEN
        SET ReturnCode := (1);
        LEAVE return_label;
    END IF
    /* Failure */
    /* Is @enable the only parameter used beside jobname and jobid? */;

    IF ((par_enabled IS NOT NULL) AND (par_new_name IS NULL) AND (par_freq_type IS NULL) AND (par_freq_interval IS NULL) AND (par_freq_subday_type IS NULL) AND (par_freq_subday_interval IS NULL) AND (par_freq_relative_interval IS NULL) AND (par_freq_recurrence_factor IS NULL) AND (par_active_start_date IS NULL) AND (par_active_end_date IS NULL) AND (par_active_start_time IS NULL) AND (par_active_end_time IS NULL) AND (par_owner_login_name IS NULL)) THEN
        SELECT
            1
            INTO var_enable_only_used;
    ELSE
        SELECT
            0
            INTO var_enable_only_used;
    END IF
    /* If the param @owner_login_name is null or doesn't get resolved by SUSER_SID() set it to the current owner of the schedule */;

    IF (var_owner_sid IS NULL) THEN
        SELECT
            var_cur_owner_sid
            INTO var_owner_sid;
    END IF
    /* Set the x_ (existing) variables */;
    SELECT
        name, enabled, freq_type, freq_interval, freq_subday_type, freq_subday_interval, freq_relative_interval, freq_recurrence_factor, active_start_date, active_end_date, active_start_time, active_end_time
        INTO var_x_name, var_x_enabled, var_x_freq_type, var_x_freq_interval, var_x_freq_subday_type, var_x_freq_subday_interval, var_x_freq_relative_interval, var_x_freq_recurrence_factor, var_x_active_start_date, var_x_active_end_date, var_x_active_start_time, var_x_active_end_time
        FROM aws_sqlserver_ext.sysschedules
        WHERE (schedule_id = par_schedule_id)
    /* Fill out the values for all non-supplied parameters from the existing values */;

    IF (par_new_name IS NULL) THEN
        SELECT
            var_x_name
            INTO par_new_name;
    END IF;

    IF (par_enabled IS NULL) THEN
        SELECT
            var_x_enabled
            INTO par_enabled;
    END IF;

    IF (par_freq_type IS NULL) THEN
        SELECT
            var_x_freq_type
            INTO par_freq_type;
    END IF;

    IF (par_freq_interval IS NULL) THEN
        SELECT
            var_x_freq_interval
            INTO par_freq_interval;
    END IF;

    IF (par_freq_subday_type IS NULL) THEN
        SELECT
            var_x_freq_subday_type
            INTO par_freq_subday_type;
    END IF;

    IF (par_freq_subday_interval IS NULL) THEN
        SELECT
            var_x_freq_subday_interval
            INTO par_freq_subday_interval;
    END IF;

    IF (par_freq_relative_interval IS NULL) THEN
        SELECT
            var_x_freq_relative_interval
            INTO par_freq_relative_interval;
    END IF;

    IF (par_freq_recurrence_factor IS NULL) THEN
        SELECT
            var_x_freq_recurrence_factor
            INTO par_freq_recurrence_factor;
    END IF;

    IF (par_active_start_date IS NULL) THEN
        SELECT
            var_x_active_start_date
            INTO par_active_start_date;
    END IF;

    IF (par_active_end_date IS NULL) THEN
        SELECT
            var_x_active_end_date
            INTO par_active_end_date;
    END IF;

    IF (par_active_start_time IS NULL) THEN
        SELECT
            var_x_active_start_time
            INTO par_active_start_time;
    END IF;

    IF (par_active_end_time IS NULL) THEN
        SELECT
            var_x_active_end_time
            INTO par_active_end_time;
    END IF
    /* Check schedule (frequency and owner) parameters */;
    CALL aws_sqlserver_ext.sp_verify_schedule (par_schedule_id
    /* @schedule_id */, par_new_name
    /* @name */, par_enabled
    /* @enabled */, par_freq_type
    /* @freq_type */, par_freq_interval
    /* @freq_interval */, par_freq_subday_type
    /* @freq_subday_type */, par_freq_subday_interval
    /* @freq_subday_interval */, par_freq_relative_interval
    /* @freq_relative_interval */, par_freq_recurrence_factor
    /* @freq_recurrence_factor */, par_active_start_date
    /* @active_start_date */, par_active_start_time
    /* @active_start_time */, par_active_end_date
    /* @active_end_date */, par_active_end_time
    /* @active_end_time */, var_owner_sid, var_retval) /* @owner_sid */;

    IF (var_retval <> 0) THEN
        SET ReturnCode := (1);
        LEAVE return_label;
    END IF
    /* Failure */
    /* Update the sysschedules table */;
    UPDATE aws_sqlserver_ext.sysschedules
        SET name = par_new_name, owner_sid = var_owner_sid, enabled = par_enabled, freq_type = par_freq_type, freq_interval = par_freq_interval, freq_subday_type = par_freq_subday_type, freq_subday_interval = par_freq_subday_interval, freq_relative_interval = par_freq_relative_interval, freq_recurrence_factor = par_freq_recurrence_factor, active_start_date = par_active_start_date, active_end_date = par_active_end_date, active_start_time = par_active_start_time, active_end_time = par_active_end_time
        /* date_modified          = GETDATE(), */, version_number = version_number + 1
        WHERE (schedule_id = par_schedule_id);
    SELECT
        0
        INTO var_retval
    /* @@error */
    /* update any job that has repl steps */
    /*
DECLARE @job_id UNIQUEIDENTIFIER
  DECLARE jobsschedule_cursor CURSOR LOCAL FOR
  SELECT job_id
  FROM dbo.sysjobschedules
  WHERE (schedule_id = @schedule_id)

  IF @x_freq_type <> @freq_type
  BEGIN
    OPEN jobsschedule_cursor
    FETCH NEXT FROM jobsschedule_cursor INTO @job_id

    WHILE (@@FETCH_STATUS = 0)
    BEGIN
      EXEC  sp_update_replication_job_parameter @job_id = @job_id,
                                                @old_freq_type = @x_freq_type,
                                                @new_freq_type = @freq_type
      FETCH NEXT FROM jobsschedule_cursor INTO @job_id
    END
    CLOSE jobsschedule_cursor
  END
  DEALLOCATE jobsschedule_cursor
*/;
    SET ReturnCode := (var_retval);
    LEAVE return_label
    /* 0 means success */;
END]]></complex-attribute>
                        <category _I_D="e213447b-3bad-40f7-90b3-155c197bda86" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="c10ad8c2-494e-46e8-bc80-02aadb9df8a2" name="sp_verify_job" context="sp_verify_job" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_job_type INT;
  DECLARE var_retval INT;
  DECLARE var_current_date INT;
  DECLARE var_res_valid_range VARCHAR (200);
  DECLARE _messageText VARCHAR (255);
  DECLARE var_max_step_id INT;
  DECLARE var_valid_range VARCHAR (50);
  
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_name)) INTO par_name;
  SELECT LTRIM(RTRIM(par_category_name)) INTO par_category_name;
  SELECT UPPER(LTRIM(RTRIM(par_originating_server))) INTO par_originating_server;

  IF (
    EXISTS (
      SELECT * 
        FROM sysjobs AS job
       WHERE (name = par_name)
       /* AND (job_id <> ISNULL(@job_id, 0x911)))) -- When adding a new job @job_id is NULL */       
    )
  )
  THEN /* Failure */
    SET _messageText := CONCAT('The specified %s ("%s") already exists.', '. Argument: ', '@name', '. Argument: ', par_name);
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Check enabled state */
  IF (par_enabled <> 0) AND (par_enabled <> 1) 
  THEN /* Failure */
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@enabled', '. Argument: ', '0, 1');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Check start step */
  IF (par_job_id IS NULL) /* New job */ 
  THEN
    IF (par_start_step_id <> 1) 
    THEN /* Failure */
      SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@start_step_id', '. Argument: ', '1');
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
      SET ReturnCode := 1;
      LEAVE return_label;
    END IF;
  ELSE /* Existing job */
    /* Get current maximum step id */
    SELECT COALESCE(MAX(step_id), 0) INTO var_max_step_id
      FROM sysjobsteps
     WHERE (job_id = par_job_id);

    IF (par_start_step_id < 1) OR (par_start_step_id > var_max_step_id + 1) 
    THEN /* Failure */
      SELECT CONCAT('1..', CONVERT (var_max_step_id + 1, CHAR)) 
        INTO var_valid_range;
      SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@start_step_id', '. Argument: ', var_valid_range);
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
      SET ReturnCode := 1;
      LEAVE return_label;
    END IF;
  END IF;
  
  /* Get the category_id, handling any special-cases as appropriate */
  SELECT NULL INTO par_category_id;

  IF (par_category_name = '[DEFAULT]') /* User wants to revert to the default job category */
  THEN
     SELECT
        CASE COALESCE(var_job_type, 1) 
          WHEN 1 THEN 0 /* [Uncategorized (Local)] */
          WHEN 2 THEN 2 /* [Uncategorized (Multi-Server)] */
        END
        INTO par_category_id;
  ELSE
    SELECT 0 INTO par_category_id;
  END IF;
  
  /* Success */
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="78863091-0975-4c3c-9434-4226d28d401a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="2883f6d3-55ab-4496-bf67-6dbfa90bde93" name="sp_verify_jobstep" context="sp_verify_jobstep" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_max_step_id INT;
  DECLARE var_retval INT;
  DECLARE var_valid_values VARCHAR (50);
  DECLARE var_database_name_temp VARCHAR (258);
  DECLARE var_database_user_name_temp VARCHAR (256);
  DECLARE var_temp_command LONGTEXT;
  DECLARE var_iPos INT;
  DECLARE var_create_count INT;
  DECLARE var_destroy_count INT;
  DECLARE var_is_olap_subsystem TINYINT UNSIGNED;
  DECLARE var_owner_sid CHAR (85);
  DECLARE var_owner_name VARCHAR (128);
  DECLARE _messageText VARCHAR (255);
  
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_subsystem)) INTO par_subsystem;
  SELECT LTRIM(RTRIM(par_server)) INTO par_server;
  SELECT LTRIM(RTRIM(par_output_file_name)) INTO par_output_file_name;

  /* Get current maximum step id */
  SELECT COALESCE(MAX(step_id), 0)
    INTO var_max_step_id
    FROM sysjobsteps
   WHERE (job_id = par_job_id);
   
  /* Check step id */
  IF (par_step_id < 1) OR (par_step_id > var_max_step_id + 1) 
  THEN /* Failure */
    SELECT CONCAT('1..', CONVERT (var_max_step_id + 1, CHAR)) INTO var_valid_values;
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@step_id', '. Argument: ', var_valid_values);
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Check step name */
  IF (
    EXISTS (
      SELECT *
        FROM sysjobsteps
       WHERE (job_id = par_job_id) AND (step_name = par_step_name)
    )
  ) 
  THEN /* Failure */
    SET _messageText := CONCAT('The specified %s ("%s") already exists.', '. Argument: ', '@step_name', '. Argument: ', par_step_name);
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Check on-success action/step */
  IF (par_on_success_action <> 1) /* Quit Qith Success */
    AND (par_on_success_action <> 2) /* Quit Qith Failure */
    AND (par_on_success_action <> 3) /* Goto Next Step */
    AND (par_on_success_action <> 4) /* Goto Step */
  THEN /* Failure */
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@on_success_action', '. Argument: ', '1, 2, 3, 4');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF (par_on_success_action = 4) AND ((par_on_success_step_id < 1) OR (par_on_success_step_id = par_step_id)) 
  THEN /* Failure */
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are greater than 0 but excluding %ld).', '. Argument: ', '@on_success_step', '. Argument: ', par_step_id);
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Check on-fail action/step */
  IF (par_on_fail_action <> 1) /* Quit With Success */
    AND (par_on_fail_action <> 2) /* Quit With Failure */
    AND (par_on_fail_action <> 3) /* Goto Next Step */
    AND (par_on_fail_action <> 4) /* Goto Step */
  THEN /* Failure */
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@on_failure_action', '. Argument: ', '1, 2, 3, 4');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF (par_on_fail_action = 4) AND ((par_on_fail_step_id < 1) OR (par_on_fail_step_id = par_step_id)) 
  THEN /* Failure */
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are greater than 0 but excluding %ld).', '. Argument: ', '@on_failure_step', '. Argument: ', par_step_id);
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Warn the user about forward references */
  IF ((par_on_success_action = 4) AND (par_on_success_step_id > var_max_step_id)) 
  THEN
    SET _messageText := CONCAT('Warning: Non-existent step referenced by %s.', '. Argument: ', '@on_success_step_id');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
  END IF;

  IF ((par_on_fail_action = 4) AND (par_on_fail_step_id > var_max_step_id)) 
  THEN
    SET _messageText := CONCAT('Warning: Non-existent step referenced by %s.', '. Argument: ', '@on_fail_step_id');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
  END IF;
  
  /* Check run priority: must be a valid value to pass to SetThreadPriority: */
  /* [-15 = IDLE, -1 = BELOW_NORMAL, 0 = NORMAL, 1 = ABOVE_NORMAL, 15 = TIME_CRITICAL] */
  IF (par_os_run_priority NOT IN (- 15, - 1, 0, 1, 15)) 
  THEN /* Failure */
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@os_run_priority', '. Argument: ', '-15, -1, 0, 1, 15');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Check flags */
  IF ((par_flags < 0) OR (par_flags > 114)) 
  THEN /* Failure */
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@flags', '. Argument: ', '0..114');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF (UPPER(par_subsystem) <> 'TSQL') 
  THEN /* Failure */
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@subsystem', '. Argument: ', 'TSQL');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Success */
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="52d2421e-e7cc-495b-a444-e75621da4f6c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="34fe1ec0-aee3-4cd7-b229-d8b4ca945d13" name="sp_verify_job_date" context="sp_verify_job_date" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_date_name)) INTO par_date_name;
  
  /*
  IF ((ISDATE(CONVERT(VARCHAR, @date)) = 0) OR (@date < 19900101) OR (@date > 99991231))
  BEGIN
    RAISERROR('The specified "%s" is invalid (valid values are: %s).', 0, 0, @date_name, '19900101..99991231')
    RETURN(1) -- Failure
  END
  */
  
  /* Success */
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="bb4c729f-0618-4005-bf2e-e4c8cfbd4e14" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="4a8d1a79-b33b-4d8c-92fe-7969b7840a51" name="sp_verify_job_identifiers" context="sp_verify_job_identifiers" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_retval INT;
  DECLARE var_job_id_as_char VARCHAR (36);
  DECLARE _messageText VARCHAR (255);
  
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_name_of_name_parameter)) INTO par_name_of_name_parameter;
  SELECT LTRIM(RTRIM(par_name_of_id_parameter)) INTO par_name_of_id_parameter;
  SELECT LTRIM(RTRIM(par_job_name)) INTO par_job_name;

  IF (par_job_name = '') 
  THEN
    SELECT NULL INTO par_job_name;
  END IF;

  IF ((par_job_name IS NULL) AND (par_job_id IS NULL)) OR ((par_job_name IS NOT NULL) AND (par_job_id IS NOT NULL)) 
  THEN /* Failure */
    SET _messageText := CONCAT('Supply either %s or %s to identify the job.', '. Argument: ', par_name_of_id_parameter, '. Argument: ', par_name_of_name_parameter);
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Check job id */
  IF (par_job_id IS NOT NULL) 
  THEN
    SELECT name
         , owner_sid
      INTO par_job_name
         , par_owner_sid
      FROM sysjobs
     WHERE (job_id = par_job_id);
     
    /* the view would take care of all the permissions issues. */
    IF (par_job_name IS NULL) 
    THEN /* Failure */
      SELECT CONVERT (par_job_id, CHAR)
        INTO var_job_id_as_char;
      SET _messageText := CONCAT('The specified %s ("%s") does not exist.', '. Argument: ', '@job_id', '. Argument: ', var_job_id_as_char);
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
      SET ReturnCode := 1;
      LEAVE return_label;
    END IF;   
  ELSE
    /* Check job name */
    IF (par_job_name IS NOT NULL) 
    THEN
      /* Check if the job name is ambiguous */
      IF (SELECT COUNT(*) FROM sysjobs WHERE (name = par_job_name)) > 1 
      THEN /* Failure */
        SET _messageText := CONCAT('There are two or more jobs named "%s". Specify %s instead of %s to uniquely identify the job.', '. Argument: ', par_job_name, '. Argument: ', par_name_of_id_parameter, '. Argument: ', par_name_of_name_parameter);
        SIGNAL SQLSTATE VALUE '50000'                     SET MESSAGE_TEXT = _messageText;
        SET ReturnCode := 1;
        LEAVE return_label;
      END IF;
      
      /* The name is not ambiguous, so get the corresponding job_id (if the job exists) */
      SELECT job_id
           , owner_sid
        INTO par_job_id
           , par_owner_sid
        FROM sysjobs
       WHERE (name = par_job_name);
       
      /* the view would take care of all the permissions issues. */
      IF (par_job_id IS NULL) 
      THEN /* Failure */
        SET _messageText := CONCAT('The specified %s ("%s") does not exist.', '. Argument: ', '@job_name', '. Argument: ', par_job_name);
        SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
        SET ReturnCode := 1;
        LEAVE return_label;
      END IF;
    END IF;
  END IF;
  
  /* Success */
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="def93c7a-29f7-4543-8fb7-70b3074f85b1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="d6c37636-5491-4ee6-870c-c0400c3af6d7" name="sp_verify_job_time" context="sp_verify_job_time" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_hour INT;
  DECLARE var_minute INT;
  DECLARE var_second INT;
  DECLARE _messageText VARCHAR (255);
  
  SET ReturnCode := 0;
  LEAVE return_label;


  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_time_name)) INTO par_time_name;

  IF ((par_time < 0) OR (par_time > 235959)) 
  THEN
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', par_time_name, '. Argument: ', '000000..235959');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  SELECT (par_time / 10000) INTO var_hour;
  SELECT (par_time % 10000) / 100 INTO var_minute;
  SELECT (par_time % 100) INTO var_second;

  /* Check hour range */
  IF (var_hour > 23) 
  THEN
    SET _messageText := CONCAT('The "%s" supplied has an invalid %s.', '. Argument: ', par_time_name, '. Argument: ', 'hour');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Check minute range */
  IF (var_minute > 59) 
  THEN
    SET _messageText := CONCAT('Message: The "%s" supplied has an invalid %s.', '. Argument: ', par_time_name, '. Argument: ', 'minute');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Check second range */
  IF (var_second > 59) 
  THEN
    SET _messageText := CONCAT('The "%s" supplied has an invalid %s.', '. Argument: ', par_time_name, '. Argument: ', 'second');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="da47d6e3-4383-4722-b237-a51a201e99db" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="3069122a-3f12-4e00-9187-e4e520e5828a" name="sp_verify_schedule" context="sp_verify_schedule" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_return_code INT;
  DECLARE var_isAdmin INT;
  DECLARE _messageText VARCHAR (255);
  
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_name)) INTO par_name;
  
  /* Make sure that NULL input/output parameters - if NULL - are initialized to 0 */
  SELECT COALESCE(par_freq_interval, 0) INTO par_freq_interval;
  SELECT COALESCE(par_freq_subday_type, 0) INTO par_freq_subday_type;
  SELECT COALESCE(par_freq_subday_interval, 0) INTO par_freq_subday_interval;
  SELECT COALESCE(par_freq_relative_interval, 0) INTO par_freq_relative_interval;
  SELECT COALESCE(par_freq_recurrence_factor, 0) INTO par_freq_recurrence_factor;
  SELECT COALESCE(par_active_start_date, 0) INTO par_active_start_date;
  SELECT COALESCE(par_active_start_time, 0) INTO par_active_start_time;
  SELECT COALESCE(par_active_end_date, 0) INTO par_active_end_date;
  SELECT COALESCE(par_active_end_time, 0) INTO par_active_end_time;
  
  /* Verify name (we disallow schedules called 'ALL' since this has special meaning in sp_delete_jobschedules) */
  SELECT 0 INTO var_isAdmin;

  IF (
    EXISTS (
      SELECT * 
        FROM sysschedules
       WHERE (name = par_name)
    )
  ) 
  THEN /* Failure */
    SET _messageText := CONCAT('The specified %s ("%s") already exists.', '. Argument: ', '@name', '. Argument: ', par_name);
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF (UPPER(par_name) = 'ALL') 
  THEN /* Failure */
    SET _messageText := CONCAT('The specified "%s" is invalid.', '. Argument: ', '@name');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Verify enabled state */
  IF (par_enabled <> 0) AND (par_enabled <> 1) 
  THEN /* Failure */
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@enabled', '. Argument: ', '0, 1');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Verify frequency type */
  IF (par_freq_type = 2) /* OnDemand is no longer supported */
  THEN /* Failure */
    SIGNAL SQLSTATE VALUE '50000'  SET MESSAGE_TEXT = 'Frequency Type 0x2 (OnDemand) is no longer supported.';
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF (par_freq_type NOT IN (1, 4, 8, 16, 32, 64, 128)) 
  THEN /* Failure */
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@freq_type', '. Argument: ', '1, 4, 8, 16, 32, 64, 128');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Verify frequency sub-day type */
  IF (par_freq_subday_type <> 0) AND (par_freq_subday_type NOT IN (1, 2, 4, 8)) 
  THEN /* Failure */
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@freq_subday_type', '. Argument: ', '0x1, 0x2, 0x4, 0x8');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Default active start/end date/times (if not supplied, or supplied as NULLs or 0) */
  IF (par_active_start_date = 0) 
  THEN
    SELECT YEAR(NOW()) * 10000 + MONTH(NOW()) * 100 + DAYOFMONTH(NOW())
      INTO par_active_start_date;
  END IF;
  
  /* This is an ISO format: "yyyymmdd" */
  IF (par_active_end_date = 0) 
  THEN
    /* December 31st 9999 */
    SELECT 99991231 INTO par_active_end_date;
  END IF;

  IF (par_active_start_time = 0) 
  THEN
    /* 12:00:00 am */
    SELECT 000000 INTO par_active_start_time;
  END IF;

  IF (par_active_end_time = 0) 
  THEN
    /* 11:59:59 pm */
    SELECT 235959 INTO par_active_end_time;
  END IF;
    
  /* Verify active start/end dates */
  IF (par_active_end_date = 0) 
  THEN
    SELECT 99991231 INTO par_active_end_date;
  END IF;
  
  CALL aws_sqlserver_ext.sp_verify_job_date (par_active_end_date, 'active_end_date', var_return_code);

  IF (var_return_code <> 0) 
  THEN /* Failure */
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  CALL aws_sqlserver_ext.sp_verify_job_date (par_active_start_date, 'active_start_date', var_return_code);

  IF (var_return_code <> 0) 
  THEN /* Failure */
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  IF (par_active_end_date < par_active_start_date) 
  THEN /* Failure */
    SET _messageText := CONCAT('%s cannot be before %s.', '. Argument: ', 'active_end_date', '. Argument: ', 'active_start_date');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  CALL aws_sqlserver_ext.sp_verify_job_time (par_active_end_time, 'active_end_time', var_return_code);

  IF (var_return_code <> 0) 
  THEN /* Failure */
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  CALL aws_sqlserver_ext.sp_verify_job_time(par_active_start_time, 'active_start_time', var_return_code);

  IF (var_return_code <> 0) 
  THEN /* Failure */
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
    
  IF (par_active_start_time = par_active_end_time AND (par_freq_subday_type IN (2, 4, 8))) 
  THEN /* Failure */
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@active_end_time', '. Argument: ', 'before or after @active_start_time');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF ((par_freq_type = 1) /* FREQTYPE_ONETIME */
    OR (par_freq_type = 64) /* FREQTYPE_AUTOSTART */
    OR (par_freq_type = 128)) /* FREQTYPE_ONIDLE */
  THEN /* Set standard defaults for non-required parameters */
    SELECT 0 INTO par_freq_interval;
    SELECT 0 INTO par_freq_subday_type;
    SELECT 0 INTO par_freq_subday_interval;
    SELECT 0 INTO par_freq_relative_interval;
    SELECT 0 INTO par_freq_recurrence_factor;
    /* Success */    
    SET ReturnCode := 0;
    LEAVE return_label;
  END IF;
  
  IF (par_freq_subday_type = 0) /* FREQSUBTYPE_ONCE */
  THEN
    SELECT 1 INTO par_freq_subday_type;
  END IF;

  IF ((par_freq_subday_type <> 1) /* FREQSUBTYPE_ONCE */
    AND (par_freq_subday_type <> 2) /* FREQSUBTYPE_SECOND */
    AND (par_freq_subday_type <> 4) /* FREQSUBTYPE_MINUTE */
    AND (par_freq_subday_type <> 8)) /* FREQSUBTYPE_HOUR */
  THEN /* Failure */
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'The schedule for this job is invalid (reason: The specified @freq_subday_type is invalid (valid values are: 0x1, 0x2, 0x4, 0x8).).';
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF ((par_freq_subday_type <> 0x1) AND (par_freq_subday_interval < 1)) /* FREQSUBTYPE_ONCE and less than 1 interval */
    OR ((par_freq_subday_type = 0x2) AND (par_freq_subday_interval < 10)) /* FREQSUBTYPE_SECOND and less than 10 seconds (see MIN_SCHEDULE_GRANULARITY in SqlAgent source code) */
  THEN /* Failure */
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'The schedule for this job is invalid (reason: The specified @freq_subday_interval is invalid).';
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF (par_freq_type = 4) /* FREQTYPE_DAILY */
  THEN
    SELECT 0 INTO par_freq_recurrence_factor;

    IF (par_freq_interval < 1) 
    THEN /* Failure */
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'The schedule for this job is invalid (reason: @freq_interval must be at least 1 for a daily job.).';
      SET ReturnCode := 1;
      LEAVE return_label;
    END IF;
  END IF;

  IF (par_freq_type = 8) /* FREQTYPE_WEEKLY */
  THEN
    IF (par_freq_interval < 1) OR (par_freq_interval > 127) /* (2^7)-1 [freq_interval is a bitmap (Sun=1..Sat=64)] */
    THEN /* Failure */
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'The schedule for this job is invalid (reason: @freq_interval must be a valid day of the week bitmask [Sunday = 1 .. Saturday = 64] for a weekly job.).';
      SET ReturnCode := 1;
      LEAVE return_label;
    END IF;
  END IF;

  IF (par_freq_type = 16) /* FREQTYPE_MONTHLY */
  THEN
    IF (par_freq_interval < 1) OR (par_freq_interval > 31) 
    THEN /* Failure */
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'The schedule for this job is invalid (reason: @freq_interval must be between 1 and 31 for a monthly job.).';
      SET ReturnCode := 1;
      LEAVE return_label;
    END IF;
  END IF;

  IF (par_freq_type = 32) /* FREQTYPE_MONTHLYRELATIVE */
  THEN
    IF (par_freq_relative_interval <> 1) /* RELINT_1ST */
      AND (par_freq_relative_interval <> 2) /* RELINT_2ND */
      AND (par_freq_relative_interval <> 4) /* RELINT_3RD */
      AND (par_freq_relative_interval <> 8) /* RELINT_4TH */
      AND (par_freq_relative_interval <> 16) /* RELINT_LAST */
    THEN /* Failure */
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'The schedule for this job is invalid (reason: @freq_relative_interval must be one of 1st (0x1), 2nd (0x2), 3rd [0x4], 4th (0x8) or Last (0x10).).';
      SET ReturnCode := 1;
      LEAVE return_label;
    END IF;
  END IF;

  IF (par_freq_type = 32) /* FREQTYPE_MONTHLYRELATIVE */
  THEN
    IF (par_freq_interval <> 01) /* RELATIVE_SUN */
      AND (par_freq_interval <> 02) /* RELATIVE_MON */
      AND (par_freq_interval <> 03) /* RELATIVE_TUE */
      AND (par_freq_interval <> 04) /* RELATIVE_WED */
      AND (par_freq_interval <> 05) /* RELATIVE_THU */
      AND (par_freq_interval <> 06) /* RELATIVE_FRI */
      AND (par_freq_interval <> 07) /* RELATIVE_SAT */
      AND (par_freq_interval <> 08) /* RELATIVE_DAY */
      AND (par_freq_interval <> 09) /* RELATIVE_WEEKDAY */
      AND (par_freq_interval <> 10) /* RELATIVE_WEEKENDDAY */
    THEN /* Failure */
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'The schedule for this job is invalid (reason: @freq_interval must be between 1 and 10 (1 = Sunday .. 7 = Saturday, 8 = Day, 9 = Weekday, 10 = Weekend-day) for a monthly-relative job.).';
      SET ReturnCode := 1;
      LEAVE return_label;
    END IF;
  END IF;

  IF ((par_freq_type = 8) /* FREQTYPE_WEEKLY */
    OR (par_freq_type = 16) /* FREQTYPE_MONTHLY */
    OR (par_freq_type = 32)) /* FREQTYPE_MONTHLYRELATIVE */
    AND (par_freq_recurrence_factor < 1)
  THEN /* Failure */
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'The schedule for this job is invalid (reason: @freq_recurrence_factor must be at least 1.).';
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Success */
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="36284e5d-7fc3-45c6-a05d-d0c9c69b65ff" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="19c9d5d5-926d-44cc-9094-35007e77b713" name="sp_verify_schedule_identifiers" context="sp_verify_schedule_identifiers" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_retval INT;
  DECLARE var_schedule_id_as_char VARCHAR (36);
  DECLARE var_sch_name_count INT;
  DECLARE _messageText VARCHAR (255);
  
  /* Remove any leading/trailing spaces from parameters */
  SELECT LTRIM(RTRIM(par_name_of_name_parameter)) INTO par_name_of_name_parameter;
  SELECT LTRIM(RTRIM(par_name_of_id_parameter)) INTO par_name_of_id_parameter;
  SELECT LTRIM(RTRIM(par_schedule_name)) INTO par_schedule_name;
  SELECT 0 INTO var_sch_name_count;

  IF (par_schedule_name = '') 
  THEN
    SELECT NULL INTO par_schedule_name;
  END IF;

  IF ((par_schedule_name IS NULL) AND (par_schedule_id IS NULL)) OR ((par_schedule_name IS NOT NULL) AND (par_schedule_id IS NOT NULL)) 
  THEN /* Failure */
    SET _messageText := CONCAT('Supply either %s or %s to identify the schedule.', '. Argument: ', par_name_of_id_parameter, '. Argument: ', par_name_of_name_parameter);
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /* Check schedule id */
  IF (par_schedule_id IS NOT NULL) 
  THEN
    /* Look at all schedules */
    SELECT name
         , owner_sid
         , originating_server_id
      INTO par_schedule_name
         , par_owner_sid
         , par_orig_server_id
      FROM sysschedules
     WHERE (schedule_id = par_schedule_id);

    IF (par_schedule_name IS NULL) 
    THEN /* Failure */
      SELECT CONVERT (par_schedule_id, CHAR)
        INTO var_schedule_id_as_char;
       
      SET _messageText := CONCAT('The specified %s ("%s") does not exist.', '. Argument: ', '@schedule_id', '. Argument: ', var_schedule_id_as_char);
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
      SET ReturnCode := 1;
      LEAVE return_label;
    END IF;
  ELSE 
    IF (par_schedule_name IS NOT NULL)
    THEN
      /* Check if the schedule name is ambiguous */
      IF (SELECT COUNT(*) FROM sysschedules WHERE name = par_schedule_name) > 1 
      THEN /* Failure */
        SET _messageText := CONCAT('There are two or more sysschedules named "%". Specify % instead of % to uniquely identify the sysschedules.', '. Argument: ', '@schedule_id', '. Argument: ', var_schedule_id_as_char);
        SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
        SET ReturnCode := 1;
        LEAVE return_label;
      END IF;
    
      /* The name is not ambiguous, so get the corresponding job_id (if the job exists) */
      SELECT schedule_id
           , owner_sid
        INTO par_schedule_id, par_owner_sid
        FROM sysschedules
       WHERE (name = par_schedule_name);
     
      /* the view would take care of all the permissions issues. */
      IF (par_schedule_id IS NULL) 
      THEN /* Failure */
        SET _messageText := CONCAT('The specified % ("%") does not exist.', '. Argument: ', 'par_schedule_name', '. Argument: ', par_schedule_name);
        SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
        SET ReturnCode := 1;
        LEAVE return_label;
      END IF;
    END IF;
  END IF;
  
  /* Success */
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="3e7e23ca-4471-4854-89e0-94ef85ece2a6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="69a5841f-88ec-4671-9272-8f44da5f72a1" name="sysmail_add_account_sp" context="sysmail_add_account_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_rc INT;
  DECLARE _messageText VARCHAR (255);
  
  CALL aws_sqlserver_ext.sysmail_verify_addressparams_sp (par_replyto_address, 'par_replyto_address', var_rc);

  IF (var_rc <> 0) 
  THEN
    SET ReturnCode := var_rc;
    LEAVE return_label;
  END IF;

  IF (par_mailserver_name IS NULL) 
  THEN /* Failure */
    SET _messageText := CONCAT('%s is not a valid mailserver_name', '. Argument: ', par_mailserver_name);
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF (par_mailserver_type IS NULL) 
  THEN /* Failure */
    SET _messageText := CONCAT('%s is not a valid par_mailserver_type', '. Argument: ', par_mailserver_type);
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  INSERT 
    INTO aws_sqlserver_ext.sysmail_account (
         name
       , description
       , email_address
       , display_name
       , replyto_address) 
  VALUES (
         par_account_name
       , par_description
       , par_email_address
       , par_display_name
       , par_replyto_address);
       
  SELECT account_id
    INTO par_account_id
    FROM aws_sqlserver_ext.sysmail_account
   WHERE name = par_account_name;


  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="01a2d0ea-6b01-423f-a5f7-2ee703916852" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="cd4ada68-f201-4b25-93c0-c06911fdcddf" name="sysmail_add_profileaccount_sp" context="sysmail_add_profileaccount_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_rc INT;
  DECLARE var_profileid INT;
  DECLARE var_accountid INT;
  
  CALL aws_sqlserver_ext.sysmail_verify_profile_sp (par_profile_id, par_profile_name, 0, 0, var_profileid, var_rc);

  IF var_rc <> 0 
  THEN
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  CALL aws_sqlserver_ext.sysmail_verify_account_sp (par_account_id, par_account_name, 0, 0, var_accountid, var_rc);

  IF var_rc <> 0 
  THEN
    SET ReturnCode := 2;
    LEAVE return_label;
  END IF;
  
  /* insert new account record, rely on primary key constraint to error out */
  INSERT INTO aws_sqlserver_ext.sysmail_profileaccount (profile_id, account_id, sequence_number)
  VALUES (var_profileid, var_accountid, par_sequence_number);
  
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="1ccd225f-fcfc-43a1-b220-687c13de19f9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="7a903df6-e8e2-4cba-a9db-4691d0452b51" name="sysmail_add_profile_sp" context="sysmail_add_profile_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  /* insert new profile record, rely on primary key constraint to error out */
  INSERT INTO sysmail_profile (name, description)
  VALUES (par_profile_name, par_description);
  
  /* fetch back profile_id */
  SELECT profile_id
    INTO par_profile_id
    FROM sysmail_profile
   WHERE name = par_profile_name;
   
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="3f2f78f1-a7c9-4860-b8be-73fd03e0b4d4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="337bfa85-18cb-404c-bc8d-f8d126c2c2a3" name="sysmail_dbmail_json" context="sysmail_dbmail_json" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_r VARCHAR (2) DEFAULT CONCAT(CAST(CHAR(10) AS CHAR (1)), CAST(CHAR(13) AS CHAR (1)));
  DECLARE var_t1 VARCHAR (2) DEFAULT '  ';
  DECLARE var_t2 VARCHAR (4) DEFAULT '    ';
  DECLARE var_t3 VARCHAR (6) DEFAULT '      ';
  DECLARE var_t4 VARCHAR (8) DEFAULT '        ';
  DECLARE var_xml LONGTEXT DEFAULT '';
  DECLARE var_source VARCHAR (255);
  DECLARE var_profile_id INT;
  DECLARE var_recipients LONGTEXT;
  DECLARE var_copy_recipients LONGTEXT;
  DECLARE var_blind_copy_recipients LONGTEXT;
  DECLARE var_subject VARCHAR (255);
  DECLARE var_body_format VARCHAR (20);
  DECLARE var_body LONGTEXT;
  DECLARE var_from_address LONGTEXT;
  DECLARE var_reply_to LONGTEXT;
  DECLARE var_importance VARCHAR (6);
  DECLARE var_sensitivity VARCHAR (12);
  DECLARE var_mailitem_id INT;

  SELECT mailitem_id
       , profile_id
       , recipients
       , copy_recipients
       , blind_copy_recipients
       , subject
       , UPPER(body_format)
       , body
       , importance
       , sensitivity
       /* @file_attachments = file_attachments, */
       /* @attachment_encoding = attachment_encoding, */
       /* @query = query, */
       /* @execute_query_database = execute_query_database, */
       /* @attach_query_result_as_file = attach_query_result_as_file, */
       /* @query_result_header = query_result_header, */
       /* @query_result_width = query_result_width, */
       /* @query_result_separator = query_result_separator, */
       /* @exclude_query_output = exclude_query_output, */
       /* @append_query_error = append_query_error, */
       , from_address
       , reply_to
    INTO var_mailitem_id
       , var_profile_id
       , var_recipients
       , var_copy_recipients
       , var_blind_copy_recipients
       , var_subject
       , var_body_format
       , var_body
       , var_importance
       , var_sensitivity
       , var_from_address
       , var_reply_to
    FROM aws_sqlserver_ext.sysmail_mailitems
   WHERE mailitem_id = par_mail_id /* sent_status = 0 */
   ORDER BY mailitem_id ASC
   LIMIT 1;

  IF (var_mailitem_id IS NULL) 
  THEN
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'E-mail messages are missing.';
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  SELECT CASE
           WHEN CHAR_LENGTH(a.display_name) = 0 THEN a.email_address
           ELSE CONCAT(a.display_name, ' <', a.email_address, '>')
         END
    INTO var_source
    FROM aws_sqlserver_ext.sysmail_profile AS p
   INNER JOIN aws_sqlserver_ext.sysmail_profileaccount AS pa
      ON pa.profile_id = p.profile_id
   INNER JOIN aws_sqlserver_ext.sysmail_account AS a
      ON a.account_id = pa.account_id
   WHERE p.profile_id = var_profile_id
   LIMIT 1;

  SELECT servername
    INTO par_server_name
    FROM aws_sqlserver_ext_data.sysmail_server
   WHERE account_id = 0
     AND servertype = 'AWSLAMBDA'
   LIMIT 1;

  IF (par_server_name IS NULL) 
  THEN
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'ARN are missing.';
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  SET var_xml := CONCAT(var_xml, '{', var_r);
  SET var_xml := CONCAT(var_xml, var_t1, '"service": "ses",', var_r);
  SET var_xml := CONCAT(var_xml, var_t1, '"args": {', var_r);
  /* set source */
  SET var_xml := CONCAT(var_xml, var_t2, '"source": "', var_source, '",', var_r);
  /* recipients */
  SET var_xml := CONCAT(var_xml, var_t2, '"recipients": [', var_r);
  SET var_xml := CONCAT(var_xml, var_t3, '"', var_recipients, '"', var_r);     /* !!!!!!!!!! */
  /* SET @xml = CONCAT(@xml, @t3, '"address": "hello1 <hello1@rusgl.info>",', @r);    !!!!!!!!!! */
  /* SET @xml = CONCAT(@xml, @t3, '"address": "hello2@rusgl.info"', @r);    !!!!!!!!!! */
  SET var_xml := CONCAT(var_xml, var_t2, '],', var_r);
  
  /* copy_recipients */
  SET var_xml := CONCAT(var_xml, var_t2, '"copyrecipients": [', var_r);
  IF (var_copy_recipients IS NOT NULL AND CHAR_LENGTH(var_copy_recipients) > 0) 
  THEN
    SET var_xml := CONCAT(var_xml, var_t3, '"', var_copy_recipients, '",', var_r);         /* !!!!!!!!!! */
    /* SET @xml = CONCAT(@xml, @t3, '"address": "hello3 <hello3@rusgl.info>",', @r);    !!!!!!!!!! */
    /* SET @xml = CONCAT(@xml, @t3, '"address": "hello4@rusgl.info"', @r);    !!!!!!!!!! */
  END IF;
  SET var_xml := CONCAT(var_xml, var_t2, '],', var_r);

  /* blind_copy_recipients */
  SET var_xml := CONCAT(var_xml, var_t2, '"blindcopyrecipients": [', var_r);
  IF (var_blind_copy_recipients IS NOT NULL AND CHAR_LENGTH(var_blind_copy_recipients) > 0) 
  THEN
    SET var_xml := CONCAT(var_xml, var_t3, '"', var_blind_copy_recipients, '",', var_r);         /* !!!!!!!!!! */
    /* SET @xml = CONCAT(@xml, @t3, '"address": "hello5 <hello5@rusgl.info>",', @r);   -- !!!!!!!!!! */
    /* SET @xml = CONCAT(@xml, @t3, '"address": "hello6@rusgl.info"', @r);   -- !!!!!!!!!! */
  END IF;
  SET var_xml := CONCAT(var_xml, var_t2, '],', var_r);

  SET var_xml := CONCAT(var_xml, var_t2, '"importance": "', var_importance, '",', var_r);
  SET var_xml := CONCAT(var_xml, var_t2, '"sensitivity": "', var_sensitivity, '",', var_r);
  SET var_xml := CONCAT(var_xml, var_t2, '"subject": "', var_subject, '",', var_r);
  SET var_xml := CONCAT(var_xml, var_t2, '"format": "', var_body_format, '",', var_r);
  SET var_xml := CONCAT(var_xml, var_t2, '"body": {', var_r);
  SET var_xml := CONCAT(var_xml, var_t3, '"data": "', var_body, '"', var_r);
  SET var_xml := CONCAT(var_xml, var_t2, '}', var_r);
  SET var_xml := CONCAT(var_xml, var_t1, '}', var_r);
  SET var_xml := CONCAT(var_xml, '}');
  
  SET par_mail_data := var_xml;
END]]></complex-attribute>
                        <category _I_D="8422fe24-67ff-4386-b3fd-a5b04aeac757" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="a5306a7b-a056-4cd6-baca-85a0a8540565" name="sysmail_dbmail_xml" context="sysmail_dbmail_xml" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_r VARCHAR (2) DEFAULT CONCAT(CAST(CHAR(10) AS CHAR (1)), CAST(CHAR(13) AS CHAR (1)));
  DECLARE var_t1 VARCHAR (2) DEFAULT '  ';
  DECLARE var_t2 VARCHAR (4) DEFAULT '    ';
  DECLARE var_t3 VARCHAR (6) DEFAULT '      ';
  DECLARE var_t4 VARCHAR (8) DEFAULT '        ';
  DECLARE var_xml LONGTEXT DEFAULT '';
  DECLARE var_source VARCHAR (255);
  DECLARE var_profile_id INT;
  DECLARE var_recipients LONGTEXT;
  DECLARE var_copy_recipients LONGTEXT;
  DECLARE var_blind_copy_recipients LONGTEXT;
  DECLARE var_subject VARCHAR (255);
  DECLARE var_body_format VARCHAR (20);
  DECLARE var_body LONGTEXT;
  DECLARE var_from_address LONGTEXT;
  DECLARE var_reply_to LONGTEXT;
  DECLARE var_importance VARCHAR (6);
  DECLARE var_sensitivity VARCHAR (12);
  DECLARE var_mailitem_id INT;

  SELECT mailitem_id
       , profile_id
       , recipients
       , copy_recipients
       , blind_copy_recipients
       , subject
       , UPPER(body_format)
       , body
       , importance
       , sensitivity
       /* @file_attachments = file_attachments, */
       /* @attachment_encoding = attachment_encoding, */
       /* @query = query, */
       /* @execute_query_database = execute_query_database, */
       /* @attach_query_result_as_file = attach_query_result_as_file, */
       /* @query_result_header = query_result_header, */
       /* @query_result_width = query_result_width, */
       /* @query_result_separator = query_result_separator, */
       /* @exclude_query_output = exclude_query_output, */
       /* @append_query_error = append_query_error, */
       , from_address
       , reply_to
    INTO var_mailitem_id
       , var_profile_id
       , var_recipients
       , var_copy_recipients
       , var_blind_copy_recipients
       , var_subject
       , var_body_format
       , var_body
       , var_importance
       , var_sensitivity
       , var_from_address
       , var_reply_to
    FROM aws_sqlserver_ext.sysmail_mailitems
   WHERE mailitem_id = par_mail_id /* sent_status = 0 */
   ORDER BY mailitem_id ASC
   LIMIT 1;

  IF (var_mailitem_id IS NULL) 
  THEN
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'E-mail messages are missing.';
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  /*
  UPDATE sysmail_mailitems
     SET sent_status = 1
   WHERE mailitem_id = var_mailitem_id AND sent_status = 0;
  */        

  SELECT CASE
           WHEN CHAR_LENGTH(a.display_name) = 0 THEN a.email_address
           ELSE CONCAT(a.display_name, ' <', a.email_address, '>')
         END
       , servername
    INTO var_source
       , par_server_name
    FROM aws_sqlserver_ext.sysmail_profile AS p
   INNER JOIN aws_sqlserver_ext.sysmail_profileaccount AS pa
      ON pa.profile_id = p.profile_id
   INNER JOIN aws_sqlserver_ext.sysmail_account AS a
      ON a.account_id = pa.account_id
   INNER JOIN aws_sqlserver_ext_data.sysmail_server AS ss
      ON ss.account_id = pa.account_id
   WHERE p.profile_id = var_profile_id
   LIMIT 1;

  SET var_xml := CONCAT(var_xml, '<mail>', var_r);
  /* set source */
  SET var_xml := CONCAT(var_xml, var_t1, '<source>', var_source, '</source>', var_r);
  /* set destination */
  SET var_xml := CONCAT(var_xml, var_t1, '<destination>', var_r);
  SET var_xml := CONCAT(var_xml, var_t2, '<to_addresses>', var_r);
  SET var_xml := CONCAT(var_xml, var_t3, '<address>', var_recipients, '</address>', var_r);
  /* SET @xml = CONCAT(@xml, @t3, '<address>', @destination2, '</address>', @r); */
  SET var_xml := CONCAT(var_xml, var_t2, '</to_addresses>', var_r);
  SET var_xml := CONCAT(var_xml, var_t1, '</destination>', var_r);
  /* set message */
  SET var_xml := CONCAT(var_xml, var_t1, '<message>', var_r);
  SET var_xml := CONCAT(var_xml, var_t2, '<subject>', var_r);
  SET var_xml := CONCAT(var_xml, var_t3, '<data>', var_subject, '</data>', var_r);
  SET var_xml := CONCAT(var_xml, var_t3, '<charset>UTF-8</charset>', var_r);
  SET var_xml := CONCAT(var_xml, var_t2, '</subject>', var_r);
  SET var_xml := CONCAT(var_xml, var_t2, '<body>', var_r);
  
  IF (var_body_format = 'TEXT') 
  THEN
    SET var_xml := CONCAT(var_xml, var_t3, '<text>', var_r);
    SET var_xml := CONCAT(var_xml, var_t4, '<data>', var_body, '</data>', var_r);
    SET var_xml := CONCAT(var_xml, var_t4, '<charset>UTF-8</charset>', var_r);
    SET var_xml := CONCAT(var_xml, var_t3, '</text>', var_r);
  ELSE /* 'HTML' */
    SET var_xml := CONCAT(var_xml, var_t3, '<html>', var_r);
    SET var_xml := CONCAT(var_xml, var_t4, '<data>', var_body, '</data>', var_r);
    SET var_xml := CONCAT(var_xml, var_t4, '<charset>UTF-8</charset>', var_r);
    SET var_xml := CONCAT(var_xml, var_t3, '</html>', var_r);
  END IF;
  
  SET var_xml := CONCAT(var_xml, var_t2, '</body>', var_r);
  SET var_xml := CONCAT(var_xml, var_t1, '</message>', var_r);
  /* reply to */
  SET var_xml := CONCAT(var_xml, var_t1, '<reply_to_addresses>', var_r);
  SET var_xml := CONCAT(var_xml, var_t2, '<address>', var_source, '</address>', var_r);
  /* SET @xml = CONCAT(@xml, @t2, '<address>',@reply_to_addresses2,'</address>', @r); */
  SET var_xml := CONCAT(var_xml, var_t1, '</reply_to_addresses>', var_r);
  SET var_xml := CONCAT(var_xml, '</mail>');
  SET par_mail_data := var_xml;
END]]></complex-attribute>
                        <category _I_D="75fe7397-c798-4e51-ad7a-b5760c8feef1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="c984867e-3332-4886-bcec-f252fd4352df" name="sysmail_delete_account_sp" context="sysmail_delete_account_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_rc INT;
  DECLARE var_accountid INT;
  DECLARE var_credential_name VARCHAR (128);
  
  CALL aws_sqlserver_ext.sysmail_verify_account_sp (par_account_id, par_account_name, 0, 0, var_accountid, var_rc);

  IF var_rc <> 0 
  THEN
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  DELETE
    FROM aws_sqlserver_ext.sysmail_account
   WHERE account_id = var_accountid;
   
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="d398465c-66b4-499d-bdb7-9ef782dbda7c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="bccc128d-402c-422b-829b-3a4807448716" name="sysmail_delete_mailitems_sp" context="sysmail_delete_mailitems_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE _messageText VARCHAR (255);
  SET par_sent_status := LTRIM(RTRIM(par_sent_status));

  IF par_sent_status = '' 
  THEN
    SET par_sent_status := NULL;
  END IF;

  IF ((par_sent_status IS NOT NULL) AND (LOWER(par_sent_status) NOT IN ('unsent', 'sent', 'failed', 'retrying'))) 
  THEN /* Failure */
    SET _messageText := CONCAT('The specified "%s" is invalid (valid values are: %s).', '. Argument: ', '@sent_status', '. Argument: ', 'unsent, sent, failed, retrying');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF (par_sent_before IS NULL AND par_sent_status IS NULL) 
  THEN /* Failure */
    SET _messageText := CONCAT('Either %s or %s parameter needs to be supplied', '. Argument: ', '@sent_before', '. Argument: ', '@sent_status');
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  DELETE
    FROM sysmail_mailitems
   WHERE ((par_sent_before IS NULL) OR (send_request_date < par_sent_before)) 
     AND ((par_sent_status IS NULL) OR (sent_status = par_sent_status));
END]]></complex-attribute>
                        <category _I_D="da8349c5-d77d-4ecc-96c2-0ed6c7b4594d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="3461302f-0936-443a-bc61-caceb7ae12ee" name="sysmail_delete_profileaccount_sp" context="sysmail_delete_profileaccount_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_rc INT;
  DECLARE var_profileid INT;
  DECLARE var_accountid INT;
  DECLARE _messageText VARCHAR (255);
  
  CALL aws_sqlserver_ext.sysmail_verify_profile_sp (par_profile_id, par_profile_name, 1, 0, var_profileid, var_rc);

  IF var_rc <> 0 
  THEN
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  CALL aws_sqlserver_ext.sysmail_verify_account_sp (par_account_id, par_account_name, 1, 0, var_accountid, var_rc);

  IF var_rc <> 0 
  THEN
    SET ReturnCode := 2;
    LEAVE return_label;
  END IF;

  IF (var_profileid IS NOT NULL AND var_accountid IS NOT NULL) /* both parameters supplied for deletion */
  THEN
    DELETE 
      FROM aws_sqlserver_ext.sysmail_profileaccount
     WHERE profile_id = var_profileid AND account_id = var_accountid;
  ELSE
    IF (var_profileid IS NOT NULL) /* profile id is supplied */
    THEN
      DELETE
        FROM aws_sqlserver_ext.sysmail_profileaccount
       WHERE profile_id = var_profileid;
    ELSE
      IF (var_accountid IS NOT NULL) /* account id is supplied */
      THEN
        DELETE
          FROM aws_sqlserver_ext.sysmail_profileaccount
         WHERE account_id = var_accountid;
      ELSE /* no parameters are supplied for deletion */
        SET _messageText := CONCAT('Either %s or %s parameter needs to be supplied', '. Argument: ', 'profile', '. Argument: ', 'account');
        SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
        SET ReturnCode := 3;
        LEAVE return_label;
      END IF;
    END IF;
  END IF;
  
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="976c1e29-7633-4542-a39b-9af9f0bdabf4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="ab2c41bb-1181-4d09-bd0d-1808cc1c3fd6" name="sysmail_delete_profile_sp" context="sysmail_delete_profile_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_rc INT;
  DECLARE var_profileid INT;
  DECLARE _messageText VARCHAR (255);
  
  CALL aws_sqlserver_ext.sysmail_verify_profile_sp (par_profile_id, par_profile_name, 0, 0, var_profileid, var_rc);

  IF var_rc <> 0 
  THEN
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF (
    EXISTS (
      SELECT 1 
        FROM aws_sqlserver_ext.sysmail_mailitems m
       WHERE m.profile_id = var_profileid
         AND m.sent_status IN (0,3))
    AND par_force_delete <> 1
  ) 
  THEN
    IF (par_profile_name IS NULL) 
    THEN
      SELECT name INTO par_profile_name
        FROM aws_sqlserver_ext.sysmail_profile
       WHERE profile_id = var_profileid;
    END IF;
    
    SET _messageText := CONCAT('Deleting profile %s failed because there are some unsent emails associated with this profile, use force_delete option to force the deletion of the profile.', '. Argument: ', par_profile_name);
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  UPDATE aws_sqlserver_ext.sysmail_mailitems
     SET sent_status = 2 /* ZZZZZ check status : unsent, sent, failed, retrying */
       , sent_date = NOW()
   WHERE profile_id = var_profileid 
     AND sent_status <> 1;
     
  DELETE FROM aws_sqlserver_ext.sysmail_profile
   WHERE profile_id = var_profileid;
   
  SET ReturnCode := (0);
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="3b33a7b3-73ad-4988-ac42-d1bf47502282" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="adcfee29-22d9-481d-b60b-65d905da6c7a" name="sysmail_help_account_sp" context="sysmail_help_account_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_rc INT;
  DECLARE var_accountid INT;
  
  CALL aws_sqlserver_ext.sysmail_verify_account_sp (par_account_id, par_account_name, 1, 0, var_accountid, var_rc);

  IF var_rc <> 0 
  THEN
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF (var_accountid IS NOT NULL) 
  THEN
    SELECT a.account_id
         , a.name
         , a.description
         , a.email_address
         , a.display_name
         , a.replyto_address
         , s.servertype
         , s.servername
      FROM aws_sqlserver_ext.sysmail_account AS a
      JOIN aws_sqlserver_ext_data.sysmail_server AS s
        ON s.account_id = a.account_id
     WHERE a.account_id = var_accountid;
  ELSE
    SELECT a.account_id
         , a.name
         , a.description
         , a.email_address
         , a.display_name
         , a.replyto_address
         , s.servertype
         , s.servername
      FROM aws_sqlserver_ext.sysmail_account AS a
      JOIN aws_sqlserver_ext_data.sysmail_server AS s
        ON s.account_id = a.account_id;
  END IF;
  
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="d82eeb22-03b7-4567-a9f7-1a30451b3597" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="5a785601-f107-4d67-a385-0371da66132e" name="sysmail_help_profileaccount_sp" context="sysmail_help_profileaccount_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_rc INT;
  DECLARE var_profileid INT;
  DECLARE var_accountid INT;
  
  CALL aws_sqlserver_ext.sysmail_verify_profile_sp (par_profile_id, par_profile_name, 1, 0, var_profileid, var_rc);

  IF var_rc <> 0 
  THEN
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  CALL aws_sqlserver_ext.sysmail_verify_account_sp (par_account_id, par_account_name, 1, 0, var_accountid, var_rc);

  IF var_rc <> 0 
  THEN
    SET ReturnCode := 2;
    LEAVE return_label;
  END IF;

  IF (var_profileid IS NOT NULL AND var_accountid IS NOT NULL) 
  THEN
    SELECT p.profile_id
         , p.name AS profile_name
         , a.account_id
         , a.name AS account_name
         , c.sequence_number
      FROM aws_sqlserver_ext.sysmail_profile AS p
         , aws_sqlserver_ext.sysmail_account AS a
         , aws_sqlserver_ext.sysmail_profileaccount AS c
     WHERE p.profile_id = c.profile_id 
       AND a.account_id = c.account_id 
       AND c.profile_id = var_profileid 
       AND c.account_id = var_accountid;
  ELSE
    IF (var_profileid IS NOT NULL) 
    THEN
      SELECT p.profile_id
           , p.name AS profile_name
           , a.account_id
           , a.name AS account_name
           , c.sequence_number
        FROM aws_sqlserver_ext.sysmail_profile AS p
           , aws_sqlserver_ext.sysmail_account AS a
           , aws_sqlserver_ext.sysmail_profileaccount AS c
       WHERE p.profile_id = c.profile_id 
         AND a.account_id = c.account_id 
         AND c.profile_id = var_profileid;
    ELSE
      IF (var_accountid IS NOT NULL) 
      THEN
        SELECT p.profile_id
             , p.name AS profile_name
             , a.account_id
             , a.name AS account_name
             , c.sequence_number
          FROM aws_sqlserver_ext.sysmail_profile AS p
             , aws_sqlserver_ext.sysmail_account AS a
             , aws_sqlserver_ext.sysmail_profileaccount AS c
         WHERE p.profile_id = c.profile_id 
           AND a.account_id = c.account_id 
           AND c.account_id = var_accountid;
      ELSE
        SELECT p.profile_id
             , p.name AS profile_name
             , a.account_id
             , a.name AS account_name
             , c.sequence_number
          FROM aws_sqlserver_ext.sysmail_profile AS p
             , aws_sqlserver_ext.sysmail_account AS a
             , aws_sqlserver_ext.sysmail_profileaccount AS c
         WHERE p.profile_id = c.profile_id 
           AND a.account_id = c.account_id;
      END IF;
    END IF;
  END IF;
  
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="5d3168fc-51aa-4ca3-a170-88074ab44f6c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="443dd101-04fe-4c01-bccf-29109974c270" name="sysmail_help_profile_sp" context="sysmail_help_profile_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_rc INT;
  DECLARE var_profileid INT;
  CALL aws_sqlserver_ext.sysmail_verify_profile_sp (par_profile_id, par_profile_name, 1, 0, var_profileid, var_rc);

  IF var_rc <> 0 
  THEN
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF (var_profileid IS NOT NULL) 
  THEN
    SELECT profile_id
         , name
         , description
      FROM aws_sqlserver_ext.sysmail_profile
     WHERE profile_id = var_profileid;
  ELSE
    SELECT profile_id
         , name
         , description
      FROM aws_sqlserver_ext.sysmail_profile;
  END IF;
  
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="2b58a5e0-c95b-4efb-922d-9952b8ef8105" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="bd39f36a-04b5-412a-b50a-121b055d8334" name="sysmail_set_arn_sp" context="sysmail_set_arn_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_rc INT;
  DECLARE _messageText VARCHAR (255);
  
  IF (par_mailserver_name IS NULL) 
  THEN /* Failure */
    SET _messageText := CONCAT('%s is not a valid mailserver_name', '. Argument: ', par_mailserver_name);
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  DELETE FROM aws_sqlserver_ext_data.sysmail_server;

  INSERT 
    INTO aws_sqlserver_ext_data.sysmail_server (
         account_id
       , servertype
       , servername) 
  VALUES (
         0
       , 'AWSLAMBDA'
       , par_mailserver_name);

  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="3d369508-dfb8-45b2-b325-b76bae6dd94a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="c12e3586-d3b8-45e5-b9d6-0538ad761ff4" name="sysmail_update_account_sp" context="sysmail_update_account_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_rc INT;
  DECLARE var_accountid INT;
  
  CALL aws_sqlserver_ext.sysmail_verify_account_sp (par_account_id, par_account_name, 0, 1, var_accountid, var_rc);

  IF var_rc <> 0 
  THEN
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF (par_email_address IS NULL) 
  THEN
    SELECT email_address
      INTO par_email_address
      FROM aws_sqlserver_ext.sysmail_account
     WHERE account_id = var_accountid;
  END IF;

  IF (par_display_name IS NULL) 
  THEN
    SELECT display_name
      INTO par_display_name
      FROM aws_sqlserver_ext.sysmail_account
     WHERE account_id = var_accountid;
  END IF;

  IF (par_replyto_address IS NULL) 
  THEN
    SELECT replyto_address
      INTO par_replyto_address
      FROM aws_sqlserver_ext.sysmail_account
     WHERE account_id = var_accountid;
  END IF;

  IF (par_description IS NULL) 
  THEN
    SELECT description
      INTO par_description
      FROM aws_sqlserver_ext.sysmail_account
     WHERE account_id = var_accountid;
  END IF;
  
  /* update account table */
  IF (par_account_name IS NOT NULL) 
  THEN
    IF (par_email_address IS NOT NULL) 
    THEN
      UPDATE aws_sqlserver_ext.sysmail_account
         SET name = par_account_name
           , description = par_description
           , email_address = par_email_address
           , display_name = par_display_name
           , replyto_address = par_replyto_address
       WHERE account_id = var_accountid;
    ELSE
      UPDATE aws_sqlserver_ext.sysmail_account
         SET name = par_account_name
           , description = par_description
           , display_name = par_display_name
           , replyto_address = par_replyto_address
       WHERE account_id = var_accountid;
    END IF;
  ELSE
    IF (par_email_address IS NOT NULL) 
    THEN
      UPDATE aws_sqlserver_ext.sysmail_account
         SET description = par_description
           , email_address = par_email_address
           , display_name = par_display_name
           , replyto_address = par_replyto_address
       WHERE account_id = var_accountid;
    ELSE
      UPDATE aws_sqlserver_ext.sysmail_account
         SET description = par_description
           , display_name = par_display_name
           , replyto_address = par_replyto_address
       WHERE account_id = var_accountid;
    END IF;
  END IF;

  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="087b9b16-4f26-4756-8944-c16a75c583a8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="b113b55d-0419-4c3f-baa0-fc95abf6f291" name="sysmail_update_profileaccount_sp" context="sysmail_update_profileaccount_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_rc INT;
  DECLARE var_profileid INT;
  DECLARE var_accountid INT;
  
  CALL aws_sqlserver_ext.sysmail_verify_profile_sp (par_profile_id, par_profile_name, 0, 0, var_profileid, var_rc);

  IF var_rc <> 0 
  THEN
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;
  
  CALL aws_sqlserver_ext.sysmail_verify_account_sp (par_account_id, par_account_name, 0, 0, var_accountid, var_rc);

  IF var_rc <> 0 
  THEN
    SET ReturnCode := 2;
    LEAVE return_label;
  END IF;

  IF (par_sequence_number IS NULL) 
  THEN
    SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'Account sequence number must be supplied for update';
    SET ReturnCode := 3;
    LEAVE return_label;
  END IF;
  
  UPDATE aws_sqlserver_ext.sysmail_profileaccount
     SET sequence_number = par_sequence_number
   WHERE profile_id = var_profileid AND account_id = var_accountid;
  
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="6f5fd912-36bf-4762-aa7f-32ad2296313d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="8aa8eb29-d7cb-4c89-8916-4304c4207130" name="sysmail_update_profile_sp" context="sysmail_update_profile_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_rc INT;
  DECLARE var_profileid INT;
  CALL aws_sqlserver_ext.sysmail_verify_profile_sp (par_profile_id, par_profile_name, 0, 1, var_profileid, var_rc);

  IF var_rc <> 0 
  THEN
    SET ReturnCode := 1;
    LEAVE return_label;
  END IF;

  IF (par_profile_name IS NOT NULL AND par_description IS NOT NULL) 
  THEN
    UPDATE aws_sqlserver_ext.sysmail_profile
       SET name = par_profile_name
         , description = par_description
     WHERE profile_id = var_profileid;
  ELSE
    IF (par_profile_name IS NOT NULL) 
    THEN
      UPDATE aws_sqlserver_ext.sysmail_profile
         SET name = par_profile_name
       WHERE profile_id = var_profileid;
    ELSE
      IF (par_description IS NOT NULL) 
      THEN
        UPDATE aws_sqlserver_ext.sysmail_profile
           SET description = par_description
         WHERE profile_id = var_profileid;
      ELSE
        SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = 'Either par_profile_name or par_description parameter needs to be specified for update';
        SET ReturnCode := 1;
        LEAVE return_label;
      END IF;
    END IF;
  END IF;
  
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="4f061a85-3ad9-42f8-8efb-c3d4da3e7309" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="f9d74019-fba1-4f0d-acce-a3bb2f9a04c0" name="sysmail_verify_account_sp" context="sysmail_verify_account_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE _messageText VARCHAR (255);

  /* at least one parameter must be supplied */
  IF par_allow_both_nulls = 0 
  THEN
    IF (par_account_id IS NULL AND par_account_name IS NULL) 
    THEN
      SET _messageText := CONCAT('Both %s parameters (id and name) cannot be NULL', '. Argument: ', 'account');
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
      SET ReturnCode := 1;
      LEAVE return_label;
    END IF;
  END IF;

  /* use both parameters */
  IF ((par_allow_id_name_mismatch = 0) AND (par_account_id IS NOT NULL AND par_account_name IS NOT NULL))
  THEN
    SELECT account_id
      INTO par_accountid
      FROM sysmail_account
     WHERE account_id = par_account_id AND name = par_account_name;

    IF (par_accountid IS NULL) /* id and name do not match */
    THEN
      SET _messageText := CONCAT('Both %s parameters (id and name) do not point to the same object', '. Argument: ', 'account');
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
      SET ReturnCode := 2;
      LEAVE return_label;
    END IF;
  ELSE
    IF (par_account_id IS NOT NULL) /* use id */
    THEN
      SELECT account_id
        INTO par_accountid
        FROM sysmail_account
       WHERE account_id = par_account_id;

      IF (par_accountid IS NULL) /* id is invalid */
      THEN
        SET _messageText := CONCAT('%s id is not valid', '. Argument: ', 'account');
        SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
        SET ReturnCode := 3;
        LEAVE return_label;
      END IF;
    ELSE
      IF (par_account_name IS NOT NULL) /* use name */
      THEN
        SELECT account_id
          INTO par_accountid
          FROM sysmail_account
         WHERE name = par_account_name;

        IF (par_accountid IS NULL) /* name is invalid */
        THEN
          SET _messageText := CONCAT('%s name is not valid', '. Argument: ', 'account');
          SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
          SET ReturnCode := 4;
          LEAVE return_label;
        END IF;
      END IF;
    END IF;
  END IF;
  
  /* SUCCESS */
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="8e0562a8-a837-430b-8445-0df3b7ee3ec7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="bed90bbf-40e8-42cd-887e-7a240b44a2d2" name="sysmail_verify_addressparams_sp" context="sysmail_verify_addressparams_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_commaIndex INT;
  DECLARE _messageText VARCHAR (255);

  IF ((par_address IS NOT NULL) AND (par_address != '')) 
  THEN
    SET var_commaIndex := LOCATE(',', par_address);

    IF (var_commaIndex > 0) 
    THEN
      SET _messageText := CONCAT('The specified "%s" cannot use commas (,) to separate addresses: "%s". To continue, use semicolons (;) to separate addresses.', '. Argument: ', par_parameter_name, '. Argument: ', par_address);
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
      SET ReturnCode := 1;
      LEAVE return_label;
    END IF;
  END IF;
  
  SET ReturnCode := (0);
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="6915f62f-318e-4f1a-bc06-ed540f440c6c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="c0de4ad0-e6c5-4afb-b054-33ae5388087f" name="sysmail_verify_profile_sp" context="sysmail_verify_profile_sp" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE _messageText VARCHAR (255);

  IF par_allow_both_nulls = 0 
  THEN /* at least one parameter must be supplied */
    IF (par_profile_id IS NULL AND par_profile_name IS NULL) 
    THEN
      SET _messageText := CONCAT('Both %s parameters (id and name) cannot be NULL', '. Argument: ', 'profile');
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
      SET ReturnCode := 1;
      LEAVE return_label;
    END IF;
  END IF;

  /* use both parameters */
  IF ((par_allow_id_name_mismatch = 0) AND (par_profile_id IS NOT NULL AND par_profile_name IS NOT NULL))
  THEN
    SELECT profile_id
      INTO par_profileid
      FROM sysmail_profile
     WHERE profile_id = par_profile_id AND name = par_profile_name;

    IF (par_profileid IS NULL) /* id and name do not match */
    THEN
      SET _messageText := CONCAT('Both %s parameters (id and name) do not point to the same object', '. Argument: ', 'profile');
      SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
      SET ReturnCode := 2;
      LEAVE return_label;
    END IF;
  ELSE
    IF (par_profile_id IS NOT NULL) /* use id */
    THEN
      SELECT profile_id
        INTO par_profileid
        FROM sysmail_profile
       WHERE profile_id = par_profile_id;

      IF (par_profileid IS NULL) /* id is invalid */
      THEN
        SET _messageText := CONCAT('%s id is not valid', '. Argument: ', 'profile');
        SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
        SET ReturnCode := 3;
        LEAVE return_label;
      END IF;
    ELSE
      IF (par_profile_name IS NOT NULL) /* use name */
      THEN
        SELECT profile_id
          INTO par_profileid
          FROM sysmail_profile
         WHERE name = par_profile_name;

        IF (par_profileid IS NULL) /* name is invalid */
        THEN
          SET _messageText := CONCAT('%s name is not valid', '. Argument: ', 'profile');
          SIGNAL SQLSTATE VALUE '50000' SET MESSAGE_TEXT = _messageText;
          SET ReturnCode := 4;
          LEAVE return_label;
        END IF;
      END IF;
    END IF;
  END IF;
  
  SET ReturnCode := 0;
  LEAVE return_label;
END]]></complex-attribute>
                        <category _I_D="8a01d695-b6f4-49d8-b0e0-f9ac3b9618ce" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="3937975e-9784-476d-b279-ea1f39703692" name="update_job" context="update_job" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="CONTAINS SQL">
                        <complex-attribute name="sql"><![CDATA[return_label:
BEGIN
  DECLARE var_enabled smallint;
  DECLARE var_freq_type integer;
  DECLARE var_freq_interval integer;
  DECLARE var_freq_subday_type integer;
  DECLARE var_freq_subday_interval integer;
  DECLARE var_freq_relative_interval integer;
  DECLARE var_freq_recurrence_factor integer;
  DECLARE var_tmp_interval varchar(50);
  DECLARE var_job_id integer;
  DECLARE var_schedule_id integer;
  DECLARE var_job_step_id integer;
  DECLARE var_step_id integer;
  DECLARE var_step_name VARCHAR(128);

/*
  SET var_job_step_id = p_job;

  SELECT jst.job_id, jsc.schedule_id, jst.step_name, jst.step_id 
    INTO var_job_id, var_schedule_id, var_step_name, var_step_id  
    FROM aws_sqlserver_ext.sysjobsteps jst
   INNER JOIN aws_sqlserver_ext.sysjobschedules jsc
      ON jsc.job_id = jst.job_id
   WHERE jst.job_step_id = var_job_step_id;
*/
  INSERT 
    INTO aws_sqlserver_ext.sysjobhistory (
         job_id
       , step_id
       , step_name
       , sql_message_id
       , sql_severity
       , message
       , run_status
       , run_date
       , run_time
       , run_duration
       , operator_id_emailed
       , operator_id_netsent
       , operator_id_paged
       , retries_attempted
       , server)
  VALUES (
         p_job
       , 0 /* var_step_id */
       , '' /* var_step_name */
       , 0
       , 0
       , p_error_message
       , 0
       , DATE(Now())
       , TIME(Now())
       , 0
       , 0
       , 0
       , 0
       , 0
       , '');
  
  -- CALL aws_sqlserver_ext.sp_set_next_run (var_job_id, var_schedule_id);
END]]></complex-attribute>
                        <category _I_D="39948873-f33c-4b87-8d6d-9e0f8afd85e6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                </category>
                <category _I_D="df061a25-8a07-4672-babb-4b4b32d0aebd" name="Functions" order-num="3" objects-loading="extended" subcategories-loading="none" child-type="function">
                    <function _I_D="c720124b-bd52-4965-b7be-b1bca2458eaa" name="conv_datetime_to_string" context="conv_datetime_to_string" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function converts the DATETIME value into a character string, according to specified style (conversion mask).]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_dateval DATE;
    DECLARE v_length INTEGER;
    DECLARE v_resstring NVARCHAR(150);
    DECLARE v_timepart VARCHAR(30);
    DECLARE v_resmask VARCHAR(30);
    DECLARE v_monthname NVARCHAR(40);
    DECLARE v_millisecond NVARCHAR(10);
    DECLARE v_language VARCHAR(50);
    DECLARE CONVERSION_LANG VARCHAR(50) DEFAULT ''; -- Default (override) conversion language, for example: ENGLISH
    DECLARE v_lengthstr, v_resdatatype VARCHAR(100);
    DECLARE v_datatype VARCHAR(100) DEFAULT UPPER(TRIM(p_datatype));
    DECLARE v_srcdatatype VARCHAR(100) DEFAULT UPPER(TRIM(p_srcdatatype));
    DECLARE v_srcdatatype_mask VARCHAR(120) DEFAULT '^[[:space:]]*(DATETIME|SMALLDATETIME|DATETIME2)[[:space:]]*$';
    DECLARE v_datatype_mask VARCHAR(120) DEFAULT '^[[:space:]]*(CHAR|NCHAR|VARCHAR|NVARCHAR)[[:space:]]*\([[:space:]]*([[:digit:]]{1,4}|MAX)[[:space:]]*\)[[:space:]]*$';
    DECLARE v_datatype_regexp VARCHAR(120) DEFAULT '^[[:space:]]*(CHAR|NCHAR|VARCHAR|NVARCHAR)[[:space:]]*$';

    DECLARE v_error_message VARCHAR(500);
    DECLARE conversion_failed CONDITION FOR SQLSTATE '45520';
    DECLARE invalid_style CONDITION FOR SQLSTATE '45521';
    DECLARE maximum_exceeded CONDITION FOR SQLSTATE '45522';
    DECLARE incorrect_datatype CONDITION FOR SQLSTATE '45523';
    DECLARE incorrect_srcdatatype CONDITION FOR SQLSTATE '45524';

    -- Cases when style param value is not not valid for datetime to string conversion
    DECLARE EXIT HANDLER FOR invalid_style
    BEGIN
        SET v_error_message = CONCAT(p_style, ' is not a valid style number when converting from datetime to a character string.');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Cases when specified data type length exceeds its maximum allowed value
    DECLARE EXIT HANDLER FOR maximum_exceeded
    BEGIN
        SET v_error_message = CONCAT('The size (',
                                     v_length,
                                     ') given to the convert specification '',
                                     LOWER(v_resdatatype),
                                     '' exceeds the maximum allowed for any data type (',
                                     CASE
                                        WHEN v_resdatatype IN ('CHAR', 'VARCHAR') THEN 8000
                                        ELSE 4000
                                     END, ').');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Cases when supplied data type param value is not one of CHAR/VARCHAR/NCHAR/NVARCHAR
    DECLARE EXIT HANDLER FOR incorrect_datatype
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Data type should be one of these values: 'CHAR(n|MAX)', 'NCHAR(n|MAX)', 'VARCHAR(n|MAX)', 'NVARCHAR(n|MAX)'.';
    END;

    -- Cases when supplied source data type param value is not one of DATETIME/SMALLDATETIME/DATETIME2
    DECLARE EXIT HANDLER FOR incorrect_srcdatatype
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Source data type should be one of these values: 'DATETIME', 'SMALLDATETIME', 'DATETIME2'.';
    END;

    -- Checking source data type
    IF (v_srcdatatype NOT REGEXP v_srcdatatype_mask) THEN
        SIGNAL incorrect_srcdatatype;
    END IF;

    /* Checking "style" param value
       (throw an error if incorrect) */
    IF ((p_style BETWEEN 15 AND 19) OR
        (p_style BETWEEN 26 AND 99) OR
        (p_style BETWEEN 115 AND 119) OR
        (p_style BETWEEN 122 AND 125) OR
        (p_style BETWEEN 128 AND 129))
    THEN
        -- Incorrect "style" param value
        SIGNAL invalid_style;
    END IF;

    -- Parsing data type and length pair of values
    IF (v_datatype REGEXP v_datatype_mask)
    THEN
        -- Extracting data type value from data type expression
        SET v_resdatatype = RTRIM(SUBSTRING_INDEX(v_datatype, '(', 1));

        -- Extract length data from data type expression
        SET v_lengthstr = TRIM(SUBSTRING(v_datatype,
                                         INSTR(v_datatype, '(') + 1,
                                         (INSTR(v_datatype, ')') - INSTR(v_datatype, '(') - 1)));
        IF (v_lengthstr = 'MAX') THEN
            SET v_length = IF(v_resdatatype IN ('CHAR', 'VARCHAR'), 8000, 4000);
        ELSEIF (NOT ISNULL(v_lengthstr)) THEN
            SET v_length = CONVERT(v_lengthstr, UNSIGNED);

            -- Checking data type size is in correct boundaries
            IF ((v_resdatatype IN ('CHAR', 'VARCHAR') AND v_length > 8000) OR
                (v_resdatatype IN ('NCHAR', 'NVARCHAR') AND v_length > 4000))
            THEN
                -- Incorrect data type size
                SIGNAL maximum_exceeded;
            END IF;
        END IF;
    ELSEIF (v_datatype REGEXP v_datatype_regexp) THEN
        -- Extracting data type value
        SET v_resdatatype = RTRIM(v_datatype);
    ELSE
        -- Incorrect data type
        SIGNAL incorrect_datatype;
    END IF;

    -- Determining the right calendar date (master) to convert
    SET v_dateval = CASE
                       WHEN (p_style NOT IN (130, 131)) THEN p_datetimeval
                       -- Converting Gregorian to Hijri date
                       ELSE aws_sqlserver_ext.conv_greg_to_hijri(DAY(p_datetimeval),
                                                                 MONTH(p_datetimeval),
                                                                 YEAR(p_datetimeval)) + 1
                    END;

    -- Determining the proper language for month name conversion
    SET v_language = CASE
                        WHEN (p_style IN (130, 131)) THEN 'HIJRI'
                        ELSE CONVERSION_LANG
                     END;

    -- Determining month national name by month num, extracted from master date
    SET v_monthname = JSON_UNQUOTE(JSON_EXTRACT(aws_sqlserver_ext.get_lang_metadata_json(v_language),
                                                CONCAT('$.months_shortnames[', MONTH(v_dateval) - 1, ']')));

    -- Rounding ractional seconds part according to data type
    IF (v_srcdatatype IN ('DATETIME', 'SMALLDATETIME'))
    THEN
        SET v_millisecond = aws_sqlserver_ext.round_fractseconds(CONVERT(MICROSECOND(p_datetimeval) / 1000,
                                                                         UNSIGNED));
        IF (v_millisecond = 1000) THEN
            SET v_millisecond = '000';
            SET p_datetimeval = DATE_ADD(p_datetimeval, INTERVAL 1 SECOND);
        END IF;
        SET v_millisecond = LPAD(v_millisecond, 3, '0');
    ELSE
        SET v_millisecond = LPAD(MICROSECOND(p_datetimeval), 6, '0');
    END IF;

    -- Picking up the right date to string conversion mask
    IF (p_style = 1) THEN
        SET v_resmask = '%m/%d/%y'; -- 09/15/17
    ELSEIF (p_style = 10) THEN
        SET v_resmask = '%m-%d-%y'; -- 09-15-17
    ELSEIF (p_style = 23) THEN
        SET v_resmask = '%Y-%m-%d'; -- 2017-09-15
    ELSEIF (p_style = 101) THEN
        SET v_resmask = '%m/%d/%Y'; -- 09/15/2017
    ELSEIF (p_style = 2) THEN
        SET v_resmask = '%y.%m.%d'; -- 17.09.15
    ELSEIF (p_style = 102) THEN
        SET v_resmask = '%Y.%m.%d'; -- 2017.09.15
    ELSEIF (p_style = 3) THEN
        SET v_resmask = '%d/%m/%y'; -- 15/09/17
    ELSEIF (p_style = 103) THEN
        SET v_resmask = '%d/%m/%Y'; -- 15/09/2017
    ELSEIF (p_style = 4) THEN
        SET v_resmask = '%d.%m.%y'; -- 15/09/17
    ELSEIF (p_style = 104) THEN
        SET v_resmask = '%d.%m.%Y'; -- 15/09/2017
    ELSEIF (p_style = 5) THEN
        SET v_resmask = '%d-%m-%y'; -- 15-09-17
    ELSEIF (p_style = 105) THEN
        SET v_resmask = '%d-%m-%Y'; -- 15-09-2017
    ELSEIF (p_style = 6) THEN
        SET v_resmask = CONCAT('%d ', v_monthname, ' %y'); -- 15 Sep 17
    ELSEIF (p_style = 106) THEN
        SET v_resmask = CONCAT('%d ', v_monthname, ' %Y'); -- 15 Sep 2017
    ELSEIF (p_style = 7) THEN
        SET v_resmask = CONCAT(v_monthname, ' %d, %y'); -- Sep 15 17
    ELSEIF (p_style = 107) THEN
        SET v_resmask = CONCAT(v_monthname, ' %d, %Y'); -- Sep 15 2017
    ELSEIF (p_style = 110) THEN
        SET v_resmask = '%m-%d-%Y'; -- 09-15-2017
    ELSEIF (p_style = 11) THEN
        SET v_resmask = '%y/%m/%d'; -- 17/09/15
    ELSEIF (p_style = 111) THEN
        SET v_resmask = '%Y/%m/%d'; -- 2017/09/15
    ELSEIF (p_style = 12) THEN
        SET v_resmask = '%y%m%d'; -- 170915
    ELSEIF (p_style = 112) THEN
        SET v_resmask = '%Y%m%d'; -- 20170915
    ELSEIF (p_style IN (8, 24, 108)) THEN
        SET v_resmask = '%H:%i:%s'; -- 03:24:36
    ELSEIF (p_style = 22) THEN
        SET v_resmask = CONCAT('%m/%d/%y ',
                               LPAD(DATE_FORMAT(p_datetimeval, '%l'), 2, SPACE(1)),
                               ':%i:%s %p'); -- 09/15/17 12:24:36 PM
    ELSEIF (p_style IN (20, 120)) THEN
        SET v_resmask = '%Y-%m-%d %h:%i:%s'; -- 2017-09-15 03:24:36
    ELSEIF (p_style IN (14, 114)) THEN
        SET v_resmask = CASE v_srcdatatype
                           WHEN 'DATETIME2' THEN CONCAT('%H:%i:%s.', v_millisecond) -- 03:24:36.347583
                           ELSE CONCAT('%H:%i:%s:', v_millisecond) -- 03:24:36:347
                        END;
    ELSEIF (p_style IN (13, 113)) THEN
        SET v_resmask = CASE v_srcdatatype
                           WHEN 'DATETIME2' THEN CONCAT('%d ', v_monthname, ' %Y %H:%i:%s.', v_millisecond) -- 15 Sep 2017 03:24:36.347583
                           ELSE CONCAT('%d ', v_monthname, ' %Y %H:%i:%s:', v_millisecond) -- 15 Sep 2017 03:24:36:347
                        END;
    ELSEIF ((ISNULL(p_style) AND v_srcdatatype = 'DATETIME2') OR
            p_style IN (21, 25, 121)) THEN
        SET v_resmask = CONCAT('%Y-%m-%d %h:%i:%s.', v_millisecond); -- 2017-09-15 03:24:36.347
    ELSEIF (p_style IN (126, 127)) THEN
        SET v_resmask = CASE v_srcdatatype
                           WHEN 'SMALLDATETIME' THEN CONCAT('%Y-%m-%dT%H:%i:%s') -- 2017-09-15T03:24:36
                           ELSE CONCAT('%Y-%m-%dT%H:%i:%s.', v_millisecond) -- 2017-09-15T03:24:36.347
                        END;
    END IF;

    -- Converting master date to a character string using conversion mask
    IF ((ISNULL(p_style) AND v_srcdatatype <> 'DATETIME2') OR
        p_style IN (0, 9, 100, 109))
    THEN
        SET v_resmask = CASE
                           WHEN (ISNULL(p_style) OR p_style IN (0, 100)) THEN ':%i%p'
                           ELSE CONCAT(':%i:%s:', v_millisecond, '%p')
                        END;

        SET v_resstring = CONCAT(v_monthname,
                                 SPACE(1),
                                 LPAD(DAY(p_datetimeval), 2, SPACE(1)),
                                 SPACE(1),
                                 YEAR(p_datetimeval),
                                 SPACE(1),
                                 LPAD(DATE_FORMAT(p_datetimeval, '%l'), 2, SPACE(1)),
                                 DATE_FORMAT(p_datetimeval, v_resmask));
    -- (18/06/2012|18  1435) 03:24:36.347583
    ELSEIF (p_style IN (130, 131)) THEN
        -- Constructing fractional time part
        SET v_timepart = CONCAT(LPAD(DATE_FORMAT(p_datetimeval, '%l'), 2, SPACE(1)),
                                DATE_FORMAT(p_datetimeval, ':%i:%s'),
                                IF(v_srcdatatype = 'DATETIME2', '.', ':'),
                                v_millisecond);

        SET v_resstring = CASE
                             WHEN (p_style = 130)
                             THEN CONCAT_WS(SPACE(1), LPAD(DAY(v_dateval), 2, SPACE(1)), -- Hijri day
                                                  v_monthname, -- Hijri month
                                                  YEAR(v_dateval), -- Hijri year
                                                  v_timepart,
                                                  DATE_FORMAT(p_datetimeval, '%p'))
                             ELSE  -- p_style 131
                                  CONCAT(DATE_FORMAT(v_dateval, '%e/%m/%Y '), -- Hijri date, 25/06/1435
                                         v_timepart,
                                         DATE_FORMAT(p_datetimeval, '%p'))
                          END;
    ELSE
        SET v_resstring = DATE_FORMAT(p_datetimeval, v_resmask);
    END IF;

    -- Resizing result string according to the data type size value
    SET v_resstring = SUBSTRING(v_resstring, 1, COALESCE(v_length, CHAR_LENGTH(v_resstring)));

    RETURN CASE
              WHEN v_resdatatype IN ('CHAR', 'NCHAR') THEN
                  RPAD(v_resstring, COALESCE(v_length, CHAR_LENGTH(v_resstring)), SPACE(1))
              ELSE v_resstring
           END;
END]]></complex-attribute>
                        <category _I_D="c3a11f86-7713-4638-b1b8-98bb82a667be" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8d6d1f63-ffe0-4fce-b049-4a325c584408" name="conv_date_to_string" context="conv_date_to_string" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function converts the DATE value into a VARCHAR string, according to specified style (conversion mask).]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_dateval DATE;
    DECLARE v_length INTEGER;
    DECLARE v_resstring NVARCHAR(150);
    DECLARE v_resmask VARCHAR(30);
    DECLARE v_monthname NVARCHAR(40);
    DECLARE v_language VARCHAR(50);
    DECLARE CONVERSION_LANG VARCHAR(50) DEFAULT ''; -- Default (override) conversion language, for example: ENGLISH
    DECLARE v_lengthstr, v_resdatatype VARCHAR(100);
    DECLARE v_datatype VARCHAR(100) DEFAULT UPPER(TRIM(p_datatype));
    DECLARE v_datatype_mask VARCHAR(120) DEFAULT '^[[:space:]]*(CHAR|NCHAR|VARCHAR|NVARCHAR)[[:space:]]*\([[:space:]]*([[:digit:]]{1,4}|MAX)[[:space:]]*\)[[:space:]]*$'; -- VARCHAR(8000) and other variations
    DECLARE v_datatype_regexp VARCHAR(120) DEFAULT '^[[:space:]]*(CHAR|NCHAR|VARCHAR|NVARCHAR)[[:space:]]*$'; -- CHAR/VARCHAR/NCHAR/NVARCHAR

    -- Declaration of eror coditions and handlers
    DECLARE v_error_message VARCHAR(500);
    DECLARE conversion_failed CONDITION FOR SQLSTATE '45520';
    DECLARE invalid_style CONDITION FOR SQLSTATE '45521';
    DECLARE maximum_exceeded CONDITION FOR SQLSTATE '45522';
    DECLARE incorrect_datatype CONDITION FOR SQLSTATE '45523';

    -- Conversion process failed
    DECLARE EXIT HANDLER FOR conversion_failed
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Error converting data type datetime to varchar.';
    END;

    -- Cases when style param value is not not valid for datetime to string conversion
    DECLARE EXIT HANDLER FOR invalid_style
    BEGIN
        SET v_error_message = CONCAT(p_style, ' is not a valid style number when converting from datetime to a character string.');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Cases when specified data type length exceeds its maximum allowed value
    DECLARE EXIT HANDLER FOR maximum_exceeded
    BEGIN
        SET v_error_message = CONCAT('The size (',
                                     v_length,
                                     ') given to the convert specification '',
                                     LOWER(v_resdatatype),
                                     '' exceeds the maximum allowed for any data type (',
                                     CASE
                                        WHEN v_resdatatype IN ('CHAR', 'VARCHAR') THEN 8000
                                        ELSE 4000
                                     END, ').');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Cases when supplied data type param value is not one of CHAR/VARCHAR/NCHAR/NVARCHAR
    DECLARE EXIT HANDLER FOR incorrect_datatype
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Data type should be one of these values: 'CHAR(n|MAX)', 'NCHAR(n|MAX)', 'VARCHAR(n|MAX)', 'NVARCHAR(n|MAX)'.';
    END;

    /* Checking "style" param value
       (throw an error if incorrect) */
    IF ((p_style BETWEEN 14 AND 19) OR
        (p_style BETWEEN 26 AND 99) OR
        (p_style BETWEEN 114 AND 119) OR
        (p_style BETWEEN 122 AND 125) OR
        (p_style BETWEEN 128 AND 129))
    THEN
        -- Incorrect "style" param value
        SIGNAL invalid_style;
    ELSEIF (p_style IN (8, 24, 108)) THEN
        -- Conversion failed
        SIGNAL conversion_failed;
    END IF;

    -- Parsing data type and length pair of values
    IF (v_datatype REGEXP v_datatype_mask) THEN
        -- Extracting data type value from data type expression
        SET v_resdatatype = RTRIM(SUBSTRING_INDEX(v_datatype, '(', 1));

        -- Extract length data from data type expression
        SET v_lengthstr = TRIM(SUBSTRING(v_datatype,
                                         INSTR(v_datatype, '(') + 1,
                                         (INSTR(v_datatype, ')') - INSTR(v_datatype, '(') - 1)));
        IF (v_lengthstr = 'MAX') THEN
            SET v_length = IF(v_resdatatype IN ('CHAR', 'VARCHAR'), 8000, 4000);
        ELSEIF (NOT ISNULL(v_lengthstr)) THEN
            SET v_length = CONVERT(v_lengthstr, UNSIGNED);

            -- Checking data type size is in correct boundaries
            IF ((v_resdatatype IN ('CHAR', 'VARCHAR') AND v_length > 8000) OR
                (v_resdatatype IN ('NCHAR', 'NVARCHAR') AND v_length > 4000))
            THEN
                -- Incorrect data type size
                SIGNAL maximum_exceeded;
            END IF;
        END IF;
    ELSEIF (v_datatype REGEXP v_datatype_regexp) THEN
        -- Extracting data type value
        SET v_resdatatype = RTRIM(v_datatype);
    ELSE
        -- Incorrect data type
        SIGNAL incorrect_datatype;
    END IF;

    -- Determining the right calendar date (master) to convert
    SET v_dateval = CASE
                       WHEN (p_style NOT IN (130, 131)) THEN p_dateval
                       -- Converting Gregorian to Hijri date
                       ELSE aws_sqlserver_ext.conv_greg_to_hijri(DAY(p_dateval),
                                                                 MONTH(p_dateval),
                                                                 YEAR(p_dateval)) + 1
                    END;

    -- Determining the proper language for month name conversion
    SET v_language = CASE
                        WHEN (p_style IN (130, 131)) THEN 'HIJRI'
                        ELSE CONVERSION_LANG
                     END;

    -- Determining month national name by month num, extracted from master date
    SET v_monthname = JSON_UNQUOTE(JSON_EXTRACT(aws_sqlserver_ext.get_lang_metadata_json(v_language),
                                                CONCAT('$.months_shortnames[', MONTH(v_dateval) - 1, ']')));

    -- Picking up the right date to string conversion mask
    IF (ISNULL(p_style) OR
        p_style IN (20, 21, 23, 25, 120, 121, 126, 127))
    THEN
        SET v_resmask = '%Y-%m-%d'; -- 2012-06-18
    ELSEIF (p_style = 5) THEN
        SET v_resmask = '%d-%m-%y'; -- 18-06-12
    ELSEIF (p_style = 105) THEN
        SET v_resmask = '%d-%m-%Y'; -- 18-06-2012
    ELSEIF (p_style = 4) THEN
        SET v_resmask = '%d.%m.%y'; -- 18.06.12
    ELSEIF (p_style = 104) THEN
        SET v_resmask = '%d.%m.%Y'; -- 18.06.2012
    ELSEIF (p_style = 3) THEN
        SET v_resmask = '%d/%m/%y'; -- 18/06/12
    ELSEIF (p_style = 103) THEN
        SET v_resmask = '%d/%m/%Y'; -- 18/06/2012
    ELSEIF (p_style = 6) THEN
        SET v_resmask = CONCAT('%d ', v_monthname, ' %y'); -- 18 Jun 12
    ELSEIF (p_style IN (13, 106, 113)) THEN
        SET v_resmask = CONCAT('%d ', v_monthname, ' %Y'); -- 18 Jun 2012
    ELSEIF (p_style = 7) THEN
        SET v_resmask = CONCAT(v_monthname, ' %d, %y'); -- Jun 18 12
    ELSEIF (p_style = 107) THEN
        SET v_resmask = CONCAT(v_monthname, ' %d, %Y'); -- Jun 18 2012
    ELSEIF (p_style = 10) THEN
        SET v_resmask = '%m-%d-%y'; -- 06-18-12
    ELSEIF (p_style = 110) THEN
        SET v_resmask = '%m-%d-%Y'; -- 06-18-2012
    ELSEIF (p_style IN (1, 22)) THEN
        SET v_resmask = '%m/%d/%y'; -- 06/18/12
    ELSEIF (p_style = 101) THEN
        SET v_resmask = '%m/%d/%Y'; -- 06/18/2012
    ELSEIF (p_style = 2) THEN
        SET v_resmask = '%y.%m.%d'; -- 12.06.18
    ELSEIF (p_style = 102) THEN
        SET v_resmask = '%Y.%m.%d'; -- 2012.06.18
    ELSEIF (p_style = 11) THEN
        SET v_resmask = '%y/%m/%d'; -- 12/06/18
    ELSEIF (p_style = 111) THEN
        SET v_resmask = '%Y/%m/%d'; -- 2012/06/18
    ELSEIF (p_style = 12) THEN
        SET v_resmask = '%y%m%d'; -- 120618
    ELSEIF (p_style = 112) THEN
        SET v_resmask = '%Y%m%d'; -- 20120618
    ELSEIF (p_style = 131) THEN
        SET v_resmask = '%e/%m/%Y'; -- Hijri date
    END IF;

    -- Converting master date to a character string using conversion mask
    SET v_resstring = CASE
                         WHEN (p_style = 130) -- Hijri date
                         THEN CONCAT_WS(SPACE(1), LPAD(DAY(v_dateval), 2, SPACE(1)), -- Hijri day
                                                  v_monthname, -- Hijri month
                                                  YEAR(v_dateval)) -- Hijri year
                         WHEN (p_style IN (0, 9, 100, 109))
                         THEN CONCAT_WS(SPACE(1), v_monthname,
                                                  LPAD(DAY(p_dateval), 2, SPACE(1)),
                                                  YEAR(v_dateval))
                         ELSE DATE_FORMAT(v_dateval, v_resmask)
                      END;

    -- Resizing result string according to the data type size value
    SET v_resstring = SUBSTRING(v_resstring, 1, COALESCE(v_length, CHAR_LENGTH(v_resstring)));

    RETURN CASE
              WHEN v_resdatatype IN ('CHAR', 'NCHAR') THEN
                  RPAD(v_resstring, COALESCE(v_length, CHAR_LENGTH(v_resstring)), SPACE(1))
              ELSE v_resstring
           END;
END]]></complex-attribute>
                        <category _I_D="2b925ef4-6761-4415-bedb-67a32f446476" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="45a6133b-70b4-422d-b33d-1eec8ec92e1f" name="conv_greg_to_hijri" context="conv_greg_to_hijri" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function converts date from Gregorian calendar to the appropriate date in Hijri calendar.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_jdnum DOUBLE PRECISION;
    DECLARE v_lnum, v_nnum, v_inum, v_jnum DOUBLE PRECISION;
    DECLARE v_day, v_month, v_year INTEGER;
    DECLARE v_error_message VARCHAR(500);

    -- Declaration of error conditions and handlers
    DECLARE conversion_failed CONDITION FOR SQLSTATE '45530';
    DECLARE negative_date CONDITION FOR SQLSTATE '45531';
    DECLARE equal_to_zero CONDITION FOR SQLSTATE '45532';

    -- Date part value is negative
    DECLARE EXIT HANDLER FOR negative_date
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Any part of the date couldn't be negative';
    END;

    -- Year value is equal to zero
    DECLARE EXIT HANDLER FOR equal_to_zero
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Year couldn't be equal to zero';
    END;

    IF ((SIGN(p_day) = -1) OR
        (SIGN(p_month) = -1) OR
        (SIGN(p_year) = -1))
    THEN
        SIGNAL negative_date;
    ELSEIF (p_year = 0)
    THEN
        SIGNAL equal_to_zero;
    END IF;

    IF ((p_year > 1582) OR ((p_year = 1582) AND (p_month > 10)) OR ((p_year = 1582) AND (p_month = 10) AND (p_day > 14))) THEN
        SET v_jdnum = aws_sqlserver_ext.get_int_part((1461 * (p_year + 4800 + aws_sqlserver_ext.get_int_part((p_month - 14) / 12))) / 4) +
                      aws_sqlserver_ext.get_int_part((367 * (p_month - 2 - 12 * (aws_sqlserver_ext.get_int_part((p_month - 14) / 12)))) / 12) -
                      aws_sqlserver_ext.get_int_part((3 * (aws_sqlserver_ext.get_int_part((p_year + 4900 +
                      aws_sqlserver_ext.get_int_part((p_month - 14) / 12)) / 100))) / 4) + p_day - 32075;
    ELSE
        SET v_jdnum = 367 * p_year - aws_sqlserver_ext.get_int_part((7 * (p_year + 5001 +
                      aws_sqlserver_ext.get_int_part((p_month - 9) / 7))) / 4) +
                      aws_sqlserver_ext.get_int_part((275 * p_month) / 9) + p_day + 1729777;
    END IF;

    SET v_lnum = v_jdnum - 1948440 + 10632;
    SET v_nnum = aws_sqlserver_ext.get_int_part((v_lnum - 1) / 10631);
    SET v_lnum = v_lnum - 10631 * v_nnum + 354;
    SET v_jnum = (aws_sqlserver_ext.get_int_part((10985 - v_lnum) / 5316)) * (aws_sqlserver_ext.get_int_part((50 * v_lnum) / 17719)) +
                 (aws_sqlserver_ext.get_int_part(v_lnum / 5670)) * (aws_sqlserver_ext.get_int_part((43 * v_lnum) / 15238));
    SET v_lnum = v_lnum - (aws_sqlserver_ext.get_int_part((30 - v_jnum) / 15)) * (aws_sqlserver_ext.get_int_part((17719 * v_jnum) / 50)) -
                 (aws_sqlserver_ext.get_int_part(v_jnum / 16)) * (aws_sqlserver_ext.get_int_part((15238 * v_jnum) / 43)) + 29;

    SET v_month = aws_sqlserver_ext.get_int_part((24 * v_lnum) / 709);
    SET v_day = v_lnum - aws_sqlserver_ext.get_int_part((709 * v_month) / 24);
    SET v_year = 30 * v_nnum + v_jnum - 30;

    -- Constructing Hijri date from parts
    RETURN STR_TO_DATE(CONCAT_WS('.', v_day, -- day
                                      v_month, -- month
                                      v_year), -- year
                       '%d.%m.%Y');
END]]></complex-attribute>
                        <category _I_D="d8246dbf-8ee0-4cbf-a9b7-2c107bb4ad4b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8ec051da-635e-4ab9-bf3f-58e29f32102b" name="conv_hijri_to_greg" context="conv_hijri_to_greg" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function converts date from Hijri calendar to the appropriate date in Gregorian calendar.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_jdnum DOUBLE PRECISION;
    DECLARE v_lnum, v_inum, v_nnum, v_jnum, v_knum DOUBLE PRECISION;
    DECLARE v_day, v_month, v_year INTEGER;
    DECLARE v_error_message VARCHAR(500);

    -- Declaration of error conditions and handlers
    DECLARE conversion_failed CONDITION FOR SQLSTATE '45600';
    DECLARE invalid_datepart CONDITION FOR SQLSTATE '45751';
    DECLARE negative_date CONDITION FOR SQLSTATE '45752';
    DECLARE equal_to_zero CONDITION FOR SQLSTATE '45753';

    -- Some of the arguments have values which are not valid for date conversion
    DECLARE EXIT HANDLER FOR invalid_datepart
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'The date, constructed from supplied parts is invalid';
    END;

    -- STR_TO_DATE func supplied with incorrect date parts
    DECLARE CONTINUE HANDLER FOR 1411
    BEGIN
        SIGNAL invalid_datepart;
    END;

    -- STR_TO_DATE func supplied with incorrect date parts
    DECLARE EXIT HANDLER FOR 1292
    BEGIN
        SIGNAL invalid_datepart;
    END;

    -- Date part value is negative
    DECLARE EXIT HANDLER FOR negative_date
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Any part of the date couldn't be negative';
    END;

    -- Year value is equal to zero
    DECLARE EXIT HANDLER FOR equal_to_zero
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Year couldn't be equal to zero';
    END;

    IF ((SIGN(p_day) = -1) OR
        (SIGN(p_month) = -1) OR
        (SIGN(p_year) = -1))
    THEN
        SIGNAL negative_date;
    ELSEIF (p_year = 0)
    THEN
        SIGNAL equal_to_zero;
    END IF;

    SET v_jdnum = aws_sqlserver_ext.get_int_part((11 * p_year + 3) / 30) + 354 * p_year + 30 * p_month - aws_sqlserver_ext.get_int_part((p_month - 1) / 2) + p_day + 1948440 - 385;

    IF (v_jdnum > 2299160) THEN
        SET v_lnum = v_jdnum + 68569;
        SET v_nnum = aws_sqlserver_ext.get_int_part((4 * v_lnum) / 146097);
        SET v_lnum = v_lnum - aws_sqlserver_ext.get_int_part((146097 * v_nnum + 3) / 4);
        SET v_inum = aws_sqlserver_ext.get_int_part((4000 * (v_lnum + 1)) / 1461001);
        SET v_lnum = v_lnum - aws_sqlserver_ext.get_int_part((1461 * v_inum) / 4) + 31;
        SET v_jnum = aws_sqlserver_ext.get_int_part((80 * v_lnum) / 2447);
        SET v_day = v_lnum - aws_sqlserver_ext.get_int_part((2447 * v_jnum) / 80);
        SET v_lnum = aws_sqlserver_ext.get_int_part(v_jnum / 11);
        SET v_month = v_jnum + 2 - 12 * v_lnum;
        SET v_year = 100 * (v_nnum - 49) + v_inum + v_lnum;
    ELSE
        SET v_jnum = v_jdnum + 1402;
        SET v_knum = aws_sqlserver_ext.get_int_part((v_jnum - 1) / 1461);
        SET v_lnum = v_jnum - 1461 * v_knum;
        SET v_nnum = aws_sqlserver_ext.get_int_part((v_lnum - 1) / 365) - aws_sqlserver_ext.get_int_part(v_lnum / 1461);
        SET v_inum = v_lnum - 365 * v_nnum + 30;
        SET v_jnum = aws_sqlserver_ext.get_int_part((80 * v_inum) / 2447);
        SET v_day = v_inum-aws_sqlserver_ext.get_int_part((2447 * v_jnum) / 80);
        SET v_inum = aws_sqlserver_ext.get_int_part(v_jnum / 11);
        SET v_month = v_jnum + 2 - 12 * v_inum;
        SET v_year = 4 * v_knum + v_nnum + v_inum - 4716;
    END IF;

    -- Constructing Gregorian date from parts
    RETURN STR_TO_DATE(CONCAT_WS('.', v_day, -- day
                                      v_month, -- month
                                      v_year), -- year
                       '%d.%m.%Y');
END]]></complex-attribute>
                        <category _I_D="ab7ae8fd-1b2e-4ec5-99ee-873dee1ee459" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="fc8b4a90-3ed9-455c-8777-2c8eafd1fdf4" name="conv_string_to_date" context="conv_string_to_date" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function parses the TEXT string and converts it into a DATE value, according to specified style (conversion mask).]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    /* MS SQL Server session variables emulation:
       - LANGUAGE (SET LANGUAGE ENGLISH)
       - DATE_FORMAT (SET DATEFORMAT MDY) */
    DECLARE CONVERSION_LANG VARCHAR(50) DEFAULT ''; -- Override default language for parsing of months and days names, for example: ENGLISH
    DECLARE DATE_FORMAT VARCHAR(50) DEFAULT ''; -- Override using of the default date format (linked with language) - (MDY|YDM|DMY|DYM)
    /* ----- constants_declaration ----- */
    DECLARE v_date_format VARCHAR(10);
    DECLARE v_compmonth_regexp NVARCHAR(500);
    DECLARE v_lang_metadata_json JSON;
    DECLARE v_masksep CHAR(1);
    DECLARE v_day, v_month, v_monthname, v_year, v_leftpart, v_midpart, v_rightpart NVARCHAR(50);
    DECLARE v_mseconds INTEGER DEFAULT 0;
    DECLARE v_resdate, v_hijridate DATE;
    DECLARE v_resmask VARCHAR(30);
    DECLARE v_reversedpart NVARCHAR(100);
    DECLARE v_datestring NVARCHAR(150) DEFAULT LOWER(TRIM(p_datestring));
    DECLARE v_compyear_regexp VARCHAR(40) DEFAULT '([[:digit:]]{1,2}|[[:digit:]]{4})'; -- y/yy/yyyy
    DECLARE v_fullyear_regexp VARCHAR(20) DEFAULT '[[:digit:]]{4}'; -- yyyy
    DECLARE v_shortyear_regexp VARCHAR(20) DEFAULT '[[:digit:]]{1,2}'; -- y/yy
    DECLARE v_daymm_regexp VARCHAR(20) DEFAULT '[[:digit:]]{1,2}'; -- d/dd(m/mm)
    DECLARE v_timeunit_regexp VARCHAR(120) DEFAULT '[[:space:]]*[[:digit:]]{1,2}[[:space:]]*';
    DECLARE v_ms_regexp VARCHAR(120) DEFAULT '[[:space:]]*[[:digit:]]{1,9}[[:space:]]*';
    DECLARE v_AMPM_regexp VARCHAR(40) DEFAULT '[[:space:]]*(AM|PM)*';
    DECLARE v_hhmmssms_part VARCHAR(450) DEFAULT CONCAT('(',
    /* 03:24:36.347 or 03:24:36:347 */                  v_timeunit_regexp, '\:', v_timeunit_regexp, '|', -- 03:24
                                                        v_timeunit_regexp, '\:', v_timeunit_regexp, '\:', v_timeunit_regexp, '|', -- 03:24:36
                                                        v_timeunit_regexp, '\:', v_timeunit_regexp, '\:', v_timeunit_regexp, '(\.|\:)', v_ms_regexp, -- 03:24:36(./:)346
                                                        ')');
    DECLARE v_hhmmssms_dotpart VARCHAR(450) DEFAULT CONCAT('(',
    /* 03:24:36.347 */                                     v_timeunit_regexp, '\:', v_timeunit_regexp, '|', -- 03:24
                                                           v_timeunit_regexp, '\:', v_timeunit_regexp, '\:', v_timeunit_regexp, '|', -- 03:24:36
                                                           v_timeunit_regexp, '\:', v_timeunit_regexp, '\:', v_timeunit_regexp, '\.', v_ms_regexp, -- 03:24:36.346
                                                           ')?');
    DECLARE v_hhmmssms_mask VARCHAR(550) DEFAULT CONCAT('^[[:space:]]*', v_hhmmssms_part, v_AMPM_regexp, '[[:space:]]*$');
    DECLARE v_hhmmssms_dotmask VARCHAR(550) DEFAULT CONCAT('^[[:space:]]*', v_hhmmssms_dotpart, v_AMPM_regexp, '[[:space:]]*$');
    DECLARE v_defmask1 NVARCHAR(550) DEFAULT LOWER(CONCAT('^($comp_month$)[[:space:]]*', v_daymm_regexp, '[[:space:]]+', v_compyear_regexp, '$')); -- mon/Month d/dd y/yy/yyyy
    DECLARE v_defmask2 NVARCHAR(550) DEFAULT LOWER(CONCAT('^', v_daymm_regexp, '[[:space:]]*($comp_month$)[[:space:]]*', v_compyear_regexp, '$')); -- d/dd mon/Month y/yy/yyyy
    DECLARE v_defmask3 NVARCHAR(550) DEFAULT LOWER(CONCAT('^', v_fullyear_regexp, '[[:space:]]*($comp_month$)[[:space:]]*', v_daymm_regexp, '$')); -- yyyy mon/Month d/dd
    DECLARE v_defmask4 NVARCHAR(550) DEFAULT LOWER(CONCAT('^', v_fullyear_regexp, '[[:space:]]+', v_daymm_regexp, '[[:space:]]*($comp_month$)$')); -- yyyy d/dd mon/Month
    DECLARE v_defmask5 NVARCHAR(550) DEFAULT LOWER(CONCAT('^', v_daymm_regexp, '[[:space:]]+', v_compyear_regexp, '[[:space:]]*($comp_month$)$')); -- d/dd y/yy/yyyy mon/Month
    DECLARE v_defmask6 NVARCHAR(550) DEFAULT LOWER(CONCAT('^($comp_month$)[[:space:]]*', v_fullyear_regexp, '[[:space:]]+', v_daymm_regexp, '$')); -- mon/Month yyyy d/dd
    DECLARE v_defmask7 NVARCHAR(550) DEFAULT LOWER(CONCAT('^($comp_month$)[[:space:]]*', v_daymm_regexp, '[[:space:]]*,[[:space:]]*', v_compyear_regexp, '$')); -- mon/Month d/dd, y/yy/yyyy
    DECLARE v_defmask8 NVARCHAR(550) DEFAULT LOWER(CONCAT('^', v_fullyear_regexp, '[[:space:]]*($comp_month$).*$')); -- yyyy mon/Month
    DECLARE v_defmask9 NVARCHAR(550) DEFAULT LOWER(CONCAT('^($comp_month$)[[:space:]]*', v_fullyear_regexp, '.*$')); -- mon/Month yyyy
    DECLARE v_defmask10 NVARCHAR(550) DEFAULT LOWER(CONCAT('^', v_daymm_regexp, '[[:space:]]*\.[[:space:]]*($comp_month$)[[:space:]]*\.[[:space:]]*', v_compyear_regexp, '$')); -- (d/dd).(mon/Month).(y/yy/yyyy)
    DECLARE v_defmask11 NVARCHAR(550) DEFAULT LOWER(CONCAT('^', v_daymm_regexp, '[[:space:]]*/[[:space:]]*($comp_month$)[[:space:]]*/[[:space:]]*', v_compyear_regexp, '$')); -- (d/dd)/(mon/Month)/(y/yy/yyyy)
    DECLARE v_defmask12 NVARCHAR(550) DEFAULT LOWER(CONCAT('^', v_daymm_regexp, '[[:space:]]*-[[:space:]]*($comp_month$)[[:space:]]*-[[:space:]]*', v_compyear_regexp, '$')); -- (d/dd)-(mon/Month)-(y/yy/yyyy)
    DECLARE v_dotshortyearmask VARCHAR(150) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*\.[[:space:]]*', v_daymm_regexp, '[[:space:]]*\.[[:space:]]*', v_shortyear_regexp, '$'); -- (x/xx).(x/xx).(x/xx)
    DECLARE v_dotfullyearmask VARCHAR(150) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*\.[[:space:]]*', v_daymm_regexp, '[[:space:]]*\.[[:space:]]*', v_fullyear_regexp, '$'); -- (m/mm).(d/dd).yyyy
    DECLARE v_slashshortyearmask VARCHAR(150) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*/[[:space:]]*', v_daymm_regexp, '[[:space:]]*/[[:space:]]*', v_shortyear_regexp, '$'); -- (x/xx)/(x/xx)/(x/xx)
    DECLARE v_slashfullyearmask VARCHAR(150) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*/[[:space:]]*', v_daymm_regexp, '[[:space:]]*/[[:space:]]*', v_fullyear_regexp, '$'); -- (m/mm)/(d/dd)/yyyy
    DECLARE v_dashshortyearmask VARCHAR(150) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*-[[:space:]]*', v_daymm_regexp, '[[:space:]]*-[[:space:]]*', v_shortyear_regexp, '$'); -- (x/xx)-(x/xx)-(x/xx)
    DECLARE v_dashfullyearmask VARCHAR(150) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*-[[:space:]]*', v_daymm_regexp, '[[:space:]]*-[[:space:]]*', v_fullyear_regexp, '$'); -- (m/mm)-(d/dd)-yyyy
    DECLARE v_dotmask1 VARCHAR(150) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*\.[[:space:]]*', v_daymm_regexp, '[[:space:]]*\.[[:space:]]*', v_daymm_regexp, '$'); -- yyyy.(m/mm).(d/dd)
    DECLARE v_slashmask1 VARCHAR(150) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*/[[:space:]]*', v_daymm_regexp, '[[:space:]]*/[[:space:]]*', v_daymm_regexp, '$'); -- yyyy/(m/mm)/(d/dd)
    DECLARE v_dashmask1 VARCHAR(150) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*-[[:space:]]*', v_daymm_regexp, '[[:space:]]*-[[:space:]]*', v_daymm_regexp, '$'); -- yyyy-(m/mm)-(d/dd)
    DECLARE v_digitmask1 VARCHAR(50) DEFAULT '^[[:digit:]]{6}$'; -- yymmdd
    DECLARE v_digitmask2 VARCHAR(50) DEFAULT '^[[:digit:]]{8}$'; -- yyyymmdd

    -- Declaration of error conditions and handlers
    DECLARE v_error_message VARCHAR(500);
    DECLARE conversion_failed CONDITION FOR SQLSTATE '45520';
    DECLARE str_style_mismatch CONDITION FOR SQLSTATE '45521';
    DECLARE invalid_style CONDITION FOR SQLSTATE '45523';
    DECLARE YDM_not_supported CONDITION FOR SQLSTATE '45526';

    -- Conversion process failed
    DECLARE EXIT HANDLER FOR conversion_failed
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Conversion failed when converting date from character string.';
    END;

    -- Cases when stype param value is not not valid for string to date conversion
    DECLARE EXIT HANDLER FOR str_style_mismatch
    BEGIN
        SET v_error_message = CONCAT('The input character string doesn't follow style ', COALESCE(p_style, 'NULL'),
                                     ', either change the input character string or use a different style.');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Cases when stype param value is not not valid for date to string conversion
    DECLARE EXIT HANDLER FOR invalid_style
    BEGIN
        SET v_error_message = CONCAT('The style ', COALESCE(p_style, 'NULL'),
                                     ' is not supported for conversions from varchar to date.');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Cases when 'YDM' dateformat is not applicable to convert particular string expression
    DECLARE EXIT HANDLER FOR YDM_not_supported
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'The YDM date format isn't supported when converting from this string format to date.';
    END;

    -- Cases when constructed date is a Leap-year date (e.g. "29.02.2017")
    DECLARE EXIT HANDLER FOR 1292
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Conversion failed when converting date and time from character string.';
    END;

    -- Cases when STR_TO_DATE func supplied with incorrect date parts
    DECLARE EXIT HANDLER FOR 1411
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Conversion failed when converting date and time from character string.';
    END;

    -- Getting language metadata JSON by lang name (specified by CONVERSION_LANG constant)
    SET v_lang_metadata_json = aws_sqlserver_ext.get_lang_metadata_json(CONVERSION_LANG);

    -- Determining which DATE_FORMAT value to use
    SET v_date_format = COALESCE(NULLIF(UPPER(TRIM(DATE_FORMAT)), ''), JSON_UNQUOTE(JSON_EXTRACT(v_lang_metadata_json, '$.date_format')));

    -- Replacing arabic day half markers with AM|PM
    SET v_datestring = REPLACE(REPLACE(v_datestring, N'', 'AM'), N'', 'PM');

    SET v_compmonth_regexp = aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_names'), JSON_ARRAY('')), '|');

    SET v_compmonth_regexp = CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_extranames'), JSON_ARRAY('')), '|'), ''));

    SET v_compmonth_regexp = CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_shortnames'), JSON_ARRAY('')), '|'), ''));

    -- Composing complete months names regexp ("Jan|Feb|Mar|Apr|May|...")
    SET v_compmonth_regexp = UPPER(CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_extrashortnames'), JSON_ARRAY('')), '|'), '')));

    -- Throw an error if style param value is incorrect
    IF ((p_style NOT BETWEEN 0 AND 14) AND
        (p_style NOT BETWEEN 20 AND 25) AND
        (p_style NOT BETWEEN 100 AND 114) AND
        p_style NOT IN (120, 121, 126, 127, 130, 131))
    THEN
        SIGNAL invalid_style;
    END IF;

    -- Remove timestamp part (if exists and compared with date)
    IF((v_datestring REGEXP v_hhmmssms_part) AND
       (NOT v_datestring REGEXP v_hhmmssms_mask))
    THEN
        SET v_reversedpart = TRIM(REVERSE(SUBSTRING_INDEX(v_datestring, ':', 1)));
        SET v_datestring = REVERSE(SUBSTRING(v_reversedpart, LOCATE(SPACE(1), v_reversedpart) + 1));
    END IF;

    -- Replacing "$comp_month$" marker with composed months names regexp
    SET v_defmask1 = REPLACE(v_defmask1, '$comp_month$', v_compmonth_regexp);
    SET v_defmask2 = REPLACE(v_defmask2, '$comp_month$', v_compmonth_regexp);
    SET v_defmask3 = REPLACE(v_defmask3, '$comp_month$', v_compmonth_regexp);
    SET v_defmask4 = REPLACE(v_defmask4, '$comp_month$', v_compmonth_regexp);
    SET v_defmask5 = REPLACE(v_defmask5, '$comp_month$', v_compmonth_regexp);
    SET v_defmask6 = REPLACE(v_defmask6, '$comp_month$', v_compmonth_regexp);
    SET v_defmask7 = REPLACE(v_defmask7, '$comp_month$', v_compmonth_regexp);
    SET v_defmask8 = REPLACE(v_defmask8, '$comp_month$', v_compmonth_regexp);
    SET v_defmask9 = REPLACE(v_defmask9, '$comp_month$', v_compmonth_regexp);
    SET v_defmask10 = REPLACE(v_defmask10, '$comp_month$', v_compmonth_regexp);
    SET v_defmask11 = REPLACE(v_defmask11, '$comp_month$', v_compmonth_regexp);
    SET v_defmask12 = REPLACE(v_defmask12, '$comp_month$', v_compmonth_regexp);

    -- Match dates like "Feb 02 2017" etc. (see below desc.)
    IF ((v_datestring REGEXP v_defmask1) OR -- Feb 02 2017 (mon/Month d/dd y/yy/yyyy)
        (v_datestring REGEXP v_defmask2) OR -- 02 Feb 2017 (d/dd mon/Month y/yy/yyyy)
        (v_datestring REGEXP v_defmask3) OR -- 2017 Feb 02 (yyyy mon/Month d/dd)
        (v_datestring REGEXP v_defmask4) OR -- 2017 02 Feb (yyyy d/dd mon/Month)
        (v_datestring REGEXP v_defmask5) OR -- 02 2017 Feb (d/dd y/yy/yyyy mon/Month)
        (v_datestring REGEXP v_defmask6) OR -- Feb 2017 02 (mon/Month yyyy d/dd)
        (v_datestring REGEXP v_defmask7) OR -- Feb 02, 2017 (mon/Month d/dd, y/yy/yyyy)
        (v_datestring REGEXP v_defmask8) OR -- 2017 Feb (yyyy mon/Month)
        (v_datestring REGEXP v_defmask9) OR -- Feb 2017 (mon/Month yyyy)
        (v_datestring REGEXP v_defmask10) OR -- 16.Dec.17 ((d/dd).(mon/Month).(y/yy/yyyy))
        (v_datestring REGEXP v_defmask11) OR -- 16/Dec/17 ((d/dd)/(mon/Month)/(y/yy/yyyy))
        (v_datestring REGEXP v_defmask12)) -- 16-Dec-17 ((d/dd)-(mon/Month)-(y/yy/yyyy))
    THEN
        IF (p_style IN (130, 131)) THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        END IF;

        -- Extracting month part from supplied expression ("Feb" from "Feb02 2017")
        SET v_monthname = aws_sqlserver_ext.regexp_substr(v_datestring, CONCAT('(', v_compmonth_regexp, ')'), 1, 1, 'i');

        -- Obtaining month number (0-11) from month name (0 - January, 1 - February, 2 - March)
        SET v_month = aws_sqlserver_ext.get_monthnum_by_name(v_monthname, v_lang_metadata_json);

        IF (v_datestring REGEXP v_defmask1) -- Feb 02 2017 (mon/Month d/dd y/yy/yyyy)
        THEN
            SET v_year = SUBSTRING_INDEX(v_datestring, SPACE(1), -1);
            SET v_day = TRIM(SUBSTRING(v_datestring,
                                       CHAR_LENGTH(v_monthname) + 1,
                                       CHAR_LENGTH(v_datestring) - CHAR_LENGTH(v_monthname) - CHAR_LENGTH(v_year)));
        ELSEIF (v_datestring REGEXP v_defmask2) -- 02 Feb 2017 (d/dd mon/Month y/yy/yyyy)
        THEN
            SET v_day = RTRIM(LEFT(v_datestring, POSITION(v_monthname IN v_datestring) - 1));
            SET v_year = LTRIM(SUBSTRING(v_datestring, POSITION(v_monthname IN v_datestring) + CHAR_LENGTH(v_monthname)));
        ELSEIF (v_datestring REGEXP v_defmask3) -- 2017 Feb 02 (yyyy mon/Month d/dd)
        THEN
            SET v_day = LTRIM(SUBSTRING(v_datestring, POSITION(v_monthname IN v_datestring) + CHAR_LENGTH(v_monthname)));
            SET v_year = RTRIM(LEFT(v_datestring, POSITION(v_monthname IN v_datestring) - 1));
        ELSEIF (v_datestring REGEXP v_defmask4) -- 2017 02 Feb (yyyy d/dd mon/Month)
        THEN
            SET v_year = SUBSTRING_INDEX(v_datestring, SPACE(1), 1);
            SET v_day = TRIM(SUBSTRING(v_datestring,
                                       CHAR_LENGTH(v_year) + 1,
                                       CHAR_LENGTH(v_datestring) - CHAR_LENGTH(v_year) - CHAR_LENGTH(v_monthname)));
        ELSEIF (v_datestring REGEXP v_defmask5) -- 02 17(2017) Feb (d/dd y/yy/yyyy mon/Month)
        THEN
            SET v_day = RTRIM(SUBSTRING_INDEX(v_datestring, SPACE(1), 1));
            SET v_year = TRIM(SUBSTRING(v_datestring,
                                        CHAR_LENGTH(v_day) + 1,
                                        CHAR_LENGTH(v_datestring) - CHAR_LENGTH(v_day) - CHAR_LENGTH(v_monthname)));
        ELSEIF (v_datestring REGEXP v_defmask6) -- Feb 2017 02 (mon/Month yyyy d/dd)
        THEN
            SET v_day = LTRIM(SUBSTRING_INDEX(v_datestring, SPACE(1), -1));
            SET v_year = TRIM(SUBSTRING(v_datestring,
                                        CHAR_LENGTH(v_monthname) + 1,
                                        CHAR_LENGTH(v_datestring) - CHAR_LENGTH(v_day) - CHAR_LENGTH(v_monthname)));
        ELSEIF (v_datestring REGEXP v_defmask7) -- Feb 02, 2017 (mon/Month d/dd, y/yy/yyyy)
        THEN
            SET v_day = TRIM(SUBSTRING(SUBSTRING_INDEX(v_datestring, ',', 1),
                                       CHAR_LENGTH(v_monthname) + 1));
            SET v_year = LTRIM(SUBSTRING_INDEX(v_datestring, ',', -1));
        ELSEIF (v_datestring REGEXP v_defmask8) -- 2017 Feb (yyyy mon/Month)
        THEN
            SET v_day = 1;
            SET v_year = RTRIM(SUBSTRING(v_datestring, 1, CHAR_LENGTH(v_datestring) - CHAR_LENGTH(v_monthname)));
        ELSEIF (v_datestring REGEXP v_defmask9) -- Feb 2017 (mon/Month yyyy)
        THEN
            SET v_day = 1;
            SET v_year = LTRIM(SUBSTRING(v_datestring, CHAR_LENGTH(v_monthname) + 1));
        ELSE -- "16.Dec.17" or "16/Dec/17" or "16-Dec-17" (see masks above)
            SET v_masksep = CASE
                               WHEN (v_datestring REGEXP v_defmask10) THEN '.'
                               WHEN (v_datestring REGEXP v_defmask11) THEN '/'
                               ELSE '-'
                            END;
            SET v_day = RTRIM(SUBSTRING_INDEX(v_datestring, v_masksep, 1));
            SET v_year = LTRIM(SUBSTRING_INDEX(v_datestring, v_masksep, -1));
        END IF;

        -- Make sure that year is always presented as four-digit value
        SET v_year = aws_sqlserver_ext.get_full_year(v_year, '', NULL);
    ELSEIF ((v_datestring REGEXP v_dotshortyearmask) OR -- 03.05.17 (3.5.17 => March 5 2017)
            (v_datestring REGEXP v_dotfullyearmask) OR -- 03.05.1917 (3.5.1917 => March 5 1917)
            (v_datestring REGEXP v_slashshortyearmask) OR -- 03/05/17 (3/5/17 => March 5 2017)
            (v_datestring REGEXP v_slashfullyearmask) OR -- 03/05/1917 (3/5/1917 => March 5 1917)
            (v_datestring REGEXP v_dashshortyearmask) OR -- 03-05-17 (3-5-17 => March 5 2017)
            (v_datestring REGEXP v_dashfullyearmask)) -- 03-05-1917 (3-5-1917 => March 5 1917)
    THEN
        -- Picking up the right day parts separator
        SET v_masksep = CASE
                           WHEN ((v_datestring REGEXP v_dotshortyearmask) OR (v_datestring REGEXP v_dotfullyearmask)) THEN '.'
                           WHEN ((v_datestring REGEXP v_slashshortyearmask) OR (v_datestring REGEXP v_slashfullyearmask)) THEN '/'
                           ELSE '-'
                        END;

        -- Parse dirty string parts divided by separator
        SET v_leftpart = RTRIM(SUBSTRING_INDEX(v_datestring, v_masksep, 1));
        SET v_midpart = LTRIM(SUBSTRING_INDEX(RTRIM(SUBSTRING_INDEX(v_datestring, v_masksep, 2)), v_masksep, -1));
        SET v_rightpart = LTRIM(SUBSTRING_INDEX(v_datestring, v_masksep, -1));

        -- Common part regarding style param errors
        IF (p_style IN (6, 7, 8, 9, 12, 13, 14, 24, 100, 106, 107, 108, 109, 112, 113, 114, 130)) THEN
            -- Invalid stype param for string to date conversion
            SIGNAL str_style_mismatch;
        ELSEIF (p_style IN (20, 21, 23, 25, 102, 111, 120, 121, 126, 127)) THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        END IF;

        IF ((v_datestring REGEXP v_dotshortyearmask) OR -- 03.05.17
            (v_datestring REGEXP v_slashshortyearmask) OR -- 03/05/17
            (v_datestring REGEXP v_dashshortyearmask)) -- 03-05-17
        THEN
            IF ((p_style IN (1, 10, 22) AND v_date_format <> 'MDY') OR
                ((ISNULL(p_style) OR p_style IN (0, 1, 10, 22)) AND
                v_date_format NOT IN ('YDM', 'YMD', 'DMY', 'DYM', 'MYD')))
            THEN
                SET v_day = v_midpart;
                SET v_month = v_leftpart;
                SET v_year = aws_sqlserver_ext.get_full_year(v_rightpart, '', NULL);
            ELSEIF ((p_style IN (2, 11) AND v_date_format <> 'YMD') OR
                    ((ISNULL(p_style) OR p_style IN (0, 2, 11)) AND
                    v_date_format = 'YMD'))
            THEN
                SET v_day = v_rightpart;
                SET v_month = v_midpart;
                SET v_year = aws_sqlserver_ext.get_full_year(v_leftpart, '', NULL);
            ELSEIF ((p_style IN (3, 4, 5) AND v_date_format <> 'DMY') OR
                    ((ISNULL(p_style) OR p_style IN (0, 3, 4, 5)) AND
                    v_date_format = 'DMY'))
            THEN
                SET v_day = v_leftpart;
                SET v_month = v_midpart;
                SET v_year = aws_sqlserver_ext.get_full_year(v_rightpart, '', NULL);
            ELSEIF ((ISNULL(p_style) OR p_style = 0) AND v_date_format = 'DYM')
            THEN
                SET v_day = v_leftpart;
                SET v_month = v_rightpart;
                SET v_year = aws_sqlserver_ext.get_full_year(v_midpart, '', NULL);
            ELSEIF ((ISNULL(p_style) OR p_style = 0) AND v_date_format = 'MYD')
            THEN
                SET v_day = v_rightpart;
                SET v_month = v_leftpart;
                SET v_year = aws_sqlserver_ext.get_full_year(v_midpart, '', NULL);
            ELSEIF ((ISNULL(p_style) OR p_style = 0) AND v_date_format = 'YDM')
            THEN
                -- YDM date format isn't supported
                SIGNAL YDM_not_supported;
            ELSEIF (p_style IN (101, 103, 104, 105, 110, 131)) THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            END IF;
        ELSEIF ((v_datestring REGEXP v_dotfullyearmask) OR -- 03.05.2017
                (v_datestring REGEXP v_slashfullyearmask) OR -- 03/05/2017
                (v_datestring REGEXP v_dashfullyearmask)) -- 03-05-2017
        THEN
            -- Year is always from the right
            SET v_year = v_rightpart;

            IF (v_leftpart <= 12) THEN
                IF ((p_style IN (103, 104, 105, 131) AND v_date_format <> 'DMY') OR
                    ((ISNULL(p_style) OR p_style IN (0, 103, 104, 105, 131)) AND
                    v_date_format = 'DMY'))
                THEN
                    SET v_day = v_leftpart;
                    SET v_month = v_midpart;
                ELSEIF ((p_style IN (101, 110) AND v_date_format IN ('YDM', 'DMY', 'DYM')) OR
                        ((ISNULL(p_style) OR p_style IN (0, 101, 110)) AND
                        v_date_format NOT IN ('YDM', 'DMY', 'DYM')))
                THEN
                    SET v_day = v_midpart;
                    SET v_month = v_leftpart;
                ELSEIF ((p_style IN (1, 2, 3, 4, 5, 10, 11, 22) AND v_date_format <> 'YDM') OR
                        ((ISNULL(p_style) OR p_style IN (0, 1, 2, 3, 4, 5, 10, 11, 22)) AND
                        v_date_format = 'YDM'))
                THEN
                    -- Conversion failed
                    SIGNAL conversion_failed;
                END IF;
            ELSE
                IF ((p_style IN (103, 104, 105, 131) AND v_date_format <> 'DMY') OR
                    ((ISNULL(p_style) OR p_style IN (0, 103, 104, 105, 131)) AND
                    v_date_format = 'DMY'))
                THEN
                    SET v_day = v_leftpart;
                    SET v_month = v_midpart;
                ELSEIF ((p_style IN (1, 2, 3, 4, 5, 10, 11, 22, 101, 110) AND v_date_format = 'DMY') OR
                        ((ISNULL(p_style) OR p_style IN (0, 1, 2, 3, 4, 5, 10, 11, 22, 101, 110)) AND
                        v_date_format <> 'DMY'))
                THEN
                    -- Conversion failed
                    SIGNAL conversion_failed;
                END IF;
            END IF;
        END IF;
    ELSEIF ((v_datestring REGEXP v_dotmask1) OR -- 2007.05.12 (May 12 2007)
            (v_datestring REGEXP v_slashmask1) OR -- 2007/05/12
            (v_datestring REGEXP v_dashmask1)) -- 2007-05-12
    THEN
        -- Picking up the right day parts separator
        SET v_masksep = CASE
                           WHEN (v_datestring REGEXP v_dotmask1) THEN '.'
                           WHEN (v_datestring REGEXP v_slashmask1) THEN '/'
                           ELSE '-'
                        END;

        IF (p_style IN (6, 7, 8, 9, 12, 13, 14, 24, 100, 106, 107, 108, 109, 112, 113, 114, 130)) THEN
            -- Invalid stype param for string to date conversion
            SIGNAL str_style_mismatch;
        ELSEIF (p_style IN (1, 2, 3, 4, 5, 10, 11, 22, 101, 103, 104, 105, 110, 131)) THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        ELSE
            SET v_year = RTRIM(SUBSTRING_INDEX(v_datestring, v_masksep, 1));
            SET v_day = LTRIM(SUBSTRING_INDEX(v_datestring, v_masksep, -1));
            SET v_month = LTRIM(SUBSTRING_INDEX(RTRIM(SUBSTRING_INDEX(v_datestring, v_masksep, 2)), v_masksep, -1));
        END IF;
    ELSEIF ((v_datestring REGEXP v_digitmask1) OR -- yymmdd
            (v_datestring REGEXP v_digitmask2)) -- yyyymmdd
    THEN
        IF (v_datestring REGEXP v_digitmask1) -- yymmdd
        THEN
            SET v_day = SUBSTRING(v_datestring, 5, 2);
            SET v_month = SUBSTRING(v_datestring, 3, 2);
            SET v_year = aws_sqlserver_ext.get_full_year(SUBSTRING(v_datestring, 1, 2), '', NULL);
        ELSE
            SET v_day = SUBSTRING(v_datestring, 7, 2);
            SET v_month = SUBSTRING(v_datestring, 5, 2);
            SET v_year = SUBSTRING(v_datestring, 1, 4);
        END IF;
    ELSEIF (v_datestring REGEXP v_hhmmssms_mask) -- 03:24:36[.|:]347
    THEN
        -- Extracting microseconds value from source date string
        SET v_mseconds = COALESCE(aws_sqlserver_ext.extract_time_unit(v_datestring, 'MICROSECONDS'), 0);

        IF ((v_datestring NOT REGEXP v_hhmmssms_dotmask) AND -- 03:24:36.347
            (CHAR_LENGTH(v_mseconds) > 3))
        THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        END IF;

        SET v_day = 1, v_month = 1, v_year = 1900; -- 01.01.1900
    ELSE
        -- Conversion failed
        SIGNAL conversion_failed;
    END IF;

    -- Hijri date block
    IF (((v_datestring REGEXP v_hhmmssms_mask) AND p_style IN (130, 131)) OR -- 03:24:36[.|:]347
        (((v_datestring REGEXP v_digitmask1) OR -- yymmdd
         (v_datestring REGEXP v_digitmask2)) AND p_style IN (130, 131)) OR -- yyyymmdd
        (((v_datestring REGEXP v_dotfullyearmask) OR (v_datestring REGEXP v_slashfullyearmask) OR -- (m/mm)[.|/](d/dd)[.|/]yyyy
        (v_datestring REGEXP v_dashfullyearmask)) AND p_style = 131)) -- (m/mm)-(d/dd)-yyyy
    THEN
        -- Checking that day parts lie within correct value ranges
        IF ((v_month NOT BETWEEN 1 AND 12) OR
            (v_day NOT BETWEEN 1 AND 29))
        THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        END IF;

       -- Calculating Hijri date and converting it back to Gregorian
        SET v_hijridate = aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_year) - 1;
        SET v_day = DAY(v_hijridate);
        SET v_month = MONTH(v_hijridate);
        SET v_year = YEAR(v_hijridate);
    END IF;

    -- Constructing date object from separate date parts
    RETURN STR_TO_DATE(CONCAT_WS('.', v_day, v_month, v_year),
                       '%d.%m.%Y');
END]]></complex-attribute>
                        <category _I_D="61e45d4f-d29a-4c8a-8cd7-d45c021121cf" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0451ae37-cfd6-448c-8f01-3006fc657f12" name="conv_string_to_datetime" context="conv_string_to_datetime" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function parses the TEXT string and converts it into a DATETIME value, according to specified style (conversion mask).]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    /*
    *   Title: Parse the TEXT string and convert it into a DATETIME value, according to specified style (conversion mask)
    *   Author: Andrii Oseledko
    *   Date: 09.09.2021
    *   Code version: 2.0
    *   Description: MS SQL Server style conversion mask values described here:
    *   https://docs.microsoft.com/en-us/sql/t-sql/functions/cast-and-convert-transact-sql#date-and-time-styles
    *   Arabic style date format conversion is supported by using the Kuwaiti algorithm.
    */
    /* MS SQL Server session variables emulation:
       - LANGUAGE (SET LANGUAGE ENGLISH)
       - DATE_FORMAT (SET DATEFORMAT MDY) */
    DECLARE CONVERSION_LANG VARCHAR(50) DEFAULT ''; -- Override default language for parsing of months and days names, for example: ENGLISH
    DECLARE DATE_FORMAT VARCHAR(50) DEFAULT ''; -- Override using of the default date format (linked with language) - (MDY|YDM|DMY|DYM)
    /* ----- constants_declaration ----- */
    DECLARE v_date_format VARCHAR(10);
    DECLARE v_compmonth_regexp NVARCHAR(500);
    DECLARE v_lang_metadata_json JSON;
    DECLARE v_datatype VARCHAR(100) DEFAULT UPPER(TRIM(p_datatype));
    DECLARE v_datetimestring NVARCHAR(4000) DEFAULT LOWER(TRIM(p_datetimestring));
    DECLARE v_day, v_month, v_monthname, v_year NVARCHAR(50);
    DECLARE v_leftpart, v_midpart, v_rightpart, v_timepart NVARCHAR(500);
    DECLARE v_datepart NVARCHAR(150);
    DECLARE v_masksep CHAR(1);
    DECLARE v_resdatetime DATETIME(6);
    DECLARE v_hijridate DATE;
    DECLARE v_resmask VARCHAR(30);
    DECLARE v_reversedpart NVARCHAR(100);
    DECLARE v_length, v_scale, v_rndfract INTEGER;
    DECLARE v_resdatatype VARCHAR(100);
    DECLARE v_hours, v_minutes, v_seconds, v_fseconds INTEGER DEFAULT 0;
    DECLARE v_datatype_mask VARCHAR(120) DEFAULT '^[[:space:]]*(DATETIME|SMALLDATETIME|DATETIME2)[[:space:]]*\([[:space:]]*([[:digit:]]+)[[:space:]]*\)[[:space:]]*$'; -- DATETIME2(7)
    DECLARE v_datatype_regexp VARCHAR(120) DEFAULT '^[[:space:]]*(DATETIME|SMALLDATETIME|DATETIME2)[[:space:]]*$'; -- DATETIME/SMALLDATETIME/DATETIME2
    DECLARE v_compyear_regexp VARCHAR(40) DEFAULT '([[:digit:]]{1,2}|[[:digit:]]{4})'; -- y/yy/yyyy
    DECLARE v_fullyear_regexp VARCHAR(20) DEFAULT '[[:digit:]]{4}'; -- yyyy
    DECLARE v_shortyear_regexp VARCHAR(20) DEFAULT '[[:digit:]]{1,2}'; -- y/yy
    DECLARE v_daymm_regexp VARCHAR(20) DEFAULT '[[:digit:]]{1,2}'; -- d/dd(m/mm)
    DECLARE v_timeunit_regexp VARCHAR(120) DEFAULT '[[:space:]]*[[:digit:]]{1,2}[[:space:]]*';
    DECLARE v_ms_regexp VARCHAR(120) DEFAULT '[[:space:]]*[[:digit:]]{1,9}[[:space:]]*';
    DECLARE v_AMPM_regexp VARCHAR(40) DEFAULT '[[:space:]]*(AM|PM)*';
    DECLARE v_hhmmssms_regexp VARCHAR(450) DEFAULT CONCAT('(',
    /* 03:24:36.347 or 03:24:36:347 */                    '[[:space:]]+', v_timeunit_regexp, '\:', v_timeunit_regexp, '|', -- 03:24
                                                          '[[:space:]]+', v_timeunit_regexp, '\:', v_timeunit_regexp, '\:', v_timeunit_regexp, '|', -- 03:24:36
                                                          '[[:space:]]+', v_timeunit_regexp, '\:', v_timeunit_regexp, '\:', v_timeunit_regexp, '(\.|\:)', v_ms_regexp, -- 03:24:36(./:)346
                                                          ')?');
    DECLARE v_hhmmssms_part VARCHAR(450) DEFAULT CONCAT('(',
    /* 03:24:36.347 or 03:24:36:347 */                  v_timeunit_regexp, '\:', v_timeunit_regexp, '|', -- 03:24
                                                        v_timeunit_regexp, '\:', v_timeunit_regexp, '\:', v_timeunit_regexp, '|', -- 03:24:36
                                                        v_timeunit_regexp, '\:', v_timeunit_regexp, '\:', v_timeunit_regexp, '(\.|\:)', v_ms_regexp, -- 03:24:36(./:)346
                                                        ')?');
    DECLARE v_hhmmssms_dotpart VARCHAR(450) DEFAULT CONCAT('(',
    /* 03:24:36.347 */                                     v_timeunit_regexp, '\:', v_timeunit_regexp, '|', -- 03:24
                                                           v_timeunit_regexp, '\:', v_timeunit_regexp, '\:', v_timeunit_regexp, '|', -- 03:24:36
                                                           v_timeunit_regexp, '\:', v_timeunit_regexp, '\:', v_timeunit_regexp, '\.', v_ms_regexp, -- 03:24:36.346
                                                           ')?');
    DECLARE v_hhmmssms_mask VARCHAR(550) DEFAULT CONCAT('^[[:space:]]*', v_hhmmssms_part, v_AMPM_regexp, '[[:space:]]*$');
    DECLARE v_hhmmssms_dotmask VARCHAR(550) DEFAULT CONCAT('^[[:space:]]*', v_hhmmssms_dotpart, v_AMPM_regexp, '[[:space:]]*$');
    DECLARE v_defmask1 NVARCHAR(800) DEFAULT LOWER(CONCAT('^[[:space:]]*(\.|-|/)*[[:space:]]*($comp_month$)[[:space:]]*', v_daymm_regexp, '[[:space:]]+', v_compyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- mon/Month d/dd y/yy/yyyy HH:mi:ss(./:)ms
    DECLARE v_defmask1_sep NVARCHAR(800) DEFAULT LOWER(CONCAT('^[[:space:]]*(\.|-|/)?[[:space:]]*($comp_month$)[[:space:]]*', v_daymm_regexp, '[[:space:]]+', v_compyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- mon/Month d/dd y/yy/yyyy HH:mi:ss(./:)ms
    DECLARE v_defmask2 NVARCHAR(800) DEFAULT LOWER(CONCAT('^', v_daymm_regexp, '[[:space:]]*($comp_month$)[[:space:]]*', v_compyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- d/dd mon/Month y/yy/yyyy HH:mi:ss(./:)ms
    DECLARE v_defmask3 NVARCHAR(800) DEFAULT LOWER(CONCAT('^', v_fullyear_regexp, '[[:space:]]*($comp_month$)[[:space:]]*', v_daymm_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- yyyy mon/Month d/dd HH:mi:ss(./:)ms
    DECLARE v_defmask4 NVARCHAR(800) DEFAULT LOWER(CONCAT('^', v_fullyear_regexp, '[[:space:]]+', v_daymm_regexp, '[[:space:]]*($comp_month$)', v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- yyyy d/dd mon/Month HH:mi:ss(./:)ms
    DECLARE v_defmask5 NVARCHAR(800) DEFAULT LOWER(CONCAT('^', v_daymm_regexp, '[[:space:]]+', v_compyear_regexp, '[[:space:]]*($comp_month$)', v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- d/dd y/yy/yyyy mon/Month HH:mi:ss(./:)ms
    DECLARE v_defmask6 NVARCHAR(800) DEFAULT LOWER(CONCAT('^[[:space:]]*(\.|-|/)*[[:space:]]*($comp_month$)[[:space:]]*', v_fullyear_regexp, '[[:space:]]+', v_daymm_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- mon/Month yyyy d/dd HH:mi:ss(./:)ms
    DECLARE v_defmask6_sep NVARCHAR(800) DEFAULT LOWER(CONCAT('^[[:space:]]*(\.|-|/)?[[:space:]]*($comp_month$)[[:space:]]*', v_fullyear_regexp, '[[:space:]]+', v_daymm_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- mon/Month yyyy d/dd HH:mi:ss(./:)ms
    DECLARE v_defmask7 NVARCHAR(800) DEFAULT LOWER(CONCAT('^[[:space:]]*(\.|-|/)*[[:space:]]*($comp_month$)[[:space:]]*', v_daymm_regexp, '[[:space:]]*,[[:space:]]*', v_compyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- mon/Month d/dd, y/yy/yyyy HH:mi:ss(./:)ms
    DECLARE v_defmask7_sep NVARCHAR(800) DEFAULT LOWER(CONCAT('^[[:space:]]*(\.|-|/)?[[:space:]]*($comp_month$)[[:space:]]*', v_daymm_regexp, '[[:space:]]*,[[:space:]]*', v_compyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- mon/Month d/dd, y/yy/yyyy HH:mi:ss(./:)ms
    DECLARE v_defmask8 NVARCHAR(800) DEFAULT LOWER(CONCAT('^', v_fullyear_regexp, '[[:space:]]*($comp_month$)', v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- yyyy mon/Month HH:mi:ss(./:)ms
    DECLARE v_defmask9 NVARCHAR(800) DEFAULT LOWER(CONCAT('^[[:space:]]*(\.|-|/)*[[:space:]]*($comp_month$)[[:space:]]*', v_fullyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- mon/Month yyyy HH:mi:ss(./:)ms
    DECLARE v_defmask9_sep NVARCHAR(800) DEFAULT LOWER(CONCAT('^[[:space:]]*(\.|-|/)?[[:space:]]*($comp_month$)[[:space:]]*', v_fullyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- mon/Month yyyy HH:mi:ss(./:)ms
    DECLARE v_defmask10 NVARCHAR(800) DEFAULT LOWER(CONCAT('^', v_daymm_regexp, '[[:space:]]*\.[[:space:]]*($comp_month$)[[:space:]]*\.[[:space:]]*', v_compyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- (d/dd).(mon/Month).(y/yy/yyyy) HH:mi:ss(./:)ms
    DECLARE v_defmask11 NVARCHAR(800) DEFAULT LOWER(CONCAT('^', v_daymm_regexp, '[[:space:]]*/[[:space:]]*($comp_month$)[[:space:]]*/[[:space:]]*', v_compyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- (d/dd)/(mon/Month)/(y/yy/yyyy) HH:mi:ss(./:)ms
    DECLARE v_defmask12 NVARCHAR(800) DEFAULT LOWER(CONCAT('^', v_daymm_regexp, '[[:space:]]*-[[:space:]]*($comp_month$)[[:space:]]*-[[:space:]]*', v_compyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$')); -- (d/dd)-(mon/Month)-(y/yy/yyyy) HH:mi:ss(./:)ms
    DECLARE v_dotshortyearmask VARCHAR(600) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*\.[[:space:]]*', v_daymm_regexp, '[[:space:]]*\.[[:space:]]*', v_shortyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$'); -- (x/xx).(x/xx).(x/xx) HH:mi:ss(./:)ms
    DECLARE v_dotfullyearmask VARCHAR(600) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*\.[[:space:]]*', v_daymm_regexp, '[[:space:]]*\.[[:space:]]*', v_fullyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$'); -- (m/mm).(d/dd).yyyy HH:mi:ss(./:)ms
    DECLARE v_slashshortyearmask VARCHAR(600) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*/[[:space:]]*', v_daymm_regexp, '[[:space:]]*/[[:space:]]*', v_shortyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$'); -- (x/xx)/(x/xx)/(x/xx) HH:mi:ss(./:)ms
    DECLARE v_slashfullyearmask VARCHAR(600) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*/[[:space:]]*', v_daymm_regexp, '[[:space:]]*/[[:space:]]*', v_fullyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$'); -- (m/mm)/(d/dd)/yyyy HH:mi:ss(./:)ms
    DECLARE v_dashshortyearmask VARCHAR(600) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*-[[:space:]]*', v_daymm_regexp, '[[:space:]]*-[[:space:]]*', v_shortyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$'); -- (x/xx)-(x/xx)-(x/xx) HH:mi:ss(./:)ms
    DECLARE v_dashfullyearmask VARCHAR(600) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*-[[:space:]]*', v_daymm_regexp, '[[:space:]]*-[[:space:]]*', v_fullyear_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$'); -- (m/mm)-(d/dd)-yyyy HH:mi:ss(./:)ms
    DECLARE v_dotmask1 VARCHAR(600) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*\.[[:space:]]*', v_daymm_regexp, '[[:space:]]*\.[[:space:]]*', v_daymm_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$'); -- yyyy.(m/mm).(d/dd) HH:mi:ss(./:)ms
    DECLARE v_slashmask1 VARCHAR(600) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*/[[:space:]]*', v_daymm_regexp, '[[:space:]]*/[[:space:]]*', v_daymm_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$'); -- yyyy/(m/mm)/(d/dd) HH:mi:ss(./:)ms
    DECLARE v_dashmask1 VARCHAR(600) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*-[[:space:]]*', v_daymm_regexp, '[[:space:]]*-[[:space:]]*', v_daymm_regexp, v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$'); -- yyyy-(m/mm)-(d/dd) HH:mi:ss(./:)ms
    DECLARE v_digitmask1 VARCHAR(500) DEFAULT CONCAT('^[[:digit:]]{6}', v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$'); -- yymmdd HH:mi:ss(./:)ms
    DECLARE v_digitmask2 VARCHAR(500) DEFAULT CONCAT('^[[:digit:]]{8}', v_hhmmssms_regexp, v_AMPM_regexp, '[[:space:]]*$'); -- yyyymmdd HH:mi:ss(./:)ms

    -- Declaration of eror coditions and handlers
    DECLARE v_error_message VARCHAR(500);
    DECLARE conversion_failed CONDITION FOR SQLSTATE '45520';
    DECLARE outofrange_value CONDITION FOR SQLSTATE '45600';
    DECLARE str_style_mismatch CONDITION FOR SQLSTATE '45521';
    DECLARE invalid_dtype_scale CONDITION FOR SQLSTATE '45522';
    DECLARE invalid_style CONDITION FOR SQLSTATE '45523';
    DECLARE incorrect_datatype CONDITION FOR SQLSTATE '45524';
    DECLARE value_out_of_range CONDITION FOR SQLSTATE '45525';
    DECLARE YDM_not_supported CONDITION FOR SQLSTATE '45526';

    -- Conversion process failed
    DECLARE EXIT HANDLER FOR conversion_failed
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Conversion failed when converting date and time from character string.';
    END;

    -- Cases when "datetimefromparts" function supplied with incorrect date parts
    DECLARE EXIT HANDLER FOR outofrange_value
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'The conversion of a varchar data type to a datetime data type resulted in an out-of-range value.';
    END;

    -- Cases when stype param value is not not valid for date to string conversion
    DECLARE EXIT HANDLER FOR str_style_mismatch
    BEGIN
        SET v_error_message = CONCAT('The input character string doesn't follow style ', COALESCE(p_style, 'NULL'),
                                     ', either change the input character string or use a different style.');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Cases when specified DATETIME2 scale is not in range 0..7
    DECLARE EXIT HANDLER FOR invalid_dtype_scale
    BEGIN
        SET v_error_message = CONCAT('Specified scale ', v_scale, ' is invalid.');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Cases when stype param value is not not valid for date to string conversion
    DECLARE EXIT HANDLER FOR invalid_style
    BEGIN
        SET v_error_message = CONCAT('The style ', COALESCE(p_style, 'NULL'),
                                     ' is not supported for conversions from varchar to date and time.');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Cases when supplied data type param value is not one of DATETIME|SMALLDATETIME|DATETIME2
    DECLARE EXIT HANDLER FOR incorrect_datatype
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Data type should be one of these values: 'DATETIME', 'SMALLDATETIME', 'DATETIME2'/'DATETIME2(n)'.';
    END;

    -- Cases when conversion process results in an out-of-range value
    DECLARE EXIT HANDLER FOR value_out_of_range
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'The conversion of a varchar(nvarchar) data type to a datetime(smalldatetime) data type resulted in an out-of-range value.';
    END;

    -- Cases when 'YDM' dateformat is not applicable to convert particular string expression
    DECLARE EXIT HANDLER FOR YDM_not_supported
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'The YDM date format isn't supported when converting from this string format to date.';
    END;

    -- STR_TO_DATE function supplied with incorrect date parts
    DECLARE EXIT HANDLER FOR 1411
    BEGIN
        IF (v_resdatatype = 'DATETIME2') THEN
            SIGNAL conversion_failed
            SET MESSAGE_TEXT = 'Conversion failed when converting date and time from character string.';
        ELSE
            SIGNAL value_out_of_range
            SET MESSAGE_TEXT = 'The conversion of a varchar(nvarchar) data type to a datetime(smalldatetime) data type resulted in an out-of-range value.';
        END IF;
    END;

    -- STR_TO_DATE function supplied with incorrect date parts
    DECLARE EXIT HANDLER FOR 1292
    BEGIN
        IF (v_resdatatype = 'DATETIME2') THEN
            SIGNAL conversion_failed
            SET MESSAGE_TEXT = 'Conversion failed when converting date and time from character string.';
        ELSE
            SIGNAL value_out_of_range
            SET MESSAGE_TEXT = 'The conversion of a varchar(nvarchar) data type to a datetime(smalldatetime) data type resulted in an out-of-range value.';
        END IF;
    END;

    -- Parse supplied datatype expression - extract data type and scale
    IF (v_datatype REGEXP v_datatype_mask) -- DATETIME2(x)
    THEN
        SET v_resdatatype = RTRIM(SUBSTRING_INDEX(v_datatype, '(', 1));

        -- Extract scale data from datatype expression
        SET v_scale = CONVERT(TRIM(SUBSTRING(v_datatype,
                                   INSTR(v_datatype, '(') + 1,
                                   (INSTR(v_datatype, ')') - INSTR(v_datatype, '(') - 1))), UNSIGNED);
        IF (v_scale NOT BETWEEN 0 AND 7) THEN -- 0 => 6(7)
            SIGNAL invalid_dtype_scale;
        END IF;

        SET v_scale = IF(v_scale = 7, 6, v_scale);
    ELSEIF (v_datatype REGEXP v_datatype_regexp) THEN
        SET v_resdatatype = RTRIM(v_datatype);
        SET v_scale = 6; -- Default MS SQL DATETIME2 scale is 7, 6 - for MySQL
    ELSE
        -- Incorrect target datatype
        SIGNAL incorrect_datatype;
    END IF;

    -- Getting language metadata JSON by lang name (specified by CONVERSION_LANG constant)
    SET v_lang_metadata_json = aws_sqlserver_ext.get_lang_metadata_json(CONVERSION_LANG);

    -- Determining which DATE_FORMAT value to use
    SET v_date_format = COALESCE(NULLIF(UPPER(TRIM(DATE_FORMAT)), ''), JSON_UNQUOTE(JSON_EXTRACT(v_lang_metadata_json, '$.date_format')));

    -- Replacing arabic day half markers with AM|PM
    SET v_datetimestring = REPLACE(REPLACE(v_datetimestring, N'', 'AM'), N'', 'PM');

    SET v_compmonth_regexp = aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_names'), JSON_ARRAY('')), '|');

    SET v_compmonth_regexp = CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_extranames'), JSON_ARRAY('')), '|'), ''));

    SET v_compmonth_regexp = CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_shortnames'), JSON_ARRAY('')), '|'), ''));

    -- Composing complete months names regexp ("Jan|Feb|Mar|Apr|May|...")
    SET v_compmonth_regexp = UPPER(CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_extrashortnames'), JSON_ARRAY('')), '|'), '')));

    -- Replacing "$comp_month$" marker with composed months names regexp
    SET v_defmask1 = REPLACE(v_defmask1, '$comp_month$', v_compmonth_regexp);
    SET v_defmask1_sep = REPLACE(v_defmask1_sep, '$comp_month$', v_compmonth_regexp);
    SET v_defmask2 = REPLACE(v_defmask2, '$comp_month$', v_compmonth_regexp);
    SET v_defmask3 = REPLACE(v_defmask3, '$comp_month$', v_compmonth_regexp);
    SET v_defmask4 = REPLACE(v_defmask4, '$comp_month$', v_compmonth_regexp);
    SET v_defmask5 = REPLACE(v_defmask5, '$comp_month$', v_compmonth_regexp);
    SET v_defmask6 = REPLACE(v_defmask6, '$comp_month$', v_compmonth_regexp);
    SET v_defmask6_sep = REPLACE(v_defmask6_sep, '$comp_month$', v_compmonth_regexp);
    SET v_defmask7 = REPLACE(v_defmask7, '$comp_month$', v_compmonth_regexp);
    SET v_defmask7_sep = REPLACE(v_defmask7_sep, '$comp_month$', v_compmonth_regexp);
    SET v_defmask8 = REPLACE(v_defmask8, '$comp_month$', v_compmonth_regexp);
    SET v_defmask9 = REPLACE(v_defmask9, '$comp_month$', v_compmonth_regexp);
    SET v_defmask9_sep = REPLACE(v_defmask9_sep, '$comp_month$', v_compmonth_regexp);
    SET v_defmask10 = REPLACE(v_defmask10, '$comp_month$', v_compmonth_regexp);
    SET v_defmask11 = REPLACE(v_defmask11, '$comp_month$', v_compmonth_regexp);
    SET v_defmask12 = REPLACE(v_defmask12, '$comp_month$', v_compmonth_regexp);

    -- Match dates like "Feb 02 2017" etc. (see below desc.)
    IF ((v_datetimestring REGEXP v_defmask1) OR -- Feb 02 2017 (mon/Month d/dd y/yy/yyyy)
        (v_datetimestring REGEXP v_defmask2) OR -- 02 Feb 2017 (d/dd mon/Month y/yy/yyyy)
        (v_datetimestring REGEXP v_defmask3) OR -- 2017 Feb 02 (yyyy mon/Month d/dd)
        (v_datetimestring REGEXP v_defmask4) OR -- 2017 02 Feb (yyyy d/dd mon/Month)
        (v_datetimestring REGEXP v_defmask5) OR -- 02 2017 Feb (d/dd y/yy/yyyy mon/Month)
        (v_datetimestring REGEXP v_defmask6) OR -- Feb 2017 02 (mon/Month yyyy d/dd)
        (v_datetimestring REGEXP v_defmask7) OR -- Feb 02, 2017 (mon/Month d/dd, y/yy/yyyy)
        (v_datetimestring REGEXP v_defmask8) OR -- 2017 Feb (yyyy mon/Month)
        (v_datetimestring REGEXP v_defmask9) OR -- Feb 2017 (mon/Month yyyy)
        (v_datetimestring REGEXP v_defmask10) OR -- 16.Dec.17 ((d/dd).(mon/Month).(y/yy/yyyy))
        (v_datetimestring REGEXP v_defmask11) OR -- 16/Dec/17 ((d/dd)/(mon/Month)/(y/yy/yyyy))
        (v_datetimestring REGEXP v_defmask12)) -- 16-Dec-17 ((d/dd)-(mon/Month)-(y/yy/yyyy))
    THEN
        IF ((p_style IN (127, 130, 131) AND v_resdatatype IN ('DATETIME', 'SMALLDATETIME')) OR
            (p_style IN (130, 131) AND v_resdatatype = 'DATETIME2'))
        THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        ELSEIF (((p_style BETWEEN 15 AND 19) OR
                 (p_style BETWEEN 26 AND 99) OR
                 (p_style BETWEEN 115 AND 119) OR
                 (p_style IN (122, 123, 124, 125, 128, 129))) AND
                v_resdatatype = 'DATETIME2')
        THEN
            /* Incorrect style param value
               for this mask and data type */
            SIGNAL invalid_style;
        END IF;

        -- Extracting month part from supplied expression ("Feb" from "Feb02 2017")
        SET v_monthname = aws_sqlserver_ext.regexp_substr(v_datetimestring, CONCAT('(', v_compmonth_regexp, ')'), 1, 1, 'i');

        -- Obtaining month number (0-11) from month name (0 - January, 1 - February, 2 - March)
        SET v_month = aws_sqlserver_ext.get_monthnum_by_name(v_monthname, v_lang_metadata_json);

        IF (v_datetimestring REGEXP v_defmask1) -- Feb 02 2017 (mon/Month d/dd y/yy/yyyy HH:mi:ss(./:)ms)
        THEN
            IF (v_datetimestring REGEXP v_defmask1_sep) -- mon/Month d/dd y/yy/yyyy HH:mi:ss(./:)ms
            THEN
                -- Divide string expresion into two constituents - date and time parts
                SET v_datetimestring = LTRIM(SUBSTRING(v_datetimestring, POSITION(v_monthname IN v_datetimestring)));
                SET v_timepart = TRIM(REPLACE(v_datetimestring, v_monthname, SPACE(0))); -- May 12 17 15:34:59.755 => 12 17 15:34:59.755
                SET v_timepart = TRIM(SUBSTRING(v_timepart, POSITION(SPACE(1) IN v_timepart))); -- 12 17 15:34:59.755 => 17 15:34:59.755
                SET v_timepart = TRIM(SUBSTRING(v_timepart, POSITION(SPACE(1) IN v_timepart))); -- 17 15:34:59.755 => 15:34:59.755
                SET v_datepart = TRIM(REPLACE(v_datetimestring, v_timepart, SPACE(0))); -- May 12 17 15:34:59.755 => May 12 17
                SET v_year = SUBSTRING_INDEX(v_datepart, SPACE(1), -1);
                SET v_day = TRIM(SUBSTRING(v_datepart, CHAR_LENGTH(v_monthname) + 1, CHAR_LENGTH(v_datepart) - CHAR_LENGTH(v_monthname) - CHAR_LENGTH(v_year)));
            ELSE
                -- Incorrect date parts
                SIGNAL outofrange_value;
            END IF;
        ELSEIF (v_datetimestring REGEXP v_defmask2) -- 02 Feb 2017 (d/dd mon/Month y/yy/yyyy HH:mi:ss(./:)ms)
        THEN
            SET v_timepart = TRIM(SUBSTRING(v_datetimestring, POSITION(v_monthname IN v_datetimestring) + CHAR_LENGTH(v_monthname))); -- 12 May 17 15:34:59.755 => 17 15:34:59.755
            SET v_timepart = TRIM(SUBSTRING(v_timepart, POSITION(SPACE(1) IN v_timepart))); -- 17 15:34:59.755 => 15:34:59.755
            SET v_datepart = TRIM(REPLACE(v_datetimestring, v_timepart, SPACE(0))); -- 12 May 17 15:34:59.755 => 12 May 17
            SET v_day = RTRIM(LEFT(v_datepart, POSITION(v_monthname IN v_datepart) - 1));
            SET v_year = LTRIM(SUBSTRING(v_datepart, POSITION(v_monthname IN v_datepart) + CHAR_LENGTH(v_monthname)));

        ELSEIF (v_datetimestring REGEXP v_defmask3) -- 2017 Feb 02 (yyyy mon/Month d/dd HH:mi:ss(./:)ms)
        THEN
            SET v_timepart = TRIM(SUBSTRING(v_datetimestring, POSITION(v_monthname IN v_datetimestring) + CHAR_LENGTH(v_monthname))); -- 2017 May 12 15:34:59.755 => 12 15:34:59.755
            SET v_timepart = TRIM(SUBSTRING(v_timepart, POSITION(SPACE(1) IN v_timepart))); -- 12 15:34:59.755 => 15:34:59.755
            SET v_datepart = TRIM(REPLACE(v_datetimestring, v_timepart, SPACE(0))); -- 2017 May 12 15:34:59.755 => 2017 May 12
            SET v_day = LTRIM(SUBSTRING(v_datepart, POSITION(v_monthname IN v_datepart) + CHAR_LENGTH(v_monthname)));
            SET v_year = RTRIM(LEFT(v_datepart, POSITION(v_monthname IN v_datepart) - 1));

        ELSEIF (v_datetimestring REGEXP v_defmask4) -- 2017 02 Feb (yyyy d/dd mon/Month HH:mi:ss(./:)ms)
        THEN
            SET v_timepart = TRIM(SUBSTRING(v_datetimestring, POSITION(v_monthname IN v_datetimestring) + CHAR_LENGTH(v_monthname))); -- 2017 12 May 15:34:59.755 => 15:34:59.755
            SET v_datepart = TRIM(REPLACE(v_datetimestring, v_timepart, SPACE(0))); -- 2017 12 May 15:34:59.755 => 2017 12 May
            SET v_year = SUBSTRING_INDEX(v_datepart, SPACE(1), 1);
            SET v_day = TRIM(SUBSTRING(v_datepart, CHAR_LENGTH(v_year) + 1, CHAR_LENGTH(v_datepart) - CHAR_LENGTH(v_year) - CHAR_LENGTH(v_monthname)));

        ELSEIF (v_datetimestring REGEXP v_defmask5) -- 02 17(2017) Feb (d/dd y/yy/yyyy mon/Month HH:mi:ss(./:)ms)
        THEN
            SET v_timepart = TRIM(SUBSTRING(v_datetimestring, POSITION(v_monthname IN v_datetimestring) + CHAR_LENGTH(v_monthname))); -- 12 17 May 15:34:59.755 => 15:34:59.755
            SET v_datepart = TRIM(REPLACE(v_datetimestring, v_timepart, SPACE(0))); -- 12 17 May 15:34:59.755 => 12 17 May
            SET v_day = RTRIM(SUBSTRING_INDEX(v_datepart, SPACE(1), 1));
            SET v_year = TRIM(SUBSTRING(v_datepart, CHAR_LENGTH(v_day) + 1, CHAR_LENGTH(v_datepart) - CHAR_LENGTH(v_day) - CHAR_LENGTH(v_monthname)));

        ELSEIF (v_datetimestring REGEXP v_defmask6) -- Feb 2017 02 (mon/Month yyyy d/dd HH:mi:ss(./:)ms)
        THEN
            IF (v_datetimestring REGEXP v_defmask6_sep) -- mon/Month yyyy d/dd HH:mi:ss(./:)ms
            THEN
                SET v_datetimestring = LTRIM(SUBSTRING(v_datetimestring, POSITION(v_monthname IN v_datetimestring)));
                SET v_timepart = TRIM(REPLACE(v_datetimestring, v_monthname, SPACE(0))); -- May 2017 12 15:34:59.755 => 2017 12 15:34:59.755
                SET v_timepart = TRIM(SUBSTRING(v_timepart, POSITION(SPACE(1) IN v_timepart))); -- 2017 12 15:34:59.755 => 12 15:34:59.755
                SET v_timepart = TRIM(SUBSTRING(v_timepart, POSITION(SPACE(1) IN v_timepart))); -- 12 15:34:59.755 => 15:34:59.755
                SET v_datepart = TRIM(REPLACE(v_datetimestring, v_timepart, SPACE(0))); -- May 2017 12 15:34:59.755 => May 2017 12
                SET v_day = LTRIM(SUBSTRING_INDEX(v_datepart, SPACE(1), -1));
                SET v_year = TRIM(SUBSTRING(v_datepart, CHAR_LENGTH(v_monthname) + 1, CHAR_LENGTH(v_datepart) - CHAR_LENGTH(v_day) - CHAR_LENGTH(v_monthname)));
            ELSE
                -- Incorrect date parts
                SIGNAL outofrange_value;
            END IF;
        ELSEIF (v_datetimestring REGEXP v_defmask7) -- Feb 02, 2017 (mon/Month d/dd, y/yy/yyyy HH:mi:ss(./:)ms)
        THEN
            IF (v_datetimestring REGEXP v_defmask7_sep) -- mon/Month d/dd, y/yy/yyyy HH:mi:ss(./:)ms
            THEN
                SET v_datetimestring = LTRIM(SUBSTRING(v_datetimestring, POSITION(v_monthname IN v_datetimestring)));
                SET v_timepart = TRIM(SUBSTRING(v_datetimestring, CHAR_LENGTH(SUBSTRING_INDEX(v_datetimestring, ',', 1)) + 2)); -- May 12, 2017 15:34:59.755 => 2017 15:34:59.755
                SET v_timepart = TRIM(SUBSTRING(v_timepart, POSITION(SPACE(1) IN v_timepart))); -- 2017 15:34:59.755 => 15:34:59.755
                SET v_datepart = TRIM(REPLACE(v_datetimestring, v_timepart, SPACE(0))); -- May 12, 2017 15:34:59.755 => May 12, 2017
                SET v_day = TRIM(SUBSTRING(SUBSTRING_INDEX(v_datepart, ',', 1), CHAR_LENGTH(v_monthname) + 1));
                SET v_year = LTRIM(SUBSTRING_INDEX(v_datepart, ',', -1));
            ELSE
                -- Incorrect date parts
                SIGNAL outofrange_value;
            END IF;
        ELSEIF (v_datetimestring REGEXP v_defmask8) -- 2017 Feb (yyyy mon/Month HH:mi:ss(./:)ms)
        THEN
            SET v_timepart = TRIM(SUBSTRING(v_datetimestring, POSITION(v_monthname IN v_datetimestring) + CHAR_LENGTH(v_monthname))); -- 2017 May 15:34:59.755 => 15:34:59.755
            SET v_datepart = TRIM(REPLACE(v_datetimestring, v_timepart, SPACE(0))); -- 2017 May 15:34:59.755 => 2017 May
            SET v_day = 1;
            SET v_year = RTRIM(SUBSTRING(v_datepart, 1, CHAR_LENGTH(v_datepart) - CHAR_LENGTH(v_monthname)));

        ELSEIF (v_datetimestring REGEXP v_defmask9) -- Feb 2017 (mon/Month yyyy HH:mi:ss(./:)ms)
        THEN
            IF (v_datetimestring REGEXP v_defmask9_sep) -- mon/Month yyyy HH:mi:ss(./:)ms
            THEN
                SET v_datetimestring = LTRIM(SUBSTRING(v_datetimestring, POSITION(v_monthname IN v_datetimestring)));
                SET v_timepart = TRIM(REPLACE(v_datetimestring, v_monthname, SPACE(0))); -- May 2017 15:34:59.755 => 2017 15:34:59.755
                SET v_timepart = TRIM(SUBSTRING(v_timepart, POSITION(SPACE(1) IN v_timepart))); -- 2017 15:34:59.755 => 15:34:59.755
                SET v_datepart = TRIM(REPLACE(v_datetimestring, v_timepart, SPACE(0))); -- May 2017 15:34:59.755 => May 2017
                SET v_day = 1;
                SET v_year = LTRIM(SUBSTRING(v_datepart, CHAR_LENGTH(v_monthname) + 1));
            ELSE
                -- Incorrect date parts
                SIGNAL outofrange_value;
            END IF;
        ELSEIF ((v_datetimestring REGEXP v_defmask10) OR -- (d/dd).(mon/Month).(y/yy) HH:mi:ss(./:)ms
                (v_datetimestring REGEXP v_defmask11) OR -- (d/dd)/(mon/Month)/(y/yy) HH:mi:ss(./:)ms
                (v_datetimestring REGEXP v_defmask12)) -- (d/dd)-(mon/Month)-(y/yy) HH:mi:ss(./:)ms
        THEN
            -- Picking up the right day parts separator
            SET v_masksep = CASE
                               WHEN (v_datetimestring REGEXP v_defmask10) THEN '.'
                               WHEN (v_datetimestring REGEXP v_defmask11) THEN '/'
                               ELSE '-'
                            END;

            SET v_timepart = TRIM(SUBSTRING(v_datetimestring, SUBSTRING_INDEX(v_datetimestring, v_masksep, 2) + 2)); -- 12.May.17 15:34:59.755 => 17 15:34:59.755
            SET v_timepart = TRIM(SUBSTRING(v_timepart, POSITION(SPACE(1) IN v_timepart))); -- 17 15:34:59.755 => 15:34:59.755
            SET v_datepart = TRIM(REPLACE(v_datetimestring, v_timepart, SPACE(0))); -- 12.May.17 15:34:59.755 => 12.May.17
            SET v_day = RTRIM(SUBSTRING_INDEX(v_datepart, v_masksep, 1));
            SET v_year = LTRIM(SUBSTRING_INDEX(v_datepart, v_masksep, -1));
        ELSE
            -- Conversion failed
            SIGNAL conversion_failed;
        END IF;

        -- Make sure that year is always presented as four-digit value
        SET v_year = aws_sqlserver_ext.get_full_year(v_year, '', NULL);

    ELSEIF ((v_datetimestring REGEXP v_dotshortyearmask) OR -- 03.05.17 HH:mi:ss(./:)ms (3.5.17 => March 5 2017)
            (v_datetimestring REGEXP v_dotfullyearmask) OR -- 03.05.1917 HH:mi:ss(./:)ms (3.5.1917 => March 5 1917)
            (v_datetimestring REGEXP v_slashshortyearmask) OR -- 03/05/17 HH:mi:ss(./:)ms (3/5/17 => March 5 2017)
            (v_datetimestring REGEXP v_slashfullyearmask) OR -- 03/05/1917 HH:mi:ss(./:)ms (3/5/1917 => March 5 1917)
            (v_datetimestring REGEXP v_dashshortyearmask) OR -- 03-05-17 HH:mi:ss(./:)ms (3-5-17 => March 5 2017)
            (v_datetimestring REGEXP v_dashfullyearmask)) -- 03-05-1917 HH:mi:ss(./:)ms (3-5-1917 => March 5 1917)
    THEN
        -- Picking up the right day parts separator
        SET v_masksep = CASE
                           WHEN ((v_datetimestring REGEXP v_dotshortyearmask) OR (v_datetimestring REGEXP v_dotfullyearmask)) THEN '.'
                           WHEN ((v_datetimestring REGEXP v_slashshortyearmask) OR (v_datetimestring REGEXP v_slashfullyearmask)) THEN '/'
                           ELSE '-'
                        END;

        -- Divide string expresion into two constituents - date and time parts
        SET v_timepart = TRIM(SUBSTRING(v_datetimestring, CHAR_LENGTH(SUBSTRING_INDEX(v_datetimestring, v_masksep, 2)) + 2)); -- 2007.05.12 03:24:36 => 12 03:24:36
        SET v_timepart = TRIM(SUBSTRING(v_timepart, POSITION(SPACE(1) IN v_timepart))); -- 12 03:24:36 => 03:24:36
        SET v_datepart = TRIM(REPLACE(v_datetimestring, v_timepart, SPACE(0))); -- 2007.05.12 03:24:36 => 2007.05.12

        -- Parse 'dirty' string parts divided by separator
        SET v_leftpart = RTRIM(SUBSTRING_INDEX(v_datepart, v_masksep, 1));
        SET v_midpart = LTRIM(SUBSTRING_INDEX(RTRIM(SUBSTRING_INDEX(v_datepart, v_masksep, 2)), v_masksep, -1));
        SET v_rightpart = LTRIM(SUBSTRING_INDEX(v_datepart, v_masksep, -1));

        IF ((v_datetimestring REGEXP v_dotshortyearmask) OR -- 03.05.17 HH:mi:ss(./:)ms
            (v_datetimestring REGEXP v_slashshortyearmask) OR -- 03/05/17 HH:mi:ss(./:)ms
            (v_datetimestring REGEXP v_dashshortyearmask)) -- 03-05-17 HH:mi:ss(./:)ms
        THEN
            IF (p_style IN (6, 7, 8, 9, 12, 13, 14, 24, 100, 106, 107, 108, 109, 112, 113, 114, 130) AND
                v_resdatatype = 'DATETIME2')
            THEN
                -- Invalid string for supplied stype param value
                SIGNAL str_style_mismatch;
            ELSEIF (((p_style BETWEEN 15 AND 19) OR
                     (p_style BETWEEN 26 AND 99) OR
                     (p_style BETWEEN 115 AND 119) OR
                     (p_style IN (122, 123, 124, 125, 128, 129))) AND
                    v_resdatatype = 'DATETIME2')
            THEN
                /* Incorrect style param value
                   for this mask and data type */
                SIGNAL invalid_style;
            ELSEIF ((((NOT ISNULL(p_style)) AND p_style NOT IN (0, 1, 2, 3, 4, 5, 10, 11)) AND v_resdatatype IN ('DATETIME', 'SMALLDATETIME')) OR
                (((NOT ISNULL(p_style)) AND p_style NOT IN (0, 1, 2, 3, 4, 5, 10, 11, 22)) AND v_resdatatype = 'DATETIME2'))
            THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            END IF;

            IF ((p_style IN (1, 10) AND v_date_format <> 'MDY' AND v_resdatatype IN ('DATETIME', 'SMALLDATETIME')) OR
                ((ISNULL(p_style) OR p_style IN (0, 1, 10)) AND v_date_format NOT IN ('DMY', 'DYM', 'MYD', 'YMD', 'YDM') AND v_resdatatype IN ('DATETIME', 'SMALLDATETIME')) OR
                ((ISNULL(p_style) OR p_style IN (0, 1, 10, 22)) AND v_date_format NOT IN ('DMY', 'DYM', 'MYD', 'YMD', 'YDM') AND v_resdatatype = 'DATETIME2') OR
                (p_style IN (1, 10, 22) AND v_date_format IN ('DMY', 'DYM', 'MYD', 'YMD', 'YDM') AND v_resdatatype = 'DATETIME2'))
            THEN
                SET v_day = v_midpart;
                SET v_month = v_leftpart;
                SET v_year = aws_sqlserver_ext.get_full_year(v_rightpart, '', NULL);
            ELSEIF ((p_style IN (2, 11) AND v_date_format <> 'YMD') OR -- 12.05.17 => 17.05.2012
                    ((ISNULL(p_style) OR p_style IN (0, 2, 11)) AND v_date_format = 'YMD'))
            THEN
                SET v_day = v_rightpart;
                SET v_month = v_midpart;
                SET v_year = aws_sqlserver_ext.get_full_year(v_leftpart, '', NULL);
            ELSEIF ((p_style IN (3, 4, 5) AND v_date_format <> 'DMY') OR
                    ((ISNULL(p_style) OR p_style IN (0, 3, 4, 5)) AND v_date_format = 'DMY'))
            THEN
                SET v_day = v_leftpart;
                SET v_month = v_midpart;
                SET v_year = aws_sqlserver_ext.get_full_year(v_rightpart, '', NULL);
            ELSEIF ((ISNULL(p_style) OR p_style = 0) AND v_date_format = 'DYM')
            THEN
                SET v_day = v_leftpart;
                SET v_month = v_rightpart;
                SET v_year = aws_sqlserver_ext.get_full_year(v_midpart, '', NULL);
            ELSEIF ((ISNULL(p_style) OR p_style = 0) AND v_date_format = 'MYD')
            THEN
                SET v_day = v_rightpart;
                SET v_month = v_leftpart;
                SET v_year = aws_sqlserver_ext.get_full_year(v_midpart, '', NULL);
            ELSEIF ((ISNULL(p_style) OR p_style = 0) AND v_date_format = 'YDM')
            THEN
                IF (v_resdatatype = 'DATETIME2') THEN
                    /* YDM dateformat is not applicable
                       to convert this string expression */
                    SIGNAL YDM_not_supported;
                END IF;

                SET v_day = v_midpart;
                SET v_month = v_rightpart;
                SET v_year = aws_sqlserver_ext.get_full_year(v_leftpart, '', NULL);
            ELSE
                -- Incorrect date parts
                SIGNAL outofrange_value;
            END IF;
        ELSEIF ((v_datetimestring REGEXP v_dotfullyearmask) OR -- 03.05.2017 HH:mi:ss(./:)ms
                (v_datetimestring REGEXP v_slashfullyearmask) OR -- 03/05/2017 HH:mi:ss(./:)ms
                (v_datetimestring REGEXP v_dashfullyearmask)) -- 03-05-2017 HH:mi:ss(./:)ms
        THEN
            IF (NOT ISNULL(p_style) AND p_style NOT IN (0, 20, 21, 101, 102, 103, 104, 105, 110, 111, 120, 121, 130, 131)
                AND v_resdatatype IN ('DATETIME', 'SMALLDATETIME'))
            THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            ELSEIF (p_style IN (130, 131) AND
                    v_resdatatype = 'SMALLDATETIME')
            THEN
                -- Conversion results in out-of-range value
                SIGNAL value_out_of_range;
            ELSEIF (p_style IN (6, 7, 8, 9, 12, 13, 14, 24, 100, 106, 107, 108, 109, 112, 113, 114, 130) AND
                    v_resdatatype = 'DATETIME2')
            THEN
                -- Invalid string for supplied stype param value
                SIGNAL str_style_mismatch;
            ELSEIF (((p_style BETWEEN 15 AND 19) OR
                    (p_style BETWEEN 26 AND 99) OR
                    (p_style BETWEEN 115 AND 119) OR
                    (p_style IN (122, 123, 124, 125, 128, 129))) AND
                    (v_resdatatype = 'DATETIME2'))
            THEN
                /* Incorrect style param value
                   for this mask and data type */
                SIGNAL invalid_style;
            END IF;

            -- Year is always from the right
            SET v_year = v_rightpart;

            IF (v_leftpart <= 12) THEN
                IF ((p_style IN (103, 104, 105, 130, 131) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')) OR
                    ((ISNULL(p_style) OR p_style IN (0, 103, 104, 105, 130, 131)) AND ((v_date_format = 'DMY' AND v_resdatatype = 'DATETIME2') OR
                    (v_date_format IN ('DMY', 'DYM', 'YDM') AND v_resdatatype <> 'DATETIME2'))) OR
                    (p_style IN (103, 104, 105, 130, 131) AND v_date_format IN ('DMY', 'DYM', 'YDM') AND v_resdatatype = 'DATETIME2'))
                THEN
                    SET v_day = v_leftpart;
                    SET v_month = v_midpart;
                ELSEIF ((p_style IN (20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format IN ('DMY', 'DYM', 'YDM') AND v_resdatatype IN ('DATETIME', 'SMALLDATETIME')) OR
                        ((ISNULL(p_style) OR p_style IN (0, 20, 21, 101, 102, 110, 111, 120, 121)) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM') AND v_resdatatype IN ('DATETIME', 'SMALLDATETIME')) OR
                        (p_style IN (101, 110) AND v_date_format IN ('DMY', 'DYM', 'MYD', 'YDM') AND v_resdatatype = 'DATETIME2') OR
                        ((ISNULL(p_style) OR p_style IN (0, 101, 110)) AND v_date_format NOT IN ('DMY', 'DYM', 'MYD', 'YDM') AND v_resdatatype = 'DATETIME2'))
                THEN
                    SET v_day = v_midpart;
                    SET v_month = v_leftpart;
                END IF;
            ELSE
                IF ((p_style IN (103, 104, 105, 130, 131) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')) OR
                    ((ISNULL(p_style) OR p_style IN (0, 103, 104, 105, 130, 131)) AND ((v_date_format = 'DMY' AND v_resdatatype = 'DATETIME2') OR
                    (v_date_format IN ('DMY', 'DYM', 'YDM') AND v_resdatatype <> 'DATETIME2'))) OR
                    (p_style IN (103, 104, 105, 130, 131) AND v_date_format IN ('DMY', 'DYM', 'YDM') AND v_resdatatype = 'DATETIME2'))
                THEN
                    SET v_day = v_leftpart;
                    SET v_month = v_midpart;
                ELSE
                    IF (v_resdatatype = 'DATETIME2')
                    THEN
                        -- Conversion failed
                        SIGNAL conversion_failed;
                    ELSE
                        -- Incorrect date parts
                        SIGNAL outofrange_value;
                    END IF;
                END IF;
            END IF;
        END IF;
    ELSEIF ((v_datetimestring REGEXP v_dotmask1) OR -- 2007.05.12 HH:mi:ss(./:)ms (May 12 2007)
            (v_datetimestring REGEXP v_slashmask1) OR -- 2007/05/12 HH:mi:ss(./:)ms
            (v_datetimestring REGEXP v_dashmask1)) -- 2007-05-12 HH:mi:ss(./:)ms
    THEN
        IF ((NOT ISNULL(p_style) AND p_style NOT IN (0, 20, 21, 101, 102, 103, 104, 105, 110, 111, 120, 121, 130, 131) AND v_resdatatype IN ('DATETIME', 'SMALLDATETIME')) OR
            (p_style IN (1, 2, 3, 4, 5, 10, 11, 22, 101, 103, 104, 105, 110, 131) AND v_resdatatype = 'DATETIME2'))
        THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        ELSEIF (p_style IN (130, 131) AND
                v_resdatatype = 'SMALLDATETIME')
        THEN
            -- Conversion results in out-of-range value
            SIGNAL value_out_of_range;
        ELSEIF (p_style IN (6, 7, 8, 9, 12, 13, 14, 24, 100, 106, 107, 108, 109, 112, 113, 114, 130) AND
                v_resdatatype = 'DATETIME2')
        THEN
            -- Invalid string for supplied stype param value
            SIGNAL str_style_mismatch;
        ELSEIF (((p_style BETWEEN 15 AND 19) OR
                (p_style BETWEEN 26 AND 99) OR
                (p_style BETWEEN 115 AND 119) OR
                (p_style IN (122, 123, 124, 125, 128, 129))) AND
                (v_resdatatype = 'DATETIME2'))
        THEN
            /* Incorrect style param value
               for this mask and data type */
            SIGNAL invalid_style;
        END IF;

        -- Picking up the right day parts separator
        SET v_masksep = CASE
                           WHEN (v_datetimestring REGEXP v_dotmask1) THEN '.'
                           WHEN (v_datetimestring REGEXP v_slashmask1) THEN '/'
                           ELSE '-'
                        END;

        -- Divide string expresion into two constituents - date and time parts
        SET v_timepart = TRIM(SUBSTRING(v_datetimestring, CHAR_LENGTH(SUBSTRING_INDEX(v_datetimestring, v_masksep, 2)) + 2));
        SET v_timepart = TRIM(SUBSTRING(v_timepart, POSITION(SPACE(1) IN v_timepart)));
        SET v_datepart = TRIM(REPLACE(v_datetimestring, v_timepart, SPACE(0)));

        -- Parse 'dirty' string parts divided by separator
        SET v_midpart = LTRIM(SUBSTRING_INDEX(RTRIM(SUBSTRING_INDEX(v_datepart, v_masksep, 2)), v_masksep, -1));
        SET v_rightpart = LTRIM(SUBSTRING_INDEX(v_datepart, v_masksep, -1));
        SET v_year = aws_sqlserver_ext.get_full_year(RTRIM(SUBSTRING_INDEX(v_datepart, v_masksep, 1)), '', NULL);

        IF ((v_resdatatype IN ('DATETIME', 'SMALLDATETIME') AND v_rightpart <= 12) OR
            v_resdatatype = 'DATETIME2')
        THEN
            IF ((p_style IN (20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format IN ('DMY', 'DYM', 'YDM') AND v_resdatatype <> 'DATETIME2') OR
                ((ISNULL(p_style) OR p_style IN (0, 20, 21, 101, 102, 110, 111, 120, 121)) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM') AND v_resdatatype <> 'DATETIME2') OR                
                ((ISNULL(p_style) OR p_style IN (0, 20, 21, 23, 25, 101, 102, 110, 111, 120, 121, 126, 127)) AND v_resdatatype = 'DATETIME2'))
            THEN
                SET v_day = v_rightpart;
                SET v_month = v_midpart;
            ELSEIF ((p_style IN (103, 104, 105, 130, 131) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')) OR
                    (ISNULL(p_style) OR p_style IN (0, 103, 104, 105, 130, 131)) AND v_date_format IN ('DMY', 'DYM', 'YDM'))
            THEN
                SET v_day = v_midpart;
                SET v_month = v_rightpart;
            END IF;
        ELSEIF (v_resdatatype IN ('DATETIME', 'SMALLDATETIME') AND v_rightpart > 12) THEN
            IF ((p_style IN (20, 21, 101, 102, 110, 111, 120, 121) AND v_date_format IN ('DMY', 'DYM', 'YDM')) OR
                ((ISNULL(p_style) OR p_style IN (0, 20, 21, 101, 102, 110, 111, 120, 121)) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')))
            THEN
                SET v_day = v_rightpart;
                SET v_month = v_midpart;
            ELSEIF ((p_style IN (103, 104, 105, 130, 131) AND v_date_format NOT IN ('DMY', 'DYM', 'YDM')) OR
                    (ISNULL(p_style) OR p_style IN (0, 103, 104, 105, 130, 131)) AND v_date_format IN ('DMY', 'DYM', 'YDM'))
            THEN
                -- Incorrect date parts
                SIGNAL outofrange_value;
            END IF;
        END IF;
    -- Match dates like "010217" (i.e. 2001-02-17) or "20010217"
    ELSEIF ((v_datetimestring REGEXP v_digitmask1) OR -- yymmdd HH:mi:ss(./:)ms
            (v_datetimestring REGEXP v_digitmask2)) -- yyyymmdd HH:mi:ss(./:)ms
    THEN
        IF (p_style = 127 AND v_resdatatype <> 'DATETIME2')
        THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        ELSEIF (p_style IN (130, 131) AND
                v_resdatatype = 'SMALLDATETIME')
        THEN
            -- Conversion results in out-of-range value
            SIGNAL value_out_of_range;
        ELSEIF (((p_style BETWEEN 15 AND 19) OR
                 (p_style BETWEEN 26 AND 99) OR
                 (p_style BETWEEN 115 AND 119) OR
                 (p_style IN (122, 123, 124, 125, 128, 129))) AND
                v_resdatatype = 'DATETIME2')
        THEN
            /* Incorrect style param value
               for this mask and data type */
            SIGNAL invalid_style;
        END IF;

        IF (v_datetimestring REGEXP v_digitmask1) -- yymmdd HH:mi:ss(./:)ms
        THEN
            SET v_day = SUBSTRING(v_datetimestring, 5, 2);
            SET v_month = SUBSTRING(v_datetimestring, 3, 2);
            SET v_year = aws_sqlserver_ext.get_full_year(SUBSTRING(v_datetimestring, 1, 2), '', NULL);
            SET v_timepart = TRIM(SUBSTRING(v_datetimestring, 7, CHAR_LENGTH(v_datetimestring) - 6));
        ELSE
            SET v_day = SUBSTRING(v_datetimestring, 7, 2);
            SET v_month = SUBSTRING(v_datetimestring, 5, 2);
            SET v_year = SUBSTRING(v_datetimestring, 1, 4);
            SET v_timepart = TRIM(SUBSTRING(v_datetimestring, 9, CHAR_LENGTH(v_datetimestring) - 8));
        END IF;
    ELSEIF (v_datetimestring REGEXP v_hhmmssms_mask) -- 03:24:36[.|:]347 (AM|PM)
    THEN
        IF (((p_style BETWEEN 15 AND 19) OR
             (p_style BETWEEN 26 AND 99) OR
             (p_style BETWEEN 115 AND 119) OR
             (p_style IN (122, 123, 124, 125, 128, 129))) AND
            v_resdatatype = 'DATETIME2')
        THEN
            /* Incorrect style param value
               for this mask and data type */
            SIGNAL invalid_style;
        END IF;

        SET v_day = 1, v_month = 1, v_year = 1900; -- 01.01.1900
        SET v_timepart = v_datetimestring;
    ELSE
        -- Conversion failed
        SIGNAL conversion_failed;
    END IF;

    IF ((v_datetimestring REGEXP v_hhmmssms_mask AND p_style IN (130, 131) AND v_resdatatype = 'DATETIME2') OR -- 03:24:36[.|:]347 (AM|PM)
        (((v_datetimestring REGEXP v_digitmask1) OR (v_datetimestring REGEXP v_digitmask2) OR -- yymmdd HH:mi:ss(./:)ms | yyyymmdd HH:mi:ss(./:)ms
          /* 2007.05.12 HH:mi:ss(./:)ms (May 12 2007) | 2007/05/12 HH:mi:ss(./:)ms | 2007-05-12 HH:mi:ss(./:)ms */
          (v_datetimestring REGEXP v_dotmask1) OR (v_datetimestring REGEXP v_slashmask1) OR (v_datetimestring REGEXP v_dashmask1) OR
          (v_datetimestring REGEXP v_dotfullyearmask) OR (v_datetimestring REGEXP v_slashfullyearmask) OR (v_datetimestring REGEXP v_dashfullyearmask)) AND
         p_style IN (130, 131)))
    THEN
        -- Hijri date calculation
        SET v_hijridate = aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_year) - 1;
        SET v_day = DAY(v_hijridate);
        SET v_month = MONTH(v_hijridate);
        SET v_year = YEAR(v_hijridate);
    END IF;

    -- Extract time units from time part expression
    SET v_hours = COALESCE(aws_sqlserver_ext.extract_time_unit(v_timepart, 'HOUR'), 0);
    SET v_minutes = COALESCE(aws_sqlserver_ext.extract_time_unit(v_timepart, 'MINUTE'), 0);
    SET v_seconds = COALESCE(aws_sqlserver_ext.extract_time_unit(v_timepart, 'SECONDS'), 0);
    SET v_fseconds = COALESCE(aws_sqlserver_ext.extract_time_unit(v_timepart, 'MICROSECONDS'), 0);

    -- Construct date from parts according to datetime type
    IF (v_resdatatype IN ('DATETIME', 'SMALLDATETIME'))
    THEN
        IF (CHAR_LENGTH(v_fseconds) > 3) THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        END IF;

        SET v_fseconds = CONVERT(RPAD(v_fseconds, 3, '0'), UNSIGNED);

       -- Constructing datetime object from the separate date and time parts
        SET v_resdatetime = aws_sqlserver_ext.datetimefromparts(v_year, v_month, v_day, -- date part
                                                                v_hours, v_minutes, v_seconds, v_fseconds); -- time part
        IF (v_resdatatype = 'SMALLDATETIME')
        THEN
            IF (SECOND(v_resdatetime) >= 30) THEN
                SET v_resdatetime = DATE_ADD(v_resdatetime, INTERVAL 1 MINUTE);
            END IF;

            SET v_resdatetime = STR_TO_DATE(DATE_FORMAT(v_resdatetime, '%d.%m.%Y.%H.%i'),
                                            '%d.%m.%Y.%H.%i');
        END IF;
    ELSEIF (v_resdatatype = 'DATETIME2')
    THEN
        IF ((v_timepart NOT REGEXP v_hhmmssms_dotmask) AND -- 03:24:36.347 (AM|PM)
            CHAR_LENGTH(v_fseconds) > 3)
        THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        END IF;

        -- Rounding fractional seconds to the specified scale (DATETIME(4) => 4)
        SET v_fseconds = aws_sqlserver_ext.get_microsecs_from_fractsecs(v_fseconds, v_scale);

        -- Constructing datetime object from separate date and time parts
        SET v_resdatetime = STR_TO_DATE(CONCAT_WS('.', v_day, v_month, v_year,
                                                       v_hours, v_minutes, v_seconds, v_fseconds),
                                        '%d.%m.%Y.%H.%i.%s.%f');
    END IF;

    RETURN v_resdatetime;
END]]></complex-attribute>
                        <category _I_D="489ac480-805b-4399-a07e-ed6ef912edc9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d426250f-49c5-4893-a2e0-249a3d740687" name="datetime2fromparts" context="datetime2fromparts" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function returns a fully initialized DATETIME2 value, constructed from separate date and time parts.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_fractions VARCHAR(50) DEFAULT FLOOR(p_fractions);
    DECLARE v_scale INTEGER DEFAULT FLOOR(p_precision);
    DECLARE v_precision VARCHAR(50);
    DECLARE v_mseconds VARCHAR(50);
    DECLARE v_error_message VARCHAR(500);

    -- Declaration of error conditions and handlers
    DECLARE conversion_failed CONDITION FOR SQLSTATE '45600';
    DECLARE invalid_datepart CONDITION FOR SQLSTATE '45751';
    DECLARE scale_out_of_range CONDITION FOR SQLSTATE '45752';
    DECLARE invalid_scale CONDITION FOR SQLSTATE '45753';

    -- Arguments have values which are not valid for DATETIME2 conversion
    DECLARE EXIT HANDLER FOR invalid_datepart
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Cannot construct data type DATETIME2, some of the arguments have values which are not valid.';
    END;

    -- Scale argument is not valid
    DECLARE EXIT HANDLER FOR invalid_scale
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Scale argument is not valid. Valid expressions for data type DATETIME2 scale argument are integer constants.';
    END;

    -- Scale is out of range
    DECLARE EXIT HANDLER FOR scale_out_of_range
    BEGIN
        SET v_error_message = CONCAT('Specified scale ', v_scale, ' is invalid.');

        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Cases when STR_TO_DATE func supplied with incorrect date parts
    DECLARE EXIT HANDLER FOR 1411
    BEGIN
        RESIGNAL SET MESSAGE_TEXT = 'Cannot construct data type DATETIME2, some of the arguments have values which are not valid.';
    END;

    -- Cases when STR_TO_DATE func supplied with incorrect date parts
    DECLARE EXIT HANDLER FOR 1292
    BEGIN
        RESIGNAL SET MESSAGE_TEXT = 'Cannot construct data type DATETIME2, some of the arguments have values which are not valid.';
    END;

    SET v_precision = TRIM(TRAILING '0' FROM p_precision);
    SET v_precision = IF(v_precision REGEXP '[.]$',
                         REPLACE(v_precision, '.', ''),
                         v_precision);

    /* Checking if input arguments belong to the valid ranges.
       (throw an error if they are not) */
    IF (ISNULL(p_year) OR ISNULL(p_month) OR ISNULL(p_day) OR
        ISNULL(p_hour) OR ISNULL(p_minute) OR ISNULL(p_seconds) OR
        ISNULL(p_fractions))
    THEN
        RETURN NULL;
    ELSEIF (ISNULL(p_precision) OR (v_precision REGEXP '[.]' AND
            CHAR_LENGTH(SUBSTRING_INDEX(v_precision, '.', -1)) > 0))
    THEN
        -- Invalid precision (scale)
        SIGNAL invalid_scale;
    ELSEIF (v_scale NOT BETWEEN 0 AND 7)
    THEN
        -- Precision (scale) is out of range
        SIGNAL scale_out_of_range;
    ELSEIF ((p_year NOT BETWEEN 1 AND 9999) OR
            (p_month NOT BETWEEN 1 AND 12) OR
            (p_day NOT BETWEEN 1 AND 31) OR
            (p_hour NOT BETWEEN 0 AND 23) OR
            (p_minute NOT BETWEEN 0 AND 59) OR
            (p_seconds NOT BETWEEN 0 AND 59) OR
            (p_fractions NOT BETWEEN 0 AND 9999999) OR
            (p_fractions != 0 AND CHAR_LENGTH(v_fractions) > p_precision))
    THEN
        -- Invalid date parts
        SIGNAL invalid_datepart;
    END IF;

    -- Composing microseconds part from fractions and precision
    SET v_mseconds = SUBSTRING(RPAD(LPAD(v_fractions, v_scale, '0'), 7, '0'), 1, 6);

    -- Constructing DATETIME value from separate date and time parts
    RETURN STR_TO_DATE(CONCAT_WS('.', FLOOR(p_day), FLOOR(p_month), FLOOR(p_year), -- day, month, year
                                      FLOOR(p_hour), FLOOR(p_minute), -- hour, minute (time part)
                                      FLOOR(p_seconds), v_mseconds), -- seconds, mseconds
                       '%d.%m.%Y.%H.%i.%s.%f'); -- mask
END]]></complex-attribute>
                        <category _I_D="65d4b1ca-e0a8-4c82-95f7-0ccef08b1357" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2f3c94eb-9a00-4cac-aa40-1b4257b03302" name="datetimefromparts" context="datetimefromparts" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function returns a fully initialized DATETIME value, constructed from separate date and time parts.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_resdatetime DATETIME(6);
    DECLARE v_milliseconds INTEGER;
    DECLARE v_error_message VARCHAR(500);

    -- Declaration of error conditions and handlers
    DECLARE conversion_failed CONDITION FOR SQLSTATE '45600';
    DECLARE invalid_datepart CONDITION FOR SQLSTATE '45751';

    -- Cases when some of the arguments have values which are not valid for datetime conversion
    DECLARE EXIT HANDLER FOR invalid_datepart
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Cannot construct data type DATETIME, some of the arguments have values which are not valid.';
    END;

    -- Cases when STR_TO_DATE func supplied with incorrect date parts
    DECLARE EXIT HANDLER FOR 1411
    BEGIN
        RESIGNAL SET MESSAGE_TEXT = 'Cannot construct data type DATETIME, some of the arguments have values which are not valid.';
    END;

    -- Cases when STR_TO_DATE func supplied with incorrect date parts
    DECLARE EXIT HANDLER FOR 1292
    BEGIN
        RESIGNAL SET MESSAGE_TEXT = 'Cannot construct data type DATETIME, some of the arguments have values which are not valid.';
    END;

    /* Checking if input arguments belong to the valid ranges.
       (throw an error if they are not) */
    IF (ISNULL(p_year) OR ISNULL(p_month) OR ISNULL(p_day) OR
        ISNULL(p_hour) OR ISNULL(p_minute) OR ISNULL(p_seconds) OR
        ISNULL(p_milliseconds))
    THEN
        RETURN NULL;
    ELSEIF ((p_year NOT BETWEEN 1753 AND 9999) OR
        (p_month NOT BETWEEN 1 AND 12) OR
        (p_day NOT BETWEEN 1 AND 31) OR
        (p_hour NOT BETWEEN 0 AND 23) OR
        (p_minute NOT BETWEEN 0 AND 59) OR
        (p_seconds NOT BETWEEN 0 AND 59) OR
        (p_milliseconds NOT BETWEEN 0 AND 999))
    THEN
        -- Invalid date parts
        SIGNAL invalid_datepart;
    END IF;

    -- Convert and round MS SQL Sever's milliseconds to microseconds
    SET v_milliseconds = CONVERT(aws_sqlserver_ext.round_fractseconds(FLOOR(p_milliseconds)), UNSIGNED) * 1000;

    -- Constructing DATETIME value from separate date and time parts
    SET v_resdatetime = STR_TO_DATE(CONCAT_WS('.', FLOOR(p_day), FLOOR(p_month), FLOOR(p_year), -- day, month, year
                                                   FLOOR(p_hour), FLOOR(p_minute), -- hour, minute (time part)
                                                   FLOOR(p_seconds), -- seconds
                                                   CASE v_milliseconds
                                                      WHEN 1000000 THEN 0
                                                      ELSE LPAD(v_milliseconds, 6, '0')
                                                   END), -- mseconds
                                    '%d.%m.%Y.%H.%i.%s.%f'); -- mask
    -- Adjusting result value
    RETURN IF(v_milliseconds = 1000000,
              DATE_ADD(v_resdatetime, INTERVAL 1 SECOND),
              v_resdatetime);
END]]></complex-attribute>
                        <category _I_D="b375e31b-edeb-4140-8803-fda4a46ef8cc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b5b9867c-2622-4373-ab17-88ed0b74e076" name="get_full_year" context="get_full_year" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function transforms two-digit year to full-size four digit year value, according to base century and cutoff boundary optional parameters.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_short_year SMALLINT DEFAULT CONVERT(TRIM(p_short_year), UNSIGNED);
    -- MS SQL Server default two digit year cutoff boundary value is 49
    DECLARE v_year_cutoff SMALLINT DEFAULT COALESCE(p_year_cutoff, 49);
    DECLARE v_base_century VARCHAR(50);
    DECLARE v_full_year SMALLINT;

    IF (v_short_year <= 99)
    THEN
        -- Determining base century value for further calculations
        SET v_base_century = IF(p_base_century REGEXP '^[[:space:]]*[1-9]{1,2}[[:space:]]*$',
                                CONCAT(TRIM(p_base_century), '00'),
                                TRUNCATE(YEAR(CURRENT_DATE), -2));

        SET v_full_year = CONVERT(v_base_century, UNSIGNED) + v_short_year;
        SET v_full_year = IF(v_short_year > v_year_cutoff,
                             v_full_year - 100,
                             v_full_year);
    ELSE
        SET v_full_year = v_short_year;
    END IF;

    RETURN v_full_year;
END]]></complex-attribute>
                        <category _I_D="69894cb0-5723-429d-9427-a36b4de8e224" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="94235513-5095-422d-a075-1c4d44fe0a40" name="get_int_part" context="get_int_part" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function returns integer part of supplied value. Rounding to integer is applied according to special logic.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    RETURN CASE
              WHEN (p_src_number < -0.0000001) THEN CEIL(p_src_number - 0.0000001)
              ELSE FLOOR(p_src_number + 0.0000001)
           END;
END]]></complex-attribute>
                        <category _I_D="0c98733f-8661-4e71-9220-c8b6dee3cc18" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5d6a530e-6bd0-43b1-a0c1-41f14b16aa20" name="get_lang_metadata_json" context="get_lang_metadata_json" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="READS SQL DATA">
                        <complex-attribute name="comment"><![CDATA[This function returns language metadata JSON by corresponding lang name or spec culture abbreviation.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_lang_data_json JSON;
    DECLARE v_lang_spec_culture VARCHAR(50) DEFAULT UPPER(TRIM(p_lang_spec_culture));
    DECLARE v_error_message VARCHAR(500);

    DECLARE conversion_failed CONDITION FOR SQLSTATE '45600';
    DECLARE no_data_found CONDITION FOR SQLSTATE '45751';

    DECLARE EXIT HANDLER FOR no_data_found
    BEGIN
        SET v_error_message = CONCAT('"', TRIM(p_lang_spec_culture), '" is not a valid special culture or language name parameter.');

        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    IF (CHAR_LENGTH(v_lang_spec_culture) > 0)
    THEN
        IF (v_lang_spec_culture IN ('AR', 'FI') OR
            v_lang_spec_culture REGEXP '-')
        THEN
            SELECT lang_data_json
              INTO v_lang_data_json
              FROM aws_sqlserver_ext.sys_languages
             WHERE spec_culture = v_lang_spec_culture;
        ELSE
            SELECT lang_data_json
              INTO v_lang_data_json
              FROM aws_sqlserver_ext.sys_languages
             WHERE lang_name_mssql = v_lang_spec_culture
                OR lang_alias_mssql = v_lang_spec_culture;
        END IF;

        IF (ISNULL(v_lang_data_json)) THEN
            SIGNAL no_data_found;
        END IF;
    ELSE
        SET v_lang_spec_culture = REPLACE(@@lc_time_names, '_', '-');

        IF (CHAR_LENGTH(v_lang_spec_culture) = 5)
        THEN
            SELECT lang_data_json
              INTO v_lang_data_json
              FROM aws_sqlserver_ext.sys_languages
             WHERE spec_culture = v_lang_spec_culture;
        ELSE
            SELECT lang_data_json
              INTO v_lang_data_json
              FROM aws_sqlserver_ext.sys_languages
             WHERE lang_name_my = SUBSTRING_INDEX(v_lang_spec_culture, '_', 1)
               AND territory = SUBSTRING_INDEX(v_lang_spec_culture, '_', 2);
        END IF;

        IF (ISNULL(v_lang_data_json))
        THEN
            SELECT lang_data_json
              INTO v_lang_data_json
              FROM aws_sqlserver_ext.sys_languages
             WHERE spec_culture = 'EN-US';
        END IF;
    END IF;

    RETURN v_lang_data_json;
END]]></complex-attribute>
                        <category _I_D="5ddaa65a-6d19-4308-bb02-dedbf3325357" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="81143276-5c73-4d1c-b7e6-a20b267a75cd" name="get_microsecs_from_fractsecs" context="get_microsecs_from_fractsecs" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function transforms MS SQL Server DATETIME2 fractions and precision (scale) parts into PostgreSQL microsecond values.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_fractions VARCHAR(50) DEFAULT TRIM(p_fractions);
    DECLARE v_precision INTEGER DEFAULT COALESCE(p_precision, 7);
    DECLARE v_purefract VARCHAR(50);
    DECLARE v_decplaces, v_rndfract INTEGER;

    -- 001 => 001000 or 006754756 => 006754756
    SET v_fractions = RPAD(v_fractions, IF(6 > CHAR_LENGTH(v_fractions), 6, CHAR_LENGTH(v_fractions)), '0');

       -- 001 => 2 (count of leading decimal places)
    SET v_decplaces = CHAR_LENGTH(v_fractions) - CHAR_LENGTH(TRIM(LEADING '0' FROM v_fractions));

    -- Extracting number part from fractions expression 001 => 1
    SET v_purefract = TRIM(LEADING '0' FROM v_fractions);

    SET v_rndfract = ROUND(CONVERT(v_fractions, UNSIGNED),
                           (CHAR_LENGTH(v_purefract) - (v_precision - (CHAR_LENGTH(v_fractions) - CHAR_LENGTH(v_purefract)))) * (-1));

    -- Adding decimal places to start of the expression 7000000 => 007000000
    SET v_fractions = CONCAT(REPLACE(SPACE(v_decplaces), SPACE(1), '0'), v_rndfract);

    RETURN CONVERT(SUBSTRING(v_fractions, 1, 6), UNSIGNED);
END]]></complex-attribute>
                        <category _I_D="8ba9d6c2-7ace-45ec-b637-caaf6974e57e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="156aeae2-da75-415e-b204-d3a1687bba45" name="get_monthnum_by_name" context="get_monthnum_by_name" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function returns month number (1-12) by corresponding month name, matched from language metadata JSON.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_monthname NVARCHAR(50) DEFAULT UPPER(TRIM(p_monthname));
    DECLARE v_monthnum_path VARCHAR(50);
    DECLARE v_error_message VARCHAR(500);
    DECLARE v_monthnum SMALLINT;

    -- Declaration of error conditions and handlers
    DECLARE conversion_failed CONDITION FOR SQLSTATE '45600';
    DECLARE invalid_monthname CONDITION FOR SQLSTATE '45621';

    -- Month number is not determined
    DECLARE EXIT HANDLER FOR invalid_monthname
    BEGIN
        SET v_error_message = CONCAT('Can not translate value "', TRIM(p_monthname), '" to a correct month number.');

        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Matching by full month name
    SET v_monthnum_path = JSON_SEARCH(UPPER(JSON_EXTRACT(p_lang_metadata_json, '$.months_names')), 'one', v_monthname);

    -- Matching by extra full month name
    SET v_monthnum_path = COALESCE(v_monthnum_path,
                                   JSON_SEARCH(UPPER(JSON_EXTRACT(p_lang_metadata_json, '$.months_extranames')), 'one', v_monthname));

    -- Matching by short month name
    SET v_monthnum_path = COALESCE(v_monthnum_path,
                                   JSON_SEARCH(UPPER(JSON_EXTRACT(p_lang_metadata_json, '$.months_shortnames')), 'one', v_monthname));

    -- Matching by extra short month name
    SET v_monthnum_path = COALESCE(v_monthnum_path,
                                   JSON_SEARCH(UPPER(JSON_EXTRACT(p_lang_metadata_json, '$.months_extrashortnames')), 'one', v_monthname));
    -- Checking month number
    IF (ISNULL(v_monthnum_path)) THEN
        -- Month name is invalid
        SIGNAL invalid_monthname;
    END IF;

    RETURN CONVERT(REPLACE(SUBSTRING(JSON_UNQUOTE(v_monthnum_path), 3), ']', ''), UNSIGNED) + 1;
END]]></complex-attribute>
                        <category _I_D="16fdb64d-3ca7-49d5-8ae6-791acb405132" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c4eb045b-cdc8-46c1-bc02-8a4157cb588c" name="get_weekdaynum_by_name" context="get_weekdaynum_by_name" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="NO" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function returns weekday number (1-7) by corresponding weekday name, matched from language metadata JSON.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_weekdayname NVARCHAR(50) DEFAULT UPPER(TRIM(p_weekdayname));
    DECLARE v_weekdaynum_path VARCHAR(50);
    DECLARE v_error_message VARCHAR(500);
    DECLARE v_weekdaynum SMALLINT;

    -- Declaration of error conditions and handlers
    DECLARE conversion_failed CONDITION FOR SQLSTATE '45600';
    DECLARE invalid_weekdayname CONDITION FOR SQLSTATE '45621';

    -- Weekday number is not determined
    DECLARE EXIT HANDLER FOR invalid_weekdayname
    BEGIN
        SET v_error_message = CONCAT('Can not translate value "', TRIM(p_weekdayname), '" to a correct weekday number.');

        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Matching by full weekday name
    SET v_weekdaynum_path = JSON_SEARCH(UPPER(JSON_EXTRACT(p_lang_metadata_json, '$.days_names')), 'one', v_weekdayname);

    -- Matching by short weekday name
    SET v_weekdaynum_path = COALESCE(v_weekdaynum_path,
                                     JSON_SEARCH(UPPER(JSON_EXTRACT(p_lang_metadata_json, '$.days_shortnames')), 'one', v_weekdayname));

    -- Matching by extra short weekday name
    SET v_weekdaynum_path = COALESCE(v_weekdaynum_path,
                                     JSON_SEARCH(UPPER(JSON_EXTRACT(p_lang_metadata_json, '$.days_extrashortnames')), 'one', v_weekdayname));
    -- Checking weekday number
    IF (ISNULL(v_weekdaynum_path)) THEN
        -- Weekday name is invalid
        SIGNAL invalid_weekdayname;
    END IF;

    RETURN CONVERT(REPLACE(SUBSTRING(JSON_UNQUOTE(v_weekdaynum_path), 3), ']', ''), UNSIGNED) + 1;
END]]></complex-attribute>
                        <category _I_D="0e6accdd-dd15-4d20-abff-21273c3d29fa" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8f680a02-fc11-4f10-9f7b-d714b60fb01a" name="int_to_bit" context="int_to_bit" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function converts BIGINT value to data type BIT.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    RETURN p_val;
END]]></complex-attribute>
                        <category _I_D="942a9323-ea59-47d3-a692-527eafc318f3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="16383491-78c5-4399-9327-bee78052c39e" name="isdate" context="isdate" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function accepts an argument and returns 1 if that argument is a valid DATE, TIME, or DATETIME value; otherwise, it returns 0.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_datetime DATETIME(6);
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        RETURN 0;
    END;

    SET v_datetime = aws_sqlserver_ext.parse_to_datetime('DATETIME2', p_expression, NULL);

    RETURN 1;
END]]></complex-attribute>
                        <category _I_D="51b91cde-ac7b-4a94-95fb-bd6a1a9a506a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4d2c7de8-e1f2-473d-a523-3c50518162a1" name="json_array_to_string" context="json_array_to_string" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function concatenates JSON array elements using supplied delimiter.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_index INTEGER DEFAULT 0;
    DECLARE v_arr_element NVARCHAR(4000);
    DECLARE v_array_string NVARCHAR(4000);
    DECLARE v_delimiter NVARCHAR(100) DEFAULT COALESCE(p_delimiter, '');
    DECLARE v_array_len INTEGER DEFAULT COALESCE(JSON_LENGTH(p_json_array), 0);

    IF (v_array_len > 0) THEN
    REPEAT
        SET v_arr_element = COALESCE(JSON_UNQUOTE(JSON_EXTRACT(p_json_array, CONCAT('$[', v_index, ']'))), '');
        SET v_array_string = CASE v_index
                                WHEN 0 THEN v_arr_element
                                ELSE IF(CHAR_LENGTH(v_arr_element) > 0,
                                        CONCAT(v_array_string, v_delimiter, v_arr_element),
                                        v_array_string)
                             END;

        SET v_index = v_index + 1;
        UNTIL (v_index = v_array_len)
    END REPEAT;
    END IF;

    RETURN v_array_string;
END]]></complex-attribute>
                        <category _I_D="3aeeb68d-4b11-42cd-bd02-ac8497382a35" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6339036e-0e90-4cf4-87b1-c607124e9574" name="parse_to_date" context="parse_to_date" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function parses the source string and translates it into the DATE value, according to specified culture (conversion mask).]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_timestring NVARCHAR(4000);
    DECLARE v_datestring NVARCHAR(4000) DEFAULT UPPER(TRIM(CONVERT(p_datestring USING utf8)));
    DECLARE v_culture VARCHAR(50) DEFAULT COALESCE(NULLIF(UPPER(TRIM(p_culture)), ''), 'EN-US');
    DECLARE v_compmonth_regexp NVARCHAR(2000);
    DECLARE v_compday_regexp NVARCHAR(1000);
    DECLARE v_weekdayname NVARCHAR(50);
    DECLARE v_arr_element NVARCHAR(50);
    DECLARE v_daypart NVARCHAR(50);
    DECLARE v_index SMALLINT DEFAULT 0;
    DECLARE v_count INTEGER DEFAULT 0;
    DECLARE v_lang_metadata_json JSON;
    DECLARE v_compday_json_array JSON;
    DECLARE v_date_format VARCHAR(20);
    DECLARE v_reg_mask NVARCHAR(100);
    DECLARE v_weekdaynum SMALLINT;

    -- Date and time components declaration
    DECLARE v_res_date DATE;
    DECLARE v_res_datetime DATETIME(6);
    DECLARE v_day, v_month, v_year INTEGER;
    DECLARE v_hours, v_minutes, v_fseconds INTEGER;
    DECLARE v_resmask_cnt SMALLINT DEFAULT 0;
    DECLARE v_seconds VARCHAR(50);

    /* MS SQL Server session variables emulation:
       - LANGUAGE (SET LANGUAGE ENGLISH)
       - DATE_FORMAT (SET DATEFORMAT MDY) */
    DECLARE CONVERSION_LANG VARCHAR(50) DEFAULT ''; -- Override using of the "p_culture" parameter value for parsing of months and days names
    DECLARE DATE_FORMAT VARCHAR(50) DEFAULT ''; -- Override using of the default date format (linked with language) - (MDY|YDM|DMY|DYM)

    DECLARE v_hijridate DATE;
    DECLARE v_datepart_sep CHAR(1) DEFAULT '_';
    DECLARE v_monthname, v_raw_year NVARCHAR(100);
    DECLARE v_fullyear_regexp VARCHAR(40) DEFAULT '[[:digit:]]{3,4}'; -- yyy/yyyy
    DECLARE v_compyear_regexp VARCHAR(40) DEFAULT '[[:digit:]]{1,4}'; -- y/yy/yyy/yyyy
    DECLARE v_daymm_regexp VARCHAR(40) DEFAULT '[[:digit:]]{1,2}'; -- d/dd(m/mm)
    DECLARE v_daypart_json JSON DEFAULT JSON_ARRAY('AM', 'PM');
    DECLARE v_weekdayampm_start_regexp VARCHAR(50) DEFAULT '(^|[[:digit:][:space:]\.,])';
    DECLARE v_weekdayampm_end_regexp VARCHAR(50) DEFAULT '([[:digit:][:space:]\.,]|$)';
    DECLARE v_anno_domini_regexp VARCHAR(20) DEFAULT '(AD|A\.D\.)';
    DECLARE v_ampm_regexp VARCHAR(10) DEFAULT '([AP]M)';
    DECLARE v_time_masksep_regexp VARCHAR(20) DEFAULT '([[:space:]]|\.|,)*';
    DECLARE v_timeunit_regexp VARCHAR(50) DEFAULT '[[:space:]]*[[:digit:]]{1,2}[[:space:]]*'; -- Time unit regexp
    DECLARE v_hhmmssfs_part_regexp NVARCHAR(4000) DEFAULT
        CONCAT('((', v_timeunit_regexp, v_ampm_regexp, ')|', -- 03AM
               '(', v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, v_time_masksep_regexp, v_ampm_regexp, '?)|', -- (AM)?03:(AM)?24(AM)?
               '(', v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, v_time_masksep_regexp, v_ampm_regexp, '?)|', -- (AM)?03:(AM)?24(AM)?:36(AM)?
               '(', v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, '[[:space:]]*[[:digit:]]{1,2}\.[[:digit:]]+', v_time_masksep_regexp, v_ampm_regexp, '?))'); -- (AM)?03:(AM)?24(AM)?:36.346(AM)?
    DECLARE v_hhmmssfs_mask_regexp NVARCHAR(4000) DEFAULT CONCAT('^', v_time_masksep_regexp, '(', v_hhmmssfs_part_regexp, ')', v_time_masksep_regexp, '$'); -- hh24:mi:ss.fs(AM|PM)
    DECLARE v_defmask1 NVARCHAR(500) DEFAULT CONCAT('^($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_compyear_regexp, '$'); -- mon/Month d/dd y/yy/yyy/yyyy
    DECLARE v_defmask2 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_compyear_regexp, '$'); -- d/dd mon/Month y/yy/yyy/yyyy
    DECLARE v_defmask3 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_compyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)$'); -- d/dd y/yy/yyy/yyyy mon/Month
    DECLARE v_defmask4 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- yyy/yyyy mon/Month d/dd
    DECLARE v_defmask5 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)$'); -- yyy/yyyy d/dd mon/Month
    DECLARE v_defmask6 NVARCHAR(500) DEFAULT CONCAT('^($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- mon/Month yyy/yyyy d/dd
    DECLARE v_defmask7 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)$'); -- yyy/yyyy mon/Month
    DECLARE v_defmask8 NVARCHAR(500) DEFAULT CONCAT('^($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '$'); -- mon/Month yyy/yyyy
    DECLARE v_defmask9 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)$'); -- d/dd mon/Month
    DECLARE v_defmask10 NVARCHAR(500) DEFAULT CONCAT('^($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- mon/Month d/dd
    DECLARE v_defmask11 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- x/xx x/xx
    DECLARE v_defmask12 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- x/xx x/xx x/xx
    DECLARE v_defmask13 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- yyy/yyyy m/mm d/dd
    DECLARE v_defmask14 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '$'); -- x/xx x/xx yyy/yyyy
    DECLARE v_defmask15 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- m/mm yyy/yyyy d/dd
    DECLARE v_defmask16 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- yyy/yyyy m/mm
    DECLARE v_defmask17 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '$'); -- m/mm yyy/yyyy

    -- Declaration of error conditions and handlers
    DECLARE conversion_failed CONDITION FOR SQLSTATE '45520';
    DECLARE v_error_message NVARCHAR(500);

    -- Conversion failed
    DECLARE EXIT HANDLER FOR conversion_failed
    BEGIN
        SET v_error_message = CONCAT('Error converting string value '', COALESCE(p_datestring, 'NULL'),
                                     '' into data type DATE using culture '', COALESCE(p_culture, 'NULL'), ''.');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Conversion failed
    DECLARE EXIT HANDLER FOR 1644
    BEGIN
        SET v_error_message = CONCAT('Error converting string value '', COALESCE(p_datestring, 'NULL'),
                                     '' into data type DATE using culture '', COALESCE(p_culture, 'NULL'), ''.');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- STR_TO_DATE function supplied with incorrect date parts
    DECLARE EXIT HANDLER FOR 1411
    BEGIN
        SET v_error_message = CONCAT('Error converting string value '', COALESCE(p_datestring, 'NULL'),
                                     '' into data type DATE using culture '', COALESCE(p_culture, 'NULL'), ''.');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Constructed date is a Leap-year date (e.g. "29.02.2017")
    DECLARE EXIT HANDLER FOR 1292
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Conversion failed when converting date and time from character string.';
    END;

    -- Getting language metadata JSON by lang name (specified by CONVERSION_LANG constant)
    SET v_lang_metadata_json = aws_sqlserver_ext.get_lang_metadata_json(COALESCE(NULLIF(CONVERSION_LANG, ''), p_culture));

    -- Determining which DATE_FORMAT value to use
    SET v_date_format = COALESCE(NULLIF(UPPER(TRIM(DATE_FORMAT)), ''), JSON_UNQUOTE(JSON_EXTRACT(v_lang_metadata_json, '$.date_format')));

    -- Replacing arabic day half markers with AM|PM
    SET v_datestring = REPLACE(REPLACE(v_datestring, N'', 'AM'), N'', 'PM');

    -- Determining the day half marker (AM or PM)
    REPEAT
        SET v_arr_element = JSON_UNQUOTE(JSON_EXTRACT(v_daypart_json, CONCAT('$[', v_index, ']')));

        IF (v_datestring REGEXP v_arr_element)
        THEN
            SET v_daypart = v_arr_element;
            SET v_count = v_count + aws_sqlserver_ext.regexp_count(v_datestring, v_arr_element, 1, 'i');
        END IF;

        SET v_index = v_index + 1;
        UNTIL (v_index = JSON_LENGTH(v_daypart_json) OR v_count > 1)
    END REPEAT;

    /* Checking that there is only one
       day half marker in the source string */
    IF (v_count > 1) THEN
        -- Conversion failed
        SIGNAL conversion_failed;
    ELSEIF (v_count = 1) THEN
        -- Removing AM|PM day half marker from the source string
        SET v_datestring = aws_sqlserver_ext.regexp_replace(v_datestring, v_ampm_regexp, '', 1, 0, 'c');
    END IF;
    SET v_count = 0, v_index = 0;

    -- Checking for "Anno Domini" (AD, A.D.) abbreviation
    IF (v_datestring REGEXP CONCAT(v_weekdayampm_start_regexp, v_anno_domini_regexp, v_weekdayampm_end_regexp))
    THEN
        IF (v_culture NOT REGEXP 'EN[-_]US|DA[-_]DK|SV[-_]SE|EN[-_]GB|HI[-_]IS') THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        END IF;

        -- Removing "Anno Domini" (AD, A.D.) abbreviation
        SET v_datestring = REPLACE(REPLACE(v_datestring, 'AD', ''), 'A.D.', '');
    END IF;

    SET v_compday_regexp = aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.days_names'), JSON_ARRAY('')), '|');

    SET v_compday_regexp = CONCAT_WS('|', v_compday_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.days_shortnames'), JSON_ARRAY('')), '|'), ''));

    -- Composing complete days names regexp
    SET v_compday_regexp = UPPER(CONCAT_WS('|', v_compday_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.days_extrashortnames'), JSON_ARRAY('')), '|'), '')));

    SET v_compday_json_array = aws_sqlserver_ext.string_to_json_array(v_compday_regexp, '|', TRUE);

    -- Determining the weekdays names array, extracted from the source string
    IF (v_datestring REGEXP v_compday_regexp)
    THEN
        REPEAT
            SET v_arr_element = COALESCE(JSON_UNQUOTE(JSON_EXTRACT(v_compday_json_array, CONCAT('$[', v_index, ']'))), '');
            SET v_reg_mask = IF(CHAR_LENGTH(v_arr_element) > 0, CONCAT(UPPER(v_arr_element), '([[:space:][:digit:].,/-]|$)'), NULL);

            IF (v_datestring REGEXP v_reg_mask)
            THEN
                SET v_weekdayname = v_arr_element;
                SET v_count = v_count + aws_sqlserver_ext.regexp_count(v_datestring, v_reg_mask, 1, 'i');
            END IF;

            SET v_index = v_index + 1;
            UNTIL (v_index = JSON_LENGTH(v_compday_json_array))
        END REPEAT;
    END IF;

    /* Checking that there is only one
       weekday name in a source string */
    IF (v_count > 1) THEN
        -- Conversion failed
        SIGNAL conversion_failed;
    ELSEIF (v_count = 1) THEN
        -- Removing weekday name from the source string
        SET v_datestring = REPLACE(v_datestring, UPPER(v_weekdayname), '');
    END IF;

    SET v_compmonth_regexp = aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_names'), JSON_ARRAY('')), '|');

    SET v_compmonth_regexp = CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_extranames'), JSON_ARRAY('')), '|'), ''));

    SET v_compmonth_regexp = CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_shortnames'), JSON_ARRAY('')), '|'), ''));

    -- Composing complete months names regexp ("Jan|Feb|Mar|Apr|May|...")
    SET v_compmonth_regexp = UPPER(CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_extrashortnames'), JSON_ARRAY('')), '|'), '')));

    IF (v_datestring REGEXP v_hhmmssfs_part_regexp AND
        (NOT v_datestring REGEXP v_hhmmssfs_mask_regexp))
    THEN
        -- Separate time part (if coupled with the date data)
        SET v_timestring = aws_sqlserver_ext.regexp_substr(v_datestring, v_hhmmssfs_part_regexp, 1, 1, 'i');
        SET v_datestring = REPLACE(v_datestring, v_timestring, '');
    END IF;

    -- Performing date string purification (removing meaningless commas, etc.)
    SET v_datestring = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(v_datestring, ',', v_datepart_sep), '/', v_datepart_sep), '-', v_datepart_sep), ' ', v_datepart_sep), '.', v_datepart_sep); -- [[:space:]\\.,/=] => "_"
    SET v_datestring = aws_sqlserver_ext.regexp_replace(v_datestring, CONCAT(v_datepart_sep, '+'), v_datepart_sep, 1, 0, 'i'); -- "_______" => "_"
    SET v_datestring = TRIM(TRAILING v_datepart_sep FROM TRIM(LEADING v_datepart_sep FROM v_datestring)); -- "_DEC_14_2010_" => "DEC_14_2010"

    -- Replacing "$comp_month$" marker with composed months names regexp
    SET v_defmask1 = REPLACE(v_defmask1, '$comp_month$', v_compmonth_regexp);
    SET v_defmask2 = REPLACE(v_defmask2, '$comp_month$', v_compmonth_regexp);
    SET v_defmask3 = REPLACE(v_defmask3, '$comp_month$', v_compmonth_regexp);
    SET v_defmask4 = REPLACE(v_defmask4, '$comp_month$', v_compmonth_regexp);
    SET v_defmask5 = REPLACE(v_defmask5, '$comp_month$', v_compmonth_regexp);
    SET v_defmask6 = REPLACE(v_defmask6, '$comp_month$', v_compmonth_regexp);
    SET v_defmask7 = REPLACE(v_defmask7, '$comp_month$', v_compmonth_regexp);
    SET v_defmask8 = REPLACE(v_defmask8, '$comp_month$', v_compmonth_regexp);
    SET v_defmask9 = REPLACE(v_defmask9, '$comp_month$', v_compmonth_regexp);
    SET v_defmask10 = REPLACE(v_defmask10, '$comp_month$', v_compmonth_regexp);

    -- Match dates like "Feb 02 2017" etc. (see below desc.)
    IF ((v_datestring REGEXP v_defmask1) OR -- Feb 02 17(2017) (mon/Month d/dd y/yy/yyy/yyyy)
        (v_datestring REGEXP v_defmask2) OR -- 02 Feb 17(2017) (d/dd mon/Month y/yy/yyy/yyyy)
        (v_datestring REGEXP v_defmask3) OR -- 02 17(2017) Feb (d/dd y/yy/yyy/yyyy mon/Month)
        (v_datestring REGEXP v_defmask4) OR -- 2017 Feb 02 (yyy/yyyy mon/Month d/dd)
        (v_datestring REGEXP v_defmask5) OR -- 2017 02 Feb (yyy/yyyy d/dd mon/Month)
        (v_datestring REGEXP v_defmask6) OR -- Feb 2017 02 (mon/Month yyy/yyyy d/dd)
        (v_datestring REGEXP v_defmask7) OR -- 2017 Feb (yyy/yyyy mon/Month)
        (v_datestring REGEXP v_defmask8) OR -- Feb 2017 (mon/Month yyy/yyyy)
        (v_datestring REGEXP v_defmask9) OR -- 19 Oct (d/dd mon/Month)
        (v_datestring REGEXP v_defmask10)) -- Oct 19 (mon/Month d/dd)
    THEN
        -- Extract month part from supplied expression ("Feb" from "Feb02 2017")
        SET v_monthname = aws_sqlserver_ext.regexp_substr(v_datestring, CONCAT('(', v_compmonth_regexp, ')'), 1, 1, 'i');
        SET v_month = aws_sqlserver_ext.get_monthnum_by_name(v_monthname, v_lang_metadata_json);

        IF (v_datestring REGEXP v_defmask1) -- Feb 02 17(2017) (mon/Month d/dd y/yy/yyy/yyyy)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 2);
            SET v_year = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 3);
            SET v_year = CASE
                            WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_year, '', NULL) - 543
                            ELSE aws_sqlserver_ext.get_full_year(v_year, '', NULL)
                         END;
            SET v_raw_year = v_year;
            SET v_resmask_cnt = 1;

        ELSEIF (v_datestring REGEXP v_defmask2) -- 02 Feb 17(2017) (d/dd mon/Month y/yy/yyy/yyyy)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 1);
            SET v_year = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 3);
            SET v_year = CASE
                            WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_year, '', NULL) - 543
                            ELSE aws_sqlserver_ext.get_full_year(v_year, '', NULL)
                         END;
            SET v_raw_year = v_year;
            SET v_resmask_cnt = 2;

        ELSEIF (v_datestring REGEXP v_defmask3) -- 02 17(2017) Feb (d/dd y/yy/yyy/yyyy mon/Month)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 1);
            SET v_year = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 2);
            SET v_year = CASE
                            WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_year, '', NULL) - 543
                            ELSE aws_sqlserver_ext.get_full_year(v_year, '', NULL)
                         END;
            SET v_raw_year = v_year;
            SET v_resmask_cnt = 3;

        ELSEIF (v_datestring REGEXP v_defmask4) -- 2017 Feb 02 (yyy/yyyy mon/Month d/dd)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 3);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 1);
            SET v_resmask_cnt = 4;

        ELSEIF (v_datestring REGEXP v_defmask5) -- 2017 02 Feb (yyy/yyyy d/dd mon/Month)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 2);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 1);
            SET v_resmask_cnt = 5;

        ELSEIF (v_datestring REGEXP v_defmask6) -- Feb 2017 02 (mon/Month yyy/yyyy d/dd)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 3);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 2);
            SET v_resmask_cnt = 6;

        ELSEIF (v_datestring REGEXP v_defmask7) -- 2017 Feb (yyy/yyyy mon/Month)
        THEN
            SET v_day = 1;
            SET v_raw_year = SUBSTRING_INDEX(v_datestring, v_datepart_sep, 1);
            SET v_resmask_cnt = 7;

        ELSEIF (v_datestring REGEXP v_defmask8) -- Feb 2017 (mon/Month yyy/yyyy)
        THEN
            SET v_day = 1;
            SET v_raw_year = SUBSTRING_INDEX(v_datestring, v_datepart_sep, -1);
            SET v_resmask_cnt = 8;

        ELSEIF (v_datestring REGEXP v_defmask9) -- 19 Oct (d/dd mon/Month)
        THEN
            IF (v_month = 3 AND v_culture IN ('IT-IT', 'IT_IT'))
            THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            END IF;

            IF (v_date_format = 'YMD' AND v_culture NOT IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
            THEN
                SET v_day = 1;
                SET v_year = aws_sqlserver_ext.get_full_year(SUBSTRING_INDEX(v_datestring, v_datepart_sep, 1), '', 29);
            ELSE
                SET v_day = SUBSTRING_INDEX(v_datestring, v_datepart_sep, 1);
                SET v_year = YEAR(CURRENT_DATE);
            END IF;

            SET v_raw_year = YEAR(aws_sqlserver_ext.conv_greg_to_hijri(DAY(CURRENT_DATE), MONTH(CURRENT_DATE), YEAR(CURRENT_DATE)));
            SET v_resmask_cnt = 9;

        ELSEIF (v_datestring REGEXP v_defmask10) -- Oct 19 (mon/Month d/dd)
        THEN
            IF (v_date_format IN ('YMD', 'MDY') AND v_culture NOT IN ('SV-SE', 'SV_SE'))
            THEN
                SET v_day = SUBSTRING_INDEX(v_datestring, v_datepart_sep, -1);
                SET v_year = YEAR(CURRENT_DATE);
            ELSE
                SET v_day = 1;
                SET v_year = CASE
                                WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(SUBSTRING_INDEX(v_datestring, v_datepart_sep, -1), '', NULL) - 43
                                ELSE aws_sqlserver_ext.get_full_year(SUBSTRING_INDEX(v_datestring, v_datepart_sep, -1), '', 29)
                             END;
            END IF;

            SET v_raw_year = aws_sqlserver_ext.get_full_year(SUBSTRING(v_year, 3, 2), '14', NULL); -- 14th century (Hijri)
            SET v_resmask_cnt = 10;
        END IF;
    
        IF (v_resmask_cnt NOT IN (1, 2, 3, 9, 10))
        THEN
            SET v_year = CASE -- four-digit year
                            WHEN v_culture IN ('TH-TH', 'TH_TH') THEN CONVERT(v_raw_year, UNSIGNED) - 543
                            ELSE v_raw_year
                         END;
        END IF;

        -- Hijri calendar correction
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA')) -- Arabic (Saudi Arabia)
        THEN
            IF (v_day > 30 OR -- max Hijri day is 30
                (v_resmask_cnt NOT IN (1, 2, 3, 9, 10) AND v_year NOT BETWEEN 1318 AND 1501) OR
                (v_resmask_cnt IN (1, 2, 3) AND CONVERT(v_raw_year, UNSIGNED) NOT BETWEEN 1318 AND 1501))
            THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            END IF;

            -- Calculating Hijri date and converting it back to Gregorian
            SET v_hijridate = DATE_SUB(aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year), INTERVAL 1 DAY);

            SET v_day = DAY(v_hijridate);
            SET v_month = MONTH(v_hijridate);
            SET v_year = YEAR(v_hijridate);
        END IF;

    ELSEIF (v_datestring REGEXP v_defmask11) -- 03.12 (03.12 => 03.12.2018)
    THEN
        IF (v_date_format = 'DMY' OR
            v_culture IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
        THEN -- (d/dd) (m/mm)
            SET v_day = SUBSTRING_INDEX(v_datestring, v_datepart_sep, 1);
            SET v_month = SUBSTRING_INDEX(v_datestring, v_datepart_sep, -1);
        ELSE -- (m/mm) (d/dd)
            SET v_day = SUBSTRING_INDEX(v_datestring, v_datepart_sep, -1);
            SET v_month = SUBSTRING_INDEX(v_datestring, v_datepart_sep, 1);
        END IF;

        -- Hijri calendar correction
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA')) -- Arabic (Saudi Arabia)
        THEN
            IF (v_day > 30 OR -- max Hijri day is 30
                v_month > 12)
            THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            END IF;

            -- Calculating Hijri date and converting it back to Gregorian
            SET v_raw_year = YEAR(aws_sqlserver_ext.conv_greg_to_hijri(DAY(DATE_ADD(CURRENT_DATE, INTERVAL 1 DAY)),
                                                                       MONTH(DATE_ADD(CURRENT_DATE, INTERVAL 1 DAY)),
                                                                       YEAR(DATE_ADD(CURRENT_DATE, INTERVAL 1 DAY))));
            SET v_hijridate = DATE_SUB(aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year), INTERVAL 1 DAY);

            SET v_day = DAY(v_hijridate),
                v_month = MONTH(v_hijridate),
                v_year = YEAR(v_hijridate);
        ELSE
            SET v_year = YEAR(CURRENT_DATE);
        END IF;

    ELSEIF (v_datestring REGEXP v_defmask12) -- 03.05.17 (3.5.17 => March 5 2017)
    THEN
        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN -- (d/dd) (m/mm) (y/yy)
            SET v_day = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 1);
            SET v_month = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 2);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 3);

        ELSEIF (v_date_format = 'YMD')
        THEN -- (y/yy) (m/mm) (d/dd)
            SET v_day = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 3);
            SET v_month = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 2);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 1);

        ELSE -- (m/mm) (d/dd) (y/yy)
            SET v_day = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 2);
            SET v_month = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 1);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 3);
        END IF;

        -- Hijri calendar correction
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA')) -- Arabic (Saudi Arabia)
        THEN
            IF (v_day > 30 OR -- max Hijri day is 30
                v_month > 12)
            THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            END IF;

            -- Calculating Hijri date and converting it back to Gregorian
            SET v_raw_year = aws_sqlserver_ext.get_full_year(v_raw_year, '14', NULL); -- 14th century (Hijri)
            SET v_hijridate = DATE_SUB(aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year), INTERVAL 1 DAY);

            SET v_day = DAY(v_hijridate),
                v_month = MONTH(v_hijridate),
                v_year = YEAR(v_hijridate);

        ELSEIF (v_culture IN ('TH-TH', 'TH_TH')) THEN
            SET v_year = aws_sqlserver_ext.get_full_year(v_raw_year, '', NULL) - 43;
        ELSE
            SET v_year = aws_sqlserver_ext.get_full_year(v_raw_year, '', 29);
        END IF;
    
    ELSEIF (v_datestring REGEXP v_defmask13) -- 2017.03.05 (yyy/yyyy m/mm d/dd)
    THEN
        SET v_day = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 3);
        SET v_month = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 2);
        SET v_year = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 1);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_datestring REGEXP v_defmask14) -- 09.11.2018 (x/xx x/xx yyy/yyyy)
    THEN
        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN -- (d/dd) (m/mm)
            SET v_day = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 1);
            SET v_month = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 2);
        ELSE -- (m/mm) (d/dd)
            SET v_day = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 2);
            SET v_month = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 1);
        END IF;

        SET v_year = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 3);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_datestring REGEXP v_defmask15) -- 09.2018.11 (m/mm yyy/yyyy d/dd)
    THEN
        SET v_day = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 3);
        SET v_month = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 1);
        SET v_year = aws_sqlserver_ext.split_part(v_datestring, v_datepart_sep, 2);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_datestring REGEXP v_defmask16) -- 2017 11 (yyy/yyyy m/mm)
    THEN
        SET v_day = 1;
        SET v_month = SUBSTRING_INDEX(v_datestring, v_datepart_sep, -1);
        SET v_year = SUBSTRING_INDEX(v_datestring, v_datepart_sep, 1);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_datestring REGEXP v_defmask17) -- 11 2017 (m/mm yyy/yyyy)
    THEN
        SET v_day = 1;
        SET v_month = SUBSTRING_INDEX(v_datestring, v_datepart_sep, 1);
        SET v_year = SUBSTRING_INDEX(v_datestring, v_datepart_sep, -1);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_datestring REGEXP v_hhmmssfs_mask_regexp) -- HH:mi:ss(./:)ms
    THEN
        SET v_timestring = v_datestring;
        SET v_day = DAY(CURRENT_DATE),
            v_month = MONTH(CURRENT_DATE),
            v_year = YEAR(CURRENT_DATE);
    ELSE
        -- Conversion failed
        SIGNAL conversion_failed;
    END IF;

    -- Checking time part (if exists)
    IF (CHAR_LENGTH(v_timestring) > 0 AND v_timestring NOT REGEXP v_ampm_regexp)
    THEN
        -- Cleaning time part ("..03:..45:...55.789.." => "03:45:55.789")
        SET v_timestring = aws_sqlserver_ext.regexp_replace(v_timestring, '[[:space:],]', '', 1, 0, 'i');
        SET v_timestring = aws_sqlserver_ext.regexp_replace(v_timestring, ':\.+', '_', 1, 0, 'i');
        SET v_timestring = TRIM(BOTH '.' FROM REPLACE(v_timestring, '_', ':'));

        SET v_hours = COALESCE(SUBSTRING_INDEX(v_timestring, ':', 1), 0); -- hours

        -- Adjusting hour(s) by AM|PM day part mark
        IF ((v_daypart = 'AM' AND v_hours NOT BETWEEN 0 AND 12) OR
            (v_daypart = 'PM' AND v_hours NOT BETWEEN 1 AND 23))
        THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        ELSEIF (v_daypart = 'PM' AND v_hours < 12) THEN
            SET v_hours = v_hours + 12;
        ELSEIF (v_daypart = 'AM' AND v_hours = 12) THEN
            SET v_hours = v_hours - 12;
        END IF;

        SET v_minutes = COALESCE(NULLIF(aws_sqlserver_ext.split_part(v_timestring, ':', 2), ''), 0); -- minutes
        SET v_seconds = COALESCE(NULLIF(aws_sqlserver_ext.split_part(v_timestring, ':', 3), ''), 0); -- seconds

        IF (v_seconds REGEXP '\.') THEN
            SET v_fseconds = LEFT(SUBSTRING_INDEX(v_seconds, '.', -1), 6); -- fractional seconds
            SET v_seconds = SUBSTRING_INDEX(v_seconds, '.', 1); -- seconds
        END IF;
    ELSEIF (v_daypart = 'PM')
    THEN
        SET v_hours = 12;
    END IF;

    -- Constructing date object from the separate date and time parts
    SET v_res_datetime = STR_TO_DATE(CONCAT_WS('.', v_year, v_month, v_day, -- date part
                                                    v_hours, v_minutes, v_seconds, v_fseconds), -- time part
                                 '%Y.%m.%d.%H.%i.%s.%f');

    SET v_res_date = STR_TO_DATE(DATE_FORMAT(v_res_datetime, '%Y.%m.%d'), '%Y.%m.%d');

    /* Checking that declared weekday name
       corresponds with the parsed date */
    IF (NOT ISNULL(v_weekdayname)) THEN
        -- Translating weekday name into a weekday number
        SET v_weekdaynum = aws_sqlserver_ext.get_weekdaynum_by_name(v_weekdayname, v_lang_metadata_json);

        IF(v_weekdaynum <> IF(DAYOFWEEK(v_res_date) = 1, 7, DAYOFWEEK(v_res_date) - 1)) THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        END IF;
    END IF;

    RETURN v_res_date;
END]]></complex-attribute>
                        <category _I_D="e30ff1f4-f938-4be8-9fff-f8a0d613c94f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ab41f395-4ead-4313-bf26-62653b8ae97b" name="parse_to_datetime" context="parse_to_datetime" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function parses the source string and translates it into the DATETIME value, according to specified culture (conversion mask).]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_scale INTEGER;
    DECLARE v_timestring NVARCHAR(4000);
    DECLARE v_resdatatype VARCHAR(100);
    DECLARE v_datatype VARCHAR(100) DEFAULT UPPER(TRIM(p_datatype));
    DECLARE v_datetimestring NVARCHAR(4000) DEFAULT UPPER(TRIM(CONVERT(p_datetimestring USING utf8)));
    DECLARE v_culture VARCHAR(50) DEFAULT COALESCE(NULLIF(UPPER(TRIM(p_culture)), ''), 'EN-US');
    DECLARE v_compmonth_regexp NVARCHAR(2000);
    DECLARE v_compday_regexp NVARCHAR(1000);
    DECLARE v_weekdayname NVARCHAR(50);
    DECLARE v_arr_element NVARCHAR(50);
    DECLARE v_daypart NVARCHAR(50);
    DECLARE v_index SMALLINT DEFAULT 0;
    DECLARE v_count INTEGER DEFAULT 0;
    DECLARE v_lang_metadata_json JSON;
    DECLARE v_compday_json_array JSON;
    DECLARE v_date_format VARCHAR(20);
    DECLARE v_reg_mask NVARCHAR(100);
    DECLARE v_weekdaynum SMALLINT;

    -- Date and time components declaration
    DECLARE v_res_datetime DATETIME(6);
    DECLARE v_day, v_month, v_year INTEGER;
    DECLARE v_hours, v_minutes, v_fseconds INTEGER;
    DECLARE v_resmask_cnt SMALLINT DEFAULT 0;
    DECLARE v_seconds VARCHAR(500);

    /* MS SQL Server session variables emulation:
       - LANGUAGE (SET LANGUAGE ENGLISH)
       - DATE_FORMAT (SET DATEFORMAT MDY) */
    DECLARE CONVERSION_LANG VARCHAR(50) DEFAULT ''; -- Override using of the "p_culture" parameter value for parsing of months and days names
    DECLARE DATE_FORMAT VARCHAR(50) DEFAULT ''; -- Override using of the default date format (linked with language) - (MDY|YDM|DMY|DYM)

    DECLARE v_daypart_json JSON DEFAULT JSON_ARRAY('AM', 'PM');
    DECLARE v_weekdayampm_start_regexp VARCHAR(50) DEFAULT '(^|[[:digit:][:space:]\.,])';
    DECLARE v_weekdayampm_end_regexp VARCHAR(50) DEFAULT '([[:digit:][:space:]\.,]|$)';
    DECLARE v_anno_domini_regexp VARCHAR(20) DEFAULT '(AD|A\.D\.)';
    DECLARE v_ampm_regexp VARCHAR(10) DEFAULT '([AP]M)';
    DECLARE v_time_masksep_regexp VARCHAR(20) DEFAULT '([[:space:]]|\.|,)*';
    DECLARE v_timeunit_regexp VARCHAR(50) DEFAULT '[[:space:]]*[[:digit:]]{1,2}[[:space:]]*'; -- Time unit regexp
    DECLARE v_datatype_mask VARCHAR(120) DEFAULT '^[[:space:]]*(DATETIME|SMALLDATETIME|DATETIME2)[[:space:]]*\([[:space:]]*([[:digit:]]+)[[:space:]]*\)[[:space:]]*$'; -- DATETIME2(7)
    DECLARE v_datatype_regexp VARCHAR(120) DEFAULT '^[[:space:]]*(DATETIME|SMALLDATETIME|DATETIME2)[[:space:]]*$'; -- DATETIME/SMALLDATETIME/DATETIME2
    DECLARE v_hijridate, v_testdate DATE;
    DECLARE v_datepart_sep CHAR(1) DEFAULT '_';
    DECLARE v_monthname, v_raw_year NVARCHAR(100);
    DECLARE v_fullyear_regexp VARCHAR(40) DEFAULT '[[:digit:]]{3,4}'; -- yyy/yyyy
    DECLARE v_compyear_regexp VARCHAR(40) DEFAULT '[[:digit:]]{1,4}'; -- y/yy/yyy/yyyy
    DECLARE v_daymm_regexp VARCHAR(40) DEFAULT '[[:digit:]]{1,2}'; -- d/dd(m/mm)
    DECLARE v_hhmmssfs_part_regexp NVARCHAR(4000) DEFAULT
        CONCAT('((', v_timeunit_regexp, v_ampm_regexp, ')|', -- 03AM
               '(', v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, '', v_time_masksep_regexp, v_ampm_regexp, '?)|', -- (AM)?03:(AM)?24(AM)?
               '(', v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, '', v_time_masksep_regexp, v_ampm_regexp, '?)|', -- (AM)?03:(AM)?24(AM)?:36(AM)?
               '(', v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, '[[:space:]]*[[:digit:]]{1,2}\.[[:digit:]]+', v_time_masksep_regexp, v_ampm_regexp, '?))'); -- (AM)?03:(AM)?24(AM)?:36.346(AM)?
    DECLARE v_hhmmssfs_mask_regexp NVARCHAR(4000) DEFAULT CONCAT('^', v_time_masksep_regexp, '(', v_hhmmssfs_part_regexp, ')', v_time_masksep_regexp, '$'); -- hh24:mi:ss.fs(AM|PM)
    DECLARE v_defmask1 NVARCHAR(500) DEFAULT CONCAT('^($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_compyear_regexp, '$'); -- mon/Month d/dd y/yy/yyy/yyyy
    DECLARE v_defmask2 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_compyear_regexp, '$'); -- d/dd mon/Month y/yy/yyy/yyyy
    DECLARE v_defmask3 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_compyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)$'); -- d/dd y/yy/yyy/yyyy mon/Month
    DECLARE v_defmask4 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- yyy/yyyy mon/Month d/dd
    DECLARE v_defmask5 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)$'); -- yyy/yyyy d/dd mon/Month
    DECLARE v_defmask6 NVARCHAR(500) DEFAULT CONCAT('^($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- mon/Month yyy/yyyy d/dd
    DECLARE v_defmask7 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)$'); -- yyy/yyyy mon/Month
    DECLARE v_defmask8 NVARCHAR(500) DEFAULT CONCAT('^($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '$'); -- mon/Month yyy/yyyy
    DECLARE v_defmask9 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)$'); -- d/dd mon/Month
    DECLARE v_defmask10 NVARCHAR(500) DEFAULT CONCAT('^($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- mon/Month d/dd
    DECLARE v_defmask11 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- x/xx x/xx
    DECLARE v_defmask12 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- x/xx x/xx x/xx
    DECLARE v_defmask13 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- yyy/yyyy m/mm d/dd
    DECLARE v_defmask14 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '$'); -- x/xx x/xx yyy/yyyy
    DECLARE v_defmask15 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- m/mm yyy/yyyy d/dd
    DECLARE v_defmask16 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- yyy/yyyy m/mm
    DECLARE v_defmask17 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '$'); -- m/mm yyy/yyyy

    -- Declaration of error conditions and handlers
    DECLARE conversion_failed CONDITION FOR SQLSTATE '45520';
    DECLARE invalid_dtype_scale CONDITION FOR SQLSTATE '45521';
    DECLARE incorrect_datatype CONDITION FOR SQLSTATE '45522';
    DECLARE v_error_message NVARCHAR(500);

    -- Conversion failed
    DECLARE EXIT HANDLER FOR conversion_failed
    BEGIN
        SET v_error_message = CONCAT('Error converting string value '', COALESCE(p_datetimestring, 'NULL'),
                                     '' into data type DATE using culture '', COALESCE(p_culture, 'NULL'), ''.');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Specified DATETIME2 scale is not in range 0..7
    DECLARE EXIT HANDLER FOR invalid_dtype_scale
    BEGIN
        SET v_error_message = CONCAT('Specified scale ', v_scale, ' is invalid.');

        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Supplied data type param value is not one of DATETIME|SMALLDATETIME|DATETIME2
    DECLARE EXIT HANDLER FOR incorrect_datatype
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Data type should be one of these values: 'DATETIME', 'SMALLDATETIME', 'DATETIME2'/'DATETIME2(n)'.';
    END;

    -- STR_TO_DATE function supplied with incorrect date parts
    DECLARE EXIT HANDLER FOR 1411
    BEGIN
        SET v_error_message = CONCAT('Error converting string value '', COALESCE(p_datetimestring, 'NULL'),
                                     '' into data type DATE using culture '', COALESCE(p_culture, 'NULL'), ''.');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Constructed date is a Leap-year date (e.g. "29.02.2017")
    DECLARE EXIT HANDLER FOR 1292
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Conversion failed when converting date and time from character string.';
    END;

    -- Parse supplied datatype expression - extract data type and scale
    IF (v_datatype REGEXP v_datatype_mask) -- DATETIME2(x)
    THEN
        SET v_resdatatype = RTRIM(SUBSTRING_INDEX(v_datatype, '(', 1));

        -- Extract scale data from datatype expression
        SET v_scale = CONVERT(TRIM(SUBSTRING(v_datatype,
                                   INSTR(v_datatype, '(') + 1,
                                   (INSTR(v_datatype, ')') - INSTR(v_datatype, '(') - 1))), UNSIGNED);
        IF (v_scale NOT BETWEEN 0 AND 7) THEN -- 0 => 6(7)
            SIGNAL invalid_dtype_scale;
        END IF;

        SET v_scale = IF(v_scale = 7, 6, v_scale);
    ELSEIF (v_datatype REGEXP v_datatype_regexp) THEN
        SET v_resdatatype = RTRIM(v_datatype);
        SET v_scale = 6; -- Default MS SQL DATETIME2 scale is 7, 6 - for MySQL
    ELSE
        -- Incorrect target datatype
        SIGNAL incorrect_datatype;
    END IF;

    -- Getting language metadata JSON by lang name (specified by CONVERSION_LANG constant)
    SET v_lang_metadata_json = aws_sqlserver_ext.get_lang_metadata_json(COALESCE(NULLIF(CONVERSION_LANG, ''), p_culture));

    -- Determining which DATE_FORMAT value to use
    SET v_date_format = COALESCE(NULLIF(UPPER(TRIM(DATE_FORMAT)), ''), JSON_UNQUOTE(JSON_EXTRACT(v_lang_metadata_json, '$.date_format')));

    -- Replacing arabic day half markers with AM|PM
    SET v_datetimestring = REPLACE(REPLACE(v_datetimestring, N'', 'AM'), N'', 'PM');

    -- Determining the day half marker (AM or PM)
    REPEAT
        SET v_arr_element = JSON_UNQUOTE(JSON_EXTRACT(v_daypart_json, CONCAT('$[', v_index, ']')));

        IF (v_datetimestring REGEXP v_arr_element)
        THEN
            SET v_daypart = v_arr_element;
            SET v_count = v_count + aws_sqlserver_ext.regexp_count(v_datetimestring, v_arr_element, 1, 'i');
        END IF;

        SET v_index = v_index + 1;
        UNTIL (v_index = JSON_LENGTH(v_daypart_json) OR v_count > 1)
    END REPEAT;

    /* Checking that there is only one
       day half marker in the source string */
    IF (v_count > 1) THEN
        -- Conversion failed
        SIGNAL conversion_failed;
    ELSEIF (v_count = 1) THEN
        -- Removing AM|PM day half marker from the source string
        SET v_datetimestring = aws_sqlserver_ext.regexp_replace(v_datetimestring, v_ampm_regexp, '', 1, 0, 'c');
    END IF;
    SET v_count = 0, v_index = 0;

    -- Checking for "Anno Domini" (AD, A.D.) abbreviation
    IF (v_datetimestring REGEXP CONCAT(v_weekdayampm_start_regexp, v_anno_domini_regexp, v_weekdayampm_end_regexp))
    THEN
        IF (v_culture NOT REGEXP 'EN[-_]US|DA[-_]DK|SV[-_]SE|EN[-_]GB|HI[-_]IS') THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        END IF;

        -- Removing "Anno Domini" (AD, A.D.) abbreviation
        SET v_datetimestring = REPLACE(REPLACE(v_datetimestring, 'AD', ''), 'A.D.', '');
    END IF;

    SET v_compday_regexp = aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.days_names'), JSON_ARRAY('')), '|');

    SET v_compday_regexp = CONCAT_WS('|', v_compday_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.days_shortnames'), JSON_ARRAY('')), '|'), ''));

    -- Composing complete days names regexp
    SET v_compday_regexp = UPPER(CONCAT_WS('|', v_compday_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.days_extrashortnames'), JSON_ARRAY('')), '|'), '')));

    SET v_compday_json_array = aws_sqlserver_ext.string_to_json_array(v_compday_regexp, '|', TRUE);

    -- Determining the weekdays names array, extracted from the source string
    IF (v_datetimestring REGEXP v_compday_regexp)
    THEN
        REPEAT
            SET v_arr_element = COALESCE(JSON_UNQUOTE(JSON_EXTRACT(v_compday_json_array, CONCAT('$[', v_index, ']'))), '');
            SET v_reg_mask = IF(CHAR_LENGTH(v_arr_element) > 0, CONCAT(UPPER(v_arr_element), '([[:space:][:digit:].,/-]|$)'), NULL);

            IF (v_datetimestring REGEXP v_reg_mask)
            THEN
                SET v_weekdayname = v_arr_element;
                SET v_count = v_count + aws_sqlserver_ext.regexp_count(v_datetimestring, v_reg_mask, 1, 'i');
            END IF;

            SET v_index = v_index + 1;
            UNTIL (v_index = JSON_LENGTH(v_compday_json_array))
        END REPEAT;
    END IF;

    /* Checking that there is only one
       weekday name in the source string */
    IF (v_count > 1) THEN
        -- Conversion failed
        SIGNAL conversion_failed;
    ELSEIF (v_count = 1) THEN
        -- Removing weekday name from the source string
        SET v_datetimestring = REPLACE(v_datetimestring, UPPER(v_weekdayname), '');
    END IF;

    SET v_compmonth_regexp = aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_names'), JSON_ARRAY('')), '|');

    SET v_compmonth_regexp = CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_extranames'), JSON_ARRAY('')), '|'), ''));

    SET v_compmonth_regexp = CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_shortnames'), JSON_ARRAY('')), '|'), ''));

    -- Composing complete months names regexp ("Jan|Feb|Mar|Apr|May|...")
    SET v_compmonth_regexp = UPPER(CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_extrashortnames'), JSON_ARRAY('')), '|'), '')));

    IF (v_datetimestring REGEXP v_hhmmssfs_part_regexp AND
        (NOT v_datetimestring REGEXP v_hhmmssfs_mask_regexp))
    THEN
        -- Separate time part (if coupled with the date data)
        SET v_timestring = aws_sqlserver_ext.regexp_substr(v_datetimestring, v_hhmmssfs_part_regexp, 1, 1, 'i');
        SET v_datetimestring = REPLACE(v_datetimestring, v_timestring, '');
    END IF;

    -- Performing date string purification (removing meaningless commas, etc.)
    SET v_datetimestring = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(v_datetimestring, ',', v_datepart_sep), '/', v_datepart_sep), '-', v_datepart_sep), ' ', v_datepart_sep), '.', v_datepart_sep); -- [[:space:]\\.,/=] => "_"
    SET v_datetimestring = aws_sqlserver_ext.regexp_replace(v_datetimestring, CONCAT(v_datepart_sep, '+'), v_datepart_sep, 1, 0, 'i'); -- "_______" => "_"
    SET v_datetimestring = TRIM(TRAILING v_datepart_sep FROM TRIM(LEADING v_datepart_sep FROM v_datetimestring)); -- "_DEC_14_2010_" => "DEC_14_2010"

    -- Replacing "$comp_month$" marker with composed months names regexp
    SET v_defmask1 = REPLACE(v_defmask1, '$comp_month$', v_compmonth_regexp);
    SET v_defmask2 = REPLACE(v_defmask2, '$comp_month$', v_compmonth_regexp);
    SET v_defmask3 = REPLACE(v_defmask3, '$comp_month$', v_compmonth_regexp);
    SET v_defmask4 = REPLACE(v_defmask4, '$comp_month$', v_compmonth_regexp);
    SET v_defmask5 = REPLACE(v_defmask5, '$comp_month$', v_compmonth_regexp);
    SET v_defmask6 = REPLACE(v_defmask6, '$comp_month$', v_compmonth_regexp);
    SET v_defmask7 = REPLACE(v_defmask7, '$comp_month$', v_compmonth_regexp);
    SET v_defmask8 = REPLACE(v_defmask8, '$comp_month$', v_compmonth_regexp);
    SET v_defmask9 = REPLACE(v_defmask9, '$comp_month$', v_compmonth_regexp);
    SET v_defmask10 = REPLACE(v_defmask10, '$comp_month$', v_compmonth_regexp);

    -- Match dates like "Feb 02 2017" etc. (see below desc.)
    IF ((v_datetimestring REGEXP v_defmask1) OR -- Feb 02 17(2017) (mon/Month d/dd y/yy/yyy/yyyy)
        (v_datetimestring REGEXP v_defmask2) OR -- 02 Feb 17(2017) (d/dd mon/Month y/yy/yyy/yyyy)
        (v_datetimestring REGEXP v_defmask3) OR -- 02 17(2017) Feb (d/dd y/yy/yyy/yyyy mon/Month)
        (v_datetimestring REGEXP v_defmask4) OR -- 2017 Feb 02 (yyy/yyyy mon/Month d/dd)
        (v_datetimestring REGEXP v_defmask5) OR -- 2017 02 Feb (yyy/yyyy d/dd mon/Month)
        (v_datetimestring REGEXP v_defmask6) OR -- Feb 2017 02 (mon/Month yyy/yyyy d/dd)
        (v_datetimestring REGEXP v_defmask7) OR -- 2017 Feb (yyy/yyyy mon/Month)
        (v_datetimestring REGEXP v_defmask8) OR -- Feb 2017 (mon/Month yyy/yyyy)
        (v_datetimestring REGEXP v_defmask9) OR -- 19 Oct (d/dd mon/Month)
        (v_datetimestring REGEXP v_defmask10)) -- Oct 19 (mon/Month d/dd)
    THEN
        -- Extract month part from supplied expression ("Feb" from "Feb02 2017")
        SET v_monthname = aws_sqlserver_ext.regexp_substr(v_datetimestring, CONCAT('(', v_compmonth_regexp, ')'), 1, 1, 'i');
        SET v_month = aws_sqlserver_ext.get_monthnum_by_name(v_monthname, v_lang_metadata_json);

        IF (v_datetimestring REGEXP v_defmask1) -- Feb 02 17(2017) (mon/Month d/dd y/yy/yyy/yyyy)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 2);
            SET v_year = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 3);
            SET v_year = CASE
                            WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_year, '', NULL) - 543
                            ELSE aws_sqlserver_ext.get_full_year(v_year, '', NULL)
                         END;
            SET v_raw_year = v_year;
            SET v_resmask_cnt = 1;

        ELSEIF (v_datetimestring REGEXP v_defmask2) -- 02 Feb 17(2017) (d/dd mon/Month y/yy/yyy/yyyy)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 1);
            SET v_year = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 3);
            SET v_year = CASE
                            WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_year, '', NULL) - 543
                            ELSE aws_sqlserver_ext.get_full_year(v_year, '', NULL)
                         END;
            SET v_raw_year = v_year;
            SET v_resmask_cnt = 2;

        ELSEIF (v_datetimestring REGEXP v_defmask3) -- 02 17(2017) Feb (d/dd y/yy/yyy/yyyy mon/Month)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 1);
            SET v_year = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 2);
            SET v_year = CASE
                            WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_year, '', NULL) - 543
                            ELSE aws_sqlserver_ext.get_full_year(v_year, '', NULL)
                         END;
            SET v_raw_year = v_year;
            SET v_resmask_cnt = 3;

        ELSEIF (v_datetimestring REGEXP v_defmask4) -- 2017 Feb 02 (yyy/yyyy mon/Month d/dd)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 3);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 1);
            SET v_resmask_cnt = 4;

        ELSEIF (v_datetimestring REGEXP v_defmask5) -- 2017 02 Feb (yyy/yyyy d/dd mon/Month)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 2);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 1);
            SET v_resmask_cnt = 5;

        ELSEIF (v_datetimestring REGEXP v_defmask6) -- Feb 2017 02 (mon/Month yyy/yyyy d/dd)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 3);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 2);
            SET v_resmask_cnt = 6;

        ELSEIF (v_datetimestring REGEXP v_defmask7) -- 2017 Feb (yyy/yyyy mon/Month)
        THEN
            SET v_day = 1;
            SET v_raw_year = SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, 1);
            SET v_resmask_cnt = 7;

        ELSEIF (v_datetimestring REGEXP v_defmask8) -- Feb 2017 (mon/Month yyy/yyyy)
        THEN
            SET v_day = 1;
            SET v_raw_year = SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, -1);
            SET v_resmask_cnt = 8;

        ELSEIF (v_datetimestring REGEXP v_defmask9) -- 19 Oct (d/dd mon/Month)
        THEN
            IF (v_month = 3 AND v_culture IN ('IT-IT', 'IT_IT'))
            THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            END IF;

            IF (v_date_format = 'YMD' AND v_culture NOT IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
            THEN
                SET v_day = 1;
                SET v_year = aws_sqlserver_ext.get_full_year(SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, 1), '', 29);
            ELSE
                SET v_day = SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, 1);
                SET v_year = YEAR(CURRENT_DATE);
            END IF;

            SET v_raw_year = YEAR(aws_sqlserver_ext.conv_greg_to_hijri(DAY(CURRENT_DATE), MONTH(CURRENT_DATE), YEAR(CURRENT_DATE)));
            SET v_resmask_cnt = 9;

        ELSEIF (v_datetimestring REGEXP v_defmask10) -- Oct 19 (mon/Month d/dd)
        THEN
            IF (v_date_format IN ('YMD', 'MDY') AND v_culture NOT IN ('SV-SE', 'SV_SE'))
            THEN
                SET v_day = SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, -1);
                SET v_year = YEAR(CURRENT_DATE);
            ELSE
                SET v_day = 1;
                SET v_year = CASE
                                WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, -1), '', NULL) - 43
                                ELSE aws_sqlserver_ext.get_full_year(SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, -1), '', 29)
                             END;
            END IF;

            SET v_raw_year = aws_sqlserver_ext.get_full_year(SUBSTRING(v_year, 3, 2), '14', NULL); -- 14th century (Hijri)
            SET v_resmask_cnt = 10;
        END IF;
    
        IF (v_resmask_cnt NOT IN (1, 2, 3, 9, 10))
        THEN
            SET v_year = CASE -- four-digit year
                            WHEN v_culture IN ('TH-TH', 'TH_TH') THEN CONVERT(v_raw_year, UNSIGNED) - 543
                            ELSE v_raw_year
                         END;
        END IF;

        -- Hijri calendar correction
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA')) -- Arabic (Saudi Arabia)
        THEN
            IF (v_day > 30 OR -- max Hijri day is 30
                (v_resmask_cnt NOT IN (1, 2, 3, 9, 10) AND v_year NOT BETWEEN 1318 AND 1501) OR
                (v_resmask_cnt IN (1, 2, 3) AND CONVERT(v_raw_year, UNSIGNED) NOT BETWEEN 1318 AND 1501))
            THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            END IF;

            -- Calculating Hijri date and converting it back to Gregorian
            SET v_hijridate = DATE_SUB(aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year), INTERVAL 1 DAY);

            SET v_day = DAY(v_hijridate);
            SET v_month = MONTH(v_hijridate);
            SET v_year = YEAR(v_hijridate);
        END IF;

    ELSEIF (v_datetimestring REGEXP v_defmask11) -- 03.12 (03.12 => 03.12.2018)
    THEN
        IF (v_date_format = 'DMY' OR
            v_culture IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
        THEN -- (d/dd) (m/mm)
            SET v_day = SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, 1);
            SET v_month = SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, -1);
        ELSE -- (m/mm) (d/dd)
            SET v_day = SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, -1);
            SET v_month = SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, 1);
        END IF;

        -- Hijri calendar correction
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA')) -- Arabic (Saudi Arabia)
        THEN
            IF (v_day > 30 OR -- max Hijri day is 30
                v_month > 12)
            THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            END IF;

            -- Calculating Hijri date and converting it back to Gregorian
            SET v_raw_year = YEAR(aws_sqlserver_ext.conv_greg_to_hijri(DAY(DATE_ADD(CURRENT_DATE, INTERVAL 1 DAY)),
                                                                       MONTH(DATE_ADD(CURRENT_DATE, INTERVAL 1 DAY)),
                                                                       YEAR(DATE_ADD(CURRENT_DATE, INTERVAL 1 DAY))));
            SET v_hijridate = DATE_SUB(aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year), INTERVAL 1 DAY);

            SET v_day = DAY(v_hijridate),
                v_month = MONTH(v_hijridate),
                v_year = YEAR(v_hijridate);
        ELSE
            SET v_year = YEAR(CURRENT_DATE);
        END IF;

    ELSEIF (v_datetimestring REGEXP v_defmask12) -- 03.05.17 (3.5.17 => March 5 2017)
    THEN
        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN -- (d/dd) (m/mm) (y/yy)
            SET v_day = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 1);
            SET v_month = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 2);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 3);

        ELSEIF (v_date_format = 'YMD')
        THEN -- (y/yy) (m/mm) (d/dd)
            SET v_day = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 3);
            SET v_month = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 2);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 1);

        ELSE -- (m/mm) (d/dd) (y/yy)
            SET v_day = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 2);
            SET v_month = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 1);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 3);
        END IF;

        -- Hijri calendar correction
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA')) -- Arabic (Saudi Arabia)
        THEN
            IF (v_day > 30 OR -- max Hijri day is 30
                v_month > 12)
            THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            END IF;

            -- Calculating Hijri date and converting it back to Gregorian
            SET v_raw_year = aws_sqlserver_ext.get_full_year(v_raw_year, '14', NULL); -- 14th century (Hijri)
            SET v_hijridate = DATE_SUB(aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year), INTERVAL 1 DAY);

            SET v_day = DAY(v_hijridate),
                v_month = MONTH(v_hijridate),
                v_year = YEAR(v_hijridate);

        ELSEIF (v_culture IN ('TH-TH', 'TH_TH')) THEN
            SET v_year = aws_sqlserver_ext.get_full_year(v_raw_year, '', NULL) - 43;
        ELSE
            SET v_year = aws_sqlserver_ext.get_full_year(v_raw_year, '', 29);
        END IF;
    
    ELSEIF (v_datetimestring REGEXP v_defmask13) -- 2017.03.05 (yyy/yyyy m/mm d/dd)
    THEN
        SET v_day = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 3);
        SET v_month = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 2);
        SET v_year = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 1);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_datetimestring REGEXP v_defmask14) -- 09.11.2018 (x/xx x/xx yyy/yyyy)
    THEN
        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN -- (d/dd) (m/mm)
            SET v_day = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 1);
            SET v_month = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 2);
        ELSE -- (m/mm) (d/dd)
            SET v_day = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 2);
            SET v_month = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 1);
        END IF;

        SET v_year = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 3);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_datetimestring REGEXP v_defmask15) -- 09.2018.11 (m/mm yyy/yyyy d/dd)
    THEN
        SET v_day = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 3);
        SET v_month = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 1);
        SET v_year = aws_sqlserver_ext.split_part(v_datetimestring, v_datepart_sep, 2);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_datetimestring REGEXP v_defmask16) -- 2017 11 (yyy/yyyy m/mm)
    THEN
        SET v_day = 1;
        SET v_month = SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, -1);
        SET v_year = SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, 1);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_datetimestring REGEXP v_defmask17) -- 11 2017 (m/mm yyy/yyyy)
    THEN
        SET v_day = 1;
        SET v_month = SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, 1);
        SET v_year = SUBSTRING_INDEX(v_datetimestring, v_datepart_sep, -1);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_datetimestring REGEXP v_hhmmssfs_mask_regexp) -- HH:mi:ss(./:)ms
    THEN
        SET v_timestring = v_datetimestring;
        SET v_day = DAY(CURRENT_DATE),
            v_month = MONTH(CURRENT_DATE),
            v_year = YEAR(CURRENT_DATE);
    ELSE
        -- Conversion failed
        SIGNAL conversion_failed;
    END IF;

    -- Checking time part (if exists)
    IF (CHAR_LENGTH(v_timestring) > 0 AND v_timestring NOT REGEXP v_ampm_regexp)
    THEN
        -- Cleaning time part ("..03:..45:...55.789.." => "03:45:55.789")
        SET v_timestring = aws_sqlserver_ext.regexp_replace(v_timestring, '[[:space:],]', '', 1, 0, 'i');
        SET v_timestring = aws_sqlserver_ext.regexp_replace(v_timestring, ':\.+', '_', 1, 0, 'i');
        SET v_timestring = TRIM(BOTH '.' FROM REPLACE(v_timestring, '_', ':'));

        SET v_hours = COALESCE(SUBSTRING_INDEX(v_timestring, ':', 1), 0); -- hours

        -- Adjusting hour(s) by AM|PM day part mark
        IF ((v_daypart = 'AM' AND v_hours NOT BETWEEN 0 AND 12) OR
            (v_daypart = 'PM' AND v_hours NOT BETWEEN 1 AND 23))
        THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        ELSEIF (v_daypart = 'PM' AND v_hours < 12) THEN
            SET v_hours = v_hours + 12;
        ELSEIF (v_daypart = 'AM' AND v_hours = 12) THEN
            SET v_hours = v_hours - 12;
        END IF;

        SET v_minutes = COALESCE(NULLIF(aws_sqlserver_ext.split_part(v_timestring, ':', 2), ''), 0); -- minutes
        SET v_seconds = COALESCE(NULLIF(aws_sqlserver_ext.split_part(v_timestring, ':', 3), ''), 0); -- seconds

        IF (v_seconds REGEXP '\.') THEN
            SET v_fseconds = LEFT(SUBSTRING_INDEX(v_seconds, '.', -1), 6); -- fractional seconds
            SET v_seconds = SUBSTRING_INDEX(v_seconds, '.', 1); -- seconds
        END IF;
    ELSEIF (v_daypart = 'PM')
    THEN
        SET v_hours = 12;
    END IF;

    -- Construct date from parts according to datetime type
    IF (v_resdatatype IN ('DATETIME', 'SMALLDATETIME'))
    THEN
        IF (CHAR_LENGTH(v_fseconds) > 3) THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        END IF;

        SET v_fseconds = CONVERT(RPAD(v_fseconds, 3, '0'), UNSIGNED);
        -- Constructing datetime object from the separate date and time parts
        SET v_res_datetime = aws_sqlserver_ext.datetimefromparts(v_year, v_month, v_day, -- date part
                                                                 v_hours, v_minutes, v_seconds, v_fseconds); -- time part
        IF (v_resdatatype = 'SMALLDATETIME')
        THEN -- Rounding to minutes
            IF (SECOND(v_res_datetime) >= 30) THEN
                SET v_res_datetime = DATE_ADD(v_res_datetime, INTERVAL 1 MINUTE);
            END IF;

            SET v_res_datetime = STR_TO_DATE(DATE_FORMAT(v_res_datetime, '%d.%m.%Y.%H.%i'), '%d.%m.%Y.%H.%i');
        END IF;
    ELSEIF (v_resdatatype = 'DATETIME2')
    THEN
        -- Rounding fractional seconds to the specified scale (DATETIME(4) => 4)
        SET v_fseconds = aws_sqlserver_ext.get_microsecs_from_fractsecs(v_fseconds, v_scale);
        -- Constructing datetime object from the separate date and time parts
        SET v_res_datetime = STR_TO_DATE(CONCAT_WS('.', v_day, v_month, v_year, -- date part
                                                       v_hours, v_minutes, v_seconds, v_fseconds), -- time part
                                        '%d.%m.%Y.%H.%i.%s.%f'); -- mask
    END IF;

    /* Checking that declared weekday name
       corresponds with the parsed date */
    IF (NOT ISNULL(v_weekdayname)) THEN
        -- Translating weekday name into a weekday number
        SET v_weekdaynum = aws_sqlserver_ext.get_weekdaynum_by_name(v_weekdayname, v_lang_metadata_json);

        IF(v_weekdaynum <> IF(DAYOFWEEK(v_res_datetime) = 1, 7, DAYOFWEEK(v_res_datetime) - 1)) THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        END IF;
    END IF;

    RETURN v_res_datetime;
END]]></complex-attribute>
                        <category _I_D="c259b905-bcac-4fcf-aca6-a5e287063e41" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b5c0f665-5928-4024-9c5f-4739b3a93844" name="parse_to_time" context="parse_to_time" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function parses the source string and translates it into the TIME value, according to specified culture (conversion mask).]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_scale INTEGER;
    DECLARE v_timestring NVARCHAR(4000);
    DECLARE v_resdatatype VARCHAR(100);
    DECLARE v_datatype VARCHAR(100) DEFAULT UPPER(TRIM(p_datatype));
    DECLARE v_srctimestring NVARCHAR(4000) DEFAULT UPPER(TRIM(CONVERT(p_srctimestring USING utf8)));
    DECLARE v_culture VARCHAR(50) DEFAULT COALESCE(NULLIF(UPPER(TRIM(p_culture)), ''), 'EN-US');
    DECLARE v_compmonth_regexp NVARCHAR(2000);
    DECLARE v_compday_regexp NVARCHAR(1000);
    DECLARE v_weekdayname NVARCHAR(50);
    DECLARE v_arr_element NVARCHAR(50);
    DECLARE v_daypart NVARCHAR(50);
    DECLARE v_index SMALLINT DEFAULT 0;
    DECLARE v_count INTEGER DEFAULT 0;
    DECLARE v_lang_metadata_json JSON;
    DECLARE v_compday_json_array JSON;
    DECLARE v_date_format VARCHAR(20);
    DECLARE v_reg_mask NVARCHAR(100);
    DECLARE v_weekdaynum SMALLINT;

    -- Date and time components declaration
    DECLARE v_res_time TIME(6);
    DECLARE v_res_datetime DATETIME(6);
    DECLARE v_day, v_month, v_year INTEGER;
    DECLARE v_hours, v_minutes, v_fseconds INTEGER;
    DECLARE v_resmask_cnt SMALLINT DEFAULT 0;
    DECLARE v_seconds VARCHAR(500);

    /* MS SQL Server session variables emulation:
       - LANGUAGE (SET LANGUAGE ENGLISH)
       - DATE_FORMAT (SET DATEFORMAT MDY) */
    DECLARE CONVERSION_LANG VARCHAR(50) DEFAULT ''; -- Override using of the "p_culture" parameter value for parsing of months and days names
    DECLARE DATE_FORMAT VARCHAR(50) DEFAULT ''; -- Override using of the default date format (linked with language) - (MDY|YDM|DMY|DYM)

    DECLARE v_daypart_json JSON DEFAULT JSON_ARRAY('AM', 'PM');
    DECLARE v_weekdayampm_start_regexp VARCHAR(50) DEFAULT '(^|[[:digit:][:space:]\.,])';
    DECLARE v_weekdayampm_end_regexp VARCHAR(50) DEFAULT '([[:digit:][:space:]\.,]|$)';
    DECLARE v_anno_domini_regexp VARCHAR(20) DEFAULT '(AD|A\.D\.)';
    DECLARE v_ampm_regexp VARCHAR(10) DEFAULT '([AP]M)';
    DECLARE v_time_masksep_regexp VARCHAR(20) DEFAULT '([[:space:]]|\.|,)*';
    DECLARE v_timeunit_regexp VARCHAR(50) DEFAULT '[[:space:]]*[[:digit:]]{1,2}[[:space:]]*'; -- Time unit regexp
    DECLARE v_datatype_mask VARCHAR(120) DEFAULT '^[[:space:]]*TIME[[:space:]]*\([[:space:]]*([[:digit:]]+)[[:space:]]*\)[[:space:]]*$'; -- TIME(4)
    DECLARE v_datatype_regexp VARCHAR(120) DEFAULT '^[[:space:]]*(TIME)[[:space:]]*$'; -- TIME
    DECLARE v_hijridate, v_testdate DATE;
    DECLARE v_datepart_sep CHAR(1) DEFAULT '_';
    DECLARE v_monthname, v_raw_year NVARCHAR(100);
    DECLARE v_fullyear_regexp VARCHAR(40) DEFAULT '[[:digit:]]{3,4}'; -- yyy/yyyy
    DECLARE v_compyear_regexp VARCHAR(40) DEFAULT '[[:digit:]]{1,4}'; -- y/yy/yyy/yyyy
    DECLARE v_daymm_regexp VARCHAR(40) DEFAULT '[[:digit:]]{1,2}'; -- d/dd(m/mm)
    DECLARE v_hhmmssfs_part_regexp NVARCHAR(4000) DEFAULT
        CONCAT('((', v_timeunit_regexp, v_ampm_regexp, ')|', -- 03AM
               '(', v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, '', v_time_masksep_regexp, v_ampm_regexp, '?)|', -- (AM)?03:(AM)?24(AM)?
               '(', v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, '', v_time_masksep_regexp, v_ampm_regexp, '?)|', -- (AM)?03:(AM)?24(AM)?:36(AM)?
               '(', v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, v_timeunit_regexp, ':', v_time_masksep_regexp,
               v_ampm_regexp, '?', v_time_masksep_regexp, '[[:space:]]*[[:digit:]]{1,2}\.[[:digit:]]+', v_time_masksep_regexp, v_ampm_regexp, '?))'); -- (AM)?03:(AM)?24(AM)?:36.346(AM)?
    DECLARE v_hhmmssfs_mask_regexp NVARCHAR(4000) DEFAULT CONCAT('^', v_time_masksep_regexp, '(', v_hhmmssfs_part_regexp, ')', v_time_masksep_regexp, '$'); -- hh24:mi:ss.fs(AM|PM)
    DECLARE v_defmask1 NVARCHAR(500) DEFAULT CONCAT('^($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_compyear_regexp, '$'); -- mon/Month d/dd y/yy/yyy/yyyy
    DECLARE v_defmask2 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_compyear_regexp, '$'); -- d/dd mon/Month y/yy/yyy/yyyy
    DECLARE v_defmask3 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_compyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)$'); -- d/dd y/yy/yyy/yyyy mon/Month
    DECLARE v_defmask4 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- yyy/yyyy mon/Month d/dd
    DECLARE v_defmask5 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)$'); -- yyy/yyyy d/dd mon/Month
    DECLARE v_defmask6 NVARCHAR(500) DEFAULT CONCAT('^($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- mon/Month yyy/yyyy d/dd
    DECLARE v_defmask7 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)$'); -- yyy/yyyy mon/Month
    DECLARE v_defmask8 NVARCHAR(500) DEFAULT CONCAT('^($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '$'); -- mon/Month yyy/yyyy
    DECLARE v_defmask9 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*($comp_month$)$'); -- d/dd mon/Month
    DECLARE v_defmask10 NVARCHAR(500) DEFAULT CONCAT('^($comp_month$)[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- mon/Month d/dd
    DECLARE v_defmask11 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- x/xx x/xx
    DECLARE v_defmask12 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- x/xx x/xx x/xx
    DECLARE v_defmask13 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- yyy/yyyy m/mm d/dd
    DECLARE v_defmask14 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '$'); -- x/xx x/xx yyy/yyyy
    DECLARE v_defmask15 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- m/mm yyy/yyyy d/dd
    DECLARE v_defmask16 NVARCHAR(500) DEFAULT CONCAT('^', v_fullyear_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_daymm_regexp, '$'); -- yyy/yyyy m/mm
    DECLARE v_defmask17 NVARCHAR(500) DEFAULT CONCAT('^', v_daymm_regexp, '[[:space:]]*', v_datepart_sep, '[[:space:]]*', v_fullyear_regexp, '$'); -- m/mm yyy/yyyy

    -- Declaration of error conditions and handlers
    DECLARE conversion_failed CONDITION FOR SQLSTATE '45520';
    DECLARE invalid_dtype_scale CONDITION FOR SQLSTATE '45521';
    DECLARE incorrect_datatype CONDITION FOR SQLSTATE '45522';
    DECLARE v_error_message NVARCHAR(500);

    -- Conversion failed
    DECLARE EXIT HANDLER FOR conversion_failed
    BEGIN
        SET v_error_message = CONCAT('Error converting string value '', COALESCE(p_srctimestring, 'NULL'),
                                     '' into data type DATE using culture '', COALESCE(p_culture, 'NULL'), ''.');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Specified TIME scale is not in range 0..7
    DECLARE EXIT HANDLER FOR invalid_dtype_scale
    BEGIN
        SET v_error_message = CONCAT('Specified scale ', v_scale, ' is invalid.');

        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Incorrect data type param value
    DECLARE EXIT HANDLER FOR incorrect_datatype
    BEGIN
        SET v_error_message = 'Data type should be 'TIME' or 'TIME(n)'';

        SIGNAL incorrect_datatype
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- STR_TO_DATE function supplied with incorrect date parts
    DECLARE EXIT HANDLER FOR 1411
    BEGIN
        SET v_error_message = CONCAT('Error converting string value '', COALESCE(p_srctimestring, 'NULL'),
                                     '' into data type DATE using culture '', COALESCE(p_culture, 'NULL'), ''.');
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Constructed date is a Leap-year date (e.g. "29.02.2017")
    DECLARE EXIT HANDLER FOR 1292
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Conversion failed when converting date and time from character string.';
    END;

    -- Parse supplied datatype expression - extract data type and scale
    IF (v_datatype REGEXP v_datatype_mask) THEN
        -- Extract scale data from datatype expression
        SET v_scale = CONVERT(TRIM(SUBSTRING(v_datatype,
                                   INSTR(v_datatype, '(') + 1,
                                   (INSTR(v_datatype, ')') - INSTR(v_datatype, '(') - 1))), UNSIGNED);
        IF (v_scale NOT BETWEEN 0 AND 7) THEN -- 0 => 6(7)
            SIGNAL invalid_dtype_scale;
        END IF;

        SET v_scale = IF(v_scale = 7, 6, v_scale);
    ELSEIF (v_datatype REGEXP v_datatype_regexp) THEN
        SET v_scale = 6; -- Default MS SQL TIME scale is 7, 6 - for MySQL
    ELSE
        -- Incorrect target datatype
        SIGNAL incorrect_datatype;
    END IF;

    -- Getting language metadata JSON by lang name (specified by CONVERSION_LANG constant)
    SET v_lang_metadata_json = aws_sqlserver_ext.get_lang_metadata_json(COALESCE(NULLIF(CONVERSION_LANG, ''), p_culture));

    -- Determining which DATE_FORMAT value to use
    SET v_date_format = COALESCE(NULLIF(UPPER(TRIM(DATE_FORMAT)), ''), JSON_UNQUOTE(JSON_EXTRACT(v_lang_metadata_json, '$.date_format')));

    -- Replacing arabic day half markers with AM|PM
    SET v_srctimestring = REPLACE(REPLACE(v_srctimestring, N'', 'AM'), N'', 'PM');

    -- Determining the day half marker (AM or PM)
    REPEAT
        SET v_arr_element = JSON_UNQUOTE(JSON_EXTRACT(v_daypart_json, CONCAT('$[', v_index, ']')));

        IF (v_srctimestring REGEXP v_arr_element)
        THEN
            SET v_daypart = v_arr_element;
            SET v_count = v_count + aws_sqlserver_ext.regexp_count(v_srctimestring, v_arr_element, 1, 'i');
        END IF;

        SET v_index = v_index + 1;
        UNTIL (v_index = JSON_LENGTH(v_daypart_json) OR v_count > 1)
    END REPEAT;

    /* Checking that there is only one
       day half marker in the source string */
    IF (v_count > 1) THEN
        -- Conversion failed
        SIGNAL conversion_failed;
    ELSEIF (v_count = 1) THEN
        -- Removing AM|PM day half marker from the source string
        SET v_srctimestring = aws_sqlserver_ext.regexp_replace(v_srctimestring, v_ampm_regexp, '', 1, 0, 'c');
    END IF;
    SET v_count = 0, v_index = 0;

    -- Checking for "Anno Domini" (AD, A.D.) abbreviation
    IF (v_srctimestring REGEXP CONCAT(v_weekdayampm_start_regexp, v_anno_domini_regexp, v_weekdayampm_end_regexp))
    THEN
        IF (v_culture NOT REGEXP 'EN[-_]US|DA[-_]DK|SV[-_]SE|EN[-_]GB|HI[-_]IS') THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        END IF;

        -- Removing "Anno Domini" (AD, A.D.) abbreviation
        SET v_srctimestring = REPLACE(REPLACE(v_srctimestring, 'AD', ''), 'A.D.', '');
    END IF;

    SET v_compday_regexp = aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.days_names'), JSON_ARRAY('')), '|');

    SET v_compday_regexp = CONCAT_WS('|', v_compday_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.days_shortnames'), JSON_ARRAY('')), '|'), ''));

    -- Composing complete days names regexp
    SET v_compday_regexp = UPPER(CONCAT_WS('|', v_compday_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.days_extrashortnames'), JSON_ARRAY('')), '|'), '')));

    SET v_compday_json_array = aws_sqlserver_ext.string_to_json_array(v_compday_regexp, '|', TRUE);

    -- Determining the weekdays names array, extracted from the source string
    IF (v_srctimestring REGEXP v_compday_regexp)
    THEN
        REPEAT
            SET v_arr_element = COALESCE(JSON_UNQUOTE(JSON_EXTRACT(v_compday_json_array, CONCAT('$[', v_index, ']'))), '');
            SET v_reg_mask = IF(CHAR_LENGTH(v_arr_element) > 0, CONCAT(UPPER(v_arr_element), '([[:space:][:digit:].,/-]|$)'), NULL);

            IF (v_srctimestring REGEXP v_reg_mask)
            THEN
                SET v_weekdayname = v_arr_element;
                SET v_count = v_count + aws_sqlserver_ext.regexp_count(v_srctimestring, v_reg_mask, 1, 'i');
            END IF;

            SET v_index = v_index + 1;
            UNTIL (v_index = JSON_LENGTH(v_compday_json_array))
        END REPEAT;
    END IF;

    /* Checking that there is only one
       weekday name in the source string */
    IF (v_count > 1) THEN
        -- Conversion failed
        SIGNAL conversion_failed;
    ELSEIF (v_count = 1) THEN
        -- Removing weekday name from the source string
        SET v_srctimestring = REPLACE(v_srctimestring, UPPER(v_weekdayname), '');
    END IF;

    SET v_compmonth_regexp = aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_names'), JSON_ARRAY('')), '|');

    SET v_compmonth_regexp = CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_extranames'), JSON_ARRAY('')), '|'), ''));

    SET v_compmonth_regexp = CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_shortnames'), JSON_ARRAY('')), '|'), ''));

    -- Composing complete months names regexp ("Jan|Feb|Mar|Apr|May|...")
    SET v_compmonth_regexp = UPPER(CONCAT_WS('|', v_compmonth_regexp,
        NULLIF(aws_sqlserver_ext.json_array_to_string(COALESCE(JSON_EXTRACT(v_lang_metadata_json, '$.months_extrashortnames'), JSON_ARRAY('')), '|'), '')));

    IF (v_srctimestring REGEXP v_hhmmssfs_part_regexp AND
        (NOT v_srctimestring REGEXP v_hhmmssfs_mask_regexp))
    THEN
        -- Separate time part (if coupled with the date data)
        SET v_timestring = aws_sqlserver_ext.regexp_substr(v_srctimestring, v_hhmmssfs_part_regexp, 1, 1, 'i');
        SET v_srctimestring = REPLACE(v_srctimestring, v_timestring, '');
    END IF;

    -- Performing date string purification (removing meaningless commas, etc.)
    SET v_srctimestring = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(v_srctimestring, ',', v_datepart_sep), '/', v_datepart_sep), '-', v_datepart_sep), ' ', v_datepart_sep), '.', v_datepart_sep); -- [[:space:]\\.,/=] => "_"
    SET v_srctimestring = aws_sqlserver_ext.regexp_replace(v_srctimestring, CONCAT(v_datepart_sep, '+'), v_datepart_sep, 1, 0, 'i'); -- "_______" => "_"
    SET v_srctimestring = TRIM(TRAILING v_datepart_sep FROM TRIM(LEADING v_datepart_sep FROM v_srctimestring)); -- "_DEC_14_2010_" => "DEC_14_2010"

    -- Replacing "$comp_month$" marker with composed months names regexp
    SET v_defmask1 = REPLACE(v_defmask1, '$comp_month$', v_compmonth_regexp);
    SET v_defmask2 = REPLACE(v_defmask2, '$comp_month$', v_compmonth_regexp);
    SET v_defmask3 = REPLACE(v_defmask3, '$comp_month$', v_compmonth_regexp);
    SET v_defmask4 = REPLACE(v_defmask4, '$comp_month$', v_compmonth_regexp);
    SET v_defmask5 = REPLACE(v_defmask5, '$comp_month$', v_compmonth_regexp);
    SET v_defmask6 = REPLACE(v_defmask6, '$comp_month$', v_compmonth_regexp);
    SET v_defmask7 = REPLACE(v_defmask7, '$comp_month$', v_compmonth_regexp);
    SET v_defmask8 = REPLACE(v_defmask8, '$comp_month$', v_compmonth_regexp);
    SET v_defmask9 = REPLACE(v_defmask9, '$comp_month$', v_compmonth_regexp);
    SET v_defmask10 = REPLACE(v_defmask10, '$comp_month$', v_compmonth_regexp);

    -- Match dates like "Feb 02 2017" etc. (see below desc.)
    IF ((v_srctimestring REGEXP v_defmask1) OR -- Feb 02 17(2017) (mon/Month d/dd y/yy/yyy/yyyy)
        (v_srctimestring REGEXP v_defmask2) OR -- 02 Feb 17(2017) (d/dd mon/Month y/yy/yyy/yyyy)
        (v_srctimestring REGEXP v_defmask3) OR -- 02 17(2017) Feb (d/dd y/yy/yyy/yyyy mon/Month)
        (v_srctimestring REGEXP v_defmask4) OR -- 2017 Feb 02 (yyy/yyyy mon/Month d/dd)
        (v_srctimestring REGEXP v_defmask5) OR -- 2017 02 Feb (yyy/yyyy d/dd mon/Month)
        (v_srctimestring REGEXP v_defmask6) OR -- Feb 2017 02 (mon/Month yyy/yyyy d/dd)
        (v_srctimestring REGEXP v_defmask7) OR -- 2017 Feb (yyy/yyyy mon/Month)
        (v_srctimestring REGEXP v_defmask8) OR -- Feb 2017 (mon/Month yyy/yyyy)
        (v_srctimestring REGEXP v_defmask9) OR -- 19 Oct (d/dd mon/Month)
        (v_srctimestring REGEXP v_defmask10)) -- Oct 19 (mon/Month d/dd)
    THEN
        -- Extract month part from supplied expression ("Feb" from "Feb02 2017")
        SET v_monthname = aws_sqlserver_ext.regexp_substr(v_srctimestring, CONCAT('(', v_compmonth_regexp, ')'), 1, 1, 'i');
        SET v_month = aws_sqlserver_ext.get_monthnum_by_name(v_monthname, v_lang_metadata_json);

        IF (v_srctimestring REGEXP v_defmask1) -- Feb 02 17(2017) (mon/Month d/dd y/yy/yyy/yyyy)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 2);
            SET v_year = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 3);
            SET v_year = CASE
                            WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_year, '', NULL) - 543
                            ELSE aws_sqlserver_ext.get_full_year(v_year, '', NULL)
                         END;
            SET v_raw_year = v_year;
            SET v_resmask_cnt = 1;

        ELSEIF (v_srctimestring REGEXP v_defmask2) -- 02 Feb 17(2017) (d/dd mon/Month y/yy/yyy/yyyy)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 1);
            SET v_year = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 3);
            SET v_year = CASE
                            WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_year, '', NULL) - 543
                            ELSE aws_sqlserver_ext.get_full_year(v_year, '', NULL)
                         END;
            SET v_raw_year = v_year;
            SET v_resmask_cnt = 2;

        ELSEIF (v_srctimestring REGEXP v_defmask3) -- 02 17(2017) Feb (d/dd y/yy/yyy/yyyy mon/Month)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 1);
            SET v_year = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 2);
            SET v_year = CASE
                            WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(v_year, '', NULL) - 543
                            ELSE aws_sqlserver_ext.get_full_year(v_year, '', NULL)
                         END;
            SET v_raw_year = v_year;
            SET v_resmask_cnt = 3;

        ELSEIF (v_srctimestring REGEXP v_defmask4) -- 2017 Feb 02 (yyy/yyyy mon/Month d/dd)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 3);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 1);
            SET v_resmask_cnt = 4;

        ELSEIF (v_srctimestring REGEXP v_defmask5) -- 2017 02 Feb (yyy/yyyy d/dd mon/Month)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 2);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 1);
            SET v_resmask_cnt = 5;

        ELSEIF (v_srctimestring REGEXP v_defmask6) -- Feb 2017 02 (mon/Month yyy/yyyy d/dd)
        THEN
            SET v_day = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 3);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 2);
            SET v_resmask_cnt = 6;

        ELSEIF (v_srctimestring REGEXP v_defmask7) -- 2017 Feb (yyy/yyyy mon/Month)
        THEN
            SET v_day = 1;
            SET v_raw_year = SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, 1);
            SET v_resmask_cnt = 7;

        ELSEIF (v_srctimestring REGEXP v_defmask8) -- Feb 2017 (mon/Month yyy/yyyy)
        THEN
            SET v_day = 1;
            SET v_raw_year = SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, -1);
            SET v_resmask_cnt = 8;

        ELSEIF (v_srctimestring REGEXP v_defmask9) -- 19 Oct (d/dd mon/Month)
        THEN
            IF (v_month = 3 AND v_culture IN ('IT-IT', 'IT_IT'))
            THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            END IF;

            IF (v_date_format = 'YMD' AND v_culture NOT IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
            THEN
                SET v_day = 1;
                SET v_year = aws_sqlserver_ext.get_full_year(SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, 1), '', 29);
            ELSE
                SET v_day = SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, 1);
                SET v_year = YEAR(CURRENT_DATE);
            END IF;

            SET v_raw_year = YEAR(aws_sqlserver_ext.conv_greg_to_hijri(DAY(CURRENT_DATE), MONTH(CURRENT_DATE), YEAR(CURRENT_DATE)));
            SET v_resmask_cnt = 9;

        ELSEIF (v_srctimestring REGEXP v_defmask10) -- Oct 19 (mon/Month d/dd)
        THEN
            IF (v_date_format IN ('YMD', 'MDY') AND v_culture NOT IN ('SV-SE', 'SV_SE'))
            THEN
                SET v_day = SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, -1);
                SET v_year = YEAR(CURRENT_DATE);
            ELSE
                SET v_day = 1;
                SET v_year = CASE
                                WHEN v_culture IN ('TH-TH', 'TH_TH') THEN aws_sqlserver_ext.get_full_year(SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, -1), '', NULL) - 43
                                ELSE aws_sqlserver_ext.get_full_year(SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, -1), '', 29)
                             END;
            END IF;

            SET v_raw_year = aws_sqlserver_ext.get_full_year(SUBSTRING(v_year, 3, 2), '14', NULL); -- 14th century (Hijri)
            SET v_resmask_cnt = 10;
        END IF;
    
        IF (v_resmask_cnt NOT IN (1, 2, 3, 9, 10))
        THEN
            SET v_year = CASE -- four-digit year
                            WHEN v_culture IN ('TH-TH', 'TH_TH') THEN CONVERT(v_raw_year, UNSIGNED) - 543
                            ELSE v_raw_year
                         END;
        END IF;

        -- Hijri calendar correction
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA')) -- Arabic (Saudi Arabia)
        THEN
            IF (v_day > 30 OR -- max Hijri day is 30
                (v_resmask_cnt NOT IN (1, 2, 3, 9, 10) AND v_year NOT BETWEEN 1318 AND 1501) OR
                (v_resmask_cnt IN (1, 2, 3) AND CONVERT(v_raw_year, UNSIGNED) NOT BETWEEN 1318 AND 1501))
            THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            END IF;

            -- Calculating Hijri date and converting it back to Gregorian
            SET v_hijridate = DATE_SUB(aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year), INTERVAL 1 DAY);

            SET v_day = DAY(v_hijridate);
            SET v_month = MONTH(v_hijridate);
            SET v_year = YEAR(v_hijridate);
        END IF;

    ELSEIF (v_srctimestring REGEXP v_defmask11) -- 03.12 (03.12 => 03.12.2018)
    THEN
        IF (v_date_format = 'DMY' OR
            v_culture IN ('SV-SE', 'SV_SE', 'LV-LV', 'LV_LV'))
        THEN -- (d/dd) (m/mm)
            SET v_day = SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, 1);
            SET v_month = SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, -1);
        ELSE -- (m/mm) (d/dd)
            SET v_day = SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, -1);
            SET v_month = SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, 1);
        END IF;

        -- Hijri calendar correction
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA')) -- Arabic (Saudi Arabia)
        THEN
            IF (v_day > 30 OR -- max Hijri day is 30
                v_month > 12)
            THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            END IF;

            -- Calculating Hijri date and converting it back to Gregorian
            SET v_raw_year = YEAR(aws_sqlserver_ext.conv_greg_to_hijri(DAY(DATE_ADD(CURRENT_DATE, INTERVAL 1 DAY)),
                                                                       MONTH(DATE_ADD(CURRENT_DATE, INTERVAL 1 DAY)),
                                                                       YEAR(DATE_ADD(CURRENT_DATE, INTERVAL 1 DAY))));
            SET v_hijridate = DATE_SUB(aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year), INTERVAL 1 DAY);

            SET v_day = DAY(v_hijridate),
                v_month = MONTH(v_hijridate),
                v_year = YEAR(v_hijridate);
        ELSE
            SET v_year = YEAR(CURRENT_DATE);
        END IF;

    ELSEIF (v_srctimestring REGEXP v_defmask12) -- 03.05.17 (3.5.17 => March 5 2017)
    THEN
        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN -- (d/dd) (m/mm) (y/yy)
            SET v_day = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 1);
            SET v_month = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 2);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 3);

        ELSEIF (v_date_format = 'YMD')
        THEN -- (y/yy) (m/mm) (d/dd)
            SET v_day = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 3);
            SET v_month = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 2);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 1);

        ELSE -- (m/mm) (d/dd) (y/yy)
            SET v_day = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 2);
            SET v_month = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 1);
            SET v_raw_year = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 3);
        END IF;

        -- Hijri calendar correction
        IF (v_culture IN ('AR', 'AR-SA', 'AR_SA')) -- Arabic (Saudi Arabia)
        THEN
            IF (v_day > 30 OR -- max Hijri day is 30
                v_month > 12)
            THEN
                -- Conversion failed
                SIGNAL conversion_failed;
            END IF;

            -- Calculating Hijri date and converting it back to Gregorian
            SET v_raw_year = aws_sqlserver_ext.get_full_year(v_raw_year, '14', NULL); -- 14th century (Hijri)
            SET v_hijridate = DATE_SUB(aws_sqlserver_ext.conv_hijri_to_greg(v_day, v_month, v_raw_year), INTERVAL 1 DAY);

            SET v_day = DAY(v_hijridate),
                v_month = MONTH(v_hijridate),
                v_year = YEAR(v_hijridate);

        ELSEIF (v_culture IN ('TH-TH', 'TH_TH')) THEN
            SET v_year = aws_sqlserver_ext.get_full_year(v_raw_year, '', NULL) - 43;
        ELSE
            SET v_year = aws_sqlserver_ext.get_full_year(v_raw_year, '', 29);
        END IF;
    
    ELSEIF (v_srctimestring REGEXP v_defmask13) -- 2017.03.05 (yyy/yyyy m/mm d/dd)
    THEN
        SET v_day = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 3);
        SET v_month = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 2);
        SET v_year = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 1);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_srctimestring REGEXP v_defmask14) -- 09.11.2018 (x/xx x/xx yyy/yyyy)
    THEN
        IF (v_date_format = 'DMY' OR
            v_culture IN ('LV-LV', 'LV_LV'))
        THEN -- (d/dd) (m/mm)
            SET v_day = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 1);
            SET v_month = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 2);
        ELSE -- (m/mm) (d/dd)
            SET v_day = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 2);
            SET v_month = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 1);
        END IF;

        SET v_year = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 3);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_srctimestring REGEXP v_defmask15) -- 09.2018.11 (m/mm yyy/yyyy d/dd)
    THEN
        SET v_day = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 3);
        SET v_month = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 1);
        SET v_year = aws_sqlserver_ext.split_part(v_srctimestring, v_datepart_sep, 2);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_srctimestring REGEXP v_defmask16) -- 2017 11 (yyy/yyyy m/mm)
    THEN
        SET v_day = 1;
        SET v_month = SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, -1);
        SET v_year = SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, 1);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_srctimestring REGEXP v_defmask17) -- 11 2017 (m/mm yyy/yyyy)
    THEN
        SET v_day = 1;
        SET v_month = SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, 1);
        SET v_year = SUBSTRING_INDEX(v_srctimestring, v_datepart_sep, -1);
        SET v_year = IF(v_culture IN ('TH-TH', 'TH_TH'), v_year - 543, v_year);

    ELSEIF (v_srctimestring REGEXP v_hhmmssfs_mask_regexp) -- HH:mi:ss(./:)ms
    THEN
        SET v_timestring = v_srctimestring;
        SET v_day = DAY(CURRENT_DATE),
            v_month = MONTH(CURRENT_DATE),
            v_year = YEAR(CURRENT_DATE);
    ELSE
        -- Conversion failed
        SIGNAL conversion_failed;
    END IF;

    -- Checking time part (if exists)
    IF (CHAR_LENGTH(v_timestring) > 0 AND v_timestring NOT REGEXP v_ampm_regexp)
    THEN
        -- Cleaning time part ("..03:..45:...55.789.." => "03:45:55.789")
        SET v_timestring = aws_sqlserver_ext.regexp_replace(v_timestring, '[[:space:],]', '', 1, 0, 'i');
        SET v_timestring = aws_sqlserver_ext.regexp_replace(v_timestring, ':\.+', '_', 1, 0, 'i');
        SET v_timestring = TRIM(BOTH '.' FROM REPLACE(v_timestring, '_', ':'));

        SET v_hours = COALESCE(SUBSTRING_INDEX(v_timestring, ':', 1), 0); -- hours

        -- Adjusting hour(s) by AM|PM day part mark
        IF ((v_daypart = 'AM' AND v_hours NOT BETWEEN 0 AND 12) OR
            (v_daypart = 'PM' AND v_hours NOT BETWEEN 1 AND 23))
        THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        ELSEIF (v_daypart = 'PM' AND v_hours < 12) THEN
            SET v_hours = v_hours + 12;
        ELSEIF (v_daypart = 'AM' AND v_hours = 12) THEN
            SET v_hours = v_hours - 12;
        END IF;

        SET v_minutes = COALESCE(NULLIF(aws_sqlserver_ext.split_part(v_timestring, ':', 2), ''), 0); -- minutes
        SET v_seconds = COALESCE(NULLIF(aws_sqlserver_ext.split_part(v_timestring, ':', 3), ''), 0); -- seconds

        IF (v_seconds REGEXP '\.') THEN
            SET v_fseconds = LEFT(SUBSTRING_INDEX(v_seconds, '.', -1), 6); -- fractional seconds
            SET v_seconds = SUBSTRING_INDEX(v_seconds, '.', 1); -- seconds
        END IF;
    ELSEIF (v_daypart = 'PM')
    THEN
        SET v_hours = 12;
    END IF;

    -- Rounding fractional seconds to the specified scale (TIME(4) => 4)
    SET v_fseconds = aws_sqlserver_ext.get_microsecs_from_fractsecs(RPAD(v_fseconds, 9, '0'), v_scale);

    -- Constructing datetime object from the separate date and time parts
    SET v_res_datetime = STR_TO_DATE(CONCAT_WS('.', v_day, v_month, v_year, -- date part
                                                    v_hours, v_minutes, v_seconds, v_fseconds), -- time part
                                    '%d.%m.%Y.%H.%i.%s.%f'); -- mask

    /* Checking that declared weekday name
       corresponds with the parsed date */
    IF (NOT ISNULL(v_weekdayname)) THEN
        -- Translating weekday name into a weekday number
        SET v_weekdaynum = aws_sqlserver_ext.get_weekdaynum_by_name(v_weekdayname, v_lang_metadata_json);

        IF(v_weekdaynum <> IF(DAYOFWEEK(v_res_datetime) = 1, 7, DAYOFWEEK(v_res_datetime) - 1)) THEN
            -- Conversion failed
            SIGNAL conversion_failed;
        END IF;
    END IF;

    RETURN TIME(v_res_datetime);
END]]></complex-attribute>
                        <category _I_D="5e35d79c-7437-49c8-b1f7-b7624d04ee15" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="22c522d3-e275-4b54-a1ae-78c2d19e86b0" name="regexp_count" context="regexp_count" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function returns the number of occurrences of a substring in a source string by regular expression.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_index SMALLINT;
    DECLARE v_left_idx INTEGER DEFAULT -1;
    DECLARE v_regexp_count SMALLINT DEFAULT 0;
    DECLARE v_src_string NVARCHAR(4000);
    DECLARE v_src_substring NVARCHAR(4000);
    DECLARE v_regexp_pat NVARCHAR(2000) DEFAULT p_regexp_pat;
    DECLARE v_match_param VARCHAR(10) DEFAULT 'c';

    DECLARE v_begin_anchor NVARCHAR(10) DEFAULT ''; -- Beginning of the string anchor (^) substitute
    DECLARE v_end_anchor NVARCHAR(10) DEFAULT ''; -- End of the string anchor ($) substitute
    DECLARE v_error_message NVARCHAR(500);

    -- Declaration of error conditions and handlers
    DECLARE match_failed CONDITION FOR SQLSTATE '45520';
    DECLARE invalid_position CONDITION FOR SQLSTATE '45521';
    DECLARE invalid_match_param CONDITION FOR SQLSTATE '45522';

    -- Invalid position parameter
    DECLARE EXIT HANDLER FOR invalid_position
    BEGIN
        SET v_error_message = CONCAT('Argument '', TRIM(TRAILING '0' FROM p_position),
                                     '' is out of range. Should be greater than or equal to 1 (one)');
        SIGNAL match_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Invalid match parameter
    DECLARE EXIT HANDLER FOR invalid_match_param
    BEGIN
        SET v_error_message = CONCAT('Illegal "match_parameter" argument value '', p_match_param,
                                     ''. Must be one of the following: "i", "c", "n", "m", "x"');
        SIGNAL match_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Preparing match parameter value
    SET v_match_param = COALESCE(NULLIF(p_match_param, ''), v_match_param);

    -- Validating input parameters
    IF (ISNULL(p_src_string) OR ISNULL(p_regexp_pat))
    THEN
        RETURN NULL;
    ELSEIF (p_position <= 0) THEN
        -- Invalid position parameter
        SIGNAL invalid_position;
    ELSEIF (v_match_param NOT REGEXP  'i|c|n|m|x' COLLATE utf8_bin) THEN
        -- Invalid match parameter
        SIGNAL invalid_match_param;
    END IF;

    SET v_src_string = SUBSTRING(CONVERT(p_src_string USING utf8), COALESCE(FLOOR(p_position), 1));

    /* Replacing beginning (^) of the string anchor
       with user-defined substitute, if it's specified */
    IF (CHAR_LENGTH(v_begin_anchor) > 0)
    THEN
        SET v_regexp_pat = REPLACE(REPLACE(REPLACE(v_regexp_pat, '\^', '$nbos$'), '^', v_begin_anchor), '$nbos$', '\^');
        SET v_src_string = CONCAT(REPLACE(v_begin_anchor, '\', ''), v_src_string);
    END IF;

    /* Replacing end ($) of the string anchor
       with user-defined substitute, if it's specified */
    IF (CHAR_LENGTH(v_end_anchor) > 0)
    THEN
        SET v_regexp_pat = REPLACE(REPLACE(REPLACE(v_regexp_pat, '\$', '$neos$'), '$', v_end_anchor), '$neos$', '\$');
        SET v_src_string = CONCAT(v_src_string, REPLACE(v_end_anchor, '\', ''));
    END IF;

    WHILE (IF(v_match_param REGEXP 'i',
              v_src_string REGEXP v_regexp_pat, -- Case-insensitive match
              v_src_string REGEXP CONVERT(v_regexp_pat USING utf8) COLLATE utf8_bin)) -- Case-sensitive match
    DO
        SET v_index = 1;
        REPEAT
            -- Constructing test string symbol-by-symbol
            SET v_src_substring = SUBSTRING(v_src_string, 1, v_index);
            SET v_left_idx = v_index;
            SET v_index = v_index + 1;

            -- Exit on the first match by regexp
            UNTIL (IF(v_match_param REGEXP 'i',
                      v_src_substring REGEXP v_regexp_pat, -- Case-insensitive match
                      v_src_substring REGEXP CONVERT(v_regexp_pat USING utf8) COLLATE utf8_bin) OR -- Case-sensitive match
                   v_index > CHAR_LENGTH(v_src_string))
        END REPEAT;

        -- Continue with the rest of the source string
        SET v_src_string = SUBSTRING(v_src_string, v_left_idx);
        SET v_regexp_count = v_regexp_count + 1;
    END WHILE;

    RETURN v_regexp_count;
END]]></complex-attribute>
                        <category _I_D="29839e9a-4bec-445b-92fd-1edb2e606e3b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="00d89408-2912-4c39-9973-fa25dbb1f609" name="regexp_instr" context="regexp_instr" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function returns the location of a regular expression pattern match in a string, depending on the value of the return option argument.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_sub_srcstring NVARCHAR(4000);
    DECLARE v_start_pos INTEGER DEFAULT 1;
    DECLARE v_res_position, v_counter INTEGER DEFAULT 0;
    DECLARE v_position INTEGER DEFAULT FLOOR(p_position);
    DECLARE v_prev_pos, v_srcstr_len, v_substr_len INTEGER;
    DECLARE v_src_string NVARCHAR(4000) DEFAULT SUBSTRING(CONVERT(p_src_string USING utf8), v_position);
    DECLARE v_occurrence INTEGER DEFAULT FLOOR(p_occurrence);
    DECLARE v_ret_opt INTEGER DEFAULT FLOOR(p_ret_opt);
    DECLARE v_regexp_pat NVARCHAR(4000) DEFAULT p_regexp_pat;
    DECLARE v_match_param VARCHAR(10) DEFAULT 'c';

    DECLARE v_begin_anchor NVARCHAR(10) DEFAULT ''; -- Beginning of the string anchor (^) substitute
    DECLARE v_end_anchor NVARCHAR(10) DEFAULT ''; -- End of the string anchor ($) substitute
    DECLARE v_error_message NVARCHAR(500);

    -- Declaration of error conditions and handlers
    DECLARE match_failed CONDITION FOR SQLSTATE '45520';
    DECLARE invalid_position CONDITION FOR SQLSTATE '45521';
    DECLARE invalid_occurrence CONDITION FOR SQLSTATE '45522';
    DECLARE invalid_return_opt CONDITION FOR SQLSTATE '45523';
    DECLARE invalid_match_param CONDITION FOR SQLSTATE '45524';

    -- Invalid position parameter
    DECLARE EXIT HANDLER FOR invalid_position
    BEGIN
        SET v_error_message = CONCAT('Argument '', TRIM(TRAILING '0' FROM p_position),
                                     '' is out of range. Should be greater than or equal to 1 (one)');
        SIGNAL match_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Invalid occurrence parameter
    DECLARE EXIT HANDLER FOR invalid_occurrence
    BEGIN
        SET v_error_message = CONCAT('Argument '', TRIM(TRAILING '0' FROM p_occurrence),
                                     '' is out of range. Should be greater than or equal to 0 (zero)');
        SIGNAL match_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Invalid return option parameter
    DECLARE EXIT HANDLER FOR invalid_return_opt
    BEGIN
        SET v_error_message = CONCAT('Argument '', TRIM(TRAILING '0' FROM p_ret_opt),
                                     '' is out of range. Should be greater than or equal to 0 (zero)');
        SIGNAL match_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Invalid match parameter
    DECLARE EXIT HANDLER FOR invalid_match_param
    BEGIN
        SET v_error_message = CONCAT('Illegal "match_parameter" argument value '', p_match_param,
                                     ''. Must be one of the following: "i", "c", "n", "m", "x"');
        SIGNAL match_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Possible combinations of the input parameters (processing some of them)
    IF (CHAR_LENGTH(COALESCE(p_src_string, '')) = 0 OR CHAR_LENGTH(COALESCE(p_regexp_pat, '')) = 0 OR
        ISNULL(p_position) OR ISNULL(p_occurrence))
    THEN
        RETURN NULL;
    END IF;

    -- Preparing match parameter value
    SET v_match_param = COALESCE(NULLIF(p_match_param, ''), v_match_param);

    -- Validating input parameters
    IF (p_position <= 0) THEN
        -- Invalid position parameter
        SIGNAL invalid_position;
    ELSEIF (p_occurrence < 0) THEN
        -- Invalid occurrence parameter
        SIGNAL invalid_occurrence;
    ELSEIF (p_ret_opt < 0) THEN
        -- Invalid return option parameter
        SIGNAL invalid_return_opt;
    ELSEIF (v_match_param NOT REGEXP  'i|c|n|m|x' COLLATE utf8_bin) THEN
        -- Invalid match parameter
        SIGNAL invalid_match_param;
    END IF;

    /* Replacing beginning (^) of the string anchor
       with user-defined substitute, if it's specified */
    IF (CHAR_LENGTH(v_begin_anchor) > 0)
	THEN
        SET v_regexp_pat = REPLACE(REPLACE(REPLACE(v_regexp_pat, '\^', '$nbos$'), '^', v_begin_anchor), '$nbos$', '\^');
        SET v_src_string = CONCAT(REPLACE(v_begin_anchor, '\', ''), v_src_string);
    END IF;

    /* Replacing end ($) of the string anchor
       with user-defined substitute, if it's specified */
    IF (CHAR_LENGTH(v_end_anchor) > 0)
	THEN
        SET v_regexp_pat = REPLACE(REPLACE(REPLACE(v_regexp_pat, '\$', '$neos$'), '$', v_end_anchor), '$neos$', '\$');
        SET v_src_string = CONCAT(v_src_string, REPLACE(v_end_anchor, '\', ''));
    END IF;

    IF (IF(v_match_param REGEXP 'i',
           v_src_string REGEXP v_regexp_pat, -- Case-insensitive match
           v_src_string REGEXP CONVERT(v_regexp_pat USING utf8) COLLATE utf8_bin)) -- Case-sensitive match
    THEN
        /* Set the pattern to use to match an entire string
           rather than part of a string */
        SET v_regexp_pat = CONCAT('^', v_regexp_pat, '$');
        SET v_srcstr_len = CHAR_LENGTH(v_src_string);

        Match_loop:
        WHILE (v_start_pos <= v_srcstr_len)
        DO
            SET v_substr_len = LEAST(v_srcstr_len - v_start_pos + 1, v_srcstr_len);
            SET v_prev_pos = v_start_pos;

            Len_loop:
            WHILE (v_substr_len >= 1 AND v_substr_len <= v_srcstr_len AND
                   v_start_pos + v_substr_len - 1 <= v_srcstr_len)
            DO
                SET v_sub_srcstring = SUBSTRING(v_src_string, v_start_pos, v_substr_len);

                IF (IF(v_match_param REGEXP 'i',
                       v_sub_srcstring REGEXP v_regexp_pat, -- Case-insensitive match
                       v_sub_srcstring REGEXP CONVERT(v_regexp_pat USING utf8) COLLATE utf8_bin)) -- Case-sensitive match
                THEN
                    SET v_counter = v_counter + 1;
                    -- Matching particular occurrence
                    IF (v_counter = v_occurrence) THEN
                        -- Removing beginning and end of the string anchors
                        SET v_sub_srcstring = REPLACE(v_sub_srcstring, v_begin_anchor, '');
                        SET v_sub_srcstring = REPLACE(v_sub_srcstring, v_end_anchor, '');

                        SET v_res_position = IF(v_ret_opt = 0,
                                                v_start_pos - 1,
                                                v_start_pos + CHAR_LENGTH(v_sub_srcstring) - 1);
                        LEAVE Match_loop;
                    END IF;

                    SET v_start_pos = v_start_pos + v_substr_len;
                    LEAVE Len_loop;
                END IF;

                SET v_substr_len = v_substr_len - 1;
            END WHILE;

            IF (v_start_pos = v_prev_pos) THEN
                SET v_start_pos = v_start_pos + 1;
            END IF;
        END WHILE;
    END IF;

    RETURN v_res_position + v_position - 1;
END]]></complex-attribute>
                        <category _I_D="4f4920c6-de62-4764-9606-08b97b6917e7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b24513c9-8419-4105-9df3-3c90650dbda0" name="regexp_like" context="regexp_like" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function returns a boolean value indicating if the regular expression pattern is found in a string.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_match_param VARCHAR(10) DEFAULT 'c';
    DECLARE v_error_message NVARCHAR(500);

    -- Declaration of error conditions and handlers
    DECLARE match_failed CONDITION FOR SQLSTATE '45520';
    DECLARE invalid_match_param CONDITION FOR SQLSTATE '45521';

    -- Invalid match parameter
    DECLARE EXIT HANDLER FOR invalid_match_param
    BEGIN
        SET v_error_message = CONCAT('Illegal "match_parameter" argument value '', p_match_param,
                                     ''. Must be one of the following: "i", "c", "n", "m", "x"');
        SIGNAL match_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Possible combinations of the input parameters (processing some of them)
    IF (CHAR_LENGTH(COALESCE(p_src_string, '')) = 0 OR CHAR_LENGTH(COALESCE(p_regexp_pat, '')) = 0)
    THEN
        RETURN FALSE;
    END IF;

    -- Preparing match parameter value
    SET v_match_param = COALESCE(NULLIF(p_match_param, ''), v_match_param);

    -- Validating input parameters
    IF (v_match_param NOT REGEXP  'i|c|n|m|x' COLLATE utf8_bin) THEN
        -- Invalid match parameter
        SIGNAL invalid_match_param;
    END IF;

    RETURN IF(v_match_param REGEXP 'i',
              p_src_string REGEXP p_regexp_pat, -- Case-insensitive match
              p_src_string REGEXP CONVERT(p_regexp_pat USING utf8) COLLATE utf8_bin); -- Case-sensitive match
END]]></complex-attribute>
                        <category _I_D="66e65776-02cd-41ba-89e9-7c5f82b042e1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="547330a4-3562-48e6-bfa1-1f2cd3c4f891" name="regexp_replace" context="regexp_replace" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function returns a string where occurrences of the regular expression pattern, found in the source string, are replaced with the specified replacement string.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_counter INTEGER DEFAULT 0;
    DECLARE v_start_pos INTEGER DEFAULT 1;
    DECLARE v_position INTEGER DEFAULT FLOOR(p_position);
    DECLARE v_res_string, v_sub_srcstring NVARCHAR(4000) DEFAULT '';
    DECLARE v_prev_pos, v_srcstr_len, v_substr_len INTEGER;
    DECLARE v_src_string NVARCHAR(4000) DEFAULT SUBSTRING(CONVERT(p_src_string USING utf8), v_position);
    DECLARE v_occurrence INTEGER DEFAULT FLOOR(p_occurrence);
    DECLARE v_regexp_pat NVARCHAR(4000) DEFAULT p_regexp_pat;
    DECLARE v_match_param VARCHAR(10) DEFAULT 'c';

    DECLARE v_begin_anchor NVARCHAR(10) DEFAULT ''; -- Beginning of the string anchor (^) substitute
    DECLARE v_end_anchor NVARCHAR(10) DEFAULT ''; -- End of the string anchor ($) substitute
    DECLARE v_error_message NVARCHAR(500);

    -- Declaration of error conditions and handlers
    DECLARE match_failed CONDITION FOR SQLSTATE '45520';
    DECLARE invalid_position CONDITION FOR SQLSTATE '45521';
    DECLARE invalid_occurrence CONDITION FOR SQLSTATE '45522';
    DECLARE invalid_match_param CONDITION FOR SQLSTATE '45523';

    -- Invalid position parameter
    DECLARE EXIT HANDLER FOR invalid_position
    BEGIN
        SET v_error_message = CONCAT('Argument '', TRIM(TRAILING '0' FROM p_position),
                                     '' is out of range. Should be greater than or equal to 1 (one)');
        SIGNAL match_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Invalid occurrence parameter
    DECLARE EXIT HANDLER FOR invalid_occurrence
    BEGIN
        SET v_error_message = CONCAT('Argument '', TRIM(TRAILING '0' FROM p_occurrence),
                                     '' is out of range. Should be greater than or equal to 0 (zero)');
        SIGNAL match_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Invalid match parameter
    DECLARE EXIT HANDLER FOR invalid_match_param
    BEGIN
        SET v_error_message = CONCAT('Illegal "match_parameter" argument value '', p_match_param,
                                     ''. Must be one of the following: "i", "c", "n", "m", "x"');
        SIGNAL match_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Possible combinations of the input parameters (processing some of them)
    IF (CHAR_LENGTH(COALESCE(p_src_string, '')) = 0 OR ISNULL(p_position) OR ISNULL(p_occurrence))
    THEN
        RETURN NULL;
    ELSEIF (CHAR_LENGTH(COALESCE(p_src_string, '')) <> 0 AND CHAR_LENGTH(COALESCE(p_regexp_pat, '')) = 0) THEN
        RETURN p_src_string;
    END IF;

    -- Preparing match parameter value
    SET v_match_param = COALESCE(NULLIF(p_match_param, ''), v_match_param);

    -- Validating input parameters
    IF (p_position <= 0) THEN
        -- Invalid position parameter
        SIGNAL invalid_position;
    ELSEIF (p_occurrence < 0) THEN
        -- Invalid occurrence parameter
        SIGNAL invalid_occurrence;
    ELSEIF (v_match_param NOT REGEXP  'i|c|n|m|x' COLLATE utf8_bin) THEN
        -- Invalid match parameter
        SIGNAL invalid_match_param;
    END IF;

    /* Replacing beginning (^) of the string anchor
       with user-defined substitute, if it's specified */
    IF (CHAR_LENGTH(v_begin_anchor) > 0) THEN
        SET v_regexp_pat = REPLACE(REPLACE(REPLACE(v_regexp_pat, '\^', '$nbos$'), '^', v_begin_anchor), '$nbos$', '\^');
        SET v_src_string = CONCAT(REPLACE(v_begin_anchor, '\', ''), v_src_string);
    END IF;

    /* Replacing end ($) of the string anchor
       with user-defined substitute, if it's specified */
    IF (CHAR_LENGTH(v_end_anchor) > 0) THEN
        SET v_regexp_pat = REPLACE(REPLACE(REPLACE(v_regexp_pat, '\$', '$neos$'), '$', v_end_anchor), '$neos$', '\$');
        SET v_src_string = CONCAT(v_src_string, REPLACE(v_end_anchor, '\', ''));
    END IF;

    IF (IF(v_match_param REGEXP 'i',
           v_src_string REGEXP v_regexp_pat, -- Case-insensitive match
           v_src_string REGEXP CONVERT(v_regexp_pat USING utf8) COLLATE utf8_bin)) -- Case-sensitive match
    THEN
        /* Set the pattern to use to match an entire string
           rather than part of a string */
        SET v_regexp_pat = CONCAT('^', v_regexp_pat, '$');
        SET v_srcstr_len = CHAR_LENGTH(v_src_string);

        WHILE (v_start_pos <= v_srcstr_len)
        DO
            SET v_substr_len = LEAST(v_srcstr_len - v_start_pos + 1, v_srcstr_len);
            SET v_prev_pos = v_start_pos;

            Len_loop:
            WHILE (v_substr_len >= 1 AND v_substr_len <= v_srcstr_len AND
                   v_start_pos + v_substr_len - 1 <= v_srcstr_len)
            DO
                SET v_sub_srcstring = SUBSTRING(v_src_string, v_start_pos, v_substr_len);

                IF (IF(v_match_param REGEXP 'i',
                       v_sub_srcstring REGEXP v_regexp_pat, -- Case-insensitive match
                       v_sub_srcstring REGEXP CONVERT(v_regexp_pat USING utf8) COLLATE utf8_bin)) -- Case-sensitive match
                THEN
                    SET v_counter = v_counter + 1;
                    SET v_res_string = CONCAT(v_res_string, -- Replacing particular occurrence
                                              IF(v_counter = v_occurrence OR v_occurrence = 0,
                                                 p_replace_str,
                                                 v_sub_srcstring));
                    SET v_start_pos = v_start_pos + v_substr_len;
                    LEAVE Len_loop;
                END IF;

                SET v_substr_len = v_substr_len - 1;
            END WHILE;

            IF (v_start_pos = v_prev_pos) THEN
                SET v_res_string = CONCAT(v_res_string, SUBSTRING(v_src_string, v_start_pos, 1));
                SET v_start_pos = v_start_pos + 1;
            END IF;
        END WHILE;

        -- Removing beginning and end of the string anchors
        SET v_res_string = REPLACE(v_res_string, v_begin_anchor, '');
        SET v_res_string = REPLACE(v_res_string, v_end_anchor, '');

        -- Inserting result string within a source string at the specified position
        SET v_res_string = CONCAT(SUBSTRING(p_src_string, 1, v_position - 1), v_res_string);
    ELSE
        -- Return the source string if there are no matches
        SET v_res_string = p_src_string;
    END IF;

    RETURN v_res_string;
END]]></complex-attribute>
                        <category _I_D="9f4a608e-9440-44ae-8102-761bd23012c3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="11a02c89-d60a-4b32-a6f5-2cebf65fc6a5" name="regexp_substr" context="regexp_substr" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function returns the n-th occurrence of a substring found in a string using regular expression pattern matching.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_counter INTEGER DEFAULT 0;
    DECLARE v_start_pos INTEGER DEFAULT 1;
    DECLARE v_res_string, v_sub_srcstring NVARCHAR(4000);
    DECLARE v_position INTEGER DEFAULT FLOOR(p_position);
    DECLARE v_prev_pos, v_srcstr_len, v_substr_len INTEGER;
    DECLARE v_src_string NVARCHAR(4000) DEFAULT SUBSTRING(CONVERT(p_src_string USING utf8), v_position);
    DECLARE v_occurrence INTEGER DEFAULT FLOOR(p_occurrence);
    DECLARE v_regexp_pat NVARCHAR(4000) DEFAULT p_regexp_pat;
    DECLARE v_match_param VARCHAR(10) DEFAULT 'c';

    DECLARE v_begin_anchor NVARCHAR(10) DEFAULT ''; -- Beginning of the string anchor (^) substitute
    DECLARE v_end_anchor NVARCHAR(10) DEFAULT ''; -- End of the string anchor ($) substitute
    DECLARE v_error_message NVARCHAR(500);

    -- Declaration of error conditions and handlers
    DECLARE match_failed CONDITION FOR SQLSTATE '45520';
    DECLARE invalid_position CONDITION FOR SQLSTATE '45521';
    DECLARE invalid_occurrence CONDITION FOR SQLSTATE '45522';
    DECLARE invalid_match_param CONDITION FOR SQLSTATE '45523';

    -- Invalid position parameter
    DECLARE EXIT HANDLER FOR invalid_position
    BEGIN
        SET v_error_message = CONCAT('Argument '', TRIM(TRAILING '0' FROM p_position),
                                     '' is out of range. Should be greater than or equal to 1 (one)');
        SIGNAL match_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Invalid occurrence parameter
    DECLARE EXIT HANDLER FOR invalid_occurrence
    BEGIN
        SET v_error_message = CONCAT('Argument '', TRIM(TRAILING '0' FROM p_occurrence),
                                     '' is out of range. Should be greater than or equal to 0 (zero)');
        SIGNAL match_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Invalid match parameter
    DECLARE EXIT HANDLER FOR invalid_match_param
    BEGIN
        SET v_error_message = CONCAT('Illegal "match_parameter" argument value '', p_match_param,
                                     ''. Must be one of the following: "i", "c", "n", "m", "x"');
        SIGNAL match_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Possible combinations of the input parameters (processing some of them)
    IF (CHAR_LENGTH(COALESCE(p_src_string, '')) = 0 OR CHAR_LENGTH(COALESCE(p_regexp_pat, '')) = 0 OR
        ISNULL(p_position) OR ISNULL(p_occurrence))
    THEN
        RETURN NULL;
    END IF;

    -- Preparing match parameter value
    SET v_match_param = COALESCE(NULLIF(p_match_param, ''), v_match_param);

    -- Validating input parameters
    IF (p_position <= 0) THEN
        -- Invalid position parameter
        SIGNAL invalid_position;
    ELSEIF (p_occurrence < 0) THEN
        -- Invalid occurrence parameter
        SIGNAL invalid_occurrence;
    ELSEIF (v_match_param NOT REGEXP  'i|c|n|m|x' COLLATE utf8_bin) THEN
        -- Invalid match parameter
        SIGNAL invalid_match_param;
    END IF;

    /* Replacing beginning (^) of the string anchor
       with user-defined substitute, if it's specified */
    IF (CHAR_LENGTH(v_begin_anchor) > 0) THEN
        SET v_regexp_pat = REPLACE(REPLACE(REPLACE(v_regexp_pat, '\^', '$nbos$'), '^', v_begin_anchor), '$nbos$', '\^');
        SET v_src_string = CONCAT(REPLACE(v_begin_anchor, '\', ''), v_src_string);
    END IF;

    /* Replacing end ($) of the string anchor
       with user-defined substitute, if it's specified */
    IF (CHAR_LENGTH(v_end_anchor) > 0) THEN
        SET v_regexp_pat = REPLACE(REPLACE(REPLACE(v_regexp_pat, '\$', '$neos$'), '$', v_end_anchor), '$neos$', '\$');
        SET v_src_string = CONCAT(v_src_string, REPLACE(v_end_anchor, '\', ''));
    END IF;

    IF (IF(v_match_param REGEXP 'i',
           v_src_string REGEXP v_regexp_pat, -- Case-insensitive match
           v_src_string REGEXP CONVERT(v_regexp_pat USING utf8) COLLATE utf8_bin)) -- Case-sensitive match
    THEN
        /* Set the pattern to use to match an entire string
           rather than part of a string */
        SET v_regexp_pat = CONCAT('^', v_regexp_pat, '$');
        SET v_srcstr_len = CHAR_LENGTH(v_src_string);

        Match_loop:
        WHILE (v_start_pos <= v_srcstr_len)
        DO
            SET v_substr_len = LEAST(v_srcstr_len - v_start_pos + 1, v_srcstr_len);
            SET v_prev_pos = v_start_pos;

            Len_loop:
            WHILE (v_substr_len >= 1 AND v_substr_len <= v_srcstr_len AND
                   v_start_pos + v_substr_len - 1 <= v_srcstr_len)
            DO
                SET v_sub_srcstring = SUBSTRING(v_src_string, v_start_pos, v_substr_len);

                IF (IF(v_match_param REGEXP 'i',
                       v_sub_srcstring REGEXP v_regexp_pat, -- Case-insensitive match
                       v_sub_srcstring REGEXP CONVERT(v_regexp_pat USING utf8) COLLATE utf8_bin)) -- Case-sensitive match
                THEN
                    SET v_counter = v_counter + 1;
                    -- Matching particular occurrence
                    IF (v_counter = v_occurrence) THEN
                        SET v_res_string = v_sub_srcstring;
                        LEAVE Match_loop;
                    END IF;

                    SET v_start_pos = v_start_pos + v_substr_len;
                    LEAVE Len_loop;
                END IF;

                SET v_substr_len = v_substr_len - 1;
            END WHILE;

            IF (v_start_pos = v_prev_pos) THEN
                SET v_start_pos = v_start_pos + 1;
            END IF;
        END WHILE;

        -- Removing beginning and end of the string anchors
        SET v_res_string = REPLACE(v_res_string, v_begin_anchor, '');
        SET v_res_string = REPLACE(v_res_string, v_end_anchor, '');
    END IF;

    RETURN v_res_string;
END]]></complex-attribute>
                        <category _I_D="d2affa8a-868c-40c7-a32b-ad28f41e421f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a1fed62d-3a80-4b8b-a338-18a8c2d592ba" name="round_fractseconds" context="round_fractseconds" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function rounds milliseconds in accordance with MS SQL Server's conversion policy of datetime fractional second precision part.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_modpart INTEGER DEFAULT p_milliseconds % 10;
    DECLARE v_decpart INTEGER DEFAULT p_milliseconds - v_modpart;

    RETURN CASE
              WHEN v_modpart BETWEEN 0 AND 1 THEN v_decpart
              WHEN v_modpart BETWEEN 2 AND 4 THEN v_decpart + 3
              WHEN v_modpart BETWEEN 5 AND 8 THEN v_decpart + 7
              ELSE v_decpart + 10 -- 9
           END;
END]]></complex-attribute>
                        <category _I_D="1ca3d3c5-65fa-4e4f-9497-f8232d253861" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="282a37c2-ea1c-4492-856a-6397eeaebc6b" name="split_part" context="split_part" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function splits the string by delimiter and returns the given field (counting from one) by specified position.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_str_part NVARCHAR(4000);
    DECLARE v_idx_str_part NVARCHAR(4000);
    DECLARE v_prev_idx_pos INTEGER;

    IF (LOCATE(p_delimiter, p_string) > 0 AND p_position)
    THEN
        SET v_idx_str_part = SUBSTRING_INDEX(p_string, p_delimiter, p_position);
        SET v_prev_idx_pos = CHAR_LENGTH(SUBSTRING_INDEX(p_string, p_delimiter, p_position - 1));

        SET v_str_part = REPLACE(SUBSTRING(v_idx_str_part,
                                           IF(CHAR_LENGTH(v_idx_str_part) = v_prev_idx_pos,
                                              NULL, v_prev_idx_pos) + 1),
                                 p_delimiter, '');
    END IF;

    RETURN v_str_part;
END]]></complex-attribute>
                        <category _I_D="106f3423-7731-4860-ba99-a8dccfbf2463" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a6813799-fe17-4abc-b6ab-7f217fb851e2" name="string_to_json_array" context="string_to_json_array" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function splits the string by a given delimiter and converts it to a JSON array.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_arr_val NVARCHAR(4000);
    DECLARE v_index INTEGER DEFAULT 0;
    DECLARE v_delim_pos INTEGER DEFAULT 0;
    DECLARE v_prev_pos INTEGER DEFAULT 1;
    DECLARE v_json_array JSON DEFAULT JSON_ARRAY('');
    DECLARE v_delimiter NVARCHAR(100) DEFAULT COALESCE(p_delimiter, '');

    IF (NOT ISNULL(p_src_string) AND v_delimiter <> '')
    THEN
        REPEAT
            SET v_index = v_index + 1;
            SET v_delim_pos = LOCATE(p_delimiter, p_src_string, v_delim_pos + 1);

            SET v_arr_val = IF(v_delim_pos = 0,
                               SUBSTRING(p_src_string, v_prev_pos),
                               SUBSTRING(p_src_string, v_prev_pos, v_delim_pos - v_prev_pos));

            IF (CHAR_LENGTH(v_arr_val) > 0 OR
                (CHAR_LENGTH(v_arr_val) = 0 AND NOT p_exclude_empty))
            THEN
                SET v_json_array = JSON_ARRAY_APPEND(v_json_array, '$', v_arr_val);
            END IF;

            SET v_prev_pos = v_delim_pos + 1;
            UNTIL (v_delim_pos = 0)
        END REPEAT;

        SET v_json_array = JSON_REMOVE(v_json_array, '$[0]');
    ELSEIF (v_delimiter = '')
    THEN
        SET v_json_array = JSON_SET(v_json_array, '$[0]', p_src_string);
    END IF;

    RETURN v_json_array;
END]]></complex-attribute>
                        <category _I_D="7cb637a5-70ad-4bcb-989d-21ef4dd82cde" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7a58f7c3-754e-4e88-84ed-c8bb04d7419e" name="substring_count" context="substring_count" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function return the number of occurrences of a substring in a source string.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    RETURN ROUND((CHAR_LENGTH(p_src_string) - CHAR_LENGTH(REPLACE(p_src_string, p_sub_string, ''))) / CHAR_LENGTH(p_sub_string));
END]]></complex-attribute>
                        <category _I_D="b1006fe5-b7ec-4546-ad5a-16dde143c961" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8e03f73b-7c02-4cf3-8258-698722a5184c" name="timefromparts" context="timefromparts" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function returns a fully initialized TIME value, constructed from separate time parts.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE v_fractions VARCHAR(50) DEFAULT FLOOR(p_fractions);
    DECLARE v_scale INTEGER DEFAULT FLOOR(p_precision);
    DECLARE v_precision VARCHAR(50);
    DECLARE v_mseconds VARCHAR(50);
    DECLARE v_error_message VARCHAR(500);

    -- Declaration of error conditions and handlers
    DECLARE conversion_failed CONDITION FOR SQLSTATE '45600';
    DECLARE invalid_datepart CONDITION FOR SQLSTATE '45751';
    DECLARE scale_out_of_range CONDITION FOR SQLSTATE '45752';
    DECLARE invalid_scale CONDITION FOR SQLSTATE '45753';

    -- Arguments have values which are not valid for DATETIME2 conversion
    DECLARE EXIT HANDLER FOR invalid_datepart
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Cannot construct data type TIME, some of the arguments have values which are not valid.';
    END;

    -- Scale argument is not valid
    DECLARE EXIT HANDLER FOR invalid_scale
    BEGIN
        SIGNAL conversion_failed
        SET MESSAGE_TEXT = 'Scale argument is not valid. Valid expressions for data type TIME scale argument are integer constants.';
    END;

    -- Scale is out of range
    DECLARE EXIT HANDLER FOR scale_out_of_range
    BEGIN
        SET v_error_message = CONCAT('Specified scale ', v_scale, ' is invalid.');

        SIGNAL conversion_failed
        SET MESSAGE_TEXT = v_error_message;
    END;

    -- Cases when STR_TO_DATE func supplied with incorrect date parts
    DECLARE EXIT HANDLER FOR 1411
    BEGIN
        RESIGNAL SET MESSAGE_TEXT = 'Cannot construct data type TIME, some of the arguments have values which are not valid.';
    END;

    -- Cases when STR_TO_DATE func supplied with incorrect date parts
    DECLARE EXIT HANDLER FOR 1292
    BEGIN
        RESIGNAL SET MESSAGE_TEXT = 'Cannot construct data type TIME, some of the arguments have values which are not valid.';
    END;

    SET v_precision = TRIM(TRAILING '0' FROM p_precision);
    SET v_precision = IF(v_precision REGEXP '[.]$',
                         REPLACE(v_precision, '.', ''),
                         v_precision);

    /* Checking if input arguments belong to the valid ranges.
       (throw an error if they are not) */
    IF (ISNULL(p_hour) OR ISNULL(p_minute) OR ISNULL(p_seconds) OR
        ISNULL(p_fractions) OR ISNULL(p_precision))
    THEN
        RETURN NULL;
    ELSEIF (ISNULL(p_precision) OR (v_precision REGEXP '[.]' AND
            CHAR_LENGTH(SUBSTRING_INDEX(v_precision, '.', -1)) > 0))
    THEN
        -- Invalid precision (scale)
        SIGNAL invalid_scale;
    ELSEIF (v_scale NOT BETWEEN 0 AND 7)
    THEN
        -- Precision (scale) is out of range
        SIGNAL scale_out_of_range;
    ELSEIF ((p_hour NOT BETWEEN 0 AND 23) OR
            (p_minute NOT BETWEEN 0 AND 59) OR
            (p_seconds NOT BETWEEN 0 AND 59) OR
            (p_fractions NOT BETWEEN 0 AND 9999999) OR
            (p_fractions != 0 AND CHAR_LENGTH(v_fractions) > p_precision))
    THEN
        -- Invalid date parts
        SIGNAL invalid_datepart;
    END IF;

    -- Composing microseconds part from fractions and precision
    SET v_mseconds = SUBSTRING(RPAD(LPAD(v_fractions, v_scale, '0'), 7, '0'), 1, 6);

    -- Constructing DATETIME value from separate date and time parts
    RETURN STR_TO_DATE(CONCAT_WS('.', FLOOR(p_hour), FLOOR(p_minute), -- hour, minute (time part)
                                      FLOOR(p_seconds), v_mseconds), -- seconds, mseconds
                       '%H.%i.%s.%f'); -- mask
END]]></complex-attribute>
                        <category _I_D="e2d6f77c-f006-481a-9aae-95a1ad9fa87b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d7ae054e-85b5-4840-b92a-d4e22135c9db" name="try_parse_to_date" context="try_parse_to_date" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function parses the TEXT string and translate it into a DATE value, according to specified culture (conversion mask). If the conversion not successful, the function returns NULL.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
    END;

    RETURN aws_sqlserver_ext.parse_to_date(p_datestring,
                                           p_culture);
END]]></complex-attribute>
                        <category _I_D="00038f19-d8a2-45b2-9cc9-a2963dc47531" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9d46706b-8356-4bc0-b317-209e867c59a4" name="try_parse_to_datetime" context="try_parse_to_datetime" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function parses the TEXT string and converts it into a DATETIME value, according to specified style (conversion mask). If the conversion not successful, the function returns NULL.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
    END;

    RETURN aws_sqlserver_ext.parse_to_datetime(p_datatype,
                                               p_datetimestring,
                                               p_culture);
END]]></complex-attribute>
                        <category _I_D="8c0620e1-2219-49ab-b7c0-e7e77620fdd7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2c14b5b7-5112-4235-bd41-cd6caf1b8d1f" name="try_parse_to_time" context="try_parse_to_time" subcategories-loading="none" object-loading="extended" schema="aws_sqlserver_ext" character-set-client="utf8mb4" collation-connection="utf8mb4_0900_ai_ci" database-collation="utf8mb4_0900_ai_ci" sql-mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION" definer="root@%" security-type="DEFINER" is-deterministic="YES" sql-data-access="NO SQL">
                        <complex-attribute name="comment"><![CDATA[This function parses the TEXT string and converts it into a TIME value, according to specified style (conversion mask). If the conversion not successful, the function returns NULL.]]></complex-attribute>
                        <complex-attribute name="sql"><![CDATA[BEGIN
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
    END;

    RETURN aws_sqlserver_ext.parse_to_time(p_datatype,
                                           p_timestring,
                                           p_culture);
END]]></complex-attribute>
                        <category _I_D="07565a19-fb3f-4326-bae3-325a64341498" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                </category>
                <category _I_D="a36165b6-7d6e-4d39-8f66-bd020c7f0bed" name="Events" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="event"/>
            </schema>
            <schema _I_D="80f9fc9e-98c7-4e76-a809-d9da8e1ca6fd" name="c##chinook" is-empty="N" context="c##chinook" subcategories-loading="none" object-loading="extended" is-system="N" default-character-set-name="utf8mb4" default-collation="utf8mb4_0900_ai_ci" bytelen="4">
                <category _I_D="7496dfca-9eb9-421f-af8f-1d6d56f1f539" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="bb80d7d1-057a-4308-88f7-2ced0153abd5" name="Views" order-num="1" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="ef710fb3-bc83-4d8f-bbc8-551bd73133c7" name="Procedures" order-num="2" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="ee6a40d8-63e7-4bcb-bb61-44ddd91ca1ff" name="Functions" order-num="3" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="714b9340-0d65-4daf-bc20-2eff4cb9c092" name="Events" order-num="4" objects-loading="none" subcategories-loading="none" child-type="event"/>
            </schema>
            <schema _I_D="3f3b7b6b-fb67-4a49-9bc7-e9022c9e25b8" name="information_schema" is-empty="N" context="information_schema" subcategories-loading="none" object-loading="extended" is-system="Y" default-character-set-name="utf8mb3" default-collation="utf8mb3_general_ci" bytelen="3">
                <category _I_D="46d81b44-215b-464d-8cdf-3ebfd84ea1ae" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="db645482-90b7-45a6-a7bd-bcc73686f2da" name="Views" order-num="1" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="dedeaea4-3477-457f-a66b-2d98992e1fa2" name="Procedures" order-num="2" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="906173f4-1407-4776-b264-f7f2fac43a1c" name="Functions" order-num="3" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="e15d6e50-2bc3-4043-afdf-7c7216a374c5" name="Events" order-num="4" objects-loading="none" subcategories-loading="none" child-type="event"/>
            </schema>
            <schema _I_D="e4c94732-d511-4263-bda6-97bd7c700c3f" name="mysql" is-empty="N" context="mysql" subcategories-loading="none" object-loading="extended" is-system="Y" default-character-set-name="utf8mb4" default-collation="utf8mb4_0900_ai_ci" bytelen="4">
                <category _I_D="4437c4cd-4aa2-4600-a4a3-63b4be9e24b6" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="6b20e2ce-b9a4-4f84-8320-368e671e9ae6" name="Views" order-num="1" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="0e3e7ba1-ebab-43e4-8e82-e2455cd9099e" name="Procedures" order-num="2" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="5138bd2c-41c9-4722-8571-0bb1f84bc919" name="Functions" order-num="3" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="3c80151f-93c1-4852-be62-dfd78d77fd56" name="Events" order-num="4" objects-loading="none" subcategories-loading="none" child-type="event"/>
            </schema>
            <schema _I_D="328bc5b3-0682-4b91-a33c-b4baccb580a7" name="performance_schema" is-empty="N" context="performance_schema" subcategories-loading="none" object-loading="extended" is-system="Y" default-character-set-name="utf8mb4" default-collation="utf8mb4_0900_ai_ci" bytelen="4">
                <category _I_D="2f711029-6917-4571-8d42-0745f2999c6f" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="b350d933-ecab-4917-8ddf-86b6ce118fde" name="Views" order-num="1" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="16d64933-dc39-4475-9504-c2eab39b903a" name="Procedures" order-num="2" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="cd1112c5-3f99-4379-8978-bd356da14c3f" name="Functions" order-num="3" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="3329edae-dd3e-4b83-8ccd-867655eeb475" name="Events" order-num="4" objects-loading="none" subcategories-loading="none" child-type="event"/>
            </schema>
            <schema _I_D="51af7b33-60b1-4fe4-8f81-cf9226bfdca4" name="sys" is-empty="N" context="sys" subcategories-loading="none" object-loading="extended" is-system="Y" default-character-set-name="utf8mb4" default-collation="utf8mb4_0900_ai_ci" bytelen="4">
                <category _I_D="18335416-53e1-4e84-befc-7faa75ec27cf" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="0079c9e7-322e-4627-baba-2be07ba9b2b1" name="Views" order-num="1" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="1b638841-35b4-41f4-9635-55e0c4306c38" name="Procedures" order-num="2" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="651e32a7-5543-43ea-9d9b-7500238740ac" name="Functions" order-num="3" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="be0aade7-09e0-4db6-a1bf-9bba5b4ad3d6" name="Events" order-num="4" objects-loading="none" subcategories-loading="none" child-type="event"/>
            </schema>
            <schema _I_D="f11b4f48-0754-4aee-a444-d56058da134c" name="chinook_dbo" is-empty="N" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:50">
                <category _I_D="cdf720ab-ec70-401e-aeca-5d16463b53df" name="Tables" order-num="0" child-type="table" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables">
                    <table _I_D="b80775a8-3e75-4a48-995b-887c944504df" name="album" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:50" engine="InnoDB">
                        <category _I_D="46f8d97f-28e3-4820-ac70-788c0fd2383b" name="Columns" order-num="0" child-type="column" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Columns">
                            <column _I_D="fc0fd8a5-d9d9-4d41-88c3-644ae487bbc7" name="AlbumId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Columns,column AlbumId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="0b18f359-60b5-4ec4-910e-02da9bc000f6" name="Title" nullable="N" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="160" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Columns,column Title" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="b7ff42a4-7a26-4891-976a-e4795f719101" name="ArtistId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="3" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Columns,column ArtistId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="a9770ce9-e562-4972-a145-b950c3569659" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Constraints">
                            <constraint _I_D="f9e24baf-8531-435c-a1b1-1e3aa31102a1" table-name="Album" name="FK_AlbumArtistId" constraint-type-desc="FOREIGN KEY" transformed="2024-08-30 00:49:28" referenced-table-name="Artist" constraint-type="FOREIGN KEY" delete-rule="0" referenced-constraint-schema="chinook_dbo" referenced-constraint-name="PK_Artist" constraint-schema="chinook_dbo" update-rule="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Constraints,constraint FK_AlbumArtistId" source-vendor="MSSQL" mdl-applying-result="applying-error" mdl-applied="2024-08-30 00:49:51" mdl-applying-message="Failed to open the referenced table 'Artist'">
                                <category _I_D="d9f8e7ba-d8b1-4ea7-8df3-94ee838037be" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Constraints,constraint FK_AlbumArtistId,category Columns">
                                    <column _I_D="0cec2368-cea2-49b8-9300-41ddb6c0e1e1" name="ArtistId" transformed="2024-08-30 00:49:28" referenced-column-name="ArtistId" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Constraints,constraint FK_AlbumArtistId,category Columns,column ArtistId" source-vendor="MSSQL" mdl-applying-result="applying-error" sort-order="ASC"/>
                                </category>
                            </constraint>
                            <constraint _I_D="bce33645-e527-48c3-ae6d-f87396ebf043" table-name="Album" name="PK_Album" constraint-type-desc="PRIMARY KEY" transformed="2024-08-30 00:49:28" constraint-type="PRIMARY KEY" constraint-schema="chinook_dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Constraints,constraint PK_Album" source-vendor="MSSQL">
                                <category _I_D="7a87684a-4bfd-48e3-bd3d-cf19e0613c8b" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Constraints,constraint PK_Album,category Columns">
                                    <column _I_D="7a4036d6-05c6-47cf-aff7-855221b536b2" name="AlbumId" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Constraints,constraint PK_Album,category Columns,column AlbumId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="e4bafb34-7a35-4662-83a6-d0d376ae18a8" name="Indexes" order-num="2" child-type="index" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Indexes">
                            <index _I_D="e7f7bd5d-f4a7-43df-b878-823764dffb4b" name="IFK_AlbumArtistId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Indexes,index IFK_AlbumArtistId" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" non-unique="1">
                                <category _I_D="696cee2d-53fa-4a07-a52e-79b5950e1a91" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Indexes,index IFK_AlbumArtistId,category Columns">
                                    <column _I_D="0e57edd6-70de-4fe3-aa4d-b3c57365b57e" name="ArtistId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Indexes,index IFK_AlbumArtistId,category Columns,column ArtistId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </index>
                        </category>
                        <category _I_D="49fe18f5-f302-4587-81f6-0fcfb37f6f9d" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Album,category Triggers"/>
                    </table>
                    <table _I_D="d12da07f-6f86-4c6e-ab00-f8852cb957ff" name="artist" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:50" engine="InnoDB">
                        <category _I_D="f400be1d-722a-4021-896a-01165b756ff1" name="Columns" order-num="0" child-type="column" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Columns">
                            <column _I_D="815217e7-a790-4c5d-ba71-8c57c190a8dc" name="ArtistId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Columns,column ArtistId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="be763ebc-2971-4844-9e13-da0ad5e112ac" name="Name" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="120" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Columns,column Name" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="c7d70222-ef1e-476a-b868-44d8af42835e" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Constraints">
                            <constraint _I_D="93e8671e-08cf-4a99-bc3e-15e96531f433" table-name="Artist" name="PK_Artist" constraint-type-desc="PRIMARY KEY" transformed="2024-08-30 00:49:28" constraint-type="PRIMARY KEY" constraint-schema="chinook_dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Constraints,constraint PK_Artist" source-vendor="MSSQL">
                                <category _I_D="bb1ec23b-031b-4a0b-a58d-879b754fd03a" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Constraints,constraint PK_Artist,category Columns">
                                    <column _I_D="175179f3-6372-48b5-ae04-a31506d4f8a2" name="ArtistId" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Constraints,constraint PK_Artist,category Columns,column ArtistId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="05426072-5a07-4023-acfd-21cbe3284c4b" name="Indexes" order-num="2" child-type="index" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Indexes"/>
                        <category _I_D="407623d4-24f0-4682-b617-d9149456dc72" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Artist,category Triggers"/>
                    </table>
                    <table _I_D="ba487ca8-135d-40f9-9b4a-7c88611358da" name="customer" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:50" engine="InnoDB">
                        <category _I_D="f0d05d8c-88d6-4a29-88e6-5f4f60e3bbfd" name="Columns" order-num="0" child-type="column" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns">
                            <column _I_D="af054e4f-332f-4534-b4f3-ef564cea75fd" name="CustomerId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column CustomerId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="dc2598d3-da3b-4825-ab1d-4ffdf0d57072" name="FirstName" nullable="N" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="40" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column FirstName" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="181dd310-1bd1-48bb-a1e8-4cdd12a135c4" name="LastName" nullable="N" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="20" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="3" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column LastName" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="353e9f1f-8609-4ce2-b817-f8f3b0146d8a" name="Company" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="80" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="4" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column Company" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="a71672a7-427e-4933-9d94-675a7367f28f" name="Address" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="70" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="5" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column Address" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="14405cc4-8b0d-4ff2-b2b9-39d6aaaa8e49" name="City" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="40" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="6" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column City" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="1ec4832a-76f2-422e-a9b6-ac2f5b1435b3" name="State" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="40" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="7" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column State" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="0a96bc8b-c6f6-4451-9e5f-b5346a70b397" name="Country" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="40" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="8" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column Country" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="75cd2af2-bb1e-42be-938e-bb47efdc3434" name="PostalCode" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="10" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="9" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column PostalCode" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="4f08f001-4eb2-48b8-97f2-e38882df7cd3" name="Phone" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="24" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="10" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column Phone" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="cf091cf9-4457-4563-a244-7da9b6cee6c1" name="Fax" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="24" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="11" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column Fax" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="32eaa3dd-d3bf-4565-95c4-bc5d90c9c52c" name="Email" nullable="N" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="60" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="12" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column Email" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="1f82a802-4d95-452e-bde6-236079ef161d" name="SupportRepId" nullable="Y" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="13" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Columns,column SupportRepId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="f969f1d2-ce6b-4350-b167-26a403bc810b" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Constraints">
                            <constraint _I_D="80f21fe3-e280-4c7b-b9c3-d4528b5c1003" table-name="Customer" name="FK_CustomerSupportRepId" constraint-type-desc="FOREIGN KEY" transformed="2024-08-30 00:49:28" referenced-table-name="Employee" constraint-type="FOREIGN KEY" delete-rule="0" referenced-constraint-schema="chinook_dbo" referenced-constraint-name="PK_Employee" constraint-schema="chinook_dbo" update-rule="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Constraints,constraint FK_CustomerSupportRepId" source-vendor="MSSQL" mdl-applying-result="applying-error" mdl-applied="2024-08-30 00:49:51" mdl-applying-message="Failed to open the referenced table 'Employee'">
                                <category _I_D="8515f195-d786-4525-9dd2-1eb61a21e450" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Constraints,constraint FK_CustomerSupportRepId,category Columns">
                                    <column _I_D="120aa633-dd74-4f84-a202-32604f46da8c" name="SupportRepId" transformed="2024-08-30 00:49:28" referenced-column-name="EmployeeId" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Constraints,constraint FK_CustomerSupportRepId,category Columns,column SupportRepId" source-vendor="MSSQL" mdl-applying-result="applying-error" sort-order="ASC"/>
                                </category>
                            </constraint>
                            <constraint _I_D="b3b4b43b-afec-4ead-9352-d84a9faf5609" table-name="Customer" name="PK_Customer" constraint-type-desc="PRIMARY KEY" transformed="2024-08-30 00:49:28" constraint-type="PRIMARY KEY" constraint-schema="chinook_dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Constraints,constraint PK_Customer" source-vendor="MSSQL">
                                <category _I_D="d0afa687-ff69-4953-a072-1d07ae4a9289" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Constraints,constraint PK_Customer,category Columns">
                                    <column _I_D="90665978-2a15-4d3e-a77f-e71de7a02aae" name="CustomerId" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Constraints,constraint PK_Customer,category Columns,column CustomerId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="ca0cfac8-fcab-4e95-ae38-0ff9bbc38576" name="Indexes" order-num="2" child-type="index" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Indexes">
                            <index _I_D="dafa1578-66a4-4e33-9f89-eec6578154bc" name="IFK_CustomerSupportRepId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Indexes,index IFK_CustomerSupportRepId" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" non-unique="1">
                                <category _I_D="90461e1f-79a1-451f-b0e6-07f2a12da453" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Indexes,index IFK_CustomerSupportRepId,category Columns">
                                    <column _I_D="b276f89c-b86a-4605-8962-1962b3b34a29" name="SupportRepId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Indexes,index IFK_CustomerSupportRepId,category Columns,column SupportRepId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </index>
                        </category>
                        <category _I_D="0029ccd7-2916-4db9-8471-1e04c48d657b" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Customer,category Triggers"/>
                    </table>
                    <table _I_D="86d38396-4d16-4651-8b58-d37b279e803c" name="employee" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:50" engine="InnoDB">
                        <category _I_D="2e0ceac5-e103-4f4a-94fa-705a5c6e6f47" name="Columns" order-num="0" child-type="column" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns">
                            <column _I_D="ee0851aa-2bb4-4184-a11d-3a6c9411eeef" name="EmployeeId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column EmployeeId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="5002d3d6-9836-4b9d-9cbe-baa54c71e2ed" name="LastName" nullable="N" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="20" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column LastName" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="245b7016-0a21-473a-aca9-fa0aeb7b1b48" name="FirstName" nullable="N" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="20" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="3" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column FirstName" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="d58c1400-3336-483b-9874-27a694f37a4c" name="Title" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="30" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="4" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column Title" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="96bbf4ab-330b-48a9-83b5-11838f3347c8" name="ReportsTo" nullable="Y" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="5" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column ReportsTo" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="43eb1763-637d-495d-a5e0-79ebb527d837" name="BirthDate" nullable="Y" dt-name="DATETIME" transformed="2024-08-30 00:49:28" dt-attr-1="3" ordinal-position="6" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column BirthDate" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="e8436d1e-b027-4533-bb48-a3c115fa6593" name="HireDate" nullable="Y" dt-name="DATETIME" transformed="2024-08-30 00:49:28" dt-attr-1="3" ordinal-position="7" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column HireDate" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="c2044f2d-871e-469f-ae36-1db0dc8fbf13" name="Address" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="70" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="8" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column Address" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="043cbcef-ae8a-4343-9b8e-26bf38066bbf" name="City" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="40" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="9" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column City" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="f95a1204-f569-4ba7-94b3-cc2f15a33146" name="State" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="40" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="10" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column State" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="75fdc78c-abbf-48fc-afb2-4eb867a56188" name="Country" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="40" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="11" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column Country" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="3a72e01a-033b-4e42-a667-74556f0d6c35" name="PostalCode" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="10" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="12" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column PostalCode" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="172f9542-da15-4a5a-bfce-ff12c4f11dc5" name="Phone" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="24" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="13" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column Phone" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="16f880a3-b9d6-42b7-b75b-f2c2a0b5f9e9" name="Fax" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="24" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="14" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column Fax" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="60349bd3-7a92-4b25-8494-e650d18d5433" name="Email" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="60" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="15" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Columns,column Email" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="b92f4459-2ef2-41d5-b9ba-94363078cd33" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Constraints">
                            <constraint _I_D="062b419c-08fc-4d8d-912b-ceacd8fa0949" table-name="Employee" name="FK_EmployeeReportsTo" constraint-type-desc="FOREIGN KEY" transformed="2024-08-30 00:49:28" referenced-table-name="Employee" constraint-type="FOREIGN KEY" delete-rule="0" referenced-constraint-schema="chinook_dbo" referenced-constraint-name="PK_Employee" constraint-schema="chinook_dbo" update-rule="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Constraints,constraint FK_EmployeeReportsTo" source-vendor="MSSQL" mdl-applying-result="applying-error" mdl-applied="2024-08-30 00:49:51" mdl-applying-message="Failed to open the referenced table 'Employee'">
                                <category _I_D="1dc7b35d-74eb-4d8b-bf60-fbf8d7b2d6ca" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Constraints,constraint FK_EmployeeReportsTo,category Columns">
                                    <column _I_D="d90f85ab-0d9a-4fdb-82ce-d96c79c5489f" name="ReportsTo" transformed="2024-08-30 00:49:28" referenced-column-name="EmployeeId" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Constraints,constraint FK_EmployeeReportsTo,category Columns,column ReportsTo" source-vendor="MSSQL" mdl-applying-result="applying-error" sort-order="ASC"/>
                                </category>
                            </constraint>
                            <constraint _I_D="546922a1-0feb-4f01-ad53-b1e638f5f62c" table-name="Employee" name="PK_Employee" constraint-type-desc="PRIMARY KEY" transformed="2024-08-30 00:49:28" constraint-type="PRIMARY KEY" constraint-schema="chinook_dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Constraints,constraint PK_Employee" source-vendor="MSSQL">
                                <category _I_D="0008798a-6a9f-444c-a92b-1e9243bc15cf" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Constraints,constraint PK_Employee,category Columns">
                                    <column _I_D="8b441644-cdb0-40c7-99e8-abe4f35f441d" name="EmployeeId" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Constraints,constraint PK_Employee,category Columns,column EmployeeId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="c5f7b8d6-6d5c-4392-bbb5-a5b6364e7f76" name="Indexes" order-num="2" child-type="index" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Indexes">
                            <index _I_D="a1cf4930-a283-4568-9679-331c38e4dd86" name="IFK_EmployeeReportsTo" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Indexes,index IFK_EmployeeReportsTo" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" non-unique="1">
                                <category _I_D="45dc17b1-9eeb-462b-9e0b-5ae45312c5c8" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Indexes,index IFK_EmployeeReportsTo,category Columns">
                                    <column _I_D="70a0e0c4-b04b-48cf-9a12-bc9a928de749" name="ReportsTo" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Indexes,index IFK_EmployeeReportsTo,category Columns,column ReportsTo" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </index>
                        </category>
                        <category _I_D="eef43caf-98d1-46ee-aef9-e68df5211c6a" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Employee,category Triggers"/>
                    </table>
                    <table _I_D="bd64ad63-9c8c-499e-b267-fae85a97322d" name="genre" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:50" engine="InnoDB">
                        <category _I_D="58c24e9f-bc7f-4485-a3d4-f630a6498aa0" name="Columns" order-num="0" child-type="column" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Columns">
                            <column _I_D="65f981ab-d465-4da1-9824-82d1d8de4870" name="GenreId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Columns,column GenreId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="f1e0fb6c-7d51-4b7d-b6cb-80e9f756d853" name="Name" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="120" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Columns,column Name" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="2cbcd447-b5bb-417e-8bba-cabf007f1f9f" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Constraints">
                            <constraint _I_D="4687c1a1-9093-425d-b783-225db37c129c" table-name="Genre" name="PK_Genre" constraint-type-desc="PRIMARY KEY" transformed="2024-08-30 00:49:28" constraint-type="PRIMARY KEY" constraint-schema="chinook_dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Constraints,constraint PK_Genre" source-vendor="MSSQL">
                                <category _I_D="ff55b46a-8af9-446f-93be-99296aa4d1e5" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Constraints,constraint PK_Genre,category Columns">
                                    <column _I_D="4d46c712-87f3-489e-8a27-2265601c3f42" name="GenreId" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Constraints,constraint PK_Genre,category Columns,column GenreId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="cc3bbf15-98c6-48f1-adc4-efaa7eae8144" name="Indexes" order-num="2" child-type="index" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Indexes"/>
                        <category _I_D="1d85fddf-6f89-4bf1-a65f-1c0bae144ca7" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Genre,category Triggers"/>
                    </table>
                    <table _I_D="65fc2bec-4032-453e-9bcb-c49244452ced" name="invoice" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:50" engine="InnoDB">
                        <category _I_D="741f1e7d-750a-4401-9179-1788dc777bcf" name="Columns" order-num="0" child-type="column" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns">
                            <column _I_D="0c88d1e1-e5da-41fd-88c6-dd7df2b775b1" name="InvoiceId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column InvoiceId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="40eb73bf-5f9f-4664-8e18-881f761dea94" name="CustomerId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column CustomerId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="5442212d-0f09-41ee-b5ac-ed9eb75134d4" name="InvoiceDate" nullable="N" dt-name="DATETIME" transformed="2024-08-30 00:49:28" dt-attr-1="3" ordinal-position="3" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column InvoiceDate" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="c20a2edc-1629-466a-9194-3cffab90f241" name="BillingAddress" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="70" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="4" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column BillingAddress" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="ae6d5bee-09fb-442f-90d0-ed701d7d5922" name="BillingCity" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="40" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="5" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column BillingCity" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="d302a70c-7ce5-4ba1-9617-d378966b3480" name="BillingState" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="40" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="6" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column BillingState" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="220fe02a-0121-48ad-bf73-f208c3773ed4" name="BillingCountry" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="40" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="7" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column BillingCountry" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="714e7e6d-3ef6-438b-abca-02af1ed6c1c0" name="BillingPostalCode" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="10" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="8" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column BillingPostalCode" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="8b9b28d6-9e10-4b21-8f51-4a2649101813" name="Total" nullable="N" dt-name="NUMERIC" transformed="2024-08-30 00:49:28" dt-attr-1="10" ordinal-position="9" dt-attr-2="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Columns,column Total" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="3bea41e1-c5b7-4cd2-8ddd-c22bd67abe8e" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Constraints">
                            <constraint _I_D="19d007c3-6d58-42d3-a23d-a6aa6aa6a483" table-name="Invoice" name="FK_InvoiceCustomerId" constraint-type-desc="FOREIGN KEY" transformed="2024-08-30 00:49:28" referenced-table-name="Customer" constraint-type="FOREIGN KEY" delete-rule="0" referenced-constraint-schema="chinook_dbo" referenced-constraint-name="PK_Customer" constraint-schema="chinook_dbo" update-rule="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Constraints,constraint FK_InvoiceCustomerId" source-vendor="MSSQL" mdl-applying-result="applying-error" mdl-applied="2024-08-30 00:49:51" mdl-applying-message="Failed to open the referenced table 'Customer'">
                                <category _I_D="9f8c1af6-5a17-47b1-82bc-f9325b24e0e9" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Constraints,constraint FK_InvoiceCustomerId,category Columns">
                                    <column _I_D="6e448623-be3f-417d-bee9-fe1590395ed6" name="CustomerId" transformed="2024-08-30 00:49:28" referenced-column-name="CustomerId" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Constraints,constraint FK_InvoiceCustomerId,category Columns,column CustomerId" source-vendor="MSSQL" mdl-applying-result="applying-error" sort-order="ASC"/>
                                </category>
                            </constraint>
                            <constraint _I_D="8f559e04-fec5-46c8-a5d4-a3d9a4f94bb2" table-name="Invoice" name="PK_Invoice" constraint-type-desc="PRIMARY KEY" transformed="2024-08-30 00:49:28" constraint-type="PRIMARY KEY" constraint-schema="chinook_dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Constraints,constraint PK_Invoice" source-vendor="MSSQL">
                                <category _I_D="8b9238c7-8b98-4635-90e1-93a4a1a0f94a" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Constraints,constraint PK_Invoice,category Columns">
                                    <column _I_D="ce533b97-2aac-4ed8-9433-87837d381387" name="InvoiceId" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Constraints,constraint PK_Invoice,category Columns,column InvoiceId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="e8e98e9b-a6b5-4f05-89a2-5f2ab1c3241e" name="Indexes" order-num="2" child-type="index" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Indexes">
                            <index _I_D="12e62293-b9ee-41e0-844a-92559f7812f0" name="IFK_InvoiceCustomerId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Indexes,index IFK_InvoiceCustomerId" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" non-unique="1">
                                <category _I_D="a20d9ba4-222d-430c-8366-f862120f42b8" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Indexes,index IFK_InvoiceCustomerId,category Columns">
                                    <column _I_D="fc60ab8b-0814-4955-96a8-fb5601d7ce3a" name="CustomerId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Indexes,index IFK_InvoiceCustomerId,category Columns,column CustomerId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </index>
                        </category>
                        <category _I_D="10083657-9ae7-4fd6-a1ba-a7e93ac7b4cf" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Invoice,category Triggers"/>
                    </table>
                    <table _I_D="b06ef300-233c-424e-bc7b-0830b7596ebf" name="invoiceline" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" engine="InnoDB">
                        <category _I_D="5c3f4c26-cdcd-4fab-9252-f325e993306f" name="Columns" order-num="0" child-type="column" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Columns">
                            <column _I_D="e5bb09a8-f440-42de-8df4-45972359201e" name="InvoiceLineId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Columns,column InvoiceLineId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="fdbee1dc-c9a2-422e-902f-edb8a45bb77d" name="InvoiceId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Columns,column InvoiceId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="0a0fd686-e5f0-442a-8450-1dec09bcedbc" name="TrackId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="3" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Columns,column TrackId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="27716bb5-05fd-4cb3-a1b5-20922fd20961" name="UnitPrice" nullable="N" dt-name="NUMERIC" transformed="2024-08-30 00:49:28" dt-attr-1="10" ordinal-position="4" dt-attr-2="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Columns,column UnitPrice" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="9c715802-e56c-4734-99d3-8b1c036b8c5d" name="Quantity" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="5" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Columns,column Quantity" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="8f514840-ac14-4c73-b113-ba1df484c07f" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints">
                            <constraint _I_D="ae221141-4e99-4f82-8ba0-4aecc9d39e82" table-name="InvoiceLine" name="FK_InvoiceLineInvoiceId" constraint-type-desc="FOREIGN KEY" transformed="2024-08-30 00:49:28" referenced-table-name="Invoice" constraint-type="FOREIGN KEY" delete-rule="0" referenced-constraint-schema="chinook_dbo" referenced-constraint-name="PK_Invoice" constraint-schema="chinook_dbo" update-rule="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint FK_InvoiceLineInvoiceId" source-vendor="MSSQL" mdl-applying-result="applying-error" mdl-applied="2024-08-30 00:49:51" mdl-applying-message="Failed to open the referenced table 'Invoice'">
                                <category _I_D="addf331f-c7ae-44d7-bde2-5d3e6c58ec75" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint FK_InvoiceLineInvoiceId,category Columns">
                                    <column _I_D="135e6a8d-b65b-47cf-af5f-f094c344f90e" name="InvoiceId" transformed="2024-08-30 00:49:28" referenced-column-name="InvoiceId" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint FK_InvoiceLineInvoiceId,category Columns,column InvoiceId" source-vendor="MSSQL" mdl-applying-result="applying-error" sort-order="ASC"/>
                                </category>
                            </constraint>
                            <constraint _I_D="bfd09b1f-9148-4d29-bb81-0ab346f3d8c5" table-name="InvoiceLine" name="FK_InvoiceLineTrackId" constraint-type-desc="FOREIGN KEY" transformed="2024-08-30 00:49:28" referenced-table-name="Track" constraint-type="FOREIGN KEY" delete-rule="0" referenced-constraint-schema="chinook_dbo" referenced-constraint-name="PK_Track" constraint-schema="chinook_dbo" update-rule="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint FK_InvoiceLineTrackId" source-vendor="MSSQL" mdl-applying-result="applying-error" mdl-applied="2024-08-30 00:49:51" mdl-applying-message="Failed to open the referenced table 'Track'">
                                <category _I_D="08173d59-7ec2-4f38-beda-73edddef1f47" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint FK_InvoiceLineTrackId,category Columns">
                                    <column _I_D="b6570701-a09a-4860-a096-49cf4c29dd2f" name="TrackId" transformed="2024-08-30 00:49:28" referenced-column-name="TrackId" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint FK_InvoiceLineTrackId,category Columns,column TrackId" source-vendor="MSSQL" mdl-applying-result="applying-error" sort-order="ASC"/>
                                </category>
                            </constraint>
                            <constraint _I_D="d189bb66-bdd9-4bb3-9dfd-db6e78c5d2ae" table-name="InvoiceLine" name="PK_InvoiceLine" constraint-type-desc="PRIMARY KEY" transformed="2024-08-30 00:49:28" constraint-type="PRIMARY KEY" constraint-schema="chinook_dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint PK_InvoiceLine" source-vendor="MSSQL">
                                <category _I_D="ec9cfada-29f6-499a-84b0-c9d277b33af5" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint PK_InvoiceLine,category Columns">
                                    <column _I_D="425a3492-6c82-43bf-846e-2a115a4502ff" name="InvoiceLineId" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Constraints,constraint PK_InvoiceLine,category Columns,column InvoiceLineId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="4d4fddc1-c0bf-4ac1-a378-66adffc2e10f" name="Indexes" order-num="2" child-type="index" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Indexes">
                            <index _I_D="83dfa643-2666-425b-bfff-df66be20a37c" name="IFK_InvoiceLineInvoiceId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Indexes,index IFK_InvoiceLineInvoiceId" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" non-unique="1">
                                <category _I_D="a2835a14-cc6c-47e2-ac8b-17e016469ff8" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Indexes,index IFK_InvoiceLineInvoiceId,category Columns">
                                    <column _I_D="952b80a4-0ab3-4e0c-8a6d-2ce5bcedd6bd" name="InvoiceId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Indexes,index IFK_InvoiceLineInvoiceId,category Columns,column InvoiceId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </index>
                            <index _I_D="40fc2eb5-17ab-4161-bb55-a445af0c5dc3" name="IFK_InvoiceLineTrackId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Indexes,index IFK_InvoiceLineTrackId" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" non-unique="1">
                                <category _I_D="345ce5ad-5785-4c5a-bc5c-c5eb49a22120" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Indexes,index IFK_InvoiceLineTrackId,category Columns">
                                    <column _I_D="431df9e8-9eda-41f6-b997-ce4819b358fb" name="TrackId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Indexes,index IFK_InvoiceLineTrackId,category Columns,column TrackId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </index>
                        </category>
                        <category _I_D="8bec67f7-6e1a-4a99-919b-614f2e9ee4c9" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table InvoiceLine,category Triggers"/>
                    </table>
                    <table _I_D="5c87cefc-5136-4354-a602-fb43029d8875" name="mediatype" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" engine="InnoDB">
                        <category _I_D="719890df-f1cc-439c-b87d-a51802f19f48" name="Columns" order-num="0" child-type="column" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Columns">
                            <column _I_D="8216febf-9d8f-4d7a-863f-96799a3bd345" name="MediaTypeId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Columns,column MediaTypeId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="47788293-1684-4285-8e26-f98da6a63543" name="Name" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="120" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Columns,column Name" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="280f21d4-6c3c-46cb-a00e-66252fcdaec9" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Constraints">
                            <constraint _I_D="3a785d0f-f3eb-46c4-9ce5-78117d23b0a0" table-name="MediaType" name="PK_MediaType" constraint-type-desc="PRIMARY KEY" transformed="2024-08-30 00:49:28" constraint-type="PRIMARY KEY" constraint-schema="chinook_dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Constraints,constraint PK_MediaType" source-vendor="MSSQL">
                                <category _I_D="bf31c14f-fb2e-47b0-98a1-3e403cebf2f4" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Constraints,constraint PK_MediaType,category Columns">
                                    <column _I_D="cb41853f-eb55-49d9-9017-a4de277cdf37" name="MediaTypeId" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Constraints,constraint PK_MediaType,category Columns,column MediaTypeId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="cfd9dae4-918d-434f-9a65-1ffcb56cdd32" name="Indexes" order-num="2" child-type="index" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Indexes"/>
                        <category _I_D="6b52a5fb-db0c-46f5-8497-b4a2bf93705b" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table MediaType,category Triggers"/>
                    </table>
                    <table _I_D="b667042e-181d-4d10-8ca0-91f13dc1e2e1" name="playlist" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" engine="InnoDB">
                        <category _I_D="e5aa0e5f-6de3-4566-8932-f5c6103eebd4" name="Columns" order-num="0" child-type="column" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Columns">
                            <column _I_D="e6965bba-c70c-4762-979d-f24ceba9979a" name="PlaylistId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Columns,column PlaylistId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="c80d4c56-93b4-4df1-acc7-2d5709b4dde3" name="Name" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="120" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Columns,column Name" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="62bb1bff-e7c4-4921-a2ed-d3db15bc5570" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Constraints">
                            <constraint _I_D="576c7fcb-b98f-42b6-b625-c9d52c8bfb7c" table-name="Playlist" name="PK_Playlist" constraint-type-desc="PRIMARY KEY" transformed="2024-08-30 00:49:28" constraint-type="PRIMARY KEY" constraint-schema="chinook_dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Constraints,constraint PK_Playlist" source-vendor="MSSQL">
                                <category _I_D="da735529-8ef2-4fee-9f04-782cf7c06878" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Constraints,constraint PK_Playlist,category Columns">
                                    <column _I_D="de59222c-dcf7-49b2-ad61-1d46bcc08d73" name="PlaylistId" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Constraints,constraint PK_Playlist,category Columns,column PlaylistId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="9b4408e4-aa53-4caf-926c-8a5e5906f99e" name="Indexes" order-num="2" child-type="index" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Indexes"/>
                        <category _I_D="c9c7cd9b-87c0-4942-afb5-b7cca0acd276" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Playlist,category Triggers"/>
                    </table>
                    <table _I_D="034287af-b64d-46a3-b680-5fb6c99f9d5a" name="playlisttrack" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" engine="InnoDB">
                        <category _I_D="7c011347-64ff-4271-8957-f90d0674aa8a" name="Columns" order-num="0" child-type="column" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Columns">
                            <column _I_D="7c2710f3-b3cb-42cb-9572-60be1457da7c" name="PlaylistId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Columns,column PlaylistId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="8ec3844b-05ee-4058-aa77-daa58709d696" name="TrackId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Columns,column TrackId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="13afdfcc-4201-4330-946b-5ca4f480e0c5" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints">
                            <constraint _I_D="e27f25ae-d1c2-4487-a380-8ba737a1789d" table-name="PlaylistTrack" name="FK_PlaylistTrackPlaylistId" constraint-type-desc="FOREIGN KEY" transformed="2024-08-30 00:49:28" referenced-table-name="Playlist" constraint-type="FOREIGN KEY" delete-rule="0" referenced-constraint-schema="chinook_dbo" referenced-constraint-name="PK_Playlist" constraint-schema="chinook_dbo" update-rule="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint FK_PlaylistTrackPlaylistId" source-vendor="MSSQL" mdl-applying-result="applying-error" mdl-applied="2024-08-30 00:49:51" mdl-applying-message="Failed to open the referenced table 'Playlist'">
                                <category _I_D="975e42cd-8215-41bc-abe8-91703341a551" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint FK_PlaylistTrackPlaylistId,category Columns">
                                    <column _I_D="bea98bed-23b7-469b-87b4-0de84db36726" name="PlaylistId" transformed="2024-08-30 00:49:28" referenced-column-name="PlaylistId" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint FK_PlaylistTrackPlaylistId,category Columns,column PlaylistId" source-vendor="MSSQL" mdl-applying-result="applying-error" sort-order="ASC"/>
                                </category>
                            </constraint>
                            <constraint _I_D="80795694-799b-4689-8584-2a8715dfde8b" table-name="PlaylistTrack" name="FK_PlaylistTrackTrackId" constraint-type-desc="FOREIGN KEY" transformed="2024-08-30 00:49:28" referenced-table-name="Track" constraint-type="FOREIGN KEY" delete-rule="0" referenced-constraint-schema="chinook_dbo" referenced-constraint-name="PK_Track" constraint-schema="chinook_dbo" update-rule="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint FK_PlaylistTrackTrackId" source-vendor="MSSQL" mdl-applying-result="applying-error" mdl-applied="2024-08-30 00:49:51" mdl-applying-message="Failed to open the referenced table 'Track'">
                                <category _I_D="0fb83d70-6a66-40e1-bfd6-1e19a1c2a0c6" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint FK_PlaylistTrackTrackId,category Columns">
                                    <column _I_D="4a5ca622-862c-41d0-80f7-e292e4ef92e4" name="TrackId" transformed="2024-08-30 00:49:28" referenced-column-name="TrackId" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint FK_PlaylistTrackTrackId,category Columns,column TrackId" source-vendor="MSSQL" mdl-applying-result="applying-error" sort-order="ASC"/>
                                </category>
                            </constraint>
                            <constraint _I_D="4de057f0-7a32-4dba-b5a6-9eaf9d48f744" table-name="PlaylistTrack" name="PK_PlaylistTrack" constraint-type-desc="PRIMARY KEY" transformed="2024-08-30 00:49:28" constraint-type="PRIMARY KEY" constraint-schema="chinook_dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint PK_PlaylistTrack" source-vendor="MSSQL">
                                <category _I_D="1581796f-35ae-4080-88e4-ec63f118f6be" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint PK_PlaylistTrack,category Columns">
                                    <column _I_D="b6624b91-4199-469e-8743-ccf574c20689" name="PlaylistId" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint PK_PlaylistTrack,category Columns,column PlaylistId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                    <column _I_D="96733ac5-8b22-49bf-9c67-ef668ea283e3" name="TrackId" transformed="2024-08-30 00:49:28" ordinal-position="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Constraints,constraint PK_PlaylistTrack,category Columns,column TrackId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="722b56a0-3186-40ea-a13e-2db6790174bf" name="Indexes" order-num="2" child-type="index" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Indexes">
                            <index _I_D="886d8c61-eb56-4ce6-a908-3e8689b3e999" name="IFK_PlaylistTrackPlaylistId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Indexes,index IFK_PlaylistTrackPlaylistId" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" non-unique="1">
                                <category _I_D="5082cec1-d4fc-4f30-9a92-c6124e31f8bd" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Indexes,index IFK_PlaylistTrackPlaylistId,category Columns">
                                    <column _I_D="bbaa3316-8291-47cc-80e4-7fd7e3b29f4e" name="PlaylistId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Indexes,index IFK_PlaylistTrackPlaylistId,category Columns,column PlaylistId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </index>
                            <index _I_D="67f8da86-7a4b-4872-b1f5-50cd12433788" name="IFK_PlaylistTrackTrackId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Indexes,index IFK_PlaylistTrackTrackId" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" non-unique="1">
                                <category _I_D="fa721763-48a8-4f5e-b771-d1fc6bd3a66f" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Indexes,index IFK_PlaylistTrackTrackId,category Columns">
                                    <column _I_D="0282906c-7d1f-40c4-ad82-2acd898ec831" name="TrackId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Indexes,index IFK_PlaylistTrackTrackId,category Columns,column TrackId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </index>
                        </category>
                        <category _I_D="ceba012e-6a24-4cce-af69-e44e47c70269" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table PlaylistTrack,category Triggers"/>
                    </table>
                    <table _I_D="649588d9-f955-415d-90d4-5759f26ee306" name="track" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" engine="InnoDB">
                        <category _I_D="2194c7b6-13ab-427a-a4ad-7f8d4f62c297" name="Columns" order-num="0" child-type="column" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns">
                            <column _I_D="30cf517a-969f-45ef-970d-a7346ead28ad" name="TrackId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column TrackId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="c8e41007-8d4b-4880-9bc0-4c1882306286" name="Name" nullable="N" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="200" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column Name" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="e68b96fb-ba82-4c91-81b8-12a7639cb16c" name="AlbumId" nullable="Y" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="3" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column AlbumId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="a9c26144-0a7a-484e-a69e-7cff3f9915ef" name="MediaTypeId" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="4" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column MediaTypeId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="f4005ebd-6a0b-4b23-a53f-1f87cd1ec2f2" name="GenreId" nullable="Y" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="5" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column GenreId" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="1d102ef0-d77e-4f4b-951d-0a6690e752ad" name="Composer" nullable="Y" dt-name="VARCHAR" transformed="2024-08-30 00:49:28" dt-attr-1="220" collation-name="SQL_Latin1_General_CP1_CI_AS" ordinal-position="6" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column Composer" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="80feba0e-9ad4-4682-9753-08b59b37d8f5" name="Milliseconds" nullable="N" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="7" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column Milliseconds" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="039e201d-d796-495d-9bb1-dc4ed3267414" name="Bytes" nullable="Y" dt-name="INT" transformed="2024-08-30 00:49:28" ordinal-position="8" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column Bytes" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                            <column _I_D="012cad2a-a496-44d1-a3a4-e327c7f98327" name="UnitPrice" nullable="N" dt-name="NUMERIC" transformed="2024-08-30 00:49:28" dt-attr-1="10" ordinal-position="9" dt-attr-2="2" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Columns,column UnitPrice" source-vendor="MSSQL" mdl-applying-result="applying-success"/>
                        </category>
                        <category _I_D="92acdf42-87e5-433e-be33-8785f9dbeb3f" name="Constraints" order-num="1" child-type="constraint" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints">
                            <constraint _I_D="06049ffe-f01c-4df3-8e20-6204ad050e97" table-name="Track" name="FK_TrackAlbumId" constraint-type-desc="FOREIGN KEY" transformed="2024-08-30 00:49:28" referenced-table-name="Album" constraint-type="FOREIGN KEY" delete-rule="0" referenced-constraint-schema="chinook_dbo" referenced-constraint-name="PK_Album" constraint-schema="chinook_dbo" update-rule="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackAlbumId" source-vendor="MSSQL" mdl-applying-result="applying-error" mdl-applied="2024-08-30 00:49:51" mdl-applying-message="Failed to open the referenced table 'Album'">
                                <category _I_D="a0d9c510-789b-4c97-b25d-6e7f2e57203b" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackAlbumId,category Columns">
                                    <column _I_D="cdb93079-fc08-45db-a7ea-1418ffb7fd1d" name="AlbumId" transformed="2024-08-30 00:49:28" referenced-column-name="AlbumId" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackAlbumId,category Columns,column AlbumId" source-vendor="MSSQL" mdl-applying-result="applying-error" sort-order="ASC"/>
                                </category>
                            </constraint>
                            <constraint _I_D="54fa88d1-ff7b-40c2-b998-336864c7c071" table-name="Track" name="FK_TrackGenreId" constraint-type-desc="FOREIGN KEY" transformed="2024-08-30 00:49:28" referenced-table-name="Genre" constraint-type="FOREIGN KEY" delete-rule="0" referenced-constraint-schema="chinook_dbo" referenced-constraint-name="PK_Genre" constraint-schema="chinook_dbo" update-rule="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackGenreId" source-vendor="MSSQL" mdl-applying-result="applying-error" mdl-applied="2024-08-30 00:49:51" mdl-applying-message="Failed to open the referenced table 'Genre'">
                                <category _I_D="671ebb7a-9836-4b82-a29f-5b7f5ae0061e" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackGenreId,category Columns">
                                    <column _I_D="3fdf4eb3-2e70-46ec-81c2-aa3b066e8fac" name="GenreId" transformed="2024-08-30 00:49:28" referenced-column-name="GenreId" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackGenreId,category Columns,column GenreId" source-vendor="MSSQL" mdl-applying-result="applying-error" sort-order="ASC"/>
                                </category>
                            </constraint>
                            <constraint _I_D="d09d32b0-00b9-4957-9220-6037a6fe09c6" table-name="Track" name="FK_TrackMediaTypeId" constraint-type-desc="FOREIGN KEY" transformed="2024-08-30 00:49:28" referenced-table-name="MediaType" constraint-type="FOREIGN KEY" delete-rule="0" referenced-constraint-schema="chinook_dbo" referenced-constraint-name="PK_MediaType" constraint-schema="chinook_dbo" update-rule="0" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackMediaTypeId" source-vendor="MSSQL" mdl-applying-result="applying-error" mdl-applied="2024-08-30 00:49:51" mdl-applying-message="Failed to open the referenced table 'MediaType'">
                                <category _I_D="3d8579b5-2fe8-4bda-8390-af7b5159b6a1" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackMediaTypeId,category Columns">
                                    <column _I_D="f45e2477-23b8-46bf-96fb-cd624d4c72ea" name="MediaTypeId" transformed="2024-08-30 00:49:28" referenced-column-name="MediaTypeId" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint FK_TrackMediaTypeId,category Columns,column MediaTypeId" source-vendor="MSSQL" mdl-applying-result="applying-error" sort-order="ASC"/>
                                </category>
                            </constraint>
                            <constraint _I_D="2ec15f76-0e67-4e74-a0a1-939ad5dc17e2" table-name="Track" name="PK_Track" constraint-type-desc="PRIMARY KEY" transformed="2024-08-30 00:49:28" constraint-type="PRIMARY KEY" constraint-schema="chinook_dbo" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint PK_Track" source-vendor="MSSQL">
                                <category _I_D="f513553c-a291-480a-a95b-b2cd146b5905" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint PK_Track,category Columns">
                                    <column _I_D="5eedf879-ab77-482f-ad2b-35c7ca0ccfae" name="TrackId" transformed="2024-08-30 00:49:28" ordinal-position="1" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Constraints,constraint PK_Track,category Columns,column TrackId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="899ecd91-75ea-428a-9a9f-92c4c5f403fa" name="Indexes" order-num="2" child-type="index" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes">
                            <index _I_D="2ce1bd31-4168-4744-ae44-a0edca0b8e4d" name="IFK_TrackAlbumId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackAlbumId" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" non-unique="1">
                                <category _I_D="b3149b38-0632-4cd7-a587-2f0057cb231f" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackAlbumId,category Columns">
                                    <column _I_D="a5125915-1fc6-47f9-b9f7-4d90398390eb" name="AlbumId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackAlbumId,category Columns,column AlbumId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </index>
                            <index _I_D="c635bfff-f62a-438c-a3d2-285b89a73470" name="IFK_TrackGenreId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackGenreId" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" non-unique="1">
                                <category _I_D="c69f18bd-7c4d-40a5-a866-34dc53b5aecd" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackGenreId,category Columns">
                                    <column _I_D="a5924cbe-6d2a-4d2e-9bdb-a623d610c213" name="GenreId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackGenreId,category Columns,column GenreId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </index>
                            <index _I_D="dc141993-9f73-4c99-8257-b2e44cd13073" name="IFK_TrackMediaTypeId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackMediaTypeId" source-vendor="MSSQL" mdl-applying-result="applying-success" mdl-applied="2024-08-30 00:49:51" non-unique="1">
                                <category _I_D="1f35cd84-5213-4c52-a3a8-9dcb8620f091" name="Columns" order-num="0" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackMediaTypeId,category Columns">
                                    <column _I_D="366c14b2-b9cd-4cce-ad4b-668eb8fca59b" name="MediaTypeId" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Indexes,index IFK_TrackMediaTypeId,category Columns,column MediaTypeId" source-vendor="MSSQL" mdl-applying-result="applying-success" sort-order="ASC"/>
                                </category>
                            </index>
                        </category>
                        <category _I_D="652545bd-a582-4f50-85a6-8268b3a58b18" name="Triggers" order-num="3" child-type="trigger" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Tables,table Track,category Triggers"/>
                    </table>
                </category>
                <category _I_D="1f7204e5-747a-4a1f-8107-92654e0b9ac7" name="Views" order-num="3" child-type="view" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Views"/>
                <category _I_D="869da2aa-7858-46d1-98fb-f118567254bf" name="Procedures" order-num="4" child-type="procedure" transformed="2024-08-30 00:49:28" artificial-src-full-name="category Databases,database Chinook,category Schemas,schema dbo,category Procedures"/>
            </schema>
        </category>
        <category _I_D="743e5a46-5070-40f0-ba91-f3a5451fddba" name="User-Defined Functions" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="udf"/>
        <category _I_D="3c0ffe9b-42d7-453a-a254-06759f394ae8" name="Plugins" order-num="2" objects-loading="extended" subcategories-loading="full" child-type="plugin">
            <plugin _I_D="f624d263-39ab-4268-92a3-0ccbf31397a4" name="binlog" version="1.0" status="ACTIVE" type="STORAGE ENGINE" type-version="90001.0" author="Oracle Corporation" description="This is a pseudo storage engine to represent the binlog in a transaction" license="GPL" load-option="FORCE" context="binlog" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="f83a4927-4ef8-4554-ad19-a79bd395cabe" name="sha256_password" version="1.1" status="ACTIVE" type="AUTHENTICATION" type-version="2.1" author="Oracle Corporation" description="SHA256 password authentication" license="GPL" load-option="FORCE" context="sha256_password" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="3bc7432e-df61-4139-b930-792d68ee87f1" name="caching_sha2_password" version="1.0" status="ACTIVE" type="AUTHENTICATION" type-version="2.1" author="Oracle Corporation" description="Caching sha2 authentication" license="GPL" load-option="FORCE" context="caching_sha2_password" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="f4012540-80c3-4133-b3f7-6389a285dee7" name="sha2_cache_cleaner" version="1.0" status="ACTIVE" type="AUDIT" type-version="4.1" author="Oracle Corporation" description="Cache cleaner for Caching sha2 authentication" license="GPL" load-option="FORCE" context="sha2_cache_cleaner" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="5fa6da72-ad5a-40ee-a348-59787fdf52c9" name="daemon_keyring_proxy_plugin" version="1.0" status="ACTIVE" type="DAEMON" type-version="90001.0" author="Oracle" description="A plugin that implements the keyring component services atop of the keyring plugin" license="GPL" load-option="FORCE" context="daemon_keyring_proxy_plugin" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="91260ede-9fcf-41d7-9929-ca98a0774a49" name="CSV" version="1.0" status="ACTIVE" type="STORAGE ENGINE" type-version="90001.0" author="Oracle Corporation" description="CSV storage engine" license="GPL" load-option="FORCE" context="CSV" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="10821a26-b887-4846-adc1-9c7e65f786a1" name="MEMORY" version="1.0" status="ACTIVE" type="STORAGE ENGINE" type-version="90001.0" author="Oracle Corporation" description="Hash based, stored in memory, useful for temporary tables" license="GPL" load-option="FORCE" context="MEMORY" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="7b9c183a-8a57-4c37-bc05-e271c927af62" name="InnoDB" version="9.0" status="ACTIVE" type="STORAGE ENGINE" type-version="90001.0" author="Oracle Corporation" description="Supports transactions, row-level locking, and foreign keys" license="GPL" load-option="FORCE" context="InnoDB" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="3ccadbbd-7bfa-4e23-8ca0-eadb2252515d" name="INNODB_TRX" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="InnoDB transactions" license="GPL" load-option="FORCE" context="INNODB_TRX" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="c6d9e9ac-7b2a-4684-a35e-9822f4649c3c" name="INNODB_CMP" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="Statistics for the InnoDB compression" license="GPL" load-option="FORCE" context="INNODB_CMP" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="167dc4a2-85a0-44a5-a453-37981934e827" name="INNODB_CMP_RESET" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="Statistics for the InnoDB compression; reset cumulated counts" license="GPL" load-option="FORCE" context="INNODB_CMP_RESET" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="4698a9b9-0f33-4908-b5f8-d6c5675dec13" name="INNODB_CMPMEM" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="Statistics for the InnoDB compressed buffer pool" license="GPL" load-option="FORCE" context="INNODB_CMPMEM" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="287231b0-7465-4779-ac46-af6d94d5bae2" name="INNODB_CMPMEM_RESET" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="Statistics for the InnoDB compressed buffer pool; reset cumulated counts" license="GPL" load-option="FORCE" context="INNODB_CMPMEM_RESET" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="19a300aa-8344-45f1-a61f-0bc335affd12" name="INNODB_CMP_PER_INDEX" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="Statistics for the InnoDB compression (per index)" license="GPL" load-option="FORCE" context="INNODB_CMP_PER_INDEX" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="82692900-a51b-4d41-b670-9c119c3509fc" name="INNODB_CMP_PER_INDEX_RESET" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="Statistics for the InnoDB compression (per index); reset cumulated counts" license="GPL" load-option="FORCE" context="INNODB_CMP_PER_INDEX_RESET" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="c9eb1d2c-3b71-4549-86a2-5bd04be4f36e" name="INNODB_BUFFER_PAGE" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="InnoDB Buffer Page Information" license="GPL" load-option="FORCE" context="INNODB_BUFFER_PAGE" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="fe3f28c9-b249-482e-8669-b8cb122bf0ec" name="INNODB_BUFFER_PAGE_LRU" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="InnoDB Buffer Page in LRU" license="GPL" load-option="FORCE" context="INNODB_BUFFER_PAGE_LRU" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="7aa803cf-40f1-4250-8e7e-e312db535417" name="INNODB_BUFFER_POOL_STATS" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="InnoDB Buffer Pool Statistics Information " license="GPL" load-option="FORCE" context="INNODB_BUFFER_POOL_STATS" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="b9d9cc86-d00d-465c-a397-d5963508a94c" name="INNODB_TEMP_TABLE_INFO" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="InnoDB Temp Table Stats" license="GPL" load-option="FORCE" context="INNODB_TEMP_TABLE_INFO" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="303101d6-0a16-4fd2-ad0a-d05ba838f8be" name="INNODB_METRICS" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="InnoDB Metrics Info" license="GPL" load-option="FORCE" context="INNODB_METRICS" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="434c56b2-6ba3-4543-a424-70184fa337b1" name="INNODB_FT_DEFAULT_STOPWORD" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="Default stopword list for InnDB Full Text Search" license="GPL" load-option="FORCE" context="INNODB_FT_DEFAULT_STOPWORD" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="1b30db69-a633-4394-a2be-27240f48a650" name="INNODB_FT_DELETED" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="INNODB AUXILIARY FTS DELETED TABLE" license="GPL" load-option="FORCE" context="INNODB_FT_DELETED" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="605c54a8-51b9-41b3-a68e-1104b280fe28" name="INNODB_FT_BEING_DELETED" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="INNODB AUXILIARY FTS BEING DELETED TABLE" license="GPL" load-option="FORCE" context="INNODB_FT_BEING_DELETED" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="d1c76f07-14ed-47f7-90bb-b6bfa6985d1c" name="INNODB_FT_CONFIG" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="INNODB AUXILIARY FTS CONFIG TABLE" license="GPL" load-option="FORCE" context="INNODB_FT_CONFIG" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="10826fb1-d37f-4505-8e99-eb7b180658f8" name="INNODB_FT_INDEX_CACHE" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="INNODB AUXILIARY FTS INDEX CACHED" license="GPL" load-option="FORCE" context="INNODB_FT_INDEX_CACHE" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="768d79a2-3436-4b1d-9de9-183d54dc7cbe" name="INNODB_FT_INDEX_TABLE" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="INNODB AUXILIARY FTS INDEX TABLE" license="GPL" load-option="FORCE" context="INNODB_FT_INDEX_TABLE" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="c7419b97-2183-442c-9aba-61150b2eed10" name="INNODB_TABLES" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="InnoDB INNODB_TABLES" license="GPL" load-option="FORCE" context="INNODB_TABLES" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="c675fa57-d180-4e51-a62b-321dde7151bf" name="INNODB_TABLESTATS" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="InnoDB INNODB_TABLESTATS" license="GPL" load-option="FORCE" context="INNODB_TABLESTATS" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="0ff4eff2-3371-440e-9383-fe8a5066b59f" name="INNODB_INDEXES" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="InnoDB INNODB_INDEXES" license="GPL" load-option="FORCE" context="INNODB_INDEXES" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="8857d2d5-6f7e-43c2-8027-1b1eb76cfb1f" name="INNODB_TABLESPACES" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="InnoDB INNODB_TABLESPACES" license="GPL" load-option="FORCE" context="INNODB_TABLESPACES" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="1888dbd7-42f2-451b-86d4-2c95903a3685" name="INNODB_COLUMNS" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="InnoDB INNODB_COLUMNS" license="GPL" load-option="FORCE" context="INNODB_COLUMNS" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="edaf54e2-cd44-4437-af92-e2e1ecc70332" name="INNODB_VIRTUAL" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="InnoDB INNODB_VIRTUAL" license="GPL" load-option="FORCE" context="INNODB_VIRTUAL" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="6d2b9a05-22cb-4455-a593-c066fa758ff5" name="INNODB_CACHED_INDEXES" version="9.2" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="InnoDB cached indexes" license="GPL" load-option="FORCE" context="INNODB_CACHED_INDEXES" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="abf9a0bb-04ff-4fc7-81c8-5d683aab052f" name="INNODB_SESSION_TEMP_TABLESPACES" version="9.0" status="ACTIVE" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="InnoDB Session Temporary tablespaces" license="GPL" load-option="FORCE" context="INNODB_SESSION_TEMP_TABLESPACES" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="67685067-7402-4030-961b-8774c86ca92c" name="MyISAM" version="1.0" status="ACTIVE" type="STORAGE ENGINE" type-version="90001.0" author="Oracle Corporation" description="MyISAM storage engine" license="GPL" load-option="FORCE" context="MyISAM" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="afab6016-71c6-42b1-84aa-a557148727cb" name="MRG_MYISAM" version="1.0" status="ACTIVE" type="STORAGE ENGINE" type-version="90001.0" author="Oracle Corporation" description="Collection of identical MyISAM tables" license="GPL" load-option="FORCE" context="MRG_MYISAM" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="044a68ce-624b-4c43-9ee1-4ba6b7b7c553" name="PERFORMANCE_SCHEMA" version="0.1" status="ACTIVE" type="STORAGE ENGINE" type-version="90001.0" author="Oracle Corporation" description="Performance Schema" license="GPL" load-option="FORCE" context="PERFORMANCE_SCHEMA" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="98da70a4-2088-439e-a6dd-0bc480ced9b4" name="TempTable" version="1.0" status="ACTIVE" type="STORAGE ENGINE" type-version="90001.0" author="Oracle Corporation" description="InnoDB temporary storage engine" license="GPL" load-option="FORCE" context="TempTable" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="00ceb219-0221-4c1e-8c8b-b4fc358b3316" name="ARCHIVE" version="3.0" status="ACTIVE" type="STORAGE ENGINE" type-version="90001.0" author="Oracle Corporation" description="Archive storage engine" license="GPL" load-option="ON" context="ARCHIVE" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="bcb8718c-0929-4ec2-8b4c-e122df646f66" name="BLACKHOLE" version="1.0" status="ACTIVE" type="STORAGE ENGINE" type-version="90001.0" author="Oracle Corporation" description="/dev/null storage engine (anything you write to it disappears)" license="GPL" load-option="ON" context="BLACKHOLE" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="38bd2848-3524-4e5d-9b9c-b78fa3fbfdac" name="FEDERATED" version="1.0" status="DISABLED" type="STORAGE ENGINE" type-version="90001.0" author="Oracle Corporation" description="Federated MySQL storage engine" license="GPL" load-option="OFF" context="FEDERATED" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="7f31cb45-372d-4327-8f44-bcd4c826ce4c" name="ndbcluster" version="1.0" status="DISABLED" type="STORAGE ENGINE" type-version="90001.0" author="Oracle Corporation" description="Clustered, fault-tolerant tables" license="GPL" load-option="OFF" context="ndbcluster" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="1efb4e7b-704e-4462-86dc-6b5c30012245" name="ndbinfo" version="0.1" status="DISABLED" type="STORAGE ENGINE" type-version="90001.0" author="Oracle Corporation" description="MySQL Cluster system information storage engine" license="GPL" load-option="OFF" context="ndbinfo" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="6b9a4646-9729-455c-ab40-f92034660348" name="ndb_transid_mysql_connection_map" version="0.1" status="DISABLED" type="INFORMATION SCHEMA" type-version="90001.0" author="Oracle Corporation" description="Map between MySQL connection ID and NDB transaction ID" license="GPL" load-option="OFF" context="ndb_transid_mysql_connection_map" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="0c90a077-8f5b-4f7e-b5d2-48980e068a3a" name="ngram" version="0.1" status="ACTIVE" type="FTPARSER" type-version="1.1" author="Oracle Corporation" description="Ngram Full-Text Parser" license="GPL" load-option="ON" context="ngram" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="338df06f-03f3-485a-a718-efb2981d56af" name="mysqlx_cache_cleaner" version="1.0" status="ACTIVE" type="AUDIT" type-version="4.1" author="Oracle Corporation" description="Cache cleaner for sha2 authentication in X plugin" license="GPL" load-option="ON" context="mysqlx_cache_cleaner" subcategories-loading="full" object-loading="extended"/>
            <plugin _I_D="6a971e00-c773-42bd-9815-b4e887e54938" name="mysqlx" version="1.0" status="ACTIVE" type="DAEMON" type-version="90001.0" author="Oracle Corporation" description="X Plugin for MySQL" license="GPL" load-option="ON" context="mysqlx" subcategories-loading="full" object-loading="extended"/>
        </category>
        <category _I_D="846f5a36-90d0-4809-b72b-8a545d069bf9" name="AWS Oracle Extensions" order-num="3" objects-loading="main" subcategories-loading="none" child-type="extension">
            <extension _I_D="30521e6f-46d0-4811-ad35-1449a5fb6982" name="Database sequence emulation" is-sequences-exists="1" context="Database sequence emulation" subcategories-loading="none" object-loading="main">
                <category _I_D="e13e7cf6-6b38-434c-ba75-a368c2100f90" name="User schemas" order-num="0" objects-loading="none" subcategories-loading="none" child-type="schema"/>
            </extension>
        </category>
        <category _I_D="4b5defcb-2ce1-4b98-915f-99029be359a6" name="AWS SQL Server Extensions" order-num="4" objects-loading="main" subcategories-loading="none" child-type="extension">
            <extension _I_D="3491c2ac-32a2-414a-a5d9-842fbc57e803" name="Database sequence emulation" is-sequences-exists="0" context="Database sequence emulation" subcategories-loading="none" object-loading="main">
                <category _I_D="c0970fc4-c800-4e11-b794-b29ccbbd648b" name="User schemas" order-num="0" objects-loading="none" subcategories-loading="none" child-type="schema"/>
            </extension>
        </category>
        <category _I_D="0e8e53f6-e38c-447a-8867-c7674b3d84e0" name="AWS PostgreSQL Extensions" order-num="5" objects-loading="main" subcategories-loading="none" child-type="extension">
            <extension _I_D="f0ecb77e-9c75-4f3e-becc-4779e1fead0c" name="Database sequence emulation" is-sequences-exists="0" context="Database sequence emulation" subcategories-loading="none" object-loading="main">
                <category _I_D="0f2e7ef6-a285-4440-8e9e-df79b4b4c9d2" name="User schemas" order-num="0" objects-loading="none" subcategories-loading="none" child-type="schema"/>
            </extension>
        </category>
        <category _I_D="1abdcb1c-6baa-4100-bfb1-56f004b3dc20" name="AWS DB2zOS Extensions" order-num="6" objects-loading="main" subcategories-loading="none" child-type="extension">
            <extension _I_D="a67e9214-586d-4aa2-9027-e1ad4262e3e4" name="Database sequence emulation" is-sequences-exists="0" context="Database sequence emulation" subcategories-loading="none" object-loading="main">
                <category _I_D="9a69a5b0-4693-4ca5-882d-ff5023814fde" name="User schemas" order-num="0" objects-loading="none" subcategories-loading="none" child-type="schema"/>
            </extension>
        </category>
    </metadata>
</tree>