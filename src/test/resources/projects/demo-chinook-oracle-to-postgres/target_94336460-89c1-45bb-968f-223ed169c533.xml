<?xml version="1.0" encoding="UTF-8"?>
<tree>
    <complex-attributes>
        <type name="materialized-view">
            <attr name="sql"></attr>
        </type>
        <type name="view">
            <attr name="sql"></attr>
        </type>
        <type name="metadata">
            <attr name="vendor-engine"></attr>
        </type>
        <type name="function">
            <attr name="sql"></attr>
        </type>
        <type name="constraint">
            <attr name="check-clause"></attr>
        </type>
        <type name="trigger">
            <attr name="trigger-definition"></attr>
            <attr name="comment"></attr>
            <attr name="sql"></attr>
        </type>
        <type name="procedure">
            <attr name="sql"></attr>
        </type>
    </complex-attributes>
    <metadata _I_D="a01dc496-eb3e-42b6-8c6d-a093a9aaf9ae" vendor="POSTGRESQL" name="Chinook (Postgres from Oracle)" metaStorageUuid="94336460-89c1-45bb-968f-223ed169c533" nonquoted-case="lower" allow-similarly-named-objects="y" quoted-case="specified" connection-data="postgres@192.168.0.10:5432/chinook_from_oracle" product-version="16.3.0.0" vendor-engine-version="16.3" mdl-waiting-complex-attributes="" connection-identifier="dc1eb997aa1c84ff4f76774bbe4bc12b" max-identifier-length="63">
        <complex-attribute name="vendor-engine"><![CDATA[PostgreSQL 16.3 (Debian 16.3-1.pgdg120+1) on aarch64-unknown-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit]]></complex-attribute>
        <category _I_D="3f78c1e3-3182-4098-b438-261139c7054a" name="Schemas" order-num="0" objects-loading="extended" subcategories-loading="none" child-type="schema">
            <schema _I_D="bd7cb0e3-b644-4808-8007-a06d5bb9d0aa" name="aws_oracle_ext" is-empty="N" context="aws_oracle_ext" subcategories-loading="none" object-loading="extended" schema-owner="postgres" is-system="N">
                <category _I_D="7e6ea12c-cdc2-41d3-9c57-3e9c5bc9d4b6" name="Tables" order-num="0" objects-loading="main" subcategories-loading="none" child-type="table">
                    <table _I_D="76a99868-81e6-4c08-a37c-20a4c3cd4e65" name="charset_mapping" context="charset_mapping" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO" comment="Oracle - PostgreSQL Charset mapping">
                        <category _I_D="2e651bba-7808-4c04-a535-28a7937b6e93" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="68212b57-710e-497d-8157-86b0deabd022" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="02e92eb5-074e-468d-ba99-2be6fcda0507" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="0338ded5-2821-467c-945b-2c78218bcd02" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="aba7eaec-620d-416b-8f5b-aa2decbf10b9" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="b835492a-667b-47b8-a517-8403215297a4" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="1a17b681-d3a8-4885-a8bc-459b104072d1" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="06737add-da1e-41f0-90cb-713dde584360" name="directories" context="directories" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO" comment="Describes all directories in the database.">
                        <category _I_D="6d371372-a6cb-4d9a-aabf-13243367acd8" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="09ba1e51-2696-4ebb-833a-6ff173a031c2" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="6e4a5845-894d-4efa-a51a-5b20d2a95dec" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="76fb7ea9-de1b-4e0b-be7d-0b22dd9e694d" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="c0a420cb-ced3-4975-ad44-feaddba64879" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="d177c4b7-46d0-4739-a3e6-3f3035faeedd" name="Triggers" order-num="5" objects-loading="none" subcategories-loading="none" child-type="trigger" mdl-expected-node-count="1"/>
                        <category _I_D="40f11720-2834-41f7-9f40-24f976f64417" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="5da798de-b40d-4b3d-a0dd-0b32c9fc7148" name="format_models" context="format_models" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO" comment="Possible format models for to_char from Oracle">
                        <category _I_D="d815fd88-6110-4530-9cc9-cb1e10b56902" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="9ae3a9d9-b394-40be-af22-b3fc3d95d97f" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="931b9e7d-8afe-4364-bb4f-bbf7fa6d4fc5" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="c09d8552-3913-45e8-b3b6-0c7d82428939" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="790b0a99-a19a-4d33-9714-d9752e3977e0" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="c8058c1c-4595-4b83-8bb3-bd7309dce6e6" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="a57045d6-17ee-4aa6-a7f8-65bd3ab3cb36" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="d63ad8ea-4627-428d-ac40-d511bbc12df6" name="iso_currency_list" context="iso_currency_list" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="d52aedf1-0aa3-414f-8385-3f105c18802c" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="f0db2b6c-ee6b-446f-ad2f-9c0c1469fc41" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="79d17b51-11a4-4358-a26b-e59aa5023793" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="9b166501-3e74-4322-b858-3025536bab98" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="d720d44e-5892-4d2d-886a-bf9ebf1d4867" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="c6580e1a-5ac0-417d-8272-0d93194afbf5" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="398fd975-75a9-4cfb-b7ac-73ba0995b6cf" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="aa278a49-5e9b-459b-83fb-7122a5d8ceab" name="jobs" context="jobs" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO" comment="Jobs to be executed periodically">
                        <category _I_D="d887531c-7965-46fd-af7f-a9bd58dcadfa" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="c9dd2d72-9bcb-408c-bbb4-849823d753a0" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="c94d12d7-8490-4c19-9368-333e004196ed" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="23decf58-d2be-4a05-8655-9605dfa1281e" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="af40a577-2b46-4ca0-934c-31bbc8bed378" name="Indexes" order-num="4" objects-loading="none" subcategories-loading="none" child-type="index" mdl-expected-node-count="1"/>
                        <category _I_D="12283758-5efa-4802-857e-92ba22a9ddeb" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="045e7d43-5e28-4f9f-8744-f001375e3192" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="b337a25f-9d2e-4104-86c2-8d0a1362a3e5" name="mail_messages" context="mail_messages" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO" comment="Mail messages with their statuses">
                        <category _I_D="ce7b1aab-36fa-4675-98be-c38c7abb2092" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e3799aef-9d4a-47cd-92d4-0daa3ae2af25" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="bf4612c1-d0a3-41f9-b4b7-2595e17c67f5" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="2bac7e72-983a-4c9e-9656-d7e404ccc61f" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="7dc15b5c-0b17-4d9e-b526-6898e0989da8" name="Indexes" order-num="4" objects-loading="none" subcategories-loading="none" child-type="index" mdl-expected-node-count="1"/>
                        <category _I_D="12404bb2-40c8-4e1f-8aaa-7e04491f9e88" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="3346e85f-1a91-436f-9b88-374d6ade1116" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="2770250c-6a01-4b33-9e52-b24c773e6725" name="mapped_error_codes" context="mapped_error_codes" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO" comment="Error code mapping from Oracle built-in errors to PostgreSQL ones">
                        <category _I_D="9f14a003-1deb-4930-8c74-7086fde39f62" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="5892bf1f-130c-429a-a406-de3afc4f2ef7" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="db576ad9-112b-4a06-96eb-b67ec121b450" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="f86621b8-ea90-4f40-961e-2dffd6236c98" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="2e85f279-9ea1-4737-92af-3f392e5670ba" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="bd6335a5-df25-4962-9a54-eafe9f2cae82" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="058115b8-1230-4456-b879-604a3b1581ec" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="786836b8-8d72-4a30-84a2-a6d41ba9f6b7" name="nls_parameters" context="nls_parameters" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO" comment="Dictionary to store NLS related params transfered from Oracle.">
                        <category _I_D="120a1d38-5f0a-48e2-8f5f-cf0aa6d6d927" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="1d4161e0-7d2d-4e8e-9ca2-7b99a5017c6b" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="69257cf2-4b92-486e-89d8-a821cbaf56a8" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="0b248043-2307-4cdf-a2f1-68c3ec4d00fd" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="2ea1ef01-b658-4db7-8789-ddda8803849a" name="Indexes" order-num="4" objects-loading="none" subcategories-loading="none" child-type="index" mdl-expected-node-count="2"/>
                        <category _I_D="1451f738-c57f-4aea-9842-80d0b28db0a8" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="a446fd8c-c015-4657-93cc-0a46455f9d4b" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="958f8363-d70f-48df-9ed7-40c7def21353" name="plv8_js_modules" context="plv8_js_modules" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="d791b97c-800e-4bf4-9cbb-260b597d4de1" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="6086c428-1f6f-4b4c-b6aa-ed8da5390077" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="2bbaabb1-ae86-42a3-b27d-bceaf3cb3a9d" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="0cc5df18-a5bb-4795-bf43-3e2c6ef1bb7d" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="4c850862-29da-476c-b383-a7ccf73c9f38" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="5847c264-a425-4f8d-96d2-93beab574081" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="956a9407-21e2-402d-a80a-f813fb755d4c" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="b8763e89-8792-4e52-8544-745ae22d62ad" name="service_settings" context="service_settings" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO" comment="Settings for Extension Pack services">
                        <category _I_D="3b0447b4-2f83-4dab-a846-1a125bac2567" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="08cb5f11-4981-4207-9287-3f2f31797e27" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="4735056e-c1f4-48bd-b92d-1fa68b2ed602" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="852714aa-68ac-4011-8893-3f8849e95595" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="f1c57edb-854a-412e-a918-8696d814b658" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="ac597010-fe09-4327-a721-9401da454aea" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="15de888b-20f8-474b-ba1e-f4603dd98e0c" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="d39f210c-be6d-4c3d-ae0c-7d3100fcef6d" name="sqs_functions_settings" context="sqs_functions_settings" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="018da2d8-fd08-4820-bc31-e46855d62219" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="2e2bea26-695d-4844-a493-c1548337d1cd" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="a31784ab-52e3-47d6-b731-bc137d84f020" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="b7f2b028-98ed-4571-8b6d-76de53712563" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="ab3fde28-b93d-44c6-8efb-96aa6fa66eb5" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="e7b9ffe2-363e-42dd-b3e5-8db1d3ba4253" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="21e0ed2f-b851-4dd7-83e0-f78ef800457e" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="30de1bfd-a327-46cd-8e12-4eaafe013b5c" name="sqs_queues_settings" context="sqs_queues_settings" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="2ca54915-7b9c-4eed-b9a3-4efca27cad12" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="741911c8-518e-49d8-a0a6-f3b92557428c" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="65586908-fda0-40c2-8ab1-9b0401da5f49" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="4b762fcd-f379-4bad-8a17-3223945486e6" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="2"/>
                        <category _I_D="46ad44ff-2130-4f99-aec9-b0dde47deb39" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="f355399a-e6b9-49b4-b7eb-da7dc695eaae" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="0bde0ca2-dfbd-4c11-9d7f-7b00b5e7e289" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="c9d9a8a5-179b-4c4e-b268-7168c1b035fe" name="sqs_queues_tables" context="sqs_queues_tables" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="3bf26c3e-95b0-40d6-be82-cffa06969b4b" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="d38dd15c-d2f8-47dd-9de9-bec2cacda1ca" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="4f851696-aeb8-4b6f-8ba5-0808357ccb39" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="6da3e3de-38d5-4323-b2ba-d47f1c7197e3" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="4"/>
                        <category _I_D="8f1bd236-e283-49fb-a092-92fde16bbb4a" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="f691182d-26a4-40b7-8d7c-1ab4c6894c42" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="2d645a9a-37f8-487b-875e-5464a08aa46e" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                    <table _I_D="ad57aa8f-e84d-4e53-9b48-6f446085b28f" name="versions" context="versions" subcategories-loading="none" object-loading="extended" is-typed="NO" partitioned="NO" is-unlogged="NO">
                        <category _I_D="24f61258-0ef8-470a-846e-efbb12d5c41a" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="cc28c46c-78c6-4125-9679-57543022a399" name="Partition columns" order-num="1" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="796ccc07-abb1-4721-92b9-aa3783a947ac" name="Subpartition columns" order-num="2" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="59279444-5100-4d12-9c58-6df588988e59" name="Constraints" order-num="3" objects-loading="none" subcategories-loading="none" child-type="constraint" mdl-expected-node-count="1"/>
                        <category _I_D="dbbc0d1a-8146-4c3c-b626-c1edb95990f2" name="Indexes" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="index" mdl-expected-node-count="0"/>
                        <category _I_D="1b825540-8315-4ad5-aa04-3b976d4eb190" name="Triggers" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                        <category _I_D="c8308feb-a254-4b05-985b-077a310b25eb" name="Partitions" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="partition" mdl-expected-node-count="0"/>
                    </table>
                </category>
                <category _I_D="6878c4b0-4c62-4271-a235-b63edf7e8997" name="Foreign tables" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="foreigntable"/>
                <category _I_D="aa9f90ce-06a6-48d7-bef7-4f17fec74e46" name="Views" order-num="2" objects-loading="main" subcategories-loading="none" child-type="view">
                    <view _I_D="4aef8da5-a379-42d5-9f6e-ca54b0695493" name="sqs_vw_queues_settings" context="sqs_vw_queues_settings" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT s.qname,
    s.qpurename,
    s.url,
    s.arn,
    s.qtype,
    t.tschema,
    t.tname,
    t.tdatatypeschema,
    t.tdatatypename,
    concat('"', t.tschema, '"', '.', '"', t.tname, '"') AS quoted_table_name,
    concat('"', t.tdatatypeschema, '"', '.', '"', t.tdatatypename, '"') AS quoted_data_type
   FROM (aws_oracle_ext.sqs_queues_settings s
     JOIN aws_oracle_ext.sqs_queues_tables t ON ((s.tableid = t.id)));]]></complex-attribute>
                        <category _I_D="3df1f7e8-131a-48d2-8b32-83fadbdd9341" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="b8957872-6d1c-4b93-abc7-7ebf94fff088" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="8efa5fc2-57bb-4e76-a1f2-a2a924b6b499" name="sys_all_cons_columns" context="sys_all_cons_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="ALL_CONS_COLUMNS describes columns that are accessible to the current user and that are specified in constraints.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (x.cstrschema)::character varying(128) AS owner,
    (x.cstrname)::character varying(128) AS constraint_name,
    (x.tblname)::character varying(128) AS table_name,
    (x.colname)::character varying(4000) AS column_name,
    (rank() OVER (PARTITION BY x.cstrschema, x.tblname, x.cstrname ORDER BY x.colnum))::smallint AS "position"
   FROM (( SELECT DISTINCT nr.nspname,
            r.relname,
            r.relowner,
            a.attname,
            a.attnum,
            nc.nspname,
            c.conname
           FROM pg_namespace nr,
            pg_class r,
            pg_attribute a,
            pg_depend d,
            pg_namespace nc,
            pg_constraint c
          WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (d.refclassid = ('pg_class'::regclass)::oid) AND (d.refobjid = r.oid) AND (d.refobjsubid = a.attnum) AND (d.classid = ('pg_constraint'::regclass)::oid) AND (d.objid = c.oid) AND (c.connamespace = nc.oid) AND (c.contype = 'c'::"char") AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT a.attisdropped))
        UNION ALL
         SELECT nr.nspname,
            r.relname,
            r.relowner,
            a.attname,
            a.attnum,
            nc.nspname,
            c.conname
           FROM pg_namespace nr,
            pg_class r,
            pg_attribute a,
            pg_namespace nc,
            pg_constraint c
          WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (nc.oid = c.connamespace) AND (r.oid =
                CASE c.contype
                    WHEN 'f'::"char" THEN c.confrelid
                    ELSE c.conrelid
                END) AND (a.attnum = ANY (
                CASE c.contype
                    WHEN 'f'::"char" THEN c.confkey
                    ELSE c.conkey
                END)) AND (NOT a.attisdropped) AND (c.contype = ANY (ARRAY['p'::"char", 'u'::"char", 'f'::"char"])) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])))) x(tblschema, tblname, tblowner, colname, colnum, cstrschema, cstrname)
     JOIN pg_user u ON ((u.usesysid = x.tblowner)))
  WHERE ((u.usename = USER) OR aws_oracle_ext.has_column_privilege(((x.cstrschema)::text)::name, ((x.tblname)::text)::name, ((x.colname)::text)::name));]]></complex-attribute>
                        <category _I_D="778a0ac8-a61e-421e-9bb1-9e7243c05bc9" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e4d0d530-1ad9-4b01-9479-006d98e0e22e" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="87b40f16-f62a-400a-aa2b-ce3aa99d393b" name="sys_all_constraints" context="sys_all_constraints" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="ALL_CONSTRAINTS describes constraint definitions on tables accessible to the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspname)::character varying(30) AS owner,
    (c.conname)::character varying(30) AS constraint_name,
    (c.contype)::character varying(1) AS constraint_type,
    (cl.relname)::character varying(30) AS table_name,
    pg_get_constraintdef(c.oid) AS search_condition,
    (n_ref.nspname)::character varying(30) AS r_owner,
    (c_ref.conname)::character varying(30) AS r_constraint_name,
        CASE c.confdeltype
            WHEN 'a'::"char" THEN 'no action'::character varying(9)
            WHEN 'r'::"char" THEN 'restrict'::character varying(9)
            WHEN 'c'::"char" THEN 'cascade'::character varying(9)
            WHEN 'n'::"char" THEN 'set null'::character varying(9)
            WHEN 'd'::"char" THEN 'set default'::character varying(11)
            ELSE NULL::character varying(9)
        END AS delete_rule,
    'ENABLED'::character varying(8) AS status,
        CASE
            WHEN c.condeferrable THEN 'DEFERRABLE'::character varying(14)
            ELSE 'NOT DEFERRABLE'::character varying(14)
        END AS "deferrable",
        CASE
            WHEN c.condeferred THEN 'DEFERRED'::character varying(9)
            ELSE 'IMMEDIATE'::character varying(9)
        END AS deferred,
        CASE
            WHEN c.convalidated THEN 'VALIDATED'::character varying(13)
            ELSE 'NOT VALIDATED'::character varying(13)
        END AS validated,
    'GENERATED NAME'::character varying(14) AS generated,
    NULL::character varying(3) AS bad,
    NULL::character varying(4) AS rely,
    NULL::date AS last_change,
    (n.nspname)::character varying(30) AS index_owner,
    (cl_ind.relname)::character varying(30) AS index_name,
    NULL::character varying(7) AS invalid,
    NULL::character varying(14) AS view_related
   FROM ((((((((pg_constraint c
     JOIN pg_namespace n ON ((n.oid = c.connamespace)))
     JOIN pg_class cl ON ((cl.oid = c.conrelid)))
     JOIN pg_user u ON ((cl.relowner = u.usesysid)))
     LEFT JOIN pg_class cl_ref ON ((cl_ref.oid = c.confrelid)))
     LEFT JOIN pg_namespace n_ref ON ((n_ref.oid = cl_ref.relnamespace)))
     LEFT JOIN pg_constraint c_ref ON (((c_ref.conrelid = c.confrelid) AND (c_ref.contype = 'p'::"char"))))
     LEFT JOIN pg_index i ON ((i.indrelid = cl_ref.oid)))
     LEFT JOIN pg_class cl_ind ON ((cl_ind.oid = c.conindid)))
  WHERE ((u.usename = USER) OR has_table_privilege(((quote_ident((n_ref.nspname)::text) || '.'::text) || quote_ident((cl.relname)::text)), 'SELECT,INSERT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER'::text));]]></complex-attribute>
                        <category _I_D="93a77c14-05ce-4d50-874e-a3820c9635d7" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="a48f69d5-aecd-47b2-bf29-2ef68c3f4e12" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="e2e61fee-6e34-4560-b12b-fabf69570573" name="sys_all_directories" context="sys_all_directories" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="Describes all directories accessible to the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT owner,
    directory_name,
    directory_path,
    s3_bucket_name,
    s3_bucket_path,
    aws_region,
    origin_con_id
   FROM aws_oracle_ext.sys_dba_directories;]]></complex-attribute>
                        <category _I_D="dee42ab0-f5a7-4bdb-a79b-d6477335e6f1" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="6af7949e-a028-4152-965f-b40ee3d48719" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="a94b0650-cf8f-4fef-a908-ed8ca06e5910" name="sys_all_ind_columns" context="sys_all_ind_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="ALL_IND_COLUMNS describes the columns of indexes on all tables accessible to the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (insp.nspname)::character varying(128) AS index_owner,
    (irel.relname)::character varying(128) AS index_name,
    (tnsp.nspname)::character varying(128) AS table_owner,
    (trel.relname)::character varying(128) AS table_name,
    (a.attname)::character varying(4000) AS column_name,
    (c.ordinality)::integer AS column_position,
    COALESCE(information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)), information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))) AS column_length,
    COALESCE(information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)), 0) AS char_length,
    (
        CASE ((o.option)::integer & 1)
            WHEN 1 THEN 'DESC'::text
            ELSE 'ASC'::text
        END)::character varying(4) AS descend,
    NULL::integer AS collated_column_id
   FROM ((((((((pg_index i
     JOIN pg_class trel ON ((trel.oid = i.indrelid)))
     JOIN pg_namespace tnsp ON ((trel.relnamespace = tnsp.oid)))
     JOIN pg_class irel ON ((irel.oid = i.indexrelid)))
     JOIN pg_namespace insp ON ((irel.relnamespace = insp.oid)))
     CROSS JOIN LATERAL unnest(i.indkey) WITH ORDINALITY c(colnum, ordinality))
     LEFT JOIN LATERAL unnest(i.indoption) WITH ORDINALITY o(option, ordinality) ON ((c.ordinality = o.ordinality)))
     JOIN pg_attribute a ON (((trel.oid = a.attrelid) AND (a.attnum = c.colnum))))
     JOIN (pg_type t
     JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((a.atttypid = t.oid)))
  WHERE (pg_has_role(trel.relowner, 'USAGE'::text) OR has_table_privilege(trel.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text));]]></complex-attribute>
                        <category _I_D="dcdcc175-bf0c-4058-892c-3f59e760ab93" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="9e843b46-99d6-461e-83d8-97c8728fb4f7" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="3357ecb0-c5ff-4378-a31a-e1e40a338139" name="sys_all_indexes" context="sys_all_indexes" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="ALL_INDEXES describes the indexes on the tables accessible to the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (tnsp.nspname)::character varying(128) AS owner,
    (irel.relname)::character varying(128) AS index_name,
    (
        CASE
            WHEN (i.indexprs IS NULL) THEN 'NORMAL'::text
            ELSE 'FUNCTION-BASED NORMAL'::text
        END)::character varying(27) AS index_type,
    (tnsp.nspname)::character varying(128) AS table_owner,
    (trel.relname)::character varying(128) AS table_name,
    'TABLE'::character varying(11) AS table_type,
    (
        CASE
            WHEN i.indisunique THEN 'UNIQUE'::text
            ELSE 'NONUNIQUE'::text
        END)::character varying(9) AS uniqueness,
    'DISABLED'::character varying(13) AS compression,
    NULL::integer AS prefix_length,
    (ts.spcname)::character varying(30) AS tablespace_name,
    NULL::integer AS ini_trans,
    NULL::integer AS max_trans,
    NULL::integer AS initial_extent,
    NULL::integer AS next_extent,
    NULL::integer AS min_extents,
    NULL::integer AS max_extents,
    NULL::integer AS pct_increase,
    NULL::integer AS pct_threshold,
    NULL::integer AS include_column,
    NULL::integer AS freelists,
    NULL::integer AS freelist_groups,
    NULL::integer AS pct_free,
    (
        CASE trel.relpersistence
            WHEN 'p'::"char" THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS logging,
    NULL::integer AS blevel,
    NULL::integer AS leaf_blocks,
    (
        CASE
            WHEN i.indisprimary THEN st.n_live_tup
            ELSE NULL::bigint
        END)::integer AS distinct_keys,
    NULL::integer AS avg_leaf_blocks_per_key,
    NULL::integer AS avg_data_blocks_per_key,
    NULL::integer AS clustering_factor,
    (
        CASE
            WHEN i.indisready THEN 'ENABLED'::text
            ELSE 'DISABLED'::text
        END)::character varying(8) AS status,
    (st.n_live_tup)::integer AS num_rows,
    NULL::integer AS sample_size,
    (COALESCE(st.last_autoanalyze, st.last_analyze))::date AS last_analyzed,
    NULL::character varying(40) AS degree,
    NULL::character varying(40) AS instances,
    (
        CASE
            WHEN trel.relispartition THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS partitioned,
    (
        CASE trel.relpersistence
            WHEN 't'::"char" THEN 'Y'::text
            ELSE 'N'::text
        END)::character varying(1) AS temporary,
    'N'::character varying(1) AS generated,
    'N'::character varying(1) AS secondary,
    'DEFAULT'::character varying(7) AS buffer_pool,
    'DEFAULT'::character varying(7) AS flash_cache,
    'DEFAULT'::character varying(7) AS cell_flash_cache,
    'NO'::character varying(3) AS user_stats,
    NULL::character varying(15) AS duration,
    NULL::integer AS pct_direct_access,
    NULL::character varying(128) AS ityp_owner,
    NULL::character varying(128) AS ityp_name,
    NULL::character varying(1000) AS parameters,
    'NO'::character varying(3) AS global_stats,
    NULL::character varying(12) AS domidx_status,
    NULL::character varying(6) AS domidx_opstatus,
    NULL::character varying(8) AS funcidx_status,
    'NO'::character varying(3) AS join_index,
    'NO'::character varying(3) AS iot_redundant_pkey_elim,
    'NO'::character varying(3) AS dropped,
    (
        CASE
            WHEN i.indisvalid THEN 'VISIBLE'::text
            ELSE 'INVISIBLE'::text
        END)::character varying(9) AS visibility,
    NULL::character varying(14) AS domidx_management,
    (
        CASE irel.relpages
            WHEN 0 THEN 'NO'::text
            ELSE 'YES'::text
        END)::character varying(3) AS segment_created,
    'NO'::character varying(3) AS orphaned_entries,
    (
        CASE
            WHEN (i.indpred IS NULL) THEN 'FULL'::text
            ELSE 'PARTIAL'::text
        END)::character varying(7) AS indexing
   FROM ((((((pg_index i
     JOIN pg_class trel ON ((trel.oid = i.indrelid)))
     JOIN pg_namespace tnsp ON ((trel.relnamespace = tnsp.oid)))
     JOIN pg_class irel ON ((irel.oid = i.indexrelid)))
     JOIN pg_am am ON (((am.oid = irel.relam) AND (am.amname = 'btree'::name))))
     LEFT JOIN pg_tablespace ts ON ((ts.oid = irel.reltablespace)))
     LEFT JOIN pg_stat_all_tables st ON (((st.schemaname = tnsp.nspname) AND (st.relname = trel.relname))))
  WHERE (pg_has_role(trel.relowner, 'USAGE'::text) OR has_table_privilege(trel.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text));]]></complex-attribute>
                        <category _I_D="5f2c600b-85c7-4c09-a345-830acfcc011d" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="df07b811-9f77-42f1-ba4f-8f0c3faf6eeb" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="e7518b22-f201-4329-b1f8-80b72ed769ce" name="sys_all_objects" context="sys_all_objects" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="The ALL_OBJECTS view describes all objects in the database that are accessible to the current user">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspname)::character varying(30) AS owner,
    (c.relname)::character varying(30) AS object_name,
    NULL::character varying(30) AS subobject_name,
    (c.oid)::bigint AS object_id,
        CASE
            WHEN (c.relkind = ANY (ARRAY['t'::"char", 'r'::"char"])) THEN (c.oid)::bigint
            ELSE NULL::bigint
        END AS data_object_id,
        CASE c.relkind
            WHEN 'r'::"char" THEN 'ordinary table'::character varying(17)
            WHEN 'i'::"char" THEN 'index'::character varying(17)
            WHEN 'S'::"char" THEN 'sequence'::character varying(17)
            WHEN 'v'::"char" THEN 'view'::character varying(17)
            WHEN 'c'::"char" THEN 'composite type'::character varying(17)
            WHEN 't'::"char" THEN 'TOAST table'::character varying(17)
            WHEN 'f'::"char" THEN 'foreign table'::character varying(17)
            ELSE NULL::character varying(17)
        END AS object_type,
    NULL::date AS created,
    NULL::date AS last_ddl_time,
    NULL::character varying(78) AS "timestamp",
    'VALID'::character varying(7) AS status,
        CASE c.relpersistence
            WHEN 't'::"char" THEN 'Y'::text
            ELSE 'N'::text
        END AS temporary,
    'N'::character varying(1) AS generated,
    'N'::character varying(1) AS secondary,
    (c.reltablespace)::integer AS namespace,
    NULL::character varying(30) AS edition_name
   FROM ((pg_class c
     JOIN pg_namespace n ON ((c.relnamespace = n.oid)))
     JOIN pg_user u ON ((c.relowner = u.usesysid)))
  WHERE ((n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])) AND ((u.usename = USER) OR ((c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'p'::"char"])) AND (NOT c.relispartition) AND has_table_privilege(((quote_ident((n.nspname)::text) || '.'::text) || quote_ident((c.relname)::text)), 'SELECT,INSERT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER'::text))));]]></complex-attribute>
                        <category _I_D="be079f5b-de98-40a7-ac0d-53e877132eec" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="428922c2-5770-4263-8921-3071d4f71e03" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="77f61b76-e5f5-4b22-b11a-59d0fe4e2ab7" name="sys_all_policies" context="sys_all_policies" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="ALL_POLICIES describes all Oracle Virtual Private Database (VPD) security policies for objects accessible to the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (p.schemaname)::character varying(128) AS object_owner,
    (p.tablename)::character varying(128) AS object_name,
    'SYS_DEFAULT'::character varying(128) AS policy_group,
    (p.policyname)::character varying(128) AS policy_name,
    (p.schemaname)::character varying(128) AS pf_owner,
    NULL::character varying(128) AS package,
    NULL::character varying(128) AS function,
    (
        CASE
            WHEN (p.cmd = ANY (ARRAY['ALL'::text, 'SELECT'::text])) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS sel,
    (
        CASE
            WHEN (p.cmd = ANY (ARRAY['ALL'::text, 'INSERT'::text])) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS ins,
    (
        CASE
            WHEN (p.cmd = ANY (ARRAY['ALL'::text, 'UPDATE'::text])) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS upd,
    (
        CASE
            WHEN (p.cmd = ANY (ARRAY['ALL'::text, 'DELETE'::text])) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS del,
    'NO'::character varying(3) AS idx,
    (
        CASE
            WHEN (p.with_check IS NOT NULL) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS chk_option,
    'YES'::character varying(3) AS enable,
    'NO'::character varying(3) AS static_policy,
    'DYNAMIC'::character varying(24) AS policy_type,
    'NO'::character varying(3) AS long_predicate,
    'NO'::character varying(3) AS common,
    'NO'::character varying(3) AS inherited
   FROM ((pg_policies p
     JOIN pg_tables t ON (((t.schemaname = p.schemaname) AND (t.tablename = p.tablename))))
     JOIN pg_user u ON ((u.usename = t.tableowner)))
  WHERE (pg_has_role(t.tableowner, 'USAGE'::text) OR has_table_privilege(u.usesysid, 'SELECT, INSERT, UPDATE, DELETE'::text));]]></complex-attribute>
                        <category _I_D="e100edae-1c79-4281-9fb6-7b5c67054658" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="d22ac223-3f2a-420d-9b48-e708cf4f9a4f" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="f214bb73-7783-4d90-90a0-eb72cb3a0916" name="sys_all_sequences" context="sys_all_sequences" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="ALL_SEQUENCES describes all sequences accessible to the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (s.schemaname)::character varying(30) AS sequence_owner,
    (s.sequencename)::character varying(30) AS sequence_name,
    (s.min_value)::numeric AS min_value,
    (s.max_value)::numeric AS max_value,
    (s.increment_by)::numeric AS increment_by,
        CASE s.cycle
            WHEN false THEN 'N'::character varying(1)
            WHEN true THEN 'Y'::character varying(1)
            ELSE NULL::character varying
        END AS cycle_flag,
    'N'::character varying(1) AS order_flag,
    s.cache_size,
    s.last_value AS last_number
   FROM ((pg_sequences s
     JOIN pg_class c ON (((c.relname = s.sequencename) AND (c.relkind = 'S'::"char"))))
     JOIN pg_user u ON ((c.relowner = u.usesysid)))
  WHERE ((u.usename = USER) OR has_sequence_privilege(((quote_ident((s.schemaname)::text) || '.'::text) || quote_ident((s.sequencename)::text)), 'USAGE,SELECT,UPDATE'::text));]]></complex-attribute>
                        <category _I_D="907236bd-cddb-4f5e-a40f-bbfeeb3a682d" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="acfcef05-381a-4718-ae9e-b7c017538d74" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="7b112c5a-72f0-491a-986f-ca15554da8e3" name="sys_all_source" context="sys_all_source" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspowner)::character varying(30) AS owner,
    (s.name)::character varying(30) AS name,
    (s.type)::character varying(12) AS type,
    (generate_subscripts(s.text, 1))::numeric AS line,
    (unnest(s.text))::character varying(4000) AS text
   FROM (( SELECT c.relnamespace AS nsp,
            t.tgname AS name,
            'TRIGGER'::text AS type,
            string_to_array(pg_get_triggerdef(t.oid), chr(10)) AS text
           FROM ((pg_trigger t
             JOIN pg_class c ON ((c.oid = t.tgrelid)))
             JOIN pg_user u ON ((u.usesysid = c.relowner)))
          WHERE ((u.usename = USER) OR has_table_privilege(USER, c.oid, 'TRIGGER'::text))
        UNION ALL
         SELECT f.pronamespace AS nsp,
            f.proname AS name,
                CASE
                    WHEN (f.prokind = 'f'::"char") THEN 'FUNCTION'::text
                    WHEN (f.prokind = 'p'::"char") THEN 'PROCEDURE'::text
                    ELSE NULL::text
                END AS type,
            string_to_array(pg_get_functiondef(f.oid), chr(10)) AS text
           FROM ((pg_proc f
             JOIN pg_type ret ON ((f.prorettype = ret.oid)))
             JOIN pg_user u ON ((u.usesysid = f.proowner)))
          WHERE ((f.prokind = ANY (ARRAY['f'::"char", 'p'::"char"])) AND ((u.usename = USER) OR has_function_privilege(USER, f.oid, 'EXECUTE'::text)))
        UNION ALL
         SELECT t.typnamespace AS nsp,
            t.typname AS name,
            'TYPE'::text AS type,
                CASE
                    WHEN (t.typtype = 'c'::"char") THEN ARRAY( SELECT ((('CREATE OR REPLACE TYPE '::text || (t.typname)::text) || ' AS ('::text) || chr(10))
                    UNION ALL
                     SELECT (((((a.attname)::text || ' '::text) || format_type(a.atttypid, a.atttypmod)) ||
                            CASE
                                WHEN (lead(a.attrelid, 1) OVER () IS NULL) THEN ''::text
                                ELSE ','::text
                            END) || chr(10))
                       FROM pg_attribute a
                      WHERE (a.attrelid = t.typrelid)
                    UNION ALL
                     SELECT ');'::text)
                    WHEN (t.typtype = 'd'::"char") THEN ARRAY( SELECT ((('CREATE OR REPLACE DOMAIN '::text || (t.typname)::text) || ' AS '::text) || format_type(tt.oid, NULL::integer))
                       FROM pg_type tt
                      WHERE (tt.typarray = t.typbasetype))
                    ELSE NULL::text[]
                END AS text
           FROM (pg_type t
             JOIN pg_user u ON ((u.usesysid = t.typowner)))
          WHERE (((t.typrelid = (0)::oid) OR ( SELECT (c.relkind = 'c'::"char")
                   FROM pg_class c
                  WHERE (c.oid = t.typrelid))) AND (NOT (EXISTS ( SELECT 1
                   FROM pg_type el
                  WHERE ((el.oid = t.typelem) AND (el.typarray = t.oid))))) AND ((u.usename = USER) OR has_type_privilege(USER, t.oid, 'USAGE'::text)))) s
     JOIN pg_namespace n ON ((s.nsp = n.oid)))
  WHERE ((n.nspname <> 'pg_catalog'::name) AND (n.nspname <> 'information_schema'::name) AND (n.nspname !~ '^pg_toast'::text));]]></complex-attribute>
                        <category _I_D="37064e5d-8d16-4516-8385-ca711b106648" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="2c0414fa-3c25-48b3-a23e-d90ad61af30a" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="6be916f9-fba7-4ce8-b8e0-b0a962cf2a13" name="sys_all_tab_cols" context="sys_all_tab_cols" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="Describes the columns of the tables, views, and clusters accessible to the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspname)::character varying(30) AS owner,
    (c.relname)::character varying(30) AS table_name,
    (a.attname)::character varying(30) AS column_name,
    (format_type(a.atttypid, a.atttypmod))::character varying(106) AS data_type,
    NULL::character varying(3) AS data_type_mod,
    NULL::character varying(30) AS data_type_owner,
    (a.attlen)::numeric AS data_length,
    NULL::numeric AS data_precision,
    NULL::numeric AS data_scale,
        CASE
            WHEN a.attnotnull THEN 'N'::character varying(1)
            ELSE 'Y'::character varying(1)
        END AS nullable,
    (a.attnum)::numeric AS column_id,
    NULL::numeric AS default_length,
    pg_get_expr(d.adbin, d.adrelid) AS data_default,
    (s.n_distinct)::numeric AS num_distinct,
    NULL::numeric AS low_value,
    NULL::numeric AS high_value,
    (s.null_frac)::numeric AS density,
    NULL::numeric AS num_nulls,
    NULL::numeric AS num_buckets,
    (COALESCE(st.last_autoanalyze, st.last_analyze))::date AS last_analyzed,
    NULL::numeric AS sample_size,
    'NCHAR_CS'::character varying(44) AS character_set_name,
    NULL::numeric AS char_col_decl_length,
        CASE
            WHEN (COALESCE(st.last_autoanalyze, st.last_analyze) IS NOT NULL) THEN 'YES'::character varying(3)
            ELSE 'NO'::character varying(3)
        END AS global_stats,
    'NO'::character varying(3) AS user_stats,
    (s.avg_width)::numeric AS avg_col_len,
    information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)) AS char_length,
    NULL::character varying(1) AS char_used,
    NULL::character varying(3) AS v80_fmt_image,
    NULL::character varying(3) AS data_upgraded,
    'NO'::character varying(3) AS hidden_column,
    'NO'::character varying(3) AS virtual_column,
    (a.attnum)::numeric AS segment_column_id,
    (a.attnum)::numeric AS internal_column_id,
    'NONE'::character varying(4) AS histogram,
    (a.attname)::character varying(4000) AS qualified_col_name
   FROM (((((((pg_attribute a
     JOIN pg_class c ON ((c.oid = a.attrelid)))
     JOIN pg_user u ON ((c.relowner = u.usesysid)))
     JOIN pg_type t ON ((a.atttypid = t.oid)))
     LEFT JOIN pg_attrdef d ON (((c.oid = d.adrelid) AND (a.attnum = d.adnum))))
     JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
     LEFT JOIN pg_stats s ON (((s.schemaname = n.nspname) AND (s.tablename = c.relname) AND (s.attname = a.attname))))
     LEFT JOIN pg_stat_user_tables st ON ((st.relid = c.oid)))
  WHERE ((a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND ((u.usename = USER) OR aws_oracle_ext.has_column_privilege(n.nspname, c.relname, a.attname)) AND (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])));]]></complex-attribute>
                        <category _I_D="eb296512-1f20-4936-826c-18f8d16a3390" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="385794c8-462b-40cf-94ac-c7d5d51c6e25" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="24e15668-eee8-4284-bca1-0ef26a22a46f" name="sys_all_tab_columns" context="sys_all_tab_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="ALL_TAB_COLUMNS describes the columns of the tables, views, and clusters accessible to the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspname)::character varying(30) AS owner,
    (c.relname)::character varying(30) AS table_name,
    (a.attname)::character varying(30) AS column_name,
    (format_type(a.atttypid, a.atttypmod))::character varying(106) AS data_type,
    NULL::character varying(3) AS data_type_mod,
    NULL::character varying(30) AS data_type_owner,
    COALESCE((information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::numeric, (a.attlen)::numeric) AS data_length,
    NULL::numeric AS data_precision,
    NULL::numeric AS data_scale,
        CASE
            WHEN a.attnotnull THEN 'N'::character varying(1)
            ELSE 'Y'::character varying(1)
        END AS nullable,
    (a.attnum)::numeric AS column_id,
    NULL::numeric AS default_length,
    pg_get_expr(d.adbin, d.adrelid) AS data_default,
    (s.n_distinct)::numeric AS num_distinct,
    NULL::numeric AS low_value,
    NULL::numeric AS high_value,
    (s.null_frac)::numeric AS density,
    NULL::numeric AS num_nulls,
    NULL::numeric AS num_buckets,
    (COALESCE(st.last_autoanalyze, st.last_analyze))::date AS last_analyzed,
    NULL::numeric AS sample_size,
    'NCHAR_CS'::character varying(44) AS character_set_name,
    NULL::numeric AS char_col_decl_length,
        CASE
            WHEN (COALESCE(st.last_autoanalyze, st.last_analyze) IS NOT NULL) THEN 'YES'::character varying(3)
            ELSE 'NO'::character varying(3)
        END AS global_stats,
    'NO'::character varying(3) AS user_stats,
    (s.avg_width)::numeric AS avg_col_len,
    information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)) AS char_length,
    NULL::character varying(1) AS char_used,
    NULL::character varying(3) AS v80_fmt_image,
    NULL::character varying(3) AS data_upgraded,
    'NONE'::character varying(4) AS histogram
   FROM (((((((pg_attribute a
     JOIN pg_class c ON ((c.oid = a.attrelid)))
     JOIN pg_user u ON ((c.relowner = u.usesysid)))
     LEFT JOIN pg_attrdef d ON (((c.oid = d.adrelid) AND (a.attnum = d.adnum))))
     JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
     JOIN pg_type t ON ((a.atttypid = t.oid)))
     LEFT JOIN pg_stats s ON (((s.schemaname = n.nspname) AND (s.tablename = c.relname) AND (s.attname = a.attname))))
     LEFT JOIN pg_stat_user_tables st ON ((st.relid = c.oid)))
  WHERE ((a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND ((u.usename = USER) OR aws_oracle_ext.has_column_privilege(n.nspname, c.relname, a.attname)) AND (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])));]]></complex-attribute>
                        <category _I_D="5bfdd140-38f4-434c-84d8-1c3acf751576" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="91479fea-ce03-47ce-8f43-0186c39b2c3c" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="eeb4cce2-1fe6-4dee-93ac-9b2c7159f523" name="sys_all_tab_comments" context="sys_all_tab_comments" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspname)::character varying(30) AS owner,
    (c.relname)::character varying(30) AS table_name,
        CASE
            WHEN (c.relkind = 'r'::"char") THEN 'TABLE'::text
            WHEN (c.relkind = 'v'::"char") THEN 'VIEW'::text
            ELSE NULL::text
        END AS table_type,
    (obj_description(c.oid))::character varying(4000) AS comments,
    (0)::numeric AS origin_con_id
   FROM (pg_class c
     JOIN pg_namespace n ON ((c.relnamespace = n.oid)))
  WHERE ((c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'p'::"char"])) AND (NOT c.relispartition) AND (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])) AND has_table_privilege(((quote_ident((n.nspname)::text) || '.'::text) || quote_ident((c.relname)::text)), 'SELECT,INSERT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER'::text));]]></complex-attribute>
                        <category _I_D="b66f95d3-930e-4254-a6ce-7e5198b40e61" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="1f363882-15fc-4298-802e-78f93b498da2" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="356e5719-7e93-4333-a88d-63852a9d3399" name="sys_all_tab_partitions" context="sys_all_tab_partitions" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT (ns.nspname)::character varying(128) AS table_owner,
    (pc1.relname)::character varying(128) AS table_name,
    (
        CASE
            WHEN (pc.relkind = 'p'::"char") THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS composite,
    (pc.relname)::character varying(128) AS partition_name,
    (
        CASE
            WHEN (pc.relkind <> 'p'::"char") THEN (0)::bigint
            ELSE ( SELECT count(*) AS count
               FROM pg_inherits spc
              WHERE (spc.inhparent = pc.oid))
        END)::numeric AS subpartition_count,
    NULL::text AS high_value,
    NULL::numeric AS high_value_length,
    NULL::numeric AS partition_position,
    (( SELECT ts.spcname
           FROM pg_tablespace ts
          WHERE (ts.oid = pc.reltablespace)))::character varying(30) AS tablespace_name,
    NULL::numeric AS pct_free,
    NULL::numeric AS pct_used,
    NULL::numeric AS ini_trans,
    NULL::numeric AS max_trans,
    NULL::numeric AS initial_extent,
    NULL::numeric AS next_extent,
    NULL::numeric AS min_extent,
    NULL::numeric AS max_extent,
    NULL::numeric AS max_size,
    NULL::numeric AS pct_increase,
    NULL::numeric AS freelists,
    NULL::numeric AS freelist_groups,
    NULL::character varying(7) AS logging,
    NULL::character varying(8) AS compression,
    NULL::character varying(30) AS compress_for,
    NULL::numeric AS num_rows,
    NULL::numeric AS blocks,
    NULL::numeric AS empty_blocks,
    NULL::numeric AS avg_space,
    NULL::numeric AS chain_cnt,
    NULL::numeric AS avg_row_len,
    NULL::numeric AS sample_size,
    NULL::timestamp(0) without time zone AS last_analyzed,
    NULL::character varying(7) AS buffer_pool,
    NULL::character varying(7) AS flash_cache,
    NULL::character varying(7) AS cell_flash_cache,
    NULL::character varying(3) AS global_stats,
    NULL::character varying(3) AS user_stats,
    NULL::character varying(3) AS is_nested,
    NULL::character varying(128) AS parent_table_partition,
    NULL::character varying(3) AS "interval",
    NULL::character varying(4) AS segment_created,
    NULL::character varying(4) AS indexing,
    NULL::character varying(4) AS read_only,
    NULL::character varying(8) AS inmemory,
    NULL::character varying(8) AS inmemory_priority,
    NULL::character varying(15) AS inmemory_distribute,
    NULL::character varying(17) AS inmemory_compression,
    NULL::character varying(13) AS inmemory_duplicate,
    NULL::character varying(24) AS cellmemory,
    NULL::character varying(12) AS inmemory_service,
    NULL::character varying(1000) AS inmemory_service_name,
    NULL::character varying(8) AS memoptimize_read,
    NULL::character varying(8) AS memoptimize_write
   FROM (((((pg_class pc
     JOIN pg_inherits pi ON ((pi.inhrelid = pc.oid)))
     JOIN pg_class pc1 ON ((pi.inhparent = pc1.oid)))
     JOIN pg_partitioned_table ppt ON ((ppt.partrelid = pi.inhparent)))
     JOIN pg_namespace ns ON ((ns.oid = pc.relnamespace)))
     JOIN pg_tables t ON (((t.tablename = pc1.relname) AND (t.schemaname = ns.nspname))))
  WHERE ((ns.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])) AND ((t.tableowner = USER) OR has_table_privilege(((quote_ident((ns.nspname)::text) || '.'::text) || quote_ident((pc1.relname)::text)), 'SELECT,INSERT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER'::text)) AND pc.relispartition AND (NOT (EXISTS ( SELECT 1
           FROM pg_class pcs
          WHERE (pcs.relispartition AND (pcs.oid = pi.inhparent))))));]]></complex-attribute>
                        <category _I_D="1e05eaa9-e339-4019-add4-171f9b74f924" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="a7827af0-6f28-4f66-a90d-5aaafeabbf66" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="0c5ba734-bf4b-4ba4-adcb-7162eb00b577" name="sys_all_tab_subpartitions" context="sys_all_tab_subpartitions" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT (ns.nspname)::character varying(128) AS table_owner,
    (pc2.relname)::character varying(128) AS table_name,
    (pc1.relname)::character varying(128) AS partition_name,
    (pc.relname)::character varying(128) AS subpartition_name,
    NULL::text AS high_value,
    NULL::numeric AS high_value_length,
    NULL::numeric AS partition_position,
    NULL::numeric AS subpartition_position,
    (( SELECT ts.spcname
           FROM pg_tablespace ts
          WHERE (ts.oid = pc.reltablespace)))::character varying(30) AS tablespace_name,
    NULL::numeric AS pct_free,
    NULL::numeric AS pct_used,
    NULL::numeric AS ini_trans,
    NULL::numeric AS max_trans,
    NULL::numeric AS initial_extent,
    NULL::numeric AS next_extent,
    NULL::numeric AS min_extent,
    NULL::numeric AS max_extent,
    NULL::numeric AS max_size,
    NULL::numeric AS pct_increase,
    NULL::numeric AS freelists,
    NULL::numeric AS freelist_groups,
    NULL::character varying(3) AS logging,
    NULL::character varying(8) AS compression,
    NULL::character varying(30) AS compress_for,
    NULL::numeric AS num_rows,
    NULL::numeric AS blocks,
    NULL::numeric AS empty_blocks,
    NULL::numeric AS avg_space,
    NULL::numeric AS chain_cnt,
    NULL::numeric AS avg_row_len,
    NULL::numeric AS sample_size,
    NULL::timestamp(0) without time zone AS last_analyzed,
    NULL::character varying(7) AS buffer_pool,
    NULL::character varying(7) AS flash_cache,
    NULL::character varying(7) AS cell_flash_cache,
    NULL::character varying(3) AS global_stats,
    NULL::character varying(3) AS user_stats,
    NULL::character varying(3) AS "interval",
    NULL::character varying(3) AS segment_created,
    NULL::character varying(3) AS indexing,
    NULL::character varying(3) AS read_only,
    NULL::character varying(8) AS inmemory,
    NULL::character varying(8) AS inmemory_priority,
    NULL::character varying(15) AS inmemory_distribute,
    NULL::character varying(17) AS inmemory_compression,
    NULL::character varying(13) AS inmemory_duplicate,
    NULL::character varying(12) AS inmemory_service,
    NULL::character varying(1000) AS inmemory_service_name,
    NULL::character varying(24) AS cellmemory,
    NULL::character varying(8) AS memoptimize_read,
    NULL::character varying(8) AS memoptimize_write
   FROM (((((((pg_class pc
     JOIN pg_inherits pis ON ((pis.inhrelid = pc.oid)))
     JOIN pg_class pc1 ON ((pis.inhparent = pc1.oid)))
     JOIN pg_partitioned_table ppt ON ((ppt.partrelid = pis.inhparent)))
     JOIN pg_namespace ns ON ((ns.oid = pc.relnamespace)))
     JOIN pg_inherits pi ON ((pis.inhparent = pi.inhrelid)))
     JOIN pg_class pc2 ON ((pi.inhparent = pc2.oid)))
     JOIN pg_tables t ON (((t.tablename = pc2.relname) AND (t.schemaname = ns.nspname))))
  WHERE ((ns.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])) AND ((t.tableowner = USER) OR has_table_privilege(((quote_ident((ns.nspname)::text) || '.'::text) || quote_ident((pc1.relname)::text)), 'SELECT,INSERT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER'::text)) AND pc.relispartition);]]></complex-attribute>
                        <category _I_D="1bc1e3d7-f574-4024-9513-9f85f988b3e8" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e07eb05c-711a-44d8-9516-de029c2acf8c" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="6450facf-1c45-441d-9038-b08c8041b352" name="sys_all_tables" context="sys_all_tables" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="The ALL_TABLES view describes all tables accessible to the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (t.schemaname)::character varying(30) AS owner,
    (t.tablename)::character varying(30) AS table_name,
    (t.tablespace)::character varying(30) AS tablespace_name,
    NULL::character varying(30) AS cluster_name,
    NULL::character varying(30) AS iot_name,
    'VALID'::character varying(8) AS status,
    NULL::numeric AS pct_free,
    NULL::numeric AS pct_used,
    NULL::numeric AS ini_trans,
    NULL::numeric AS max_trans,
    NULL::numeric AS initial_extent,
    NULL::numeric AS next_extent,
    NULL::numeric AS min_extents,
    NULL::numeric AS max_extents,
    NULL::numeric AS pct_increase,
    NULL::numeric AS freelists,
    NULL::numeric AS freelist_groups,
    'NO'::character varying(3) AS logging,
    'N'::character varying(1) AS backed_up,
    stat.n_live_tup AS num_rows,
    NULL::numeric AS blocks,
    NULL::numeric AS empty_blocks,
    NULL::numeric AS avg_space,
    NULL::numeric AS chain_cnt,
    NULL::numeric AS avg_row_len,
    NULL::numeric AS avg_space_freelist_blocks,
    NULL::numeric AS num_freelist_blocks,
    NULL::character varying(10) AS degree,
    NULL::character varying(10) AS instances,
    NULL::character varying(5) AS cache,
    NULL::character varying(8) AS table_lock,
    NULL::numeric AS sample_size,
    (COALESCE(stat.last_autoanalyze, stat.last_analyze))::date AS last_analyzed,
    'NO'::character varying(3) AS partitioned,
    NULL::character varying(12) AS iot_type,
        CASE
            WHEN ((n.nspname !~ '^pg_toast'::text) AND (n.nspname ~~ 'pg_temp%'::text)) THEN 'Y'::text
            ELSE 'N'::text
        END AS temporary,
    'N'::character varying(1) AS secondary,
    'NO'::character varying(3) AS nested,
    'DEFAULT'::character varying(7) AS buffer_pool,
    'DEFAULT'::character varying(7) AS flash_cache,
    'DEFAULT'::character varying(7) AS cell_flash_cache,
    'DISABLED'::character varying(8) AS row_movement,
    'NO'::character varying(3) AS global_stats,
    NULL::character varying(3) AS user_stats,
    NULL::character varying(15) AS duration,
    'DISABLED'::character varying(8) AS skip_corrupt,
    'NO'::character varying(3) AS monitoring,
    NULL::character varying(30) AS cluster_owner,
    'DISABLED'::character varying(8) AS dependencies,
    'DISABLED'::character varying(8) AS compression,
    NULL::character varying(12) AS compress_for,
    'NO'::character varying(3) AS dropped,
    NULL::character varying(3) AS read_only,
    'YES'::character varying(3) AS segment_created,
    'DEFAULT'::character varying(7) AS result_cache
   FROM ((pg_tables t
     JOIN pg_stat_user_tables stat ON (((t.schemaname = stat.schemaname) AND (t.tablename = stat.relname))))
     JOIN pg_namespace n ON ((t.schemaname = n.nspname)))
  WHERE ((t.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])) AND ((t.tableowner = USER) OR has_table_privilege(((quote_ident((t.schemaname)::text) || '.'::text) || quote_ident((t.tablename)::text)), 'SELECT,INSERT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER'::text)));]]></complex-attribute>
                        <category _I_D="09139123-bf09-4d93-92c9-7ed119251dd6" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="7054ad6b-ca32-42c6-9889-0581d4bf66b2" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="1787de5c-a3e9-4488-8fcb-567545930813" name="sys_all_triggers" context="sys_all_triggers" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="ALL_TRIGGERS describes the triggers on tables accessible to the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspname)::character varying(128) AS owner,
    (trg.tgname)::character varying(128) AS trigger_name,
    (
        CASE ((trg.tgtype)::integer & 66)
            WHEN 2 THEN ('BEFORE'::text ||
            CASE ((trg.tgtype)::integer & 1)
                WHEN 1 THEN ' EACH ROW'::text
                ELSE 'STATEMENT'::text
            END)
            WHEN 64 THEN 'INSTEAD OF'::text
            ELSE ('AFTER'::text ||
            CASE ((trg.tgtype)::integer & 1)
                WHEN 1 THEN ' EACH ROW'::text
                ELSE 'STATEMENT'::text
            END)
        END)::character varying(16) AS trigger_type,
    (
        CASE ((trg.tgtype)::integer & ((28)::smallint)::integer)
            WHEN 32 THEN 'TRUNCATE'::text
            WHEN 16 THEN 'UPDATE'::text
            WHEN 8 THEN 'DELETE'::text
            WHEN 4 THEN 'INSERT'::text
            WHEN 20 THEN 'INSERT OR UPDATE'::text
            WHEN 28 THEN 'INSERT OR UPDATE OR DELETE'::text
            WHEN 24 THEN 'UPDATE OR DELETE'::text
            WHEN 12 THEN 'INSERT OR DELETE'::text
            ELSE NULL::text
        END)::character varying(246) AS triggering_event,
    (ns.nspname)::character varying(128) AS table_owner,
    (
        CASE ((trg.tgtype)::integer & 66)
            WHEN 64 THEN 'VIEW'::text
            ELSE 'TABLE'::text
        END)::character varying(18) AS base_object_type,
    (tbl.relname)::character varying(128) AS table_name,
    (( SELECT string_agg((a.attname)::text, ', '::text) AS string_agg
           FROM pg_attribute a
          WHERE ((a.attrelid = tbl.oid) AND (a.attnum = ANY ((trg.tgattr)::smallint[])))))::character varying(4000) AS column_name,
    'REFERENCING NEW AS NEW OLD AS OLD'::character varying(422) AS referencing_names,
    (
        CASE
            WHEN pg_has_role(tbl.relowner, 'USAGE'::text) THEN (regexp_match(pg_get_triggerdef(trg.oid), '.{35,} WHEN \((.+)\) EXECUTE PROCEDURE'::text))[1]
            ELSE NULL::text
        END)::character varying(4000) AS when_clause,
    (
        CASE
            WHEN (trg.tgenabled = 'D'::"char") THEN 'DISABLED'::text
            ELSE 'ENABLED'::text
        END)::character varying(8) AS status,
    (obj_description(trg.oid))::character varying(400) AS description,
    'PL/SQL'::character varying(11) AS action_type,
    (((n.nspname)::text || '.'::text) || (proc.proname)::text) AS trigger_body,
    'NO'::character varying(3) AS crossedition,
    'NO'::character varying(3) AS before_statement,
    'NO'::character varying(3) AS before_row,
    'NO'::character varying(3) AS after_row,
    'NO'::character varying(3) AS after_statement,
    'NO'::character varying(3) AS instead_of_row,
    (
        CASE ((trg.tgtype)::integer & 66)
            WHEN 2 THEN 'YES'::text
            WHEN 64 THEN 'NO'::text
            ELSE 'YES'::text
        END)::character varying(3) AS fire_once,
    'NO'::character varying(3) AS apply_server_only
   FROM ((((pg_trigger trg
     JOIN pg_proc proc ON ((proc.oid = trg.tgfoid)))
     JOIN pg_namespace n ON ((n.oid = proc.pronamespace)))
     JOIN pg_class tbl ON ((trg.tgrelid = tbl.oid)))
     JOIN pg_namespace ns ON ((ns.oid = tbl.relnamespace)))
  WHERE ((NOT trg.tgisinternal) AND (pg_has_role(tbl.relowner, 'USAGE'::text) OR has_table_privilege(tbl.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(tbl.oid, 'INSERT, UPDATE, REFERENCES'::text)));]]></complex-attribute>
                        <category _I_D="e748423c-ee5b-4f73-8db0-25054bf8583d" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="063af8ac-6221-4229-9e80-008b8e39a550" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="46423acd-8e4e-4408-a904-e29213a125e0" name="sys_all_users" context="sys_all_users" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="The ALL_USERS view lists all users of the database that are visible to the current user">
                        <complex-attribute name="sql"><![CDATA[ SELECT username,
    user_id,
    created
   FROM aws_oracle_ext.sys_user_users;]]></complex-attribute>
                        <category _I_D="b3dae383-dc81-4093-b0c4-aeedfded60c4" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="82faedd3-3fc3-40d7-a6e3-f7cff6688d2a" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="8f0a8e21-d745-4b10-8bae-7c7ac77fae17" name="sys_all_views" context="sys_all_views" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT (schemaname)::character varying(30) AS owner,
    (viewname)::character varying(30) AS view_name,
    (length(definition))::numeric AS text_length,
    (definition)::character varying(409600) AS text,
    NULL::numeric AS type_text_length,
    NULL::character varying(4000) AS type_text,
    NULL::numeric AS oid_text_length,
    NULL::character varying(4000) AS oid_text,
    NULL::character varying(30) AS view_type_owner,
    NULL::character varying(30) AS view_type,
    NULL::character varying(30) AS superview_name,
    'N'::character varying(1) AS editioning_view,
    'Y'::character varying(1) AS read_only
   FROM pg_views
  WHERE ((schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])) AND ((viewowner = USER) OR has_table_privilege(((quote_ident((schemaname)::text) || '.'::text) || quote_ident((viewname)::text)), 'SELECT,INSERT,UPDATE,DELETE,REFERENCES,TRIGGER'::text)));]]></complex-attribute>
                        <category _I_D="70c6b907-1bf5-4bd9-9bf5-ca0b76388e34" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="1b93fce4-b347-486f-afb3-dab546ae95e1" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="7bad8d38-0b09-4c8f-a7c3-43fc1ec1cb65" name="sys_dba_cons_columns" context="sys_dba_cons_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="DBA_CONS_COLUMNS describes all columns in the database that are specified in constraints.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (cstrschema)::character varying(128) AS owner,
    (cstrname)::character varying(128) AS constraint_name,
    (tblname)::character varying(128) AS table_name,
    (colname)::character varying(4000) AS column_name,
    (rank() OVER (PARTITION BY cstrschema, tblname, cstrname ORDER BY colnum))::smallint AS "position"
   FROM ( SELECT DISTINCT nr.nspname,
            r.relname,
            r.relowner,
            a.attname,
            a.attnum,
            nc.nspname,
            c.conname
           FROM pg_namespace nr,
            pg_class r,
            pg_attribute a,
            pg_depend d,
            pg_namespace nc,
            pg_constraint c
          WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (d.refclassid = ('pg_class'::regclass)::oid) AND (d.refobjid = r.oid) AND (d.refobjsubid = a.attnum) AND (d.classid = ('pg_constraint'::regclass)::oid) AND (d.objid = c.oid) AND (c.connamespace = nc.oid) AND (c.contype = 'c'::"char") AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT a.attisdropped))
        UNION ALL
         SELECT nr.nspname,
            r.relname,
            r.relowner,
            a.attname,
            a.attnum,
            nc.nspname,
            c.conname
           FROM pg_namespace nr,
            pg_class r,
            pg_attribute a,
            pg_namespace nc,
            pg_constraint c
          WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (nc.oid = c.connamespace) AND (r.oid =
                CASE c.contype
                    WHEN 'f'::"char" THEN c.confrelid
                    ELSE c.conrelid
                END) AND (a.attnum = ANY (
                CASE c.contype
                    WHEN 'f'::"char" THEN c.confkey
                    ELSE c.conkey
                END)) AND (NOT a.attisdropped) AND (c.contype = ANY (ARRAY['p'::"char", 'u'::"char", 'f'::"char"])) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])))) x(tblschema, tblname, tblowner, colname, colnum, cstrschema, cstrname)
  WHERE (( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER)) OR pg_has_role('rds_superuser'::name, 'member'::text));]]></complex-attribute>
                        <category _I_D="71554454-0cb0-49e0-aa5a-74e0f61a9443" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e4e3d039-5397-40ea-8ca3-346a913f7427" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="ee0e302c-0ebc-4471-8b48-c50b74056b71" name="sys_dba_constraints" context="sys_dba_constraints" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="DBA_CONSTRAINTS describes all constraint definitions on all tables in the database. Its columns are the same as those in &quot;ALL_CONSTRAINTS&quot;.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspname)::character varying(30) AS owner,
    (c.conname)::character varying(30) AS constraint_name,
    (c.contype)::character varying(1) AS constraint_type,
    (cl.relname)::character varying(30) AS table_name,
    pg_get_constraintdef(c.oid) AS search_condition,
    (n_ref.nspname)::character varying(30) AS r_owner,
    (c_ref.conname)::character varying(30) AS r_constraint_name,
        CASE c.confdeltype
            WHEN 'a'::"char" THEN 'no action'::character varying(9)
            WHEN 'r'::"char" THEN 'restrict'::character varying(9)
            WHEN 'c'::"char" THEN 'cascade'::character varying(9)
            WHEN 'n'::"char" THEN 'set null'::character varying(9)
            WHEN 'd'::"char" THEN 'set default'::character varying(11)
            ELSE NULL::character varying(9)
        END AS delete_rule,
    'ENABLED'::character varying(8) AS status,
        CASE
            WHEN c.condeferrable THEN 'DEFERRABLE'::character varying(14)
            ELSE 'NOT DEFERRABLE'::character varying(14)
        END AS "deferrable",
        CASE
            WHEN c.condeferred THEN 'DEFERRED'::character varying(9)
            ELSE 'IMMEDIATE'::character varying(9)
        END AS deferred,
        CASE
            WHEN c.convalidated THEN 'VALIDATED'::character varying(13)
            ELSE 'NOT VALIDATED'::character varying(13)
        END AS validated,
    'GENERATED NAME'::character varying(14) AS generated,
    NULL::character varying(3) AS bad,
    NULL::character varying(4) AS rely,
    NULL::date AS last_change,
    (n.nspname)::character varying(30) AS index_owner,
    (cl_ind.relname)::character varying(30) AS index_name,
    NULL::character varying(7) AS invalid,
    NULL::character varying(14) AS view_related
   FROM (((((((pg_constraint c
     JOIN pg_namespace n ON ((n.oid = c.connamespace)))
     JOIN pg_class cl ON ((cl.oid = c.conrelid)))
     LEFT JOIN pg_class cl_ref ON ((cl_ref.oid = c.confrelid)))
     LEFT JOIN pg_namespace n_ref ON ((n_ref.oid = cl_ref.relnamespace)))
     LEFT JOIN pg_constraint c_ref ON (((c_ref.conrelid = c.confrelid) AND (c_ref.contype = 'p'::"char"))))
     LEFT JOIN pg_index i ON ((i.indrelid = cl_ref.oid)))
     LEFT JOIN pg_class cl_ind ON ((cl_ind.oid = c.conindid)))
  WHERE (( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER)) OR pg_has_role('rds_superuser'::name, 'member'::text));]]></complex-attribute>
                        <category _I_D="d7e57f47-fb6d-4d2c-926b-61adcc7371cc" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="eeb72f84-dc6e-44b2-be16-cae53b0ab933" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="949070a0-d929-401c-b75f-fe6359fa3e81" name="sys_dba_ind_columns" context="sys_dba_ind_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="DBA_IND_COLUMNS describes the columns of all the indexes on all tables and clusters in the database.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (insp.nspname)::character varying(128) AS index_owner,
    (irel.relname)::character varying(128) AS index_name,
    (tnsp.nspname)::character varying(128) AS table_owner,
    (trel.relname)::character varying(128) AS table_name,
    (a.attname)::character varying(4000) AS column_name,
    (c.ordinality)::integer AS column_position,
    COALESCE(information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)), information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))) AS column_length,
    COALESCE(information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)), 0) AS char_length,
    (
        CASE ((o.option)::integer & 1)
            WHEN 1 THEN 'DESC'::text
            ELSE 'ASC'::text
        END)::character varying(4) AS descend,
    NULL::integer AS collated_column_id
   FROM ((((((((pg_index i
     JOIN pg_class trel ON ((trel.oid = i.indrelid)))
     JOIN pg_namespace tnsp ON ((trel.relnamespace = tnsp.oid)))
     JOIN pg_class irel ON ((irel.oid = i.indexrelid)))
     JOIN pg_namespace insp ON ((irel.relnamespace = insp.oid)))
     CROSS JOIN LATERAL unnest(i.indkey) WITH ORDINALITY c(colnum, ordinality))
     LEFT JOIN LATERAL unnest(i.indoption) WITH ORDINALITY o(option, ordinality) ON ((c.ordinality = o.ordinality)))
     JOIN pg_attribute a ON (((trel.oid = a.attrelid) AND (a.attnum = c.colnum))))
     JOIN (pg_type t
     JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((a.atttypid = t.oid)))
  WHERE (( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER)) OR pg_has_role('rds_superuser'::name, 'member'::text));]]></complex-attribute>
                        <category _I_D="334169d8-7d47-4363-87af-b74f033cc584" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="737c45e1-7400-4e53-aafd-1eef88293ab0" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="a1e47e63-5940-4f8f-9191-f7849daa4963" name="sys_dba_indexes" context="sys_dba_indexes" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="DBA_INDEXES describes all indexes in the database.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (tnsp.nspname)::character varying(128) AS owner,
    (irel.relname)::character varying(128) AS index_name,
    (
        CASE
            WHEN (i.indexprs IS NULL) THEN 'NORMAL'::text
            ELSE 'FUNCTION-BASED NORMAL'::text
        END)::character varying(27) AS index_type,
    (tnsp.nspname)::character varying(128) AS table_owner,
    (trel.relname)::character varying(128) AS table_name,
    'TABLE'::character varying(11) AS table_type,
    (
        CASE
            WHEN i.indisunique THEN 'UNIQUE'::text
            ELSE 'NONUNIQUE'::text
        END)::character varying(9) AS uniqueness,
    'DISABLED'::character varying(13) AS compression,
    NULL::integer AS prefix_length,
    (ts.spcname)::character varying(30) AS tablespace_name,
    NULL::integer AS ini_trans,
    NULL::integer AS max_trans,
    NULL::integer AS initial_extent,
    NULL::integer AS next_extent,
    NULL::integer AS min_extents,
    NULL::integer AS max_extents,
    NULL::integer AS pct_increase,
    NULL::integer AS pct_threshold,
    NULL::integer AS include_column,
    NULL::integer AS freelists,
    NULL::integer AS freelist_groups,
    NULL::integer AS pct_free,
    (
        CASE trel.relpersistence
            WHEN 'p'::"char" THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS logging,
    NULL::integer AS blevel,
    NULL::integer AS leaf_blocks,
    (
        CASE
            WHEN i.indisprimary THEN st.n_live_tup
            ELSE NULL::bigint
        END)::integer AS distinct_keys,
    NULL::integer AS avg_leaf_blocks_per_key,
    NULL::integer AS avg_data_blocks_per_key,
    NULL::integer AS clustering_factor,
    (
        CASE
            WHEN i.indisready THEN 'ENABLED'::text
            ELSE 'DISABLED'::text
        END)::character varying(8) AS status,
    (st.n_live_tup)::integer AS num_rows,
    NULL::integer AS sample_size,
    (COALESCE(st.last_autoanalyze, st.last_analyze))::date AS last_analyzed,
    NULL::character varying(40) AS degree,
    NULL::character varying(40) AS instances,
    (
        CASE
            WHEN trel.relispartition THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS partitioned,
    (
        CASE trel.relpersistence
            WHEN 't'::"char" THEN 'Y'::text
            ELSE 'N'::text
        END)::character varying(1) AS temporary,
    'N'::character varying(1) AS generated,
    'N'::character varying(1) AS secondary,
    'DEFAULT'::character varying(7) AS buffer_pool,
    'DEFAULT'::character varying(7) AS flash_cache,
    'DEFAULT'::character varying(7) AS cell_flash_cache,
    'NO'::character varying(3) AS user_stats,
    NULL::character varying(15) AS duration,
    NULL::integer AS pct_direct_access,
    NULL::character varying(128) AS ityp_owner,
    NULL::character varying(128) AS ityp_name,
    NULL::character varying(1000) AS parameters,
    'NO'::character varying(3) AS global_stats,
    NULL::character varying(12) AS domidx_status,
    NULL::character varying(6) AS domidx_opstatus,
    NULL::character varying(8) AS funcidx_status,
    'NO'::character varying(3) AS join_index,
    'NO'::character varying(3) AS iot_redundant_pkey_elim,
    'NO'::character varying(3) AS dropped,
    (
        CASE
            WHEN i.indisvalid THEN 'VISIBLE'::text
            ELSE 'INVISIBLE'::text
        END)::character varying(9) AS visibility,
    NULL::character varying(14) AS domidx_management,
    (
        CASE irel.relpages
            WHEN 0 THEN 'NO'::text
            ELSE 'YES'::text
        END)::character varying(3) AS segment_created,
    'NO'::character varying(3) AS orphaned_entries,
    (
        CASE
            WHEN (i.indpred IS NULL) THEN 'FULL'::text
            ELSE 'PARTIAL'::text
        END)::character varying(7) AS indexing
   FROM ((((((pg_index i
     JOIN pg_class trel ON ((trel.oid = i.indrelid)))
     JOIN pg_namespace tnsp ON ((trel.relnamespace = tnsp.oid)))
     JOIN pg_class irel ON ((irel.oid = i.indexrelid)))
     JOIN pg_am am ON (((am.oid = irel.relam) AND (am.amname = 'btree'::name))))
     LEFT JOIN pg_tablespace ts ON ((ts.oid = irel.reltablespace)))
     LEFT JOIN pg_stat_all_tables st ON (((st.schemaname = tnsp.nspname) AND (st.relname = trel.relname))))
  WHERE (( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER)) OR pg_has_role('rds_superuser'::name, 'member'::text));]]></complex-attribute>
                        <category _I_D="6cf93539-3d18-4b89-b743-b65531d02e79" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="d853f134-fb86-45c0-8beb-93d4a48b29a0" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="89ad90dc-c8b9-417d-b7c0-d9e6f128eb32" name="sys_dba_objects" context="sys_dba_objects" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="DBA_OBJECTS describes all objects in the database. It has the same columns as SYS.ALL_OBJECTS.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspname)::character varying(30) AS owner,
    (c.relname)::character varying(30) AS object_name,
    NULL::character varying(30) AS subobject_name,
    (c.oid)::bigint AS object_id,
        CASE
            WHEN (c.relkind = ANY (ARRAY['t'::"char", 'r'::"char"])) THEN (c.oid)::bigint
            ELSE NULL::bigint
        END AS data_object_id,
        CASE c.relkind
            WHEN 'r'::"char" THEN 'ordinary table'::character varying(17)
            WHEN 'i'::"char" THEN 'index'::character varying(17)
            WHEN 'S'::"char" THEN 'sequence'::character varying(17)
            WHEN 'v'::"char" THEN 'view'::character varying(17)
            WHEN 'c'::"char" THEN 'composite type'::character varying(17)
            WHEN 't'::"char" THEN 'TOAST table'::character varying(17)
            WHEN 'f'::"char" THEN 'foreign table'::character varying(17)
            ELSE NULL::character varying(17)
        END AS object_type,
    NULL::date AS created,
    NULL::date AS last_ddl_time,
    NULL::character varying(78) AS "timestamp",
    'VALID'::character varying(7) AS status,
        CASE c.relpersistence
            WHEN 't'::"char" THEN 'Y'::text
            ELSE 'N'::text
        END AS temporary,
    'N'::character varying(1) AS generated,
    'N'::character varying(1) AS secondary,
    (c.reltablespace)::integer AS namespace,
    NULL::character varying(30) AS edition_name
   FROM (pg_class c
     JOIN pg_namespace n ON ((c.relnamespace = n.oid)))
  WHERE ((( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER)) OR pg_has_role('rds_superuser'::name, 'member'::text)) AND (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])));]]></complex-attribute>
                        <category _I_D="450f84f2-6233-4471-9e3e-fb9ead850417" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="d7a39ea2-6e1a-4770-a7c3-0e1d2170956d" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="4dc1b57b-e30c-4a14-bedd-4c93e93ecb05" name="sys_dba_policies" context="sys_dba_policies" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="DBA_POLICIES describes all Oracle Virtual Private Database (VPD) security policies in the database.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (schemaname)::character varying(128) AS object_owner,
    (tablename)::character varying(128) AS object_name,
    'SYS_DEFAULT'::character varying(128) AS policy_group,
    (policyname)::character varying(128) AS policy_name,
    (schemaname)::character varying(128) AS pf_owner,
    NULL::character varying(128) AS package,
    NULL::character varying(128) AS function,
    (
        CASE
            WHEN (cmd = ANY (ARRAY['ALL'::text, 'SELECT'::text])) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS sel,
    (
        CASE
            WHEN (cmd = ANY (ARRAY['ALL'::text, 'INSERT'::text])) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS ins,
    (
        CASE
            WHEN (cmd = ANY (ARRAY['ALL'::text, 'UPDATE'::text])) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS upd,
    (
        CASE
            WHEN (cmd = ANY (ARRAY['ALL'::text, 'DELETE'::text])) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS del,
    'NO'::character varying(3) AS idx,
    (
        CASE
            WHEN (with_check IS NOT NULL) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS chk_option,
    'YES'::character varying(3) AS enable,
    'NO'::character varying(3) AS static_policy,
    'DYNAMIC'::character varying(24) AS policy_type,
    'NO'::character varying(3) AS long_predicate,
    'NO'::character varying(3) AS common,
    'NO'::character varying(3) AS inherited
   FROM pg_policies p
  WHERE (( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER)) OR pg_has_role('rds_superuser'::name, 'member'::text));]]></complex-attribute>
                        <category _I_D="2c71552b-9065-4bdc-a8af-645ed796a2eb" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="fa55bd92-cccf-4f17-900b-67bb10fb9085" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="208c4ba3-c1df-4c86-81f0-fd4b6ac42dd8" name="sys_dba_roles" context="sys_dba_roles" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="DBA_ROLES lists all roles that exist in the database.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (r.rolname)::character varying(128) AS role,
    (u.usesysid)::bigint AS role_id,
    (
        CASE COALESCE(r.rolpassword, ''::text)
            WHEN ''::text THEN 'NO'::text
            ELSE 'YES'::text
        END)::character varying(8) AS password_required,
    (
        CASE COALESCE(r.rolpassword, ''::text)
            WHEN ''::text THEN 'NONE'::text
            ELSE 'PASSWORD'::text
        END)::character varying(11) AS authentication_type,
    'NO'::character varying(3) AS common,
    'N'::character varying(1) AS oracle_maintained,
    'NO'::character varying(3) AS inherited,
    'NO'::character varying(3) AS implicit
   FROM (pg_authid r
     JOIN pg_user u ON ((u.usename = r.rolname)));]]></complex-attribute>
                        <category _I_D="ce41bac2-ce6b-4f9b-9d99-91c8239396ff" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e58b18c4-9daa-428e-9bce-0f5e473a997e" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="6e252da1-f34a-4868-8bc9-df22d34aa518" name="sys_dba_sequences" context="sys_dba_sequences" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="DBA_SEQUENCES describes all sequences in the database">
                        <complex-attribute name="sql"><![CDATA[ SELECT (s.schemaname)::character varying(30) AS sequence_owner,
    (s.sequencename)::character varying(30) AS sequence_name,
    (s.min_value)::numeric AS min_value,
    (s.max_value)::numeric AS max_value,
    (s.increment_by)::numeric AS increment_by,
        CASE s.cycle
            WHEN false THEN 'N'::character varying(1)
            WHEN true THEN 'Y'::character varying(1)
            ELSE NULL::character varying
        END AS cycle_flag,
    'N'::character varying(1) AS order_flag,
    s.cache_size,
    s.last_value AS last_number
   FROM ((pg_sequences s
     JOIN pg_class c ON (((c.relname = s.sequencename) AND (c.relkind = 'S'::"char"))))
     JOIN pg_user u ON ((c.relowner = u.usesysid)))
  WHERE (( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER)) OR pg_has_role('rds_superuser'::name, 'member'::text));]]></complex-attribute>
                        <category _I_D="2605998c-4703-43f8-83a6-729de6c676de" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="d4d4ec54-9e9e-47b2-9716-279fe0d54b03" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="64f8d6a3-3487-43a7-95b0-c5f7fccdfef8" name="sys_dba_source" context="sys_dba_source" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspowner)::character varying(30) AS owner,
    (s.name)::character varying(30) AS name,
    (s.type)::character varying(12) AS type,
    (generate_subscripts(s.text, 1))::numeric AS line,
    (unnest(s.text))::character varying(4000) AS text
   FROM (( SELECT c.relnamespace AS nsp,
            t.tgname AS name,
            'TRIGGER'::text AS type,
            string_to_array(pg_get_triggerdef(t.oid), chr(10)) AS text
           FROM ((pg_trigger t
             JOIN pg_class c ON ((c.oid = t.tgrelid)))
             JOIN pg_user u ON ((u.usesysid = c.relowner)))
        UNION ALL
         SELECT f.pronamespace AS nsp,
            f.proname AS name,
                CASE
                    WHEN (f.prokind = 'f'::"char") THEN 'FUNCTION'::text
                    WHEN (f.prokind = 'p'::"char") THEN 'PROCEDURE'::text
                    ELSE NULL::text
                END AS type,
            string_to_array(pg_get_functiondef(f.oid), chr(10)) AS text
           FROM ((pg_proc f
             JOIN pg_type ret ON ((f.prorettype = ret.oid)))
             JOIN pg_user u ON ((u.usesysid = f.proowner)))
          WHERE (f.prokind = ANY (ARRAY['f'::"char", 'p'::"char"]))
        UNION ALL
         SELECT t.typnamespace AS nsp,
            t.typname AS name,
            'TYPE'::text AS type,
                CASE
                    WHEN (t.typtype = 'c'::"char") THEN ARRAY( SELECT ((('CREATE OR REPLACE TYPE '::text || (t.typname)::text) || ' AS ('::text) || chr(10))
                    UNION ALL
                     SELECT (((((a.attname)::text || ' '::text) || format_type(a.atttypid, a.atttypmod)) ||
                            CASE
                                WHEN (lead(a.attrelid, 1) OVER () IS NULL) THEN ''::text
                                ELSE ','::text
                            END) || chr(10))
                       FROM pg_attribute a
                      WHERE (a.attrelid = t.typrelid)
                    UNION ALL
                     SELECT ');'::text)
                    WHEN (t.typtype = 'd'::"char") THEN ARRAY( SELECT ((('CREATE OR REPLACE DOMAIN '::text || (t.typname)::text) || ' AS '::text) || format_type(tt.oid, NULL::integer))
                       FROM pg_type tt
                      WHERE (tt.typarray = t.typbasetype))
                    ELSE NULL::text[]
                END AS text
           FROM (pg_type t
             JOIN pg_user u ON ((u.usesysid = t.typowner)))
          WHERE (((t.typrelid = (0)::oid) OR ( SELECT (c.relkind = 'c'::"char")
                   FROM pg_class c
                  WHERE (c.oid = t.typrelid))) AND (NOT (EXISTS ( SELECT 1
                   FROM pg_type el
                  WHERE ((el.oid = t.typelem) AND (el.typarray = t.oid))))))) s
     JOIN pg_namespace n ON ((s.nsp = n.oid)))
  WHERE ((n.nspname <> 'pg_catalog'::name) AND (n.nspname <> 'information_schema'::name) AND (n.nspname !~ '^pg_toast'::text));]]></complex-attribute>
                        <category _I_D="bde8d0b2-f1e6-4ec7-913c-031a08593a72" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="24891f09-69e2-4ac6-9941-721b03c75c3d" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="e639ef0c-4f22-424f-b256-05e91a0cfad4" name="sys_dba_tab_cols" context="sys_dba_tab_cols" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="describes the columns of all tables, views, and clusters in the database">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspname)::character varying(30) AS owner,
    (c.relname)::character varying(30) AS table_name,
    (a.attname)::character varying(30) AS column_name,
    (format_type(a.atttypid, a.atttypmod))::character varying(106) AS data_type,
    NULL::character varying(3) AS data_type_mod,
    NULL::character varying(30) AS data_type_owner,
    (a.attlen)::numeric AS data_length,
    NULL::numeric AS data_precision,
    NULL::numeric AS data_scale,
        CASE
            WHEN a.attnotnull THEN 'N'::character varying(1)
            ELSE 'Y'::character varying(1)
        END AS nullable,
    (a.attnum)::numeric AS column_id,
    NULL::numeric AS default_length,
    pg_get_expr(d.adbin, d.adrelid) AS data_default,
    (s.n_distinct)::numeric AS num_distinct,
    NULL::numeric AS low_value,
    NULL::numeric AS high_value,
    (s.null_frac)::numeric AS density,
    NULL::numeric AS num_nulls,
    NULL::numeric AS num_buckets,
    (COALESCE(st.last_autoanalyze, st.last_analyze))::date AS last_analyzed,
    NULL::numeric AS sample_size,
    'NCHAR_CS'::character varying(44) AS character_set_name,
    NULL::numeric AS char_col_decl_length,
        CASE
            WHEN (COALESCE(st.last_autoanalyze, st.last_analyze) IS NOT NULL) THEN 'YES'::character varying(3)
            ELSE 'NO'::character varying(3)
        END AS global_stats,
    'NO'::character varying(3) AS user_stats,
    (s.avg_width)::numeric AS avg_col_len,
    information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)) AS char_length,
    NULL::character varying(1) AS char_used,
    NULL::character varying(3) AS v80_fmt_image,
    NULL::character varying(3) AS data_upgraded,
    'NO'::character varying(3) AS hidden_column,
    'NO'::character varying(3) AS virtual_column,
    (a.attnum)::numeric AS segment_column_id,
    (a.attnum)::numeric AS internal_column_id,
    'NONE'::character varying(4) AS histogram,
    (a.attname)::character varying(4000) AS qualified_col_name
   FROM ((((((pg_attribute a
     JOIN pg_class c ON ((c.oid = a.attrelid)))
     JOIN pg_type t ON ((a.atttypid = t.oid)))
     LEFT JOIN pg_attrdef d ON (((c.oid = d.adrelid) AND (a.attnum = d.adnum))))
     JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
     LEFT JOIN pg_stats s ON (((s.schemaname = n.nspname) AND (s.tablename = c.relname) AND (s.attname = a.attname))))
     LEFT JOIN pg_stat_user_tables st ON ((st.relid = c.oid)))
  WHERE ((a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER)) OR pg_has_role('rds_superuser'::name, 'member'::text)) AND (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])));]]></complex-attribute>
                        <category _I_D="03836b7e-d77e-416f-81a7-500c917bf7d3" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="4bd54bab-5167-486b-8cfa-afb3075979a2" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="ef6dd970-6c7e-4bf7-9718-e31854031c77" name="sys_dba_tab_columns" context="sys_dba_tab_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="DBA_TAB_COLUMNS describes the columns of all tables, views, and clusters in the database. Its columns are the same as those in &quot;ALL_TAB_COLUMNS&quot;">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspname)::character varying(30) AS owner,
    (c.relname)::character varying(30) AS table_name,
    (a.attname)::character varying(30) AS column_name,
    (format_type(a.atttypid, a.atttypmod))::character varying(106) AS data_type,
    NULL::character varying(3) AS data_type_mod,
    NULL::character varying(30) AS data_type_owner,
    COALESCE((information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::numeric, (a.attlen)::numeric) AS data_length,
    NULL::numeric AS data_precision,
    NULL::numeric AS data_scale,
        CASE
            WHEN a.attnotnull THEN 'N'::character varying(1)
            ELSE 'Y'::character varying(1)
        END AS nullable,
    (a.attnum)::numeric AS column_id,
    NULL::numeric AS default_length,
    pg_get_expr(d.adbin, d.adrelid) AS data_default,
    (s.n_distinct)::numeric AS num_distinct,
    NULL::numeric AS low_value,
    NULL::numeric AS high_value,
    (s.null_frac)::numeric AS density,
    NULL::numeric AS num_nulls,
    NULL::numeric AS num_buckets,
    (COALESCE(st.last_autoanalyze, st.last_analyze))::date AS last_analyzed,
    NULL::numeric AS sample_size,
    'NCHAR_CS'::character varying(44) AS character_set_name,
    NULL::numeric AS char_col_decl_length,
        CASE
            WHEN (COALESCE(st.last_autoanalyze, st.last_analyze) IS NOT NULL) THEN 'YES'::character varying(3)
            ELSE 'NO'::character varying(3)
        END AS global_stats,
    'NO'::character varying(3) AS user_stats,
    (s.avg_width)::numeric AS avg_col_len,
    information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)) AS char_length,
    NULL::character varying(1) AS char_used,
    NULL::character varying(3) AS v80_fmt_image,
    NULL::character varying(3) AS data_upgraded,
    'NONE'::character varying(4) AS histogram
   FROM ((((((pg_attribute a
     JOIN pg_class c ON ((c.oid = a.attrelid)))
     LEFT JOIN pg_attrdef d ON (((c.oid = d.adrelid) AND (a.attnum = d.adnum))))
     JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
     JOIN pg_type t ON ((a.atttypid = t.oid)))
     LEFT JOIN pg_stats s ON (((s.schemaname = n.nspname) AND (s.tablename = c.relname) AND (s.attname = a.attname))))
     LEFT JOIN pg_stat_user_tables st ON ((st.relid = c.oid)))
  WHERE ((a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER)) OR pg_has_role('rds_superuser'::name, 'member'::text)) AND (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])));]]></complex-attribute>
                        <category _I_D="45264256-9805-44b4-bbbc-967999b40bf7" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="f7dbb2b1-c7a7-4292-a816-f1e38dd6c71e" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="8b7b1b5c-8f33-4449-a300-9b635d62d35c" name="sys_dba_tab_comments" context="sys_dba_tab_comments" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspname)::character varying(30) AS owner,
    (c.relname)::character varying(30) AS table_name,
        CASE
            WHEN (c.relkind = 'r'::"char") THEN 'TABLE'::text
            WHEN (c.relkind = 'v'::"char") THEN 'VIEW'::text
            ELSE NULL::text
        END AS table_type,
    (obj_description(c.oid))::character varying(4000) AS comments,
    (0)::numeric AS origin_con_id
   FROM (pg_class c
     JOIN pg_namespace n ON ((c.relnamespace = n.oid)))
  WHERE ((c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'p'::"char"])) AND (NOT c.relispartition) AND (( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER)) OR pg_has_role('rds_superuser'::name, 'member'::text)) AND (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])));]]></complex-attribute>
                        <category _I_D="64bf3374-07d7-420b-86ce-b02c30b55823" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="57b2c80e-f16a-45e9-86ed-38f21d7ef493" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="530d740d-42f1-47ba-b4e3-80fe76d0f5ee" name="sys_dba_tab_partitions" context="sys_dba_tab_partitions" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT (ns.nspname)::character varying(128) AS table_owner,
    (pc1.relname)::character varying(128) AS table_name,
    (
        CASE
            WHEN (pc.relkind = 'p'::"char") THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS composite,
    (pc.relname)::character varying(128) AS partition_name,
    (
        CASE
            WHEN (pc.relkind <> 'p'::"char") THEN (0)::bigint
            ELSE ( SELECT count(*) AS count
               FROM pg_inherits spc
              WHERE (spc.inhparent = pc.oid))
        END)::numeric AS subpartition_count,
    NULL::text AS high_value,
    NULL::numeric AS high_value_length,
    NULL::numeric AS partition_position,
    (( SELECT ts.spcname
           FROM pg_tablespace ts
          WHERE (ts.oid = pc.reltablespace)))::character varying(30) AS tablespace_name,
    NULL::numeric AS pct_free,
    NULL::numeric AS pct_used,
    NULL::numeric AS ini_trans,
    NULL::numeric AS max_trans,
    NULL::numeric AS initial_extent,
    NULL::numeric AS next_extent,
    NULL::numeric AS min_extent,
    NULL::numeric AS max_extent,
    NULL::numeric AS max_size,
    NULL::numeric AS pct_increase,
    NULL::numeric AS freelists,
    NULL::numeric AS freelist_groups,
    NULL::character varying(7) AS logging,
    NULL::character varying(8) AS compression,
    NULL::character varying(30) AS compress_for,
    NULL::numeric AS num_rows,
    NULL::numeric AS blocks,
    NULL::numeric AS empty_blocks,
    NULL::numeric AS avg_space,
    NULL::numeric AS chain_cnt,
    NULL::numeric AS avg_row_len,
    NULL::numeric AS sample_size,
    NULL::timestamp(0) without time zone AS last_analyzed,
    NULL::character varying(7) AS buffer_pool,
    NULL::character varying(7) AS flash_cache,
    NULL::character varying(7) AS cell_flash_cache,
    NULL::character varying(3) AS global_stats,
    NULL::character varying(3) AS user_stats,
    NULL::character varying(3) AS is_nested,
    NULL::character varying(128) AS parent_table_partition,
    NULL::character varying(3) AS "interval",
    NULL::character varying(4) AS segment_created,
    NULL::character varying(4) AS indexing,
    NULL::character varying(4) AS read_only,
    NULL::character varying(8) AS inmemory,
    NULL::character varying(8) AS inmemory_priority,
    NULL::character varying(15) AS inmemory_distribute,
    NULL::character varying(17) AS inmemory_compression,
    NULL::character varying(13) AS inmemory_duplicate,
    NULL::character varying(24) AS cellmemory,
    NULL::character varying(12) AS inmemory_service,
    NULL::character varying(1000) AS inmemory_service_name,
    NULL::character varying(8) AS memoptimize_read,
    NULL::character varying(8) AS memoptimize_write
   FROM ((((pg_class pc
     JOIN pg_inherits pi ON ((pi.inhrelid = pc.oid)))
     JOIN pg_class pc1 ON ((pi.inhparent = pc1.oid)))
     JOIN pg_partitioned_table ppt ON ((ppt.partrelid = pi.inhparent)))
     JOIN pg_namespace ns ON ((ns.oid = pc.relnamespace)))
  WHERE ((pg_has_role('rds_superuser'::name, 'member'::text) OR ( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER))) AND (ns.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])) AND pc.relispartition AND (NOT (EXISTS ( SELECT 1
           FROM pg_class pcs
          WHERE (pcs.relispartition AND (pcs.oid = pi.inhparent))))));]]></complex-attribute>
                        <category _I_D="79abc046-a91a-4d1a-92ff-35b0b1bd6345" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="1777afc7-6fbb-43b5-9d7d-9f95dd4f3edf" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="87a74749-a443-4e9b-8cec-b184cc84dd89" name="sys_dba_tab_subpartitions" context="sys_dba_tab_subpartitions" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT (ns.nspname)::character varying(128) AS table_owner,
    (pc2.relname)::character varying(128) AS table_name,
    (pc1.relname)::character varying(128) AS partition_name,
    (pc.relname)::character varying(128) AS subpartition_name,
    NULL::text AS high_value,
    NULL::numeric AS high_value_length,
    NULL::numeric AS partition_position,
    NULL::numeric AS subpartition_position,
    (( SELECT ts.spcname
           FROM pg_tablespace ts
          WHERE (ts.oid = pc.reltablespace)))::character varying(30) AS tablespace_name,
    NULL::numeric AS pct_free,
    NULL::numeric AS pct_used,
    NULL::numeric AS ini_trans,
    NULL::numeric AS max_trans,
    NULL::numeric AS initial_extent,
    NULL::numeric AS next_extent,
    NULL::numeric AS min_extent,
    NULL::numeric AS max_extent,
    NULL::numeric AS max_size,
    NULL::numeric AS pct_increase,
    NULL::numeric AS freelists,
    NULL::numeric AS freelist_groups,
    NULL::character varying(3) AS logging,
    NULL::character varying(8) AS compression,
    NULL::character varying(30) AS compress_for,
    NULL::numeric AS num_rows,
    NULL::numeric AS blocks,
    NULL::numeric AS empty_blocks,
    NULL::numeric AS avg_space,
    NULL::numeric AS chain_cnt,
    NULL::numeric AS avg_row_len,
    NULL::numeric AS sample_size,
    NULL::timestamp(0) without time zone AS last_analyzed,
    NULL::character varying(7) AS buffer_pool,
    NULL::character varying(7) AS flash_cache,
    NULL::character varying(7) AS cell_flash_cache,
    NULL::character varying(3) AS global_stats,
    NULL::character varying(3) AS user_stats,
    NULL::character varying(3) AS "interval",
    NULL::character varying(3) AS segment_created,
    NULL::character varying(3) AS indexing,
    NULL::character varying(3) AS read_only,
    NULL::character varying(8) AS inmemory,
    NULL::character varying(8) AS inmemory_priority,
    NULL::character varying(15) AS inmemory_distribute,
    NULL::character varying(17) AS inmemory_compression,
    NULL::character varying(13) AS inmemory_duplicate,
    NULL::character varying(12) AS inmemory_service,
    NULL::character varying(1000) AS inmemory_service_name,
    NULL::character varying(24) AS cellmemory,
    NULL::character varying(8) AS memoptimize_read,
    NULL::character varying(8) AS memoptimize_write
   FROM ((((((pg_class pc
     JOIN pg_inherits pis ON ((pis.inhrelid = pc.oid)))
     JOIN pg_class pc1 ON ((pis.inhparent = pc1.oid)))
     JOIN pg_partitioned_table ppt ON ((ppt.partrelid = pis.inhparent)))
     JOIN pg_namespace ns ON ((ns.oid = pc.relnamespace)))
     JOIN pg_inherits pi ON ((pis.inhparent = pi.inhrelid)))
     JOIN pg_class pc2 ON ((pi.inhparent = pc2.oid)))
  WHERE ((pg_has_role('rds_superuser'::name, 'member'::text) OR ( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER))) AND (ns.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])) AND pc.relispartition);]]></complex-attribute>
                        <category _I_D="f0dd28b8-3a0c-4bf6-8913-2132fa635156" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="18730a66-2bfa-4ae1-9ee2-6f34d90cd649" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="0d3fe474-0668-45cb-8a43-e8b7f066fa1d" name="sys_dba_tables" context="sys_dba_tables" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="The DBA_TABLES view describes all tables in the database.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (t.schemaname)::character varying(30) AS owner,
    (t.tablename)::character varying(30) AS table_name,
    (t.tablespace)::character varying(30) AS tablespace_name,
    NULL::character varying(30) AS cluster_name,
    NULL::character varying(30) AS iot_name,
    'VALID'::character varying(8) AS status,
    NULL::numeric AS pct_free,
    NULL::numeric AS pct_used,
    NULL::numeric AS ini_trans,
    NULL::numeric AS max_trans,
    NULL::numeric AS initial_extent,
    NULL::numeric AS next_extent,
    NULL::numeric AS min_extents,
    NULL::numeric AS max_extents,
    NULL::numeric AS pct_increase,
    NULL::numeric AS freelists,
    NULL::numeric AS freelist_groups,
    'NO'::character varying(3) AS logging,
    'N'::character varying(1) AS backed_up,
    stat.n_live_tup AS num_rows,
    NULL::numeric AS blocks,
    NULL::numeric AS empty_blocks,
    NULL::numeric AS avg_space,
    NULL::numeric AS chain_cnt,
    NULL::numeric AS avg_row_len,
    NULL::numeric AS avg_space_freelist_blocks,
    NULL::numeric AS num_freelist_blocks,
    NULL::character varying(10) AS degree,
    NULL::character varying(10) AS instances,
    NULL::character varying(5) AS cache,
    NULL::character varying(8) AS table_lock,
    NULL::numeric AS sample_size,
    (COALESCE(stat.last_autoanalyze, stat.last_analyze))::date AS last_analyzed,
    'NO'::character varying(3) AS partitioned,
    NULL::character varying(12) AS iot_type,
        CASE
            WHEN ((n.nspname !~ '^pg_toast'::text) AND (n.nspname ~~ 'pg_temp%'::text)) THEN 'Y'::text
            ELSE 'N'::text
        END AS temporary,
    'N'::character varying(1) AS secondary,
    'NO'::character varying(3) AS nested,
    'DEFAULT'::character varying(7) AS buffer_pool,
    'DEFAULT'::character varying(7) AS flash_cache,
    'DEFAULT'::character varying(7) AS cell_flash_cache,
    'DISABLED'::character varying(8) AS row_movement,
    'NO'::character varying(3) AS global_stats,
    NULL::character varying(3) AS user_stats,
    NULL::character varying(15) AS duration,
    'DISABLED'::character varying(8) AS skip_corrupt,
    'NO'::character varying(3) AS monitoring,
    NULL::character varying(30) AS cluster_owner,
    'DISABLED'::character varying(8) AS dependencies,
    'DISABLED'::character varying(8) AS compression,
    NULL::character varying(12) AS compress_for,
    'NO'::character varying(3) AS dropped,
    NULL::character varying(3) AS read_only,
    'YES'::character varying(3) AS segment_created,
    'DEFAULT'::character varying(7) AS result_cache
   FROM ((pg_tables t
     JOIN pg_stat_user_tables stat ON (((t.schemaname = stat.schemaname) AND (t.tablename = stat.relname))))
     JOIN pg_namespace n ON ((t.schemaname = n.nspname)))
  WHERE (( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER)) OR (pg_has_role('rds_superuser'::name, 'member'::text) AND (t.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name]))));]]></complex-attribute>
                        <category _I_D="3ff3221b-6e2c-43b7-ac95-9af6cfa61bcc" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="63bea05c-64b8-4e7b-81ce-b19f6f1c36c5" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="b1d5c7a4-9c83-476f-9198-b57b573828fa" name="sys_dba_triggers" context="sys_dba_triggers" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="DBA_TRIGGERS describes all triggers in the database.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspname)::character varying(128) AS owner,
    (trg.tgname)::character varying(128) AS trigger_name,
    (
        CASE ((trg.tgtype)::integer & 66)
            WHEN 2 THEN ('BEFORE'::text ||
            CASE ((trg.tgtype)::integer & 1)
                WHEN 1 THEN ' EACH ROW'::text
                ELSE 'STATEMENT'::text
            END)
            WHEN 64 THEN 'INSTEAD OF'::text
            ELSE ('AFTER'::text ||
            CASE ((trg.tgtype)::integer & 1)
                WHEN 1 THEN ' EACH ROW'::text
                ELSE 'STATEMENT'::text
            END)
        END)::character varying(16) AS trigger_type,
    (
        CASE ((trg.tgtype)::integer & ((28)::smallint)::integer)
            WHEN 32 THEN 'TRUNCATE'::text
            WHEN 16 THEN 'UPDATE'::text
            WHEN 8 THEN 'DELETE'::text
            WHEN 4 THEN 'INSERT'::text
            WHEN 20 THEN 'INSERT OR UPDATE'::text
            WHEN 28 THEN 'INSERT OR UPDATE OR DELETE'::text
            WHEN 24 THEN 'UPDATE OR DELETE'::text
            WHEN 12 THEN 'INSERT OR DELETE'::text
            ELSE NULL::text
        END)::character varying(246) AS triggering_event,
    (ns.nspname)::character varying(128) AS table_owner,
    (
        CASE ((trg.tgtype)::integer & 66)
            WHEN 64 THEN 'VIEW'::text
            ELSE 'TABLE'::text
        END)::character varying(18) AS base_object_type,
    (tbl.relname)::character varying(128) AS table_name,
    (( SELECT string_agg((a.attname)::text, ', '::text) AS string_agg
           FROM pg_attribute a
          WHERE ((a.attrelid = tbl.oid) AND (a.attnum = ANY ((trg.tgattr)::smallint[])))))::character varying(4000) AS column_name,
    'REFERENCING NEW AS NEW OLD AS OLD'::character varying(422) AS referencing_names,
    (
        CASE
            WHEN pg_has_role(tbl.relowner, 'USAGE'::text) THEN (regexp_match(pg_get_triggerdef(trg.oid), '.{35,} WHEN \((.+)\) EXECUTE PROCEDURE'::text))[1]
            ELSE NULL::text
        END)::character varying(4000) AS when_clause,
    (
        CASE
            WHEN (trg.tgenabled = 'D'::"char") THEN 'DISABLED'::text
            ELSE 'ENABLED'::text
        END)::character varying(8) AS status,
    (obj_description(trg.oid))::character varying(400) AS description,
    'PL/SQL'::character varying(11) AS action_type,
    (((n.nspname)::text || '.'::text) || (proc.proname)::text) AS trigger_body,
    'NO'::character varying(3) AS crossedition,
    'NO'::character varying(3) AS before_statement,
    'NO'::character varying(3) AS before_row,
    'NO'::character varying(3) AS after_row,
    'NO'::character varying(3) AS after_statement,
    'NO'::character varying(3) AS instead_of_row,
    (
        CASE ((trg.tgtype)::integer & 66)
            WHEN 2 THEN 'YES'::text
            WHEN 64 THEN 'NO'::text
            ELSE 'YES'::text
        END)::character varying(3) AS fire_once,
    'NO'::character varying(3) AS apply_server_only
   FROM ((((pg_trigger trg
     JOIN pg_proc proc ON ((proc.oid = trg.tgfoid)))
     JOIN pg_namespace n ON ((n.oid = proc.pronamespace)))
     JOIN pg_class tbl ON ((trg.tgrelid = tbl.oid)))
     JOIN pg_namespace ns ON ((ns.oid = tbl.relnamespace)))
  WHERE ((NOT trg.tgisinternal) AND (( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER)) OR pg_has_role('rds_superuser'::name, 'member'::text)));]]></complex-attribute>
                        <category _I_D="e887d6a0-3d54-4d2c-a7bc-072d8d972a8b" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="3e036656-9e3e-401a-a033-d48812036bf3" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="04594fe3-c2a9-4bf7-8323-7131a5575a80" name="sys_dba_users" context="sys_dba_users" subcategories-loading="none" object-loading="extended" is-updatable="YES" check-option="NONE" comment="Describes all users of the database and contains more columns than ALL_USERS.">
                        <complex-attribute name="sql"><![CDATA[ SELECT nspname AS username,
    nspowner AS user_id,
    NULL::character varying(30) AS password,
    'OPEN'::character varying(32) AS account_status,
    NULL::timestamp without time zone AS lock_date,
    NULL::timestamp without time zone AS expiry_date,
    'USERS'::character varying(30) AS default_tablespace,
    'TEMP'::character varying(30) AS temporary_tablespace,
    NULL::timestamp without time zone AS created,
    'DEFAULT'::character varying(30) AS profile,
    NULL::character varying(30) AS initial_rsrc_consumer_group,
    NULL::character varying(4000) AS external_name,
    NULL::character varying(8) AS password_versions,
    NULL::character varying(1) AS editions_enabled,
    'PASSWORD'::character varying(8) AS authentication_type
   FROM pg_namespace
  WHERE (( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER)) OR pg_has_role('rds_superuser'::name, 'member'::text));]]></complex-attribute>
                        <category _I_D="f07993b3-81c4-4ebe-9b1e-b853e4635adb" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="42fb242a-b863-4edd-842b-3d1e63e0914b" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="ea9e0198-7b5c-411e-a639-3d02dca7da87" name="sys_dba_views" context="sys_dba_views" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="The SYS.DBA_VIEWS view describes all views in the database.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (schemaname)::character varying(30) AS owner,
    (viewname)::character varying(30) AS view_name,
    (length(definition))::numeric AS text_length,
    (definition)::character varying(409600) AS text,
    NULL::numeric AS type_text_length,
    NULL::character varying(4000) AS type_text,
    NULL::numeric AS oid_text_length,
    NULL::character varying(4000) AS oid_text,
    NULL::character varying(30) AS view_type_owner,
    NULL::character varying(30) AS view_type,
    NULL::character varying(30) AS superview_name,
    'N'::character varying(1) AS editioning_view,
    'Y'::character varying(1) AS read_only
   FROM pg_views
  WHERE ((( SELECT pg_user.usesuper
           FROM pg_user
          WHERE (pg_user.usename = USER)) OR pg_has_role('rds_superuser'::name, 'member'::text)) AND (schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])));]]></complex-attribute>
                        <category _I_D="186856c5-37a5-4a08-a3af-4647ecb51c22" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="b8cae8ee-8f58-4163-bb0f-22e03a557281" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="bf0d2f53-79d1-473f-8299-ad7302ed3298" name="sys_user_col_comments" context="sys_user_col_comments" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT c.relname AS table_name,
    a.attname AS column_name,
    col_description(a.attrelid, (a.attnum)::integer) AS comments,
    a.attnum AS origin_con_id
   FROM (((pg_class c
     JOIN pg_namespace n ON ((c.relnamespace = n.oid)))
     JOIN pg_user u ON ((c.relowner = u.usesysid)))
     JOIN pg_attribute a ON (((c.oid = a.attrelid) AND (a.attnum > 0))))
  WHERE ((c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'p'::"char"])) AND (NOT c.relispartition) AND (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])) AND (u.usename = USER));]]></complex-attribute>
                        <category _I_D="55fe3dd2-b43f-41f8-b8d1-767a636aedd7" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="bbf11130-a741-4a5b-b1ba-d66a7a3ad79a" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="124deafd-94b4-4cf0-bc76-446b574c3917" name="sys_user_cons_columns" context="sys_user_cons_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="USER_CONS_COLUMNS describes columns that are owned by the current user and that are specified in constraint definitions.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (x.cstrschema)::character varying(128) AS owner,
    (x.cstrname)::character varying(128) AS constraint_name,
    (x.tblname)::character varying(128) AS table_name,
    (x.colname)::character varying(4000) AS column_name,
    (rank() OVER (PARTITION BY x.cstrschema, x.tblname, x.cstrname ORDER BY x.colnum))::smallint AS "position"
   FROM (( SELECT DISTINCT nr.nspname,
            r.relname,
            r.relowner,
            a.attname,
            a.attnum,
            nc.nspname,
            c.conname
           FROM pg_namespace nr,
            pg_class r,
            pg_attribute a,
            pg_depend d,
            pg_namespace nc,
            pg_constraint c
          WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (d.refclassid = ('pg_class'::regclass)::oid) AND (d.refobjid = r.oid) AND (d.refobjsubid = a.attnum) AND (d.classid = ('pg_constraint'::regclass)::oid) AND (d.objid = c.oid) AND (c.connamespace = nc.oid) AND (c.contype = 'c'::"char") AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT a.attisdropped))
        UNION ALL
         SELECT nr.nspname,
            r.relname,
            r.relowner,
            a.attname,
            a.attnum,
            nc.nspname,
            c.conname
           FROM pg_namespace nr,
            pg_class r,
            pg_attribute a,
            pg_namespace nc,
            pg_constraint c
          WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (nc.oid = c.connamespace) AND (r.oid =
                CASE c.contype
                    WHEN 'f'::"char" THEN c.confrelid
                    ELSE c.conrelid
                END) AND (a.attnum = ANY (
                CASE c.contype
                    WHEN 'f'::"char" THEN c.confkey
                    ELSE c.conkey
                END)) AND (NOT a.attisdropped) AND (c.contype = ANY (ARRAY['p'::"char", 'u'::"char", 'f'::"char"])) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])))) x(tblschema, tblname, tblowner, colname, colnum, cstrschema, cstrname)
     JOIN pg_user u ON ((u.usesysid = x.tblowner)))
  WHERE (u.usename = USER);]]></complex-attribute>
                        <category _I_D="1a96f619-2a25-4781-90be-33d132e363b9" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="da2ec3f5-9886-49ed-b926-48ad7afc0fb2" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="4d371528-0e33-47a1-a5be-a9ec49fc1c9a" name="sys_user_constraints" context="sys_user_constraints" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="USER_CONSTRAINTS describes all constraint definitions on tables owned by the current user">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspname)::character varying(30) AS owner,
    (c.conname)::character varying(30) AS constraint_name,
    (c.contype)::character varying(1) AS constraint_type,
    (cl.relname)::character varying(30) AS table_name,
    pg_get_constraintdef(c.oid) AS search_condition,
    (n_ref.nspname)::character varying(30) AS r_owner,
    (c_ref.conname)::character varying(30) AS r_constraint_name,
        CASE c.confdeltype
            WHEN 'a'::"char" THEN 'no action'::character varying(9)
            WHEN 'r'::"char" THEN 'restrict'::character varying(9)
            WHEN 'c'::"char" THEN 'cascade'::character varying(9)
            WHEN 'n'::"char" THEN 'set null'::character varying(9)
            WHEN 'd'::"char" THEN 'set default'::character varying(11)
            ELSE NULL::character varying(9)
        END AS delete_rule,
    'ENABLED'::character varying(8) AS status,
        CASE
            WHEN c.condeferrable THEN 'DEFERRABLE'::character varying(14)
            ELSE 'NOT DEFERRABLE'::character varying(14)
        END AS "deferrable",
        CASE
            WHEN c.condeferred THEN 'DEFERRED'::character varying(9)
            ELSE 'IMMEDIATE'::character varying(9)
        END AS deferred,
        CASE
            WHEN c.convalidated THEN 'VALIDATED'::character varying(13)
            ELSE 'NOT VALIDATED'::character varying(13)
        END AS validated,
    'GENERATED NAME'::character varying(14) AS generated,
    NULL::character varying(3) AS bad,
    NULL::character varying(4) AS rely,
    NULL::date AS last_change,
    (n.nspname)::character varying(30) AS index_owner,
    (cl_ind.relname)::character varying(30) AS index_name,
    NULL::character varying(7) AS invalid,
    NULL::character varying(14) AS view_related
   FROM ((((((((pg_constraint c
     JOIN pg_namespace n ON ((n.oid = c.connamespace)))
     JOIN pg_class cl ON ((cl.oid = c.conrelid)))
     JOIN pg_user u ON ((cl.relowner = u.usesysid)))
     LEFT JOIN pg_class cl_ref ON ((cl_ref.oid = c.confrelid)))
     LEFT JOIN pg_namespace n_ref ON ((n_ref.oid = cl_ref.relnamespace)))
     LEFT JOIN pg_constraint c_ref ON (((c_ref.conrelid = c.confrelid) AND (c_ref.contype = 'p'::"char"))))
     LEFT JOIN pg_index i ON ((i.indrelid = cl_ref.oid)))
     LEFT JOIN pg_class cl_ind ON ((cl_ind.oid = c.conindid)))
  WHERE (u.usename = USER);]]></complex-attribute>
                        <category _I_D="20618176-27d5-4b71-9ce4-726b7ae95018" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="55ea561c-6dcb-480d-a29f-c98578ccddbf" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="bbc53b76-5e5c-4a51-ad64-e0b8d6af4406" name="sys_user_ind_columns" context="sys_user_ind_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="USER_IND_COLUMNS describes the columns of the indexes owned by the current user and columns of indexes on tables owned by the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (irel.relname)::character varying(128) AS index_name,
    (trel.relname)::character varying(128) AS table_name,
    (a.attname)::character varying(4000) AS column_name,
    (c.ordinality)::integer AS column_position,
    COALESCE(information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)), information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))) AS column_length,
    COALESCE(information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)), 0) AS char_length,
    (
        CASE ((o.option)::integer & 1)
            WHEN 1 THEN 'DESC'::text
            ELSE 'ASC'::text
        END)::character varying(4) AS descend,
    NULL::integer AS collated_column_id
   FROM ((((((((((pg_index i
     JOIN pg_class trel ON ((trel.oid = i.indrelid)))
     JOIN pg_namespace tnsp ON ((trel.relnamespace = tnsp.oid)))
     JOIN pg_class irel ON ((irel.oid = i.indexrelid)))
     JOIN pg_namespace insp ON ((irel.relnamespace = insp.oid)))
     CROSS JOIN LATERAL unnest(i.indkey) WITH ORDINALITY c(colnum, ordinality))
     LEFT JOIN LATERAL unnest(i.indoption) WITH ORDINALITY o(option, ordinality) ON ((c.ordinality = o.ordinality)))
     JOIN pg_attribute a ON (((trel.oid = a.attrelid) AND (a.attnum = c.colnum))))
     JOIN (pg_type t
     JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((a.atttypid = t.oid)))
     JOIN pg_user ui ON ((irel.relowner = ui.usesysid)))
     JOIN pg_user ut ON ((trel.relowner = ut.usesysid)))
  WHERE ((ui.usename = USER) OR (ut.usename = USER));]]></complex-attribute>
                        <category _I_D="5c7456ae-5a4a-4399-a311-57b89453208b" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="4c101fb9-bc0d-4cf0-a1dd-91d189101bc4" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="7d66a414-d807-445c-9967-b59b6f478d42" name="sys_user_indexes" context="sys_user_indexes" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="USER_INDEXES describes the indexes owned by the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (irel.relname)::character varying(128) AS index_name,
    (
        CASE
            WHEN (i.indexprs IS NULL) THEN 'NORMAL'::text
            ELSE 'FUNCTION-BASED NORMAL'::text
        END)::character varying(27) AS index_type,
    (tnsp.nspname)::character varying(128) AS table_owner,
    (trel.relname)::character varying(128) AS table_name,
    'TABLE'::character varying(11) AS table_type,
    (
        CASE
            WHEN i.indisunique THEN 'UNIQUE'::text
            ELSE 'NONUNIQUE'::text
        END)::character varying(9) AS uniqueness,
    'DISABLED'::character varying(13) AS compression,
    NULL::integer AS prefix_length,
    (ts.spcname)::character varying(30) AS tablespace_name,
    NULL::integer AS ini_trans,
    NULL::integer AS max_trans,
    NULL::integer AS initial_extent,
    NULL::integer AS next_extent,
    NULL::integer AS min_extents,
    NULL::integer AS max_extents,
    NULL::integer AS pct_increase,
    NULL::integer AS pct_threshold,
    NULL::integer AS include_column,
    NULL::integer AS freelists,
    NULL::integer AS freelist_groups,
    NULL::integer AS pct_free,
    (
        CASE trel.relpersistence
            WHEN 'p'::"char" THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS logging,
    NULL::integer AS blevel,
    NULL::integer AS leaf_blocks,
    (
        CASE
            WHEN i.indisprimary THEN st.n_live_tup
            ELSE NULL::bigint
        END)::integer AS distinct_keys,
    NULL::integer AS avg_leaf_blocks_per_key,
    NULL::integer AS avg_data_blocks_per_key,
    NULL::integer AS clustering_factor,
    (
        CASE
            WHEN i.indisready THEN 'ENABLED'::text
            ELSE 'DISABLED'::text
        END)::character varying(8) AS status,
    (st.n_live_tup)::integer AS num_rows,
    NULL::integer AS sample_size,
    (COALESCE(st.last_autoanalyze, st.last_analyze))::date AS last_analyzed,
    NULL::character varying(40) AS degree,
    NULL::character varying(40) AS instances,
    (
        CASE
            WHEN trel.relispartition THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS partitioned,
    (
        CASE trel.relpersistence
            WHEN 't'::"char" THEN 'Y'::text
            ELSE 'N'::text
        END)::character varying(1) AS temporary,
    'N'::character varying(1) AS generated,
    'N'::character varying(1) AS secondary,
    'DEFAULT'::character varying(7) AS buffer_pool,
    'DEFAULT'::character varying(7) AS flash_cache,
    'DEFAULT'::character varying(7) AS cell_flash_cache,
    'NO'::character varying(3) AS user_stats,
    NULL::character varying(15) AS duration,
    NULL::integer AS pct_direct_access,
    NULL::character varying(128) AS ityp_owner,
    NULL::character varying(128) AS ityp_name,
    NULL::character varying(1000) AS parameters,
    'NO'::character varying(3) AS global_stats,
    NULL::character varying(12) AS domidx_status,
    NULL::character varying(6) AS domidx_opstatus,
    NULL::character varying(8) AS funcidx_status,
    'NO'::character varying(3) AS join_index,
    'NO'::character varying(3) AS iot_redundant_pkey_elim,
    'NO'::character varying(3) AS dropped,
    (
        CASE
            WHEN i.indisvalid THEN 'VISIBLE'::text
            ELSE 'INVISIBLE'::text
        END)::character varying(9) AS visibility,
    NULL::character varying(14) AS domidx_management,
    (
        CASE irel.relpages
            WHEN 0 THEN 'NO'::text
            ELSE 'YES'::text
        END)::character varying(3) AS segment_created,
    'NO'::character varying(3) AS orphaned_entries,
    (
        CASE
            WHEN (i.indpred IS NULL) THEN 'FULL'::text
            ELSE 'PARTIAL'::text
        END)::character varying(7) AS indexing
   FROM (((((((pg_index i
     JOIN pg_class trel ON ((trel.oid = i.indrelid)))
     JOIN pg_namespace tnsp ON ((trel.relnamespace = tnsp.oid)))
     JOIN pg_class irel ON ((irel.oid = i.indexrelid)))
     JOIN pg_am am ON (((am.oid = irel.relam) AND (am.amname = 'btree'::name))))
     LEFT JOIN pg_tablespace ts ON ((ts.oid = irel.reltablespace)))
     LEFT JOIN pg_stat_all_tables st ON (((st.schemaname = tnsp.nspname) AND (st.relname = trel.relname))))
     JOIN pg_user u ON ((irel.relowner = u.usesysid)))
  WHERE (u.usename = USER);]]></complex-attribute>
                        <category _I_D="a4b7986e-a21b-4fc7-80f3-caaf122f406d" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="0ad9bfe9-9e4b-47e2-9d3d-6e2d9205a354" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="cf0a7837-c97c-4bf2-bf05-443aec68c75a" name="sys_user_objects" context="sys_user_objects" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="USER_OBJECTS describes all objects owned by the current user">
                        <complex-attribute name="sql"><![CDATA[ SELECT (c.relname)::character varying(30) AS object_name,
    NULL::character varying(30) AS subobject_name,
    (c.oid)::bigint AS object_id,
        CASE
            WHEN (c.relkind = ANY (ARRAY['t'::"char", 'r'::"char"])) THEN (c.oid)::bigint
            ELSE NULL::bigint
        END AS data_object_id,
        CASE c.relkind
            WHEN 'r'::"char" THEN 'ordinary table'::character varying(17)
            WHEN 'i'::"char" THEN 'index'::character varying(17)
            WHEN 'S'::"char" THEN 'sequence'::character varying(17)
            WHEN 'v'::"char" THEN 'view'::character varying(17)
            WHEN 'c'::"char" THEN 'composite type'::character varying(17)
            WHEN 't'::"char" THEN 'TOAST table'::character varying(17)
            WHEN 'f'::"char" THEN 'foreign table'::character varying(17)
            ELSE NULL::character varying(17)
        END AS object_type,
    NULL::date AS created,
    NULL::date AS last_ddl_time,
    NULL::character varying(78) AS "timestamp",
    'VALID'::character varying(7) AS status,
        CASE c.relpersistence
            WHEN 't'::"char" THEN 'Y'::text
            ELSE 'N'::text
        END AS temporary,
    'N'::character varying(1) AS generated,
    'N'::character varying(1) AS secondary,
    (c.reltablespace)::integer AS namespace,
    NULL::character varying(30) AS edition_name
   FROM ((pg_class c
     JOIN pg_namespace n ON ((c.relnamespace = n.oid)))
     JOIN pg_user u ON ((c.relowner = u.usesysid)))
  WHERE ((u.usename = USER) AND (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])));]]></complex-attribute>
                        <category _I_D="7d24bdca-eff5-4657-9d9c-e5812b7369e5" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="c90ddb0a-c4bd-45d6-87e4-82ff3382ed93" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="6421fa4e-e6eb-497a-a33a-dd7fd53bc6c9" name="sys_user_policies" context="sys_user_policies" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="USER_POLICIES describes all Oracle Virtual Private Database (VPD) security policies associated with objects owned by the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (p.tablename)::character varying(128) AS object_name,
    'SYS_DEFAULT'::character varying(128) AS policy_group,
    (p.policyname)::character varying(128) AS policy_name,
    (p.schemaname)::character varying(128) AS pf_owner,
    NULL::character varying(128) AS package,
    NULL::character varying(128) AS function,
    (
        CASE
            WHEN (p.cmd = ANY (ARRAY['ALL'::text, 'SELECT'::text])) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS sel,
    (
        CASE
            WHEN (p.cmd = ANY (ARRAY['ALL'::text, 'INSERT'::text])) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS ins,
    (
        CASE
            WHEN (p.cmd = ANY (ARRAY['ALL'::text, 'UPDATE'::text])) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS upd,
    (
        CASE
            WHEN (p.cmd = ANY (ARRAY['ALL'::text, 'DELETE'::text])) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS del,
    'NO'::character varying(3) AS idx,
    (
        CASE
            WHEN (p.with_check IS NOT NULL) THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS chk_option,
    'YES'::character varying(3) AS enable,
    'NO'::character varying(3) AS static_policy,
    'DYNAMIC'::character varying(24) AS policy_type,
    'NO'::character varying(3) AS long_predicate,
    'NO'::character varying(3) AS common,
    'NO'::character varying(3) AS inherited
   FROM (pg_policies p
     JOIN pg_tables t ON (((t.schemaname = p.schemaname) AND (t.tablename = p.tablename))))
  WHERE (t.tableowner = USER);]]></complex-attribute>
                        <category _I_D="701d5f19-3ccf-40f5-bebb-57c4043a0c36" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="defdb080-70e8-494e-8035-96f92602bea5" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="f68e2c8d-7f2a-4911-b82f-44b7c765b613" name="sys_user_sequences" context="sys_user_sequences" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="USER_SEQUENCES describes all sequences owned by the current user">
                        <complex-attribute name="sql"><![CDATA[ SELECT (s.sequence_name)::character varying(30) AS sequence_name,
    (s.minimum_value)::numeric AS min_value,
    (s.maximum_value)::numeric AS max_value,
    (s.increment)::numeric AS increment_by,
        CASE s.cycle_option
            WHEN 'NO'::text THEN 'N'::character varying(1)
            WHEN 'YES'::text THEN 'Y'::character varying(1)
            ELSE NULL::character varying
        END AS cycle_flag,
    'N'::character varying(1) AS order_flag,
    0 AS cache_size,
    currval((((quote_ident((s.sequence_schema)::text) || '.'::text) || quote_ident((s.sequence_name)::text)))::regclass) AS last_number
   FROM ((information_schema.sequences s
     JOIN pg_class c ON (((c.relname = (s.sequence_name)::name) AND (c.relkind = 'S'::"char"))))
     JOIN pg_user u ON ((c.relowner = u.usesysid)))
  WHERE (u.usename = USER);]]></complex-attribute>
                        <category _I_D="afaba9b8-2813-44b9-a3f2-81c38077c73e" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="97011ece-a1c4-43cb-9983-522ff8b3ef58" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="692c813c-8b25-4e88-9746-c09df9166121" name="sys_user_source" context="sys_user_source" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT (n.nspowner)::character varying(30) AS owner,
    (s.name)::character varying(30) AS name,
    (s.type)::character varying(12) AS type,
    (generate_subscripts(s.text, 1))::numeric AS line,
    (unnest(s.text))::character varying(4000) AS text
   FROM (( SELECT c.relnamespace AS nsp,
            t.tgname AS name,
            'TRIGGER'::text AS type,
            string_to_array(pg_get_triggerdef(t.oid), chr(10)) AS text
           FROM ((pg_trigger t
             JOIN pg_class c ON ((c.oid = t.tgrelid)))
             JOIN pg_user u ON ((u.usesysid = c.relowner)))
          WHERE (u.usename = USER)
        UNION ALL
         SELECT f.pronamespace AS nsp,
            f.proname AS name,
                CASE
                    WHEN (f.prokind = 'f'::"char") THEN 'FUNCTION'::text
                    WHEN (f.prokind = 'p'::"char") THEN 'PROCEDURE'::text
                    ELSE NULL::text
                END AS type,
            string_to_array(pg_get_functiondef(f.oid), chr(10)) AS text
           FROM ((pg_proc f
             JOIN pg_type ret ON ((f.prorettype = ret.oid)))
             JOIN pg_user u ON ((u.usesysid = f.proowner)))
          WHERE ((f.prokind = ANY (ARRAY['f'::"char", 'p'::"char"])) AND (u.usename = USER))
        UNION ALL
         SELECT t.typnamespace AS nsp,
            t.typname AS name,
            'TYPE'::text AS type,
                CASE
                    WHEN (t.typtype = 'c'::"char") THEN ARRAY( SELECT ((('CREATE OR REPLACE TYPE '::text || (t.typname)::text) || ' AS ('::text) || chr(10))
                    UNION ALL
                     SELECT (((((a.attname)::text || ' '::text) || format_type(a.atttypid, a.atttypmod)) ||
                            CASE
                                WHEN (lead(a.attrelid, 1) OVER () IS NULL) THEN ''::text
                                ELSE ','::text
                            END) || chr(10))
                       FROM pg_attribute a
                      WHERE (a.attrelid = t.typrelid)
                    UNION ALL
                     SELECT ');'::text)
                    WHEN (t.typtype = 'd'::"char") THEN ARRAY( SELECT ((('CREATE OR REPLACE DOMAIN '::text || (t.typname)::text) || ' AS '::text) || format_type(tt.oid, NULL::integer))
                       FROM pg_type tt
                      WHERE (tt.typarray = t.typbasetype))
                    ELSE NULL::text[]
                END AS text
           FROM (pg_type t
             JOIN pg_user u ON ((u.usesysid = t.typowner)))
          WHERE (((t.typrelid = (0)::oid) OR ( SELECT (c.relkind = 'c'::"char")
                   FROM pg_class c
                  WHERE (c.oid = t.typrelid))) AND (NOT (EXISTS ( SELECT 1
                   FROM pg_type el
                  WHERE ((el.oid = t.typelem) AND (el.typarray = t.oid))))) AND (u.usename = USER))) s
     JOIN pg_namespace n ON ((s.nsp = n.oid)))
  WHERE ((n.nspname <> 'pg_catalog'::name) AND (n.nspname <> 'information_schema'::name) AND (n.nspname !~ '^pg_toast'::text));]]></complex-attribute>
                        <category _I_D="8e92656f-0e5e-4dcc-8876-39af2a66eadc" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="6c4e7467-771f-4811-80b5-a1091964d401" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="08283272-df5f-494c-83bf-4fe50cff05e4" name="sys_user_tab_cols" context="sys_user_tab_cols" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="Describes the columns of the tables, views, and clusters owned by the current user. This view does not display the OWNER column.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (c.relname)::character varying(30) AS table_name,
    (a.attname)::character varying(30) AS column_name,
    (format_type(a.atttypid, a.atttypmod))::character varying(106) AS data_type,
    NULL::character varying(3) AS data_type_mod,
    NULL::character varying(30) AS data_type_owner,
    (a.attlen)::numeric AS data_length,
    NULL::numeric AS data_precision,
    NULL::numeric AS data_scale,
        CASE
            WHEN a.attnotnull THEN 'N'::character varying(1)
            ELSE 'Y'::character varying(1)
        END AS nullable,
    (a.attnum)::numeric AS column_id,
    NULL::numeric AS default_length,
    pg_get_expr(d.adbin, d.adrelid) AS data_default,
    (s.n_distinct)::numeric AS num_distinct,
    NULL::numeric AS low_value,
    NULL::numeric AS high_value,
    (s.null_frac)::numeric AS density,
    NULL::numeric AS num_nulls,
    NULL::numeric AS num_buckets,
    (COALESCE(st.last_autoanalyze, st.last_analyze))::date AS last_analyzed,
    NULL::numeric AS sample_size,
    'NCHAR_CS'::character varying(44) AS character_set_name,
    NULL::numeric AS char_col_decl_length,
        CASE
            WHEN (COALESCE(st.last_autoanalyze, st.last_analyze) IS NOT NULL) THEN 'YES'::character varying(3)
            ELSE 'NO'::character varying(3)
        END AS global_stats,
    'NO'::character varying(3) AS user_stats,
    (s.avg_width)::numeric AS avg_col_len,
    information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)) AS char_length,
    NULL::character varying(1) AS char_used,
    NULL::character varying(3) AS v80_fmt_image,
    NULL::character varying(3) AS data_upgraded,
    'NO'::character varying(3) AS hidden_column,
    'NO'::character varying(3) AS virtual_column,
    (a.attnum)::numeric AS segment_column_id,
    (a.attnum)::numeric AS internal_column_id,
    'NONE'::character varying(4) AS histogram,
    (a.attname)::character varying(4000) AS qualified_col_name
   FROM (((((((pg_attribute a
     JOIN pg_class c ON ((c.oid = a.attrelid)))
     JOIN pg_user u ON ((c.relowner = u.usesysid)))
     JOIN pg_type t ON ((a.atttypid = t.oid)))
     LEFT JOIN pg_attrdef d ON (((c.oid = d.adrelid) AND (a.attnum = d.adnum))))
     JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
     LEFT JOIN pg_stats s ON (((s.schemaname = n.nspname) AND (s.tablename = c.relname) AND (s.attname = a.attname))))
     LEFT JOIN pg_stat_user_tables st ON ((st.relid = c.oid)))
  WHERE ((a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (u.usename = USER) AND (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])));]]></complex-attribute>
                        <category _I_D="677b1f51-8c18-4eaf-a4d9-ea5616d2ae1e" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="459ea5d6-fa70-4104-bb6b-669547dd158a" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="d3ce9331-10cd-47e7-9061-f6d59ee63ecc" name="sys_user_tab_columns" context="sys_user_tab_columns" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="USER_TAB_COLUMNS describes the columns of the tables, views, and clusters owned by the current user">
                        <complex-attribute name="sql"><![CDATA[ SELECT (c.relname)::character varying(30) AS table_name,
    (a.attname)::character varying(30) AS column_name,
    (format_type(a.atttypid, a.atttypmod))::character varying(106) AS data_type,
    NULL::character varying(3) AS data_type_mod,
    NULL::character varying(30) AS data_type_owner,
    COALESCE((information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::numeric, (a.attlen)::numeric) AS data_length,
    NULL::numeric AS data_precision,
    NULL::numeric AS data_scale,
        CASE
            WHEN a.attnotnull THEN 'N'::character varying(1)
            ELSE 'Y'::character varying(1)
        END AS nullable,
    (a.attnum)::numeric AS column_id,
    NULL::numeric AS default_length,
    pg_get_expr(d.adbin, d.adrelid) AS data_default,
    (s.n_distinct)::numeric AS num_distinct,
    NULL::numeric AS low_value,
    NULL::numeric AS high_value,
    (s.null_frac)::numeric AS density,
    NULL::numeric AS num_nulls,
    NULL::numeric AS num_buckets,
    (COALESCE(st.last_autoanalyze, st.last_analyze))::date AS last_analyzed,
    NULL::numeric AS sample_size,
    'NCHAR_CS'::character varying(44) AS character_set_name,
    NULL::numeric AS char_col_decl_length,
        CASE
            WHEN (COALESCE(st.last_autoanalyze, st.last_analyze) IS NOT NULL) THEN 'YES'::character varying(3)
            ELSE 'NO'::character varying(3)
        END AS global_stats,
    'NO'::character varying(3) AS user_stats,
    (s.avg_width)::numeric AS avg_col_len,
    information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)) AS char_length,
    NULL::character varying(1) AS char_used,
    NULL::character varying(3) AS v80_fmt_image,
    NULL::character varying(3) AS data_upgraded,
    'NONE'::character varying(4) AS histogram
   FROM (((((((pg_attribute a
     JOIN pg_class c ON ((c.oid = a.attrelid)))
     JOIN pg_user u ON ((c.relowner = u.usesysid)))
     LEFT JOIN pg_attrdef d ON (((c.oid = d.adrelid) AND (a.attnum = d.adnum))))
     JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
     JOIN pg_type t ON ((a.atttypid = t.oid)))
     LEFT JOIN pg_stats s ON (((s.schemaname = n.nspname) AND (s.tablename = c.relname) AND (s.attname = a.attname))))
     LEFT JOIN pg_stat_user_tables st ON ((st.relid = c.oid)))
  WHERE ((a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (u.usename = USER) AND (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])));]]></complex-attribute>
                        <category _I_D="fcd4cb50-c00f-4e73-8636-a8dbc63a58d2" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="0ffa0b28-a68b-470e-bfe7-c7527aebdb91" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="0d535223-f873-42e0-adb8-e967e4e18a9c" name="sys_user_tab_comments" context="sys_user_tab_comments" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT (c.relname)::character varying(30) AS table_name,
        CASE
            WHEN (c.relkind = 'r'::"char") THEN 'TABLE'::text
            WHEN (c.relkind = 'v'::"char") THEN 'VIEW'::text
            ELSE NULL::text
        END AS table_type,
    (obj_description(c.oid))::character varying(4000) AS comments
   FROM ((pg_class c
     JOIN pg_namespace n ON ((c.relnamespace = n.oid)))
     JOIN pg_user u ON ((u.usesysid = c.relowner)))
  WHERE ((c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'p'::"char"])) AND (NOT c.relispartition) AND (n.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])) AND (u.usename = USER));]]></complex-attribute>
                        <category _I_D="2fbcf79e-a208-4ce2-907d-524bf9aa8d45" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="d4348f61-6306-4cec-ba0b-5add75b68f25" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="398ea62d-bcf1-4e7d-8357-284b7ad3a9c9" name="sys_user_tab_partitions" context="sys_user_tab_partitions" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT (pc1.relname)::character varying(128) AS table_name,
    (
        CASE
            WHEN (pc.relkind = 'p'::"char") THEN 'YES'::text
            ELSE 'NO'::text
        END)::character varying(3) AS composite,
    (pc.relname)::character varying(128) AS partition_name,
    (
        CASE
            WHEN (pc.relkind <> 'p'::"char") THEN (0)::bigint
            ELSE ( SELECT count(*) AS count
               FROM pg_inherits spc
              WHERE (spc.inhparent = pc.oid))
        END)::numeric AS subpartition_count,
    NULL::text AS high_value,
    NULL::numeric AS high_value_length,
    NULL::numeric AS partition_position,
    (( SELECT ts.spcname
           FROM pg_tablespace ts
          WHERE (ts.oid = pc.reltablespace)))::character varying(30) AS tablespace_name,
    NULL::numeric AS pct_free,
    NULL::numeric AS pct_used,
    NULL::numeric AS ini_trans,
    NULL::numeric AS max_trans,
    NULL::numeric AS initial_extent,
    NULL::numeric AS next_extent,
    NULL::numeric AS min_extent,
    NULL::numeric AS max_extent,
    NULL::numeric AS max_size,
    NULL::numeric AS pct_increase,
    NULL::numeric AS freelists,
    NULL::numeric AS freelist_groups,
    NULL::character varying(7) AS logging,
    NULL::character varying(8) AS compression,
    NULL::character varying(30) AS compress_for,
    NULL::numeric AS num_rows,
    NULL::numeric AS blocks,
    NULL::numeric AS empty_blocks,
    NULL::numeric AS avg_space,
    NULL::numeric AS chain_cnt,
    NULL::numeric AS avg_row_len,
    NULL::numeric AS sample_size,
    NULL::timestamp(0) without time zone AS last_analyzed,
    NULL::character varying(7) AS buffer_pool,
    NULL::character varying(7) AS flash_cache,
    NULL::character varying(7) AS cell_flash_cache,
    NULL::character varying(3) AS global_stats,
    NULL::character varying(3) AS user_stats,
    NULL::character varying(3) AS is_nested,
    NULL::character varying(128) AS parent_table_partition,
    NULL::character varying(3) AS "interval",
    NULL::character varying(4) AS segment_created,
    NULL::character varying(4) AS indexing,
    NULL::character varying(4) AS read_only,
    NULL::character varying(8) AS inmemory,
    NULL::character varying(8) AS inmemory_priority,
    NULL::character varying(15) AS inmemory_distribute,
    NULL::character varying(17) AS inmemory_compression,
    NULL::character varying(13) AS inmemory_duplicate,
    NULL::character varying(24) AS cellmemory,
    NULL::character varying(12) AS inmemory_service,
    NULL::character varying(1000) AS inmemory_service_name,
    NULL::character varying(8) AS memoptimize_read,
    NULL::character varying(8) AS memoptimize_write
   FROM (((((pg_class pc
     JOIN pg_inherits pi ON ((pi.inhrelid = pc.oid)))
     JOIN pg_class pc1 ON ((pi.inhparent = pc1.oid)))
     JOIN pg_partitioned_table ppt ON ((ppt.partrelid = pi.inhparent)))
     JOIN pg_namespace ns ON ((ns.oid = pc.relnamespace)))
     JOIN pg_tables t ON (((t.tablename = pc1.relname) AND (t.schemaname = ns.nspname))))
  WHERE ((ns.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])) AND (t.tableowner = USER) AND pc.relispartition AND (NOT (EXISTS ( SELECT 1
           FROM pg_class pcs
          WHERE (pcs.relispartition AND (pcs.oid = pi.inhparent))))));]]></complex-attribute>
                        <category _I_D="73eec8e6-ee79-487e-8349-2c3376ec1567" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="a02d1950-8362-43a0-b42a-4902d4c7f10e" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="bd5609e6-bff0-4908-b616-3b9f9fb08061" name="sys_user_tab_subpartitions" context="sys_user_tab_subpartitions" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE">
                        <complex-attribute name="sql"><![CDATA[ SELECT (ns.nspname)::character varying(128) AS table_owner,
    (pc2.relname)::character varying(128) AS table_name,
    (pc1.relname)::character varying(128) AS partition_name,
    (pc.relname)::character varying(128) AS subpartition_name,
    NULL::text AS high_value,
    NULL::numeric AS high_value_length,
    NULL::numeric AS partition_position,
    NULL::numeric AS subpartition_position,
    (( SELECT ts.spcname
           FROM pg_tablespace ts
          WHERE (ts.oid = pc.reltablespace)))::character varying(30) AS tablespace_name,
    NULL::numeric AS pct_free,
    NULL::numeric AS pct_used,
    NULL::numeric AS ini_trans,
    NULL::numeric AS max_trans,
    NULL::numeric AS initial_extent,
    NULL::numeric AS next_extent,
    NULL::numeric AS min_extent,
    NULL::numeric AS max_extent,
    NULL::numeric AS max_size,
    NULL::numeric AS pct_increase,
    NULL::numeric AS freelists,
    NULL::numeric AS freelist_groups,
    NULL::character varying(3) AS logging,
    NULL::character varying(8) AS compression,
    NULL::character varying(30) AS compress_for,
    NULL::numeric AS num_rows,
    NULL::numeric AS blocks,
    NULL::numeric AS empty_blocks,
    NULL::numeric AS avg_space,
    NULL::numeric AS chain_cnt,
    NULL::numeric AS avg_row_len,
    NULL::numeric AS sample_size,
    NULL::timestamp(0) without time zone AS last_analyzed,
    NULL::character varying(7) AS buffer_pool,
    NULL::character varying(7) AS flash_cache,
    NULL::character varying(7) AS cell_flash_cache,
    NULL::character varying(3) AS global_stats,
    NULL::character varying(3) AS user_stats,
    NULL::character varying(3) AS "interval",
    NULL::character varying(3) AS segment_created,
    NULL::character varying(3) AS indexing,
    NULL::character varying(3) AS read_only,
    NULL::character varying(8) AS inmemory,
    NULL::character varying(8) AS inmemory_priority,
    NULL::character varying(15) AS inmemory_distribute,
    NULL::character varying(17) AS inmemory_compression,
    NULL::character varying(13) AS inmemory_duplicate,
    NULL::character varying(12) AS inmemory_service,
    NULL::character varying(1000) AS inmemory_service_name,
    NULL::character varying(24) AS cellmemory,
    NULL::character varying(8) AS memoptimize_read,
    NULL::character varying(8) AS memoptimize_write
   FROM (((((((pg_class pc
     JOIN pg_inherits pis ON ((pis.inhrelid = pc.oid)))
     JOIN pg_class pc1 ON ((pis.inhparent = pc1.oid)))
     JOIN pg_partitioned_table ppt ON ((ppt.partrelid = pis.inhparent)))
     JOIN pg_namespace ns ON ((ns.oid = pc.relnamespace)))
     JOIN pg_inherits pi ON ((pis.inhparent = pi.inhrelid)))
     JOIN pg_class pc2 ON ((pi.inhparent = pc2.oid)))
     JOIN pg_tables t ON (((t.tablename = pc2.relname) AND (t.schemaname = ns.nspname))))
  WHERE ((ns.nspname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])) AND pc.relispartition AND (t.tableowner = USER));]]></complex-attribute>
                        <category _I_D="704a455f-18d1-447e-ac7f-bd8457eaf15a" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="71fbef45-6d81-4875-8925-4140d64c2cd5" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="fa65b6ea-60a2-4f53-9468-71eb83372630" name="sys_user_tables" context="sys_user_tables" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="USER_TABLES describes the relational tables owned by the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (t.tablename)::character varying(30) AS table_name,
    (t.tablespace)::character varying(30) AS tablespace_name,
    NULL::character varying(30) AS cluster_name,
    NULL::character varying(30) AS iot_name,
    'VALID'::character varying(8) AS status,
    NULL::numeric AS pct_free,
    NULL::numeric AS pct_used,
    NULL::numeric AS ini_trans,
    NULL::numeric AS max_trans,
    NULL::numeric AS initial_extent,
    NULL::numeric AS next_extent,
    NULL::numeric AS min_extents,
    NULL::numeric AS max_extents,
    NULL::numeric AS pct_increase,
    NULL::numeric AS freelists,
    NULL::numeric AS freelist_groups,
    'NO'::character varying(3) AS logging,
    'N'::character varying(1) AS backed_up,
    stat.n_live_tup AS num_rows,
    NULL::numeric AS blocks,
    NULL::numeric AS empty_blocks,
    NULL::numeric AS avg_space,
    NULL::numeric AS chain_cnt,
    NULL::numeric AS avg_row_len,
    NULL::numeric AS avg_space_freelist_blocks,
    NULL::numeric AS num_freelist_blocks,
    NULL::character varying(10) AS degree,
    NULL::character varying(10) AS instances,
    NULL::character varying(5) AS cache,
    NULL::character varying(8) AS table_lock,
    NULL::numeric AS sample_size,
    (COALESCE(stat.last_autoanalyze, stat.last_analyze))::date AS last_analyzed,
    'NO'::character varying(3) AS partitioned,
    NULL::character varying(12) AS iot_type,
        CASE
            WHEN ((n.nspname !~ '^pg_toast'::text) AND (n.nspname ~~ 'pg_temp%'::text)) THEN 'Y'::text
            ELSE 'N'::text
        END AS temporary,
    'N'::character varying(1) AS secondary,
    'NO'::character varying(3) AS nested,
    'DEFAULT'::character varying(7) AS buffer_pool,
    'DEFAULT'::character varying(7) AS flash_cache,
    'DEFAULT'::character varying(7) AS cell_flash_cache,
    'DISABLED'::character varying(8) AS row_movement,
    'NO'::character varying(3) AS global_stats,
    NULL::character varying(3) AS user_stats,
    NULL::character varying(15) AS duration,
    'DISABLED'::character varying(8) AS skip_corrupt,
    'NO'::character varying(3) AS monitoring,
    NULL::character varying(30) AS cluster_owner,
    'DISABLED'::character varying(8) AS dependencies,
    'DISABLED'::character varying(8) AS compression,
    NULL::character varying(12) AS compress_for,
    'NO'::character varying(3) AS dropped,
    NULL::character varying(3) AS read_only,
    'YES'::character varying(3) AS segment_created,
    'DEFAULT'::character varying(7) AS result_cache
   FROM ((pg_tables t
     JOIN pg_stat_user_tables stat ON (((t.schemaname = stat.schemaname) AND (t.tablename = stat.relname))))
     JOIN pg_namespace n ON ((t.schemaname = n.nspname)))
  WHERE ((t.tableowner = USER) AND (t.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])));]]></complex-attribute>
                        <category _I_D="8073560b-0544-4931-a5eb-ccdcb9df31b0" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="ed426238-828a-4605-8dcb-720750ed5ef1" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="4e256b9d-ad61-4e74-a140-6cedb929d817" name="sys_user_triggers" context="sys_user_triggers" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="USER_TRIGGERS describes the triggers owned by the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT (trg.tgname)::character varying(128) AS trigger_name,
    (
        CASE ((trg.tgtype)::integer & 66)
            WHEN 2 THEN ('BEFORE'::text ||
            CASE ((trg.tgtype)::integer & 1)
                WHEN 1 THEN ' EACH ROW'::text
                ELSE 'STATEMENT'::text
            END)
            WHEN 64 THEN 'INSTEAD OF'::text
            ELSE ('AFTER'::text ||
            CASE ((trg.tgtype)::integer & 1)
                WHEN 1 THEN ' EACH ROW'::text
                ELSE 'STATEMENT'::text
            END)
        END)::character varying(16) AS trigger_type,
    (
        CASE ((trg.tgtype)::integer & ((28)::smallint)::integer)
            WHEN 32 THEN 'TRUNCATE'::text
            WHEN 16 THEN 'UPDATE'::text
            WHEN 8 THEN 'DELETE'::text
            WHEN 4 THEN 'INSERT'::text
            WHEN 20 THEN 'INSERT OR UPDATE'::text
            WHEN 28 THEN 'INSERT OR UPDATE OR DELETE'::text
            WHEN 24 THEN 'UPDATE OR DELETE'::text
            WHEN 12 THEN 'INSERT OR DELETE'::text
            ELSE NULL::text
        END)::character varying(246) AS triggering_event,
    (ns.nspname)::character varying(128) AS table_owner,
    (
        CASE ((trg.tgtype)::integer & 66)
            WHEN 64 THEN 'VIEW'::text
            ELSE 'TABLE'::text
        END)::character varying(18) AS base_object_type,
    (tbl.relname)::character varying(128) AS table_name,
    (( SELECT string_agg((a.attname)::text, ', '::text) AS string_agg
           FROM pg_attribute a
          WHERE ((a.attrelid = tbl.oid) AND (a.attnum = ANY ((trg.tgattr)::smallint[])))))::character varying(4000) AS column_name,
    'REFERENCING NEW AS NEW OLD AS OLD'::character varying(422) AS referencing_names,
    (
        CASE
            WHEN pg_has_role(tbl.relowner, 'USAGE'::text) THEN (regexp_match(pg_get_triggerdef(trg.oid), '.{35,} WHEN \((.+)\) EXECUTE PROCEDURE'::text))[1]
            ELSE NULL::text
        END)::character varying(4000) AS when_clause,
    (
        CASE
            WHEN (trg.tgenabled = 'D'::"char") THEN 'DISABLED'::text
            ELSE 'ENABLED'::text
        END)::character varying(8) AS status,
    (obj_description(trg.oid))::character varying(400) AS description,
    'PL/SQL'::character varying(11) AS action_type,
    (((n.nspname)::text || '.'::text) || (proc.proname)::text) AS trigger_body,
    'NO'::character varying(3) AS crossedition,
    'NO'::character varying(3) AS before_statement,
    'NO'::character varying(3) AS before_row,
    'NO'::character varying(3) AS after_row,
    'NO'::character varying(3) AS after_statement,
    'NO'::character varying(3) AS instead_of_row,
    (
        CASE ((trg.tgtype)::integer & 66)
            WHEN 2 THEN 'YES'::text
            WHEN 64 THEN 'NO'::text
            ELSE 'YES'::text
        END)::character varying(3) AS fire_once,
    'NO'::character varying(3) AS apply_server_only
   FROM (((((pg_trigger trg
     JOIN pg_proc proc ON ((proc.oid = trg.tgfoid)))
     JOIN pg_namespace n ON ((n.oid = proc.pronamespace)))
     JOIN pg_class tbl ON ((trg.tgrelid = tbl.oid)))
     JOIN pg_namespace ns ON ((ns.oid = tbl.relnamespace)))
     JOIN pg_user u ON ((u.usesysid = tbl.relowner)))
  WHERE ((NOT trg.tgisinternal) AND (u.usename = USER));]]></complex-attribute>
                        <category _I_D="7e026d97-5862-4546-a778-3a65bb4b4aae" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="b581a930-7225-432d-a0a3-87989780cc67" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="bd1451fa-47a9-4dc3-96e0-eab76b03f7bf" name="sys_user_users" context="sys_user_users" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="USER_USERS describes the current user.">
                        <complex-attribute name="sql"><![CDATA[ SELECT n.nspname AS username,
    n.nspowner AS user_id,
    'OPEN'::character varying(32) AS account_status,
    NULL::timestamp without time zone AS lock_date,
    NULL::timestamp without time zone AS expiry_date,
    'USERS'::character varying(30) AS default_tablespace,
    'TEMP'::character varying(30) AS temporary_tablespace,
    NULL::timestamp without time zone AS created,
    NULL::character varying(30) AS initial_rsrc_consumer_group,
    NULL::character varying(4000) AS external_name
   FROM (pg_namespace n
     JOIN pg_user u ON ((n.nspowner = u.usesysid)))
  WHERE (u.usename = USER);]]></complex-attribute>
                        <category _I_D="f111a603-71be-46d9-bfac-d5769747d887" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="402b8f12-3c68-497f-a0c8-a221b94648e0" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="3bc50e24-90e8-4bff-9f1e-3cc05be04ac9" name="sys_user_views" context="sys_user_views" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="USER_VIEWS describes the views owned by the current user">
                        <complex-attribute name="sql"><![CDATA[ SELECT (viewname)::character varying(30) AS view_name,
    (length(definition))::numeric AS text_length,
    (definition)::character varying(409600) AS text,
    NULL::numeric AS type_text_length,
    NULL::character varying(4000) AS type_text,
    NULL::numeric AS oid_text_length,
    NULL::character varying(4000) AS oid_text,
    NULL::character varying(30) AS view_type_owner,
    NULL::character varying(30) AS view_type,
    NULL::character varying(30) AS superview_name,
    'N'::character varying(1) AS editioning_view,
    'Y'::character varying(1) AS read_only
   FROM pg_views
  WHERE ((schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name, 'public_synonyms'::name])) AND (viewowner = USER));]]></complex-attribute>
                        <category _I_D="e277a45e-b93f-4fe5-9a1c-3fe19a40b7c9" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="05c7e1b6-6a99-4995-8af9-e6e070ab0d30" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="aeb59ff3-984f-4ab7-8a74-ad3b7a2a8cce" name="v$instance" context="v$instance" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="This view displays the state of the current instance (emulates Oracle V$INSTANCE view)">
                        <complex-attribute name="sql"><![CDATA[ SELECT aws_oracle_ext."dbms_utility$current_instance"() AS instance_number,
    (inet_server_addr())::character varying AS instance_name,
    (inet_server_addr())::character varying AS host_name,
    current_setting('server_version_num'::text) AS version,
    pg_postmaster_start_time() AS startup_time,
    'OPEN'::character varying AS status,
    'NO'::character varying AS parallel,
    1 AS "THREAD#",
    'FAILED'::character varying AS archiver,
    NULL::character varying AS log_switch_wait,
    'ALLOWED'::character varying AS logins,
    'NO'::character varying AS shutdown_pending,
    'ACTIVE'::character varying AS database_status,
    'PRIMARY_INSTANCE'::character varying AS instance_role,
    'NORMAL'::character varying AS active_state,
    'NO'::character varying AS blocked;]]></complex-attribute>
                        <category _I_D="02ed6776-188a-4632-8d17-435f9fb458ef" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="c7f3bc82-e20f-47e5-926f-5d279d0b3410" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="1ce0b645-f090-4859-9ec7-855e7bf990b4" name="v$nls_parameters" context="v$nls_parameters" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="Emulation for oracle NLS view">
                        <complex-attribute name="sql"><![CDATA[ SELECT parameter,
    value,
    con_id
   FROM aws_oracle_ext."return_v$nls_parameters"() "return_v$nls_parameters"(parameter, value, con_id);]]></complex-attribute>
                        <category _I_D="9d629f49-d213-4728-acee-6b96fd028757" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="84c89297-6c65-412e-92be-96d6af3a84d0" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                    <view _I_D="164315a4-c8db-4a83-a8cd-2c2a19579d9f" name="v$version" context="v$version" subcategories-loading="none" object-loading="extended" is-updatable="NO" check-option="NONE" comment="V$VERSION emulation">
                        <complex-attribute name="sql"><![CDATA[ SELECT version() AS banner;]]></complex-attribute>
                        <category _I_D="74376ed2-7c80-48b4-824a-9a0091ee802e" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="6b95fb9e-87f5-40d7-b5eb-0eadf21236d1" name="Triggers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="trigger" mdl-expected-node-count="0"/>
                    </view>
                </category>
                <category _I_D="b5add179-a52f-4ea5-b763-d5174be9b616" name="Collations" order-num="3" objects-loading="empty" subcategories-loading="full" child-type="collation"/>
                <category _I_D="70bad78f-ef49-401d-aab2-202e1a40f6b1" name="Operators" order-num="4" objects-loading="empty" subcategories-loading="full" child-type="operator"/>
                <category _I_D="c0e47968-d336-48c2-829c-14434a48ed35" name="Rules" order-num="5" objects-loading="empty" subcategories-loading="full" child-type="rule"/>
                <category _I_D="746395a7-7b77-46a9-9d1e-6ab41e5f3369" name="FTS Configurations" order-num="6" objects-loading="empty" subcategories-loading="full" child-type="ftsconfiguration"/>
                <category _I_D="dd22bafa-2ba0-426a-a3fd-1d1af2bbe88d" name="FTS Dictionaries" order-num="7" objects-loading="empty" subcategories-loading="full" child-type="ftsdictionary"/>
                <category _I_D="58eb2ada-133d-4505-a809-14d8f666aadb" name="Functions" order-num="8" objects-loading="extended" subcategories-loading="none" child-type="function">
                    <function _I_D="bec624ed-bd41-4ebb-ac62-71e1fed60f63" name="a_getarrayvalue" is-trigger-function="0" unique-function-name="a_getarrayvalue" is-aggregate="f" language-name="plpgsql" context="a_getarrayvalue" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="jsonb" function-arguments="ppath text, pprocedurename text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23152" volatility="VOLATILE" is-window="f" function-identity-arguments="ppath text, pprocedurename text" overload-function-count="1" proc-language="plpgsql" function-signature="a_getarrayvalue(ppath text, pprocedurename text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    pathParts TEXT[];
    vstoragetable TEXT;
    vSQL TEXT;
    vIndexBy TEXT;
    vres JSONB;
BEGIN
    
    pathParts := aws_oracle_ext.getPathparts(ppath);
    
    IF pathParts IS NULL THEN

        RETURN FALSE;

    END IF;

    SELECT storage_table_name,
        index_by
    INTO vstoragetable,
        vIndexBy
    FROM aws_oracle_ext$arrays a
    WHERE a.array_name = aws_oracle_ext.check_identifier_case(pathParts[1])
    AND a.procedure_name = pprocedurename;

    IF NOT FOUND THEN

        RAISE USING MESSAGE = 'Array structure must be initialized';

    END IF;

    vSQL := CONCAT
    (
        'SELECT record_body FROM ',
        vstoragetable,
        ' WHERE id = CAST($1 AS ',
        vIndexBy,
        ')'
    );

    EXECUTE vSQL INTO STRICT vres USING pathParts[2];

    vres := JSONB_BUILD_OBJECT
    (
        'result',
        vres
    );

    RETURN vres;

END;
]]></complex-attribute>
                        <category _I_D="816bda06-2e40-4a85-bed1-d7fb215a610a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3bd382c1-c02a-4830-9ac2-9d00e22e731d" name="a_setarrayvalue" is-trigger-function="0" unique-function-name="a_setarrayvalue" is-aggregate="f" language-name="plpgsql" context="a_setarrayvalue" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,anyelement" is-returning-set="f" ret-datatype="bool" function-arguments="ppath text, pprocedurename text, pvalue anyelement" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23153" volatility="VOLATILE" is-window="f" function-identity-arguments="ppath text, pprocedurename text, pvalue anyelement" overload-function-count="1" proc-language="plpgsql" function-signature="a_setarrayvalue(ppath text, pprocedurename text, pvalue anyelement)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    pathParts TEXT[];
    vstoragetable TEXT;
    vSQL TEXT;
    vIndexBy TEXT;
BEGIN

    pathParts := aws_oracle_ext.getPathparts(ppath);
    
    IF pathParts IS NULL THEN

        RETURN FALSE;

    END IF;

    SELECT storage_table_name,
        index_by
    INTO vstoragetable,
        vIndexBy
    FROM aws_oracle_ext$arrays a
    WHERE a.array_name = aws_oracle_ext.check_identifier_case(pathParts[1])
    AND a.procedure_name = pprocedurename;

    IF NOT FOUND THEN

        RAISE USING MESSAGE = 'Array structure must be initialized';

    END IF;

    IF vstoragetable IS NULL THEN

        RETURN FALSE;

    END IF;
    
    vSQL := CONCAT
    (
        'INSERT INTO ',
        vstoragetable,
        $$
        AS t(id, record_body) VALUES (CAST($1 AS $$,
        vIndexBy,
        $$), aws_oracle_ext.json_set_by_path('{}'::JSONB, $2, $3))
        ON CONFLICT (id) DO UPDATE
        SET record_body = aws_oracle_ext.json_set_by_path(t.record_body, $2, $3)
        $$
    );

    EXECUTE vSQL USING pathParts[2], ppath, pvalue;

    RETURN TRUE;

END;
]]></complex-attribute>
                        <category _I_D="f9776722-01a2-41a2-b099-b005e98fc3aa" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d6c133c9-c5b3-408d-b495-ea380b5d9592" name="add_months" is-trigger-function="0" unique-function-name="add_months" is-aggregate="f" language-name="sql" context="add_months" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone,integer" is-returning-set="f" ret-datatype="timestamp" function-arguments="pdate timestamp without time zone, pmonths integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22400" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pdate timestamp without time zone, pmonths integer" overload-function-count="1" proc-language="sql" function-signature="add_months(pdate timestamp without time zone, pmonths integer)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT
        CASE
            WHEN aws_oracle_ext.last_day(pdate) <> pdate THEN
                pdate + MAKE_INTERVAL(months => pmonths)
            ELSE 
                aws_oracle_ext.last_day(pDate + MAKE_INTERVAL(months => pmonths))
    END;

]]></complex-attribute>
                        <category _I_D="928796bd-f617-42fa-9fa7-5a06700151e7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="db6df80d-b7e7-4a48-b517-6cd5c6e0d53f" name="array$add_fields_to_array" is-trigger-function="0" unique-function-name="array$add_fields_to_array" is-aggregate="f" language-name="plpgsql" context="array$add_fields_to_array" subcategories-loading="none" object-loading="extended" arguments-datatypes="bigint,text" is-returning-set="f" ret-datatype="void" function-arguments="p_array_id bigint, p_fields text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22011" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_array_id bigint, p_fields text" overload-function-count="1" proc-language="plpgsql" function-signature="array$add_fields_to_array(p_array_id bigint, p_fields text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
END;
]]></complex-attribute>
                        <category _I_D="69b49eac-f40e-4887-abdb-51bd2cfbed78" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="62157d75-4159-422e-b1b6-285572a59ca0" name="array$first" is-trigger-function="0" unique-function-name="array$first" is-aggregate="f" language-name="sql" context="array$first" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,anyelement" is-returning-set="f" ret-datatype="anyelement" function-arguments="p_array_path character varying, p_procedure_name character varying, p_def anyelement DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22016" volatility="VOLATILE" is-window="f" function-identity-arguments="p_array_path character varying, p_procedure_name character varying, p_def anyelement" overload-function-count="1" proc-language="sql" function-signature="array$first(p_array_path character varying, p_procedure_name character varying, p_def anyelement)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT aws_oracle_ext.collection_first
    (
        p_routine_name => p_procedure_name,
        p_collection_path => p_array_path,
        p_tp => p_def
    );

]]></complex-attribute>
                        <category _I_D="9c6f8211-b395-4762-beac-481b024e1afa" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="85cf6d4a-c2eb-4faf-86b6-a300958d983d" name="array$get_value" is-trigger-function="0" unique-function-name="array$get_value" is-aggregate="f" language-name="plpgsql" context="array$get_value" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,anyelement" is-returning-set="f" ret-datatype="anyelement" function-arguments="p_array_value_path character varying, p_procedure_name character varying, p_value_datatype anyelement DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22017" volatility="VOLATILE" is-window="f" function-identity-arguments="p_array_value_path character varying, p_procedure_name character varying, p_value_datatype anyelement" overload-function-count="1" proc-language="plpgsql" function-signature="array$get_value(p_array_value_path character varying, p_procedure_name character varying, p_value_datatype anyelement)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vret JSONB;
BEGIN

    vret := aws_oracle_ext.collection_element_get
	(
		p_routine_name => p_procedure_name,
        p_collection_path => p_array_value_path
	);

    IF vret IS NULL THEN

        RAISE NO_DATA_FOUND;

    END IF;

    RETURN JSONB_POPULATE_RECORD
    (
        p_value_datatype,
        vret
    );

END;
]]></complex-attribute>
                        <category _I_D="72eb1248-c393-4c31-aa88-06cb579ff055" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7dcc1d1c-54ad-4ba0-892c-c8fbfe2a5a47" name="array$last" is-trigger-function="0" unique-function-name="array$last" is-aggregate="f" language-name="sql" context="array$last" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,anyelement" is-returning-set="f" ret-datatype="anyelement" function-arguments="p_array_path character varying, p_procedure_name character varying, p_def anyelement DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22018" volatility="VOLATILE" is-window="f" function-identity-arguments="p_array_path character varying, p_procedure_name character varying, p_def anyelement" overload-function-count="1" proc-language="sql" function-signature="array$last(p_array_path character varying, p_procedure_name character varying, p_def anyelement)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT aws_oracle_ext.collection_last
    (
        p_routine_name => p_procedure_name,
        p_collection_path => p_array_path,
        p_tp => p_def
    );

]]></complex-attribute>
                        <category _I_D="60ed7444-4809-4f61-b85a-3bb347fa9859" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b1b8e515-6073-42ed-a955-91b1168f4b6e" name="array$next" is-trigger-function="0" unique-function-name="array$next" is-aggregate="f" language-name="sql" context="array$next" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying,anyelement" is-returning-set="f" ret-datatype="anyelement" function-arguments="p_array_path character varying, p_array_key character varying, p_procedure_name character varying, p_def anyelement DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22019" volatility="VOLATILE" is-window="f" function-identity-arguments="p_array_path character varying, p_array_key character varying, p_procedure_name character varying, p_def anyelement" overload-function-count="1" proc-language="sql" function-signature="array$next(p_array_path character varying, p_array_key character varying, p_procedure_name character varying, p_def anyelement)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT aws_oracle_ext.collection_next
	(
		p_routine_name => p_procedure_name,
        p_collection_path => p_array_path,
        p_idx => p_array_key,
        p_tp => p_def
	);

]]></complex-attribute>
                        <category _I_D="3a0af668-e3e0-434c-99ae-c01d81a3a5a9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c8c08ebc-016a-495b-bfd7-dd9e1f7a28be" name="array$prior" is-trigger-function="0" unique-function-name="array$prior" is-aggregate="f" language-name="sql" context="array$prior" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying,anyelement" is-returning-set="f" ret-datatype="anyelement" function-arguments="p_array_path character varying, p_array_key character varying, p_procedure_name character varying, p_def anyelement DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22020" volatility="VOLATILE" is-window="f" function-identity-arguments="p_array_path character varying, p_array_key character varying, p_procedure_name character varying, p_def anyelement" overload-function-count="1" proc-language="sql" function-signature="array$prior(p_array_path character varying, p_array_key character varying, p_procedure_name character varying, p_def anyelement)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT aws_oracle_ext.collection_prior
	(
		p_routine_name => p_procedure_name,
        p_collection_path => p_array_path,
        p_idx => p_array_key,
        p_tp => p_def
	);

]]></complex-attribute>
                        <category _I_D="89efdd34-0195-48ca-beb1-eb0dd837e18c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="53d9af6a-1ea2-43d2-8ccc-e6a1af8aa0d4" name="array$set_value" is-trigger-function="0" unique-function-name="array$set_value" is-aggregate="f" language-name="sql" context="array$set_value" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,anyelement" is-returning-set="f" ret-datatype="void" function-arguments="p_array_path character varying, p_procedure_name character varying, p_value anyelement" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22021" volatility="VOLATILE" is-window="f" function-identity-arguments="p_array_path character varying, p_procedure_name character varying, p_value anyelement" overload-function-count="1" proc-language="sql" function-signature="array$set_value(p_array_path character varying, p_procedure_name character varying, p_value anyelement)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT aws_oracle_ext.collection_element_set
    (
        p_routine_name => p_procedure_name,
        p_collection_path => p_array_path,
        p_val => p_value
    );

]]></complex-attribute>
                        <category _I_D="d2059090-d3ea-4cfe-9bda-dcad26d6f10a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="69b72adf-ecbd-4a0e-b288-48cc4bfadf7a" name="asciistr" is-trigger-function="0" unique-function-name="asciistr" is-aggregate="f" language-name="sql" context="asciistr" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="text" function-arguments="p_str text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22284" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_str text" overload-function-count="1" proc-language="sql" function-signature="asciistr(p_str text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT
        CASE
            WHEN p_str ='' THEN NULL::TEXT
            ELSE
                (
                    SELECT ARRAY_TO_STRING
                    (
                        ARRAY_AGG
                        (
                            CASE 
                                WHEN ASCII(v) <= 127 and ASCII(v) != 92 THEN
                                    v
                        ELSE
                            CONCAT
                            (
                                '\',
                                UPPER
                                (
                                    LPAD
                                    (
                                        TO_HEX(ASCII(v)),
                                        4,
                                        '0'
                                    )
                                )
                            )
                        END
                        ),
                        ''
                    )
                    FROM REGEXP_SPLIT_TO_TABLE(p_str, '') AS v
                )
        END;

]]></complex-attribute>
                        <category _I_D="a5318979-974c-4555-b828-dc8b0ff0be5c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e30eb7ef-5239-4920-b634-c306476f73fc" name="autonomous_exec" is-trigger-function="0" unique-function-name="autonomous_exec" is-aggregate="f" language-name="plpgsql" context="autonomous_exec" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,json,json" is-returning-set="f" ret-datatype="record" function-arguments="sql_text text, OUT aws_params json, OUT aws_session_env json" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23197" volatility="VOLATILE" is-window="f" function-identity-arguments="sql_text text, OUT aws_params json, OUT aws_session_env json" overload-function-count="1" proc-language="plpgsql" function-signature="autonomous_exec(sql_text text, OUT aws_params json, OUT aws_session_env json)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  v_result        JSON;
  v_srvname       name;
  v_fdwname       name;
  v_current_user  name;  
  v_connname      text;
  v_connstr       text;
  v_conn_result   text;
  v_send_result   int;
BEGIN
  v_srvname := 'loopback_dblink';
  v_current_user := current_user;
  v_connname := replace(uuid_generate_v4()::text,'-','');
  v_connstr  := v_srvname;

  --Check if the foreign server is present
  IF NOT EXISTS (SELECT 1
                   FROM pg_foreign_server s
                  WHERE s.srvname = v_srvname) THEN
    RAISE USING MESSAGE := format('The FOREIGN SERVER (%s) doesn''t exist.', v_srvname),
                DETAIL := format('The FOREIGN SERVER (%s) must be present.', v_srvname),
                HINT := format('Make sure that the FOREIGN SERVER (%s) exists.', v_srvname);
  END IF;  

  --Check the foreign-data wrapper name of the foreign_server
  SELECT w.fdwname
    INTO v_fdwname
    FROM pg_foreign_server s
    JOIN pg_foreign_data_wrapper w 
      ON w.oid = s.srvfdw
   WHERE s.srvname = v_srvname;
  IF v_fdwname <> 'dblink_fdw' THEN
    RAISE USING MESSAGE := format('The name of FOREIGN DATA WRAPPER (%s) that manages the server (%s) should be dblink_fdw', v_fdwname, v_srvname),
                DETAIL := format('The name of FOREIGN DATA WRAPPER (%s) that manages the server (%s) is not dblink_fdw', v_fdwname, v_srvname),
                HINT := format('Make sure that the FOREIGN SERVER (%s) has been defined using dblink_fdw foreign-data wrapper', v_srvname);
  END IF;  

  --Check if the user mapping is present for current user
  IF NOT EXISTS (SELECT 1
                   FROM pg_user_mappings m
                   JOIN pg_foreign_server s
                     ON s.oid = m.srvid
                  WHERE s.srvname = v_srvname
                    AND m.usename = v_current_user) THEN
    RAISE USING MESSAGE := format('No USER MAPPING exists for the FOREIGN SERVER (%s) and USER (%s).', v_srvname, v_current_user),
                DETAIL := format('The USER MAPPING for the FOREIGN SERVER (%s) and USER (%s) must be present', v_srvname, v_current_user),
                HINT := format('Make sure that the USER MAPPING for the FOREIGN SERVER (%s) and USER (%s) exists.', v_srvname, v_current_user);
  END IF;
 
  --Open the connection  
  SELECT dblink_connect(v_connname,v_connstr) 
    INTO v_conn_result;
  IF v_conn_result <> 'OK' THEN
    RAISE USING MESSAGE := 'An error has occurred while trying to open a loopback dblink connection';
  END IF;

  --Send the query with the autonomous routine call
  SELECT dblink_send_query(v_connname, sql_text) 
    INTO v_send_result;
  IF v_send_result = 0 THEN
    RAISE USING MESSAGE := 'An error has occurred while sending the query';
  END IF;

  --Get the result of the query with the autonomous routine call 
  SELECT t.aws_params, t.aws_session_env 
    INTO aws_params, aws_session_env
    FROM dblink_get_result(v_connname) 
      AS t(aws_params JSON, aws_session_env JSON);
    
  --Close a connection
  SELECT dblink_disconnect(v_connname) 
    INTO v_conn_result;
  IF v_conn_result <> 'OK' THEN
    RAISE USING MESSAGE := 'An error has occurred while trying to close a loopback dblink connection';
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    --Check if the connection exists
    IF v_connname = ANY(dblink_get_connections()) THEN
      PERFORM dblink_disconnect(v_connname);
    END IF;
    RAISE;
END;
]]></complex-attribute>
                        <category _I_D="e1c2d573-ff0e-459f-8418-1346d1ac5e62" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="730457f5-1b23-4f1f-8a67-82cc23f49841" name="bulk$fetch_cursor" is-trigger-function="0" unique-function-name="bulk$fetch_cursor" is-aggregate="f" language-name="plpgsql" context="bulk$fetch_cursor" subcategories-loading="none" object-loading="extended" arguments-datatypes="refcursor,anyelement,double precision" is-returning-set="t" ret-datatype="anyelement" function-arguments="pcur refcursor, INOUT precordtype anyelement, plimit double precision DEFAULT '-1'::integer" schema-id="21999" function-type="RET_DATASET" count-arguments="3" function-id="23141" volatility="VOLATILE" is-window="f" function-identity-arguments="pcur refcursor, INOUT precordtype anyelement, plimit double precision" overload-function-count="1" proc-language="plpgsql" function-signature="bulk$fetch_cursor(pcur refcursor, INOUT precordtype anyelement, plimit double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    LOOP
      FETCH $1 INTO $2; 
      IF (NOT FOUND) THEN
          EXIT;
      END IF;

      pLimit := pLimit-1;  
      RETURN NEXT;

      IF (pLimit=0) THEN
          EXIT;
      END IF;
    END LOOP;
  RETURN;
END;
]]></complex-attribute>
                        <category _I_D="70b34e09-8eee-4b11-a9cf-5f12f87e6859" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8e9c7747-8312-46be-9844-78ba7e403676" name="bulk_exceptions$create_array" is-trigger-function="0" unique-function-name="bulk_exceptions$create_array" is-aggregate="f" language-name="plpgsql" context="bulk_exceptions$create_array" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="void" function-arguments="p_procedure_name character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23147" volatility="VOLATILE" is-window="f" function-identity-arguments="p_procedure_name character varying" overload-function-count="1" proc-language="plpgsql" function-signature="bulk_exceptions$create_array(p_procedure_name character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  aws_oracle_ext$array_id$temporary BIGINT;
BEGIN
  aws_oracle_ext$array_id$temporary := aws_oracle_ext.array$create_array(p_array_name => 'bulk_exceptions', p_procedure_name => p_procedure_name);
  PERFORM aws_oracle_ext.array$add_fields_to_array(p_array_id => aws_oracle_ext$array_id$temporary, p_fields => '[{"error_index":"BIGINT"},{"error_code":"INTEGER"},{"sqlerrm":"TEXT"}]');
  PERFORM aws_oracle_ext.array$create_storage_table(p_array_name => 'bulk_exceptions', p_procedure_name => p_procedure_name, p_cast_type_name => 'aws_oracle_ext.sql$bulk_exceptions', pWithData => FALSE);
END;
]]></complex-attribute>
                        <category _I_D="372795d6-3707-405b-ab3f-f8f79b3459fb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="777f983b-a799-4b33-bd85-ea4f673871bb" name="chartorowid" is-trigger-function="0" unique-function-name="chartorowid" is-aggregate="f" language-name="sql" context="chartorowid" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="rowid" function-arguments="pchar text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22998" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pchar text" overload-function-count="1" proc-language="sql" function-signature="chartorowid(pchar text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT pchar::aws_oracle_data.rowid;
]]></complex-attribute>
                        <category _I_D="d2e16128-79aa-493c-92fe-b662c0f224e9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a51befcf-a061-4eab-b069-d25c0259945a" name="collection_delete" is-trigger-function="0" unique-function-name="collection_delete(pcollection anyarray)" is-aggregate="f" language-name="sql" context="collection_delete(pcollection anyarray)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray" unique-suffix="(pcollection anyarray)" routine-number="23264" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23264" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray" overload-function-count="14" proc-language="sql" function-signature="collection_delete(pcollection anyarray)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_delete
    (
        pcollection => pcollection,
        ppath => NULL::NUMERIC(10, 0)[]
    );
]]></complex-attribute>
                        <category _I_D="9cf5d06a-b826-4ee0-adcd-31b06822f37a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b1c3ffb7-1170-4425-b5e7-6cb5b194d218" name="collection_delete" is-trigger-function="0" unique-function-name="collection_delete(pcollection anyarray, pm double precision, pn double precision)" is-aggregate="f" language-name="sql" context="collection_delete(pcollection anyarray, pm double precision, pn double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,double precision,double precision" unique-suffix="(pcollection anyarray, pm double precision, pn double precision)" routine-number="23262" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pm double precision, pn double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23262" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pm double precision, pn double precision" overload-function-count="14" proc-language="sql" function-signature="collection_delete(pcollection anyarray, pm double precision, pn double precision)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_delete
    (
        pcollection => pcollection,
        ppath => NULL::NUMERIC(10, 0)[],
        pm => (pm::NUMERIC)::INTEGER,
        pn => (pn::NUMERIC)::INTEGER
    );
]]></complex-attribute>
                        <category _I_D="8e474b6e-29ab-4af1-8696-d4da2822b0b0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b0af2dbf-8676-4cc5-b97a-621288b9011a" name="collection_delete" is-trigger-function="0" unique-function-name="collection_delete(pcollection anyarray, pm double precision, pn text)" is-aggregate="f" language-name="sql" context="collection_delete(pcollection anyarray, pm double precision, pn text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,double precision,text" unique-suffix="(pcollection anyarray, pm double precision, pn text)" routine-number="23270" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pm double precision, pn text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23270" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pm double precision, pn text" overload-function-count="14" proc-language="sql" function-signature="collection_delete(pcollection anyarray, pm double precision, pn text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_delete
(
    pcollection,
    pm,
    pn::FLOAT8
);
]]></complex-attribute>
                        <category _I_D="83060d5e-1819-40b0-b4eb-64e5ff1c5b98" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d439fbad-c24a-42b9-9fd3-2177a9904c07" name="collection_delete" is-trigger-function="0" unique-function-name="collection_delete(pcollection anyarray, pm text, pn double precision)" is-aggregate="f" language-name="sql" context="collection_delete(pcollection anyarray, pm text, pn double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,text,double precision" unique-suffix="(pcollection anyarray, pm text, pn double precision)" routine-number="23269" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pm text, pn double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23269" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pm text, pn double precision" overload-function-count="14" proc-language="sql" function-signature="collection_delete(pcollection anyarray, pm text, pn double precision)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_delete
(
    pcollection,
    pm::FLOAT8,
    pn
);
]]></complex-attribute>
                        <category _I_D="955d52c1-918e-4ec7-8bf5-9a64f1f28818" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f1f90ffb-5e37-4ada-9647-94f99dde90a3" name="collection_delete" is-trigger-function="0" unique-function-name="collection_delete(pcollection anyarray, pm text, pn text)" is-aggregate="f" language-name="sql" context="collection_delete(pcollection anyarray, pm text, pn text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,text,text" unique-suffix="(pcollection anyarray, pm text, pn text)" routine-number="23271" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pm text, pn text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23271" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pm text, pn text" overload-function-count="14" proc-language="sql" function-signature="collection_delete(pcollection anyarray, pm text, pn text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_delete
(
    pcollection,
    pm::FLOAT8,
    pn::FLOAT8
);
]]></complex-attribute>
                        <category _I_D="d0bc146f-0dc6-468f-8a4e-ab15792f2a09" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dbf84f92-f3ad-48ac-ab42-c16c8340c1d9" name="collection_delete" is-trigger-function="0" unique-function-name="collection_delete(pcollection anyarray, pn double precision)" is-aggregate="f" language-name="sql" context="collection_delete(pcollection anyarray, pn double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,double precision" unique-suffix="(pcollection anyarray, pn double precision)" routine-number="23263" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pn double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23263" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pn double precision" overload-function-count="14" proc-language="sql" function-signature="collection_delete(pcollection anyarray, pn double precision)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_delete
    (
        pcollection => pcollection,
        ppath => NULL::NUMERIC(10, 0)[],
        pn => pn
    );
]]></complex-attribute>
                        <category _I_D="a515b1fe-20b4-452d-a736-901b53688d8e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6bc3a3cf-3395-4062-b736-13f1a733c515" name="collection_delete" is-trigger-function="0" unique-function-name="collection_delete(pcollection anyarray, pn text)" is-aggregate="f" language-name="sql" context="collection_delete(pcollection anyarray, pn text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,text" unique-suffix="(pcollection anyarray, pn text)" routine-number="23272" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pn text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23272" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pn text" overload-function-count="14" proc-language="sql" function-signature="collection_delete(pcollection anyarray, pn text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_delete
(
    pcollection,
    pn::FLOAT8
)
]]></complex-attribute>
                        <category _I_D="386e3d65-c837-4226-ab7d-27f4fbb4e804" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6412bf12-52a5-4b1f-aae3-e86949b1ef4c" name="collection_delete" is-trigger-function="0" unique-function-name="collection_delete(pcollection anyarray, ppath numeric[])" is-aggregate="f" language-name="plpgsql" context="collection_delete(pcollection anyarray, ppath numeric[])" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[]" unique-suffix="(pcollection anyarray, ppath numeric[])" routine-number="23261" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[]" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23261" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[]" overload-function-count="14" proc-language="plpgsql" function-signature="collection_delete(pcollection anyarray, ppath numeric[])">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;

    IF CARDINALITY(ppath) > 1 THEN

        pcollection[(ppath[1]::NUMERIC)::INTEGER] := aws_oracle_ext.collection_delete
        (
            pcollection[(ppath[1]::NUMERIC)::INTEGER],
            ppath[2:]::NUMERIC(10, 0)[]
        );

    ELSIF ppath IS NOT NULL THEN

        IF pcollection[(ppath[1]::NUMERIC)::INTEGER] IS NULL THEN

            RAISE null_value_not_allowed USING
                MESSAGE = 'Reference to uninitialized collection',
                HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

        END IF;

        pcollection[(ppath[1]::NUMERIC)::INTEGER] := '{}';

    ELSE

        pcollection := '{}';

    END IF;

    RETURN pcollection;

END;
]]></complex-attribute>
                        <category _I_D="ebe7063f-119c-4aea-9e6c-b4d56d233e2a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="391fa61a-71a2-4dad-a710-17d32900214d" name="collection_delete" is-trigger-function="0" unique-function-name="collection_delete(pcollection anyarray, ppath numeric[], pm double precision, pn double precision)" is-aggregate="f" language-name="plpgsql" context="collection_delete(pcollection anyarray, ppath numeric[], pm double precision, pn double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],double precision,double precision" unique-suffix="(pcollection anyarray, ppath numeric[], pm double precision, pn double precision)" routine-number="23259" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pm double precision, pn double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="23259" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pm double precision, pn double precision" overload-function-count="14" proc-language="plpgsql" function-signature="collection_delete(pcollection anyarray, ppath numeric[], pm double precision, pn double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF CARDINALITY(ppath) > 1 THEN

        pcollection[(ppath[1]::NUMERIC)::INTEGER] := aws_oracle_ext.collection_delete
        (
            pcollection => pcollection[(ppath[1]::NUMERIC)::INTEGER],
            ppath => ppath[2:]::NUMERIC(10, 0)[],
            pm => (pm::NUMERIC)::INTEGER,
            pn => (pn::NUMERIC)::INTEGER
        );

    ELSIF ppath IS NOT NULL THEN

        pcollection[(ppath[1]::NUMERIC)::INTEGER] := aws_oracle_ext.collection_delete_make
        (
            pcollection => pcollection[(ppath[1]::NUMERIC)::INTEGER],
            pm => (pm::NUMERIC)::INTEGER,
            pn => (pn::NUMERIC)::INTEGER
        );

    ELSE

        pcollection := aws_oracle_ext.collection_delete_make
        (
            pcollection => pcollection,
            pm => (pm::NUMERIC)::INTEGER,
            pn => (pn::NUMERIC)::INTEGER
        );

    END IF;

    RETURN pcollection;

END;
]]></complex-attribute>
                        <category _I_D="5f862d96-d7e3-4a8d-a1fe-a4397c837473" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b28fab26-6f22-4bef-9268-8aca138911da" name="collection_delete" is-trigger-function="0" unique-function-name="collection_delete(pcollection anyarray, ppath numeric[], pm double precision, pn text)" is-aggregate="f" language-name="sql" context="collection_delete(pcollection anyarray, ppath numeric[], pm double precision, pn text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],double precision,text" unique-suffix="(pcollection anyarray, ppath numeric[], pm double precision, pn text)" routine-number="23266" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pm double precision, pn text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="23266" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pm double precision, pn text" overload-function-count="14" proc-language="sql" function-signature="collection_delete(pcollection anyarray, ppath numeric[], pm double precision, pn text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_delete
(
    pcollection,
    ppath,
    pm,
    pn::FLOAT8

);
]]></complex-attribute>
                        <category _I_D="a83f2384-cf66-456b-bf2c-c5ec0b68eb1c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e8bcc52a-ef3d-47ca-941b-9c4c9e01dafb" name="collection_delete" is-trigger-function="0" unique-function-name="collection_delete(pcollection anyarray, ppath numeric[], pm text, pn double precision)" is-aggregate="f" language-name="sql" context="collection_delete(pcollection anyarray, ppath numeric[], pm text, pn double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],text,double precision" unique-suffix="(pcollection anyarray, ppath numeric[], pm text, pn double precision)" routine-number="23265" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pm text, pn double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="23265" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pm text, pn double precision" overload-function-count="14" proc-language="sql" function-signature="collection_delete(pcollection anyarray, ppath numeric[], pm text, pn double precision)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_delete
(
    pcollection,
    ppath,
    pm::FLOAT8,
    pn

);
]]></complex-attribute>
                        <category _I_D="340a0bff-e2d2-4554-be10-96525da3ca78" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3da4a72a-86f4-4f9f-a907-dccbea5442e7" name="collection_delete" is-trigger-function="0" unique-function-name="collection_delete(pcollection anyarray, ppath numeric[], pm text, pn text)" is-aggregate="f" language-name="sql" context="collection_delete(pcollection anyarray, ppath numeric[], pm text, pn text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],text,text" unique-suffix="(pcollection anyarray, ppath numeric[], pm text, pn text)" routine-number="23267" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pm text, pn text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="23267" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pm text, pn text" overload-function-count="14" proc-language="sql" function-signature="collection_delete(pcollection anyarray, ppath numeric[], pm text, pn text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_delete
(
    pcollection,
    ppath,
    pm::FLOAT8,
    pn::FLOAT8

);
]]></complex-attribute>
                        <category _I_D="df2e1256-9470-4fe6-8e23-29d7e4726bb1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6ae2b38c-55a5-4c2a-aa6f-f6c5dd34633f" name="collection_delete" is-trigger-function="0" unique-function-name="collection_delete(pcollection anyarray, ppath numeric[], pn double precision)" is-aggregate="f" language-name="plpgsql" context="collection_delete(pcollection anyarray, ppath numeric[], pn double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],double precision" unique-suffix="(pcollection anyarray, ppath numeric[], pn double precision)" routine-number="23260" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pn double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23260" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pn double precision" overload-function-count="14" proc-language="plpgsql" function-signature="collection_delete(pcollection anyarray, ppath numeric[], pn double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF CARDINALITY(ppath) > 1 THEN

        pcollection[(ppath[1]::NUMERIC)::INTEGER] := aws_oracle_ext.collection_delete
        (
            pcollection => pcollection[(ppath[1]::NUMERIC)::INTEGER],
            ppath => ppath[2:]::NUMERIC(10, 0)[],
            pn => pn::NUMERIC(10, 0)
        );

    ELSIF ppath IS NOT NULL THEN

        pcollection[(ppath[1]::NUMERIC)::INTEGER] := aws_oracle_ext.collection_delete_make
        (
            pcollection => pcollection[(ppath[1]::NUMERIC)::INTEGER],
            pm => (pn::NUMERIC)::INTEGER,
            pn => (pn::NUMERIC)::INTEGER
        );

    ELSE

        pcollection := aws_oracle_ext.collection_delete_make
        (
            pcollection => pcollection,
            pm => (pn::NUMERIC)::INTEGER,
            pn => (pn::NUMERIC)::INTEGER
        );

    END IF;

    RETURN pcollection;

END;
]]></complex-attribute>
                        <category _I_D="14a151fc-9663-4d48-b49b-f76bc646c24c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7b6f6e3e-3fa1-477f-b04a-f339d6fed6c7" name="collection_delete" is-trigger-function="0" unique-function-name="collection_delete(pcollection anyarray, ppath numeric[], pn text)" is-aggregate="f" language-name="sql" context="collection_delete(pcollection anyarray, ppath numeric[], pn text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],text" unique-suffix="(pcollection anyarray, ppath numeric[], pn text)" routine-number="23268" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pn text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23268" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pn text" overload-function-count="14" proc-language="sql" function-signature="collection_delete(pcollection anyarray, ppath numeric[], pn text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_delete
(
    pcollection,
    ppath,
    pn::FLOAT8

);
]]></complex-attribute>
                        <category _I_D="cf20a5fe-1591-4ccb-88b2-f2b0671e6b37" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f606f7e5-0f95-4d61-b09f-21c5909dbe8e" name="collection_delete_make" is-trigger-function="0" unique-function-name="collection_delete_make" is-aggregate="f" language-name="plpgsql" context="collection_delete_make" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,integer,integer" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pm integer, pn integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23249" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pm integer, pn integer" overload-function-count="1" proc-language="plpgsql" function-signature="collection_delete_make(pcollection anyarray, pm integer, pn integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    varray_count INTEGER;
    varray pcollection%type;
    vm INTEGER;
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;
    
    IF pm IS NULL OR pn IS NULL THEN
    
        RETURN pcollection;

    END IF;

    IF pm > pn THEN

        RETURN pcollection;

    END IF;

    IF pm = 0 AND pm = pn THEN

        RETURN pcollection;

    END IF;

    varray_count:= COALESCE(ARRAY_LENGTH(pcollection, 1), 0);

    IF varray_count < pm THEN

        RETURN pcollection;

    END IF;

    vm := GREATEST(1, pm);

    varray := pcollection[1:vm - 1];

    FOR i IN 1..LEAST(pn, varray_count)  - vm + 1 LOOP

        varray := ARRAY_APPEND(varray, NULL);

    END LOOP;

    varray := varray || pcollection[pn + 1:varray_count];

    RETURN varray;

END;
]]></complex-attribute>
                        <category _I_D="8e04103d-591d-4362-98f3-205b06e9db05" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f1d12ddb-1656-46e6-96a6-474f5efcbf01" name="collection_element_set" is-trigger-function="0" unique-function-name="collection_element_set(pcollection anyelement, ppath numeric[], pval double precision)" is-aggregate="f" language-name="plpgsql" context="collection_element_set(pcollection anyelement, ppath numeric[], pval double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyelement,numeric[],double precision" unique-suffix="(pcollection anyelement, ppath numeric[], pval double precision)" routine-number="23247" is-returning-set="f" ret-datatype="anyelement" function-arguments="pcollection anyelement, ppath numeric[], pval double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23247" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyelement, ppath numeric[], pval double precision" overload-function-count="6" proc-language="plpgsql" function-signature="collection_element_set(pcollection anyelement, ppath numeric[], pval double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;

    IF CARDINALITY(ppath) > 1 THEN

        pcollection[ppath[1]::INTEGER] := aws_oracle_ext.collection_element_set
        (
            pcollection[ppath[1]::INTEGER],
            ppath[2:],
            pval
        );

    ELSE

        IF ppath[1]::INTEGER <= 0 THEN

            RAISE array_subscript_error USING
                MESSAGE := 'Subscript outside of limit',
                HINT := '-6532';

        END IF;

        IF NOT aws_oracle_ext.collection_exists(pcollection, ppath[1]::INTEGER) THEN

            RAISE array_subscript_error USING
                MESSAGE := 'Subscript beyond count',
                HINT := '-6533';

        END IF;

       pcollection[ppath[1]::INTEGER] := pval;

    END IF;

    RETURN pcollection;

end;
]]></complex-attribute>
                        <category _I_D="2b38c1c2-63df-4b27-b5b6-5ffc9e371837" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5fc0b74e-b72d-46a2-a94e-7cba57be2c6b" name="collection_element_set" is-trigger-function="0" unique-function-name="collection_element_set(pcollection anyelement, ppath numeric[], pval numeric)" is-aggregate="f" language-name="plpgsql" context="collection_element_set(pcollection anyelement, ppath numeric[], pval numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyelement,numeric[],numeric" unique-suffix="(pcollection anyelement, ppath numeric[], pval numeric)" routine-number="23244" is-returning-set="f" ret-datatype="anyelement" function-arguments="pcollection anyelement, ppath numeric[], pval numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23244" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyelement, ppath numeric[], pval numeric" overload-function-count="6" proc-language="plpgsql" function-signature="collection_element_set(pcollection anyelement, ppath numeric[], pval numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;

    IF CARDINALITY(ppath) > 1 THEN

        pcollection[ppath[1]::INTEGER] := aws_oracle_ext.collection_element_set
        (
            pcollection[ppath[1]::INTEGER],
            ppath[2:],
            pval
        );

    ELSE

        IF ppath[1]::INTEGER <= 0 THEN

            RAISE array_subscript_error USING
                MESSAGE := 'Subscript outside of limit',
                HINT := '-6532';

        END IF;

        IF NOT aws_oracle_ext.collection_exists(pcollection, ppath[1]::INTEGER) THEN

            RAISE array_subscript_error USING
                MESSAGE := 'Subscript beyond count',
                HINT := '-6533';

        END IF;

       pcollection[ppath[1]::INTEGER] := pval;

    END IF;

    RETURN pcollection;

end;
]]></complex-attribute>
                        <category _I_D="24f2dfc0-55fa-4e3e-afd6-2b6aeb852007" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0f6a6944-d570-40e5-bc08-360ae83910b8" name="collection_element_set" is-trigger-function="0" unique-function-name="collection_element_set(pcollection anyelement, ppath numeric[], pval record)" is-aggregate="f" language-name="plpgsql" context="collection_element_set(pcollection anyelement, ppath numeric[], pval record)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyelement,numeric[],record" unique-suffix="(pcollection anyelement, ppath numeric[], pval record)" routine-number="23243" is-returning-set="f" ret-datatype="anyelement" function-arguments="pcollection anyelement, ppath numeric[], pval record" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23243" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyelement, ppath numeric[], pval record" overload-function-count="6" proc-language="plpgsql" function-signature="collection_element_set(pcollection anyelement, ppath numeric[], pval record)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN 

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;

    IF CARDINALITY(ppath) > 1 THEN

        pcollection[ppath[1]::INTEGER] := aws_oracle_ext.collection_element_set
        (
            pcollection[ppath[1]::INTEGER],
            ppath[2:],
            pval
        );

    ELSE

        IF ppath[1]::INTEGER <= 0 THEN

            RAISE array_subscript_error USING
                MESSAGE := 'Subscript outside of limit',
                HINT := '-6532';

        END IF;

        IF NOT aws_oracle_ext.collection_exists(pcollection, ppath[1]::INTEGER) THEN

            RAISE array_subscript_error USING
                MESSAGE := 'Subscript beyond count',
                HINT := '-6533';

        END IF;

       pcollection[ppath[1]::INTEGER] := pval.f1;

    END IF;

    RETURN pcollection;

end;
]]></complex-attribute>
                        <category _I_D="4b1f1356-c3b2-4362-92be-9c742936fff9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f06be09c-a746-445c-bb2a-9ab29580bfef" name="collection_element_set" is-trigger-function="0" unique-function-name="collection_element_set(pcollection anyelement, ppath numeric[], pval text)" is-aggregate="f" language-name="plpgsql" context="collection_element_set(pcollection anyelement, ppath numeric[], pval text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyelement,numeric[],text" unique-suffix="(pcollection anyelement, ppath numeric[], pval text)" routine-number="23245" is-returning-set="f" ret-datatype="anyelement" function-arguments="pcollection anyelement, ppath numeric[], pval text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23245" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyelement, ppath numeric[], pval text" overload-function-count="6" proc-language="plpgsql" function-signature="collection_element_set(pcollection anyelement, ppath numeric[], pval text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;

    IF CARDINALITY(ppath) > 1 THEN

        pcollection[ppath[1]::INTEGER] := aws_oracle_ext.collection_element_set
        (
            pcollection[ppath[1]::INTEGER],
            ppath[2:],
            pval
        );

    ELSE

        IF ppath[1]::INTEGER <= 0 THEN

            RAISE array_subscript_error USING
                MESSAGE := 'Subscript outside of limit',
                HINT := '-6532';

        END IF;

        IF NOT aws_oracle_ext.collection_exists(pcollection, ppath[1]::BIGINT) THEN

            RAISE array_subscript_error USING
                MESSAGE := 'Subscript beyond count',
                HINT := '-6533';

        END IF;

       pcollection[ppath[1]::INTEGER] := pval;

    END IF;

    RETURN pcollection;

end;
]]></complex-attribute>
                        <category _I_D="6d7b562f-100f-470d-9f7f-7c454461219b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0692feb0-07d6-4cc6-a542-dea359bfe063" name="collection_element_set" is-trigger-function="0" unique-function-name="collection_element_set(pcollection anyelement, ppath numeric[], pval timestamp with time zone)" is-aggregate="f" language-name="plpgsql" context="collection_element_set(pcollection anyelement, ppath numeric[], pval timestamp with time zone)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyelement,numeric[],timestamp with time zone" unique-suffix="(pcollection anyelement, ppath numeric[], pval timestamp with time zone)" routine-number="23248" is-returning-set="f" ret-datatype="anyelement" function-arguments="pcollection anyelement, ppath numeric[], pval timestamp with time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23248" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyelement, ppath numeric[], pval timestamp with time zone" overload-function-count="6" proc-language="plpgsql" function-signature="collection_element_set(pcollection anyelement, ppath numeric[], pval timestamp with time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;

    IF CARDINALITY(ppath) > 1 THEN

        pcollection[ppath[1]::INTEGER] := aws_oracle_ext.collection_element_set
        (
            pcollection[ppath[1]::INTEGER],
            ppath[2:],
            pval
        );

    ELSE

        IF ppath[1]::INTEGER <= 0 THEN

            RAISE array_subscript_error USING
                MESSAGE := 'Subscript outside of limit',
                HINT := '-6532';

        END IF;

        IF NOT aws_oracle_ext.collection_exists(pcollection, ppath[1]::INTEGER) THEN

            RAISE array_subscript_error USING
                MESSAGE := 'Subscript beyond count',
                HINT := '-6533';

        END IF;

       pcollection[ppath[1]::INTEGER] := pval;

    END IF;

    RETURN pcollection;

end;
]]></complex-attribute>
                        <category _I_D="02c98db1-367a-4799-80cb-17391fe54e41" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b67e2421-7456-4ba6-984c-4497fdadf02a" name="collection_element_set" is-trigger-function="0" unique-function-name="collection_element_set(pcollection anyelement, ppath numeric[], pval timestamp without time zone)" is-aggregate="f" language-name="plpgsql" context="collection_element_set(pcollection anyelement, ppath numeric[], pval timestamp without time zone)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyelement,numeric[],timestamp without time zone" unique-suffix="(pcollection anyelement, ppath numeric[], pval timestamp without time zone)" routine-number="23246" is-returning-set="f" ret-datatype="anyelement" function-arguments="pcollection anyelement, ppath numeric[], pval timestamp without time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23246" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyelement, ppath numeric[], pval timestamp without time zone" overload-function-count="6" proc-language="plpgsql" function-signature="collection_element_set(pcollection anyelement, ppath numeric[], pval timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;

    IF CARDINALITY(ppath) > 1 THEN

        pcollection[ppath[1]::INTEGER] := aws_oracle_ext.collection_element_set
        (
            pcollection[ppath[1]::INTEGER],
            ppath[2:],
            pval
        );

    ELSE

        IF ppath[1]::INTEGER <= 0 THEN

            RAISE array_subscript_error USING
                MESSAGE := 'Subscript outside of limit',
                HINT := '-6532';

        END IF;

        IF NOT aws_oracle_ext.collection_exists(pcollection, ppath[1]::INTEGER) THEN

            RAISE array_subscript_error USING
                MESSAGE := 'Subscript beyond count',
                HINT := '-6533';

        END IF;

       pcollection[ppath[1]::INTEGER] := pval;

    END IF;

    RETURN pcollection;

end;
]]></complex-attribute>
                        <category _I_D="38cc177a-8e4d-4ab1-9ec2-118046b5c599" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="86dad50f-0598-4ccc-934a-b4b955418bb0" name="collection_exists" is-trigger-function="0" unique-function-name="collection_exists(pcollection anyarray, n double precision)" is-aggregate="f" language-name="sql" context="collection_exists(pcollection anyarray, n double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,double precision" unique-suffix="(pcollection anyarray, n double precision)" routine-number="23240" is-returning-set="f" ret-datatype="bool" function-arguments="pcollection anyarray, n double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23240" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pcollection anyarray, n double precision" overload-function-count="3" proc-language="sql" function-signature="collection_exists(pcollection anyarray, n double precision)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT EXISTS 
    (
        SELECT
        FROM UNNEST(pcollection) WITH ORDINALITY AS t
        WHERE t.ordinality = n::INTEGER
    );

]]></complex-attribute>
                        <category _I_D="3a414f84-6ad1-4603-b105-52f9fd3a52fb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="635c5eac-5954-4b36-a91e-665cd84c34d1" name="collection_exists" is-trigger-function="0" unique-function-name="collection_exists(pcollection anyarray, n numeric)" is-aggregate="f" language-name="sql" context="collection_exists(pcollection anyarray, n numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric" unique-suffix="(pcollection anyarray, n numeric)" routine-number="23241" is-returning-set="f" ret-datatype="bool" function-arguments="pcollection anyarray, n numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23241" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pcollection anyarray, n numeric" overload-function-count="3" proc-language="sql" function-signature="collection_exists(pcollection anyarray, n numeric)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT EXISTS 
    (
        SELECT
        FROM UNNEST(pcollection) WITH ORDINALITY AS t
        WHERE t.ordinality = n::INTEGER
    );

]]></complex-attribute>
                        <category _I_D="d966cd61-dec7-49e5-86fd-2bec9345843a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d44fb18c-3570-482a-b5c2-a60924a5784a" name="collection_exists" is-trigger-function="0" unique-function-name="collection_exists(pcollection anyarray, n text)" is-aggregate="f" language-name="sql" context="collection_exists(pcollection anyarray, n text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,text" unique-suffix="(pcollection anyarray, n text)" routine-number="23242" is-returning-set="f" ret-datatype="bool" function-arguments="pcollection anyarray, n text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23242" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pcollection anyarray, n text" overload-function-count="3" proc-language="sql" function-signature="collection_exists(pcollection anyarray, n text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_exists(pcollection, n::NUMERIC);
]]></complex-attribute>
                        <category _I_D="5c190f1c-d4eb-4f4b-aa9a-3dfbb0ad7534" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d63e3545-3e3b-48b2-b49a-79156a9652d8" name="collection_extend" is-trigger-function="0" unique-function-name="collection_extend(pcollection anyarray)" is-aggregate="f" language-name="sql" context="collection_extend(pcollection anyarray)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray" unique-suffix="(pcollection anyarray)" routine-number="23278" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23278" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray" overload-function-count="14" proc-language="sql" function-signature="collection_extend(pcollection anyarray)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_extend
    (
        pcollection,
        NULL::NUMERIC[]
    );
]]></complex-attribute>
                        <category _I_D="563b8264-127e-4159-b770-ff46608811d6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="178cd846-cba3-473f-884c-caac9b6ca33f" name="collection_extend" is-trigger-function="0" unique-function-name="collection_extend(pcollection anyarray, pcount double precision)" is-aggregate="f" language-name="sql" context="collection_extend(pcollection anyarray, pcount double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,double precision" unique-suffix="(pcollection anyarray, pcount double precision)" routine-number="23276" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pcount double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23276" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pcount double precision" overload-function-count="14" proc-language="sql" function-signature="collection_extend(pcollection anyarray, pcount double precision)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_extend
    (
        pcollection,
        NULL::NUMERIC[],
        pcount
    );
]]></complex-attribute>
                        <category _I_D="553aff79-392a-452d-bfe4-9e6254a5a654" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f68fe0f1-b061-430b-a4ea-4193f32c8817" name="collection_extend" is-trigger-function="0" unique-function-name="collection_extend(pcollection anyarray, pcount double precision, pidx double precision)" is-aggregate="f" language-name="sql" context="collection_extend(pcollection anyarray, pcount double precision, pidx double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,double precision,double precision" unique-suffix="(pcollection anyarray, pcount double precision, pidx double precision)" routine-number="23274" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pcount double precision, pidx double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23274" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pcount double precision, pidx double precision" overload-function-count="14" proc-language="sql" function-signature="collection_extend(pcollection anyarray, pcount double precision, pidx double precision)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_extend
    (
        pcollection,
        NULL::NUMERIC[],
        pcount,
        pidx
    );
]]></complex-attribute>
                        <category _I_D="17b6bc76-14ce-4074-8797-98e85e2bf349" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="223a4319-63b0-40c9-a55d-1f849b68d3bb" name="collection_extend" is-trigger-function="0" unique-function-name="collection_extend(pcollection anyarray, pcount double precision, pidx text)" is-aggregate="f" language-name="sql" context="collection_extend(pcollection anyarray, pcount double precision, pidx text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,double precision,text" unique-suffix="(pcollection anyarray, pcount double precision, pidx text)" routine-number="23283" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pcount double precision, pidx text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23283" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pcount double precision, pidx text" overload-function-count="14" proc-language="sql" function-signature="collection_extend(pcollection anyarray, pcount double precision, pidx text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_extend
(
    pcollection,
    pcount,
    pidx::FLOAT8
);
]]></complex-attribute>
                        <category _I_D="3e762338-6665-4bdb-aec0-3c5ebfe8330b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c7ae354b-e91a-4340-aee2-d9bc97c45d85" name="collection_extend" is-trigger-function="0" unique-function-name="collection_extend(pcollection anyarray, pcount text)" is-aggregate="f" language-name="sql" context="collection_extend(pcollection anyarray, pcount text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,text" unique-suffix="(pcollection anyarray, pcount text)" routine-number="23286" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pcount text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23286" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pcount text" overload-function-count="14" proc-language="sql" function-signature="collection_extend(pcollection anyarray, pcount text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_extend
(
    pcollection,
    pcount::FLOAT8
);
]]></complex-attribute>
                        <category _I_D="7a3e29d6-6b33-4827-942d-a6db4149ea81" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ee764489-49ae-4d82-aeb3-1006ddcf5d97" name="collection_extend" is-trigger-function="0" unique-function-name="collection_extend(pcollection anyarray, pcount text, pidx double precision)" is-aggregate="f" language-name="sql" context="collection_extend(pcollection anyarray, pcount text, pidx double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,text,double precision" unique-suffix="(pcollection anyarray, pcount text, pidx double precision)" routine-number="23282" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pcount text, pidx double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23282" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pcount text, pidx double precision" overload-function-count="14" proc-language="sql" function-signature="collection_extend(pcollection anyarray, pcount text, pidx double precision)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_extend
(
    pcollection,
    pcount::FLOAT8,
    pidx
);
]]></complex-attribute>
                        <category _I_D="f47fd001-49e8-4212-9d90-269b3315a0b7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="52275c37-8cc9-47c5-a3d2-5c429eb12e0e" name="collection_extend" is-trigger-function="0" unique-function-name="collection_extend(pcollection anyarray, pcount text, pidx text)" is-aggregate="f" language-name="sql" context="collection_extend(pcollection anyarray, pcount text, pidx text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,text,text" unique-suffix="(pcollection anyarray, pcount text, pidx text)" routine-number="23284" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pcount text, pidx text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23284" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pcount text, pidx text" overload-function-count="14" proc-language="sql" function-signature="collection_extend(pcollection anyarray, pcount text, pidx text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_extend
(
    pcollection,
    pcount::FLOAT8,
    pidx::FLOAT8
);
]]></complex-attribute>
                        <category _I_D="64615d5f-9c96-4389-9a3b-0e2c71208856" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="be3a0cc6-d44a-4d48-80f0-01053bc23f4b" name="collection_extend" is-trigger-function="0" unique-function-name="collection_extend(pcollection anyarray, ppath numeric[])" is-aggregate="f" language-name="plpgsql" context="collection_extend(pcollection anyarray, ppath numeric[])" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[]" unique-suffix="(pcollection anyarray, ppath numeric[])" routine-number="23277" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[]" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23277" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[]" overload-function-count="14" proc-language="plpgsql" function-signature="collection_extend(pcollection anyarray, ppath numeric[])">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;

    IF COALESCE(CARDINALITY(ppath), 0) > 0 THEN

        pcollection[ppath[1]::NUMERIC(10, 0)::INTEGER] := aws_oracle_ext.collection_extend
        (
            pcollection => pcollection[ppath[1]::NUMERIC(10, 0)],
            ppath => ppath[2:]::NUMERIC(10, 0)[]
        );

    ELSE

        FOR i IN COALESCE(ARRAY_LENGTH(pcollection, 1), 0) + 1 .. COALESCE(ARRAY_LENGTH(pcollection, 1), 0) + 1 LOOP
        
            pcollection[i] := NULL;

        END LOOP;
    
    END IF;
    
    RETURN pcollection;

END;
]]></complex-attribute>
                        <category _I_D="5e29beb5-e183-42b9-bc5d-12da606e4040" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2166875a-8e09-4ae2-a2b1-995ba4092eee" name="collection_extend" is-trigger-function="0" unique-function-name="collection_extend(pcollection anyarray, ppath numeric[], pcount double precision)" is-aggregate="f" language-name="plpgsql" context="collection_extend(pcollection anyarray, ppath numeric[], pcount double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],double precision" unique-suffix="(pcollection anyarray, ppath numeric[], pcount double precision)" routine-number="23275" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pcount double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23275" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pcount double precision" overload-function-count="14" proc-language="plpgsql" function-signature="collection_extend(pcollection anyarray, ppath numeric[], pcount double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;

    IF COALESCE((pcount::NUMERIC)::INTEGER, 0) = 0 THEN

        RETURN pcollection;

    END IF;

    IF (pcount::NUMERIC)::INTEGER < 0 THEN

        RAISE data_exception USING
            MESSAGE = 'PL/SQL: numeric or value error: %s',
            HINT = aws_oracle_ext.get_ora_sqlcode('VALUE_ERROR');

    END IF;

    IF COALESCE(CARDINALITY(ppath), 0) > 0 THEN

        pcollection[ppath[1]::NUMERIC(10, 0)::INTEGER] := aws_oracle_ext.collection_extend
        (
            pcollection => pcollection[ppath[1]::NUMERIC(10, 0)],
            ppath => ppath[2:]::NUMERIC(10, 0)[],
            pcount => pcount
        );

    ELSE

        FOR i IN COALESCE(ARRAY_LENGTH(pcollection, 1), 0) + 1 .. COALESCE(ARRAY_LENGTH(pcollection, 1), 0) + (pcount::NUMERIC)::INTEGER LOOP
        
            pcollection[i] := NULL;

        END LOOP;
    
    END IF;
    
    RETURN pcollection;

END;
]]></complex-attribute>
                        <category _I_D="d8b85a9d-50ec-443b-bccd-e22790d21380" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d21aef71-5313-4d72-b681-d9c3ca3a9516" name="collection_extend" is-trigger-function="0" unique-function-name="collection_extend(pcollection anyarray, ppath numeric[], pcount double precision, pidx double precision)" is-aggregate="f" language-name="plpgsql" context="collection_extend(pcollection anyarray, ppath numeric[], pcount double precision, pidx double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],double precision,double precision" unique-suffix="(pcollection anyarray, ppath numeric[], pcount double precision, pidx double precision)" routine-number="23273" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pcount double precision, pidx double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="23273" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pcount double precision, pidx double precision" overload-function-count="14" proc-language="plpgsql" function-signature="collection_extend(pcollection anyarray, ppath numeric[], pcount double precision, pidx double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;

    IF COALESCE((pcount::NUMERIC)::INTEGER, 0) = 0 OR pidx IS NULL THEN

        RETURN pcollection;

    END IF;

    IF (pcount::NUMERIC)::INTEGER < 0 THEN

        RAISE data_exception USING
            MESSAGE = 'PL/SQL: numeric or value error: %s',
            HINT = aws_oracle_ext.get_ora_sqlcode('VALUE_ERROR');

    END IF;

    IF (pidx::NUMERIC)::INTEGER < 1 THEN

        RAISE array_subscript_error USING
            MESSAGE = 'Subscript outside of limit',
            HINT = aws_oracle_ext.get_ora_sqlcode('SUBSCRIPT_OUTSIDE_LIMIT');

    END IF;

    IF COALESCE(CARDINALITY(ppath), 0) > 0 THEN

        pcollection[ppath[1]::NUMERIC(10, 0)::INTEGER] := aws_oracle_ext.collection_extend
        (
            pcollection => pcollection[ppath[1]::NUMERIC(10, 0)],
            ppath => ppath[2:]::NUMERIC(10, 0)[],
            pcount => pcount,
            pidx => pidx
        );

    ELSE

        IF COALESCE(ARRAY_LENGTH(pcollection, 1), 0) < (pidx::NUMERIC)::INTEGER THEN

            RAISE array_subscript_error USING
            MESSAGE = 'Subscript beyond count',
            HINT = aws_oracle_ext.get_ora_sqlcode('SUBSCRIPT_BEYOND_COUNT');

        END IF;

        FOR i IN COALESCE(ARRAY_LENGTH(pcollection, 1), 0) + 1 .. COALESCE(ARRAY_LENGTH(pcollection, 1), 0) + (pcount::NUMERIC)::INTEGER LOOP
        
            pcollection[i] := pcollection[(pidx::NUMERIC)::INTEGER];

        END LOOP;
    
    END IF;
    
    RETURN pcollection;

END;
]]></complex-attribute>
                        <category _I_D="62d62752-9848-4ff5-b03e-3322ce302adc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="37844bec-b7a5-45bc-a0fe-ea65e7a3232b" name="collection_extend" is-trigger-function="0" unique-function-name="collection_extend(pcollection anyarray, ppath numeric[], pcount double precision, pidx text)" is-aggregate="f" language-name="sql" context="collection_extend(pcollection anyarray, ppath numeric[], pcount double precision, pidx text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],double precision,text" unique-suffix="(pcollection anyarray, ppath numeric[], pcount double precision, pidx text)" routine-number="23280" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pcount double precision, pidx text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="23280" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pcount double precision, pidx text" overload-function-count="14" proc-language="sql" function-signature="collection_extend(pcollection anyarray, ppath numeric[], pcount double precision, pidx text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_extend
(
    pcollection,
    ppath,
    pcount,
    pidx::FLOAT8
);
]]></complex-attribute>
                        <category _I_D="8cd597a1-0a5c-4e75-a22b-2d3a66f4781d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f0db5c95-f253-4d56-83d9-5c28688d28af" name="collection_extend" is-trigger-function="0" unique-function-name="collection_extend(pcollection anyarray, ppath numeric[], pcount text)" is-aggregate="f" language-name="sql" context="collection_extend(pcollection anyarray, ppath numeric[], pcount text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],text" unique-suffix="(pcollection anyarray, ppath numeric[], pcount text)" routine-number="23285" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pcount text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23285" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pcount text" overload-function-count="14" proc-language="sql" function-signature="collection_extend(pcollection anyarray, ppath numeric[], pcount text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_extend
(
    pcollection,
    ppath,
    pcount::FLOAT8
);
]]></complex-attribute>
                        <category _I_D="6b80e585-b851-4958-aae2-c3938cf32a1a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="42c5e297-e036-45c6-aeb4-6715f84e764f" name="collection_extend" is-trigger-function="0" unique-function-name="collection_extend(pcollection anyarray, ppath numeric[], pcount text, pidx double precision)" is-aggregate="f" language-name="sql" context="collection_extend(pcollection anyarray, ppath numeric[], pcount text, pidx double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],text,double precision" unique-suffix="(pcollection anyarray, ppath numeric[], pcount text, pidx double precision)" routine-number="23279" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pcount text, pidx double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="23279" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pcount text, pidx double precision" overload-function-count="14" proc-language="sql" function-signature="collection_extend(pcollection anyarray, ppath numeric[], pcount text, pidx double precision)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_extend
(
    pcollection,
    ppath,
    pcount::FLOAT8,
    pidx
);
]]></complex-attribute>
                        <category _I_D="c196c9eb-683b-4307-8743-d42bc8c6563b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="46c4848e-a2d2-4ce5-8b8c-12bfbb1812c1" name="collection_extend" is-trigger-function="0" unique-function-name="collection_extend(pcollection anyarray, ppath numeric[], pcount text, pidx text)" is-aggregate="f" language-name="sql" context="collection_extend(pcollection anyarray, ppath numeric[], pcount text, pidx text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],text,text" unique-suffix="(pcollection anyarray, ppath numeric[], pcount text, pidx text)" routine-number="23281" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pcount text, pidx text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="23281" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pcount text, pidx text" overload-function-count="14" proc-language="sql" function-signature="collection_extend(pcollection anyarray, ppath numeric[], pcount text, pidx text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.collection_extend
(
    pcollection,
    ppath,
    pcount::FLOAT8,
    pidx::FLOAT8
);
]]></complex-attribute>
                        <category _I_D="3015ce23-d818-416d-b6e8-0d2968c97832" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b867c0b6-91c1-4325-ac9c-4cc3ed382456" name="collection_next" is-trigger-function="0" unique-function-name="collection_next(pcollection anyarray, n double precision)" is-aggregate="f" language-name="plpgsql" context="collection_next(pcollection anyarray, n double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,double precision" unique-suffix="(pcollection anyarray, n double precision)" routine-number="23287" is-returning-set="f" ret-datatype="int4" function-arguments="pcollection anyarray, n double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23287" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pcollection anyarray, n double precision" overload-function-count="3" proc-language="plpgsql" function-signature="collection_next(pcollection anyarray, n double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;

    RETURN
        CASE
            WHEN n::INTEGER < 1 THEN
                1
            WHEN ARRAY_UPPER(pcollection, 1) IS NULL THEN
                NULL
            WHEN n::INTEGER >= ARRAY_UPPER(pcollection, 1) THEN
                NULL
            ELSE
                n::INTEGER + 1
        END;
END;
]]></complex-attribute>
                        <category _I_D="75254869-4fa7-4a2a-9ccf-4cad1be926cb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8badafd1-2670-4e57-8291-c3c2cb9cec90" name="collection_next" is-trigger-function="0" unique-function-name="collection_next(pcollection anyarray, n numeric)" is-aggregate="f" language-name="plpgsql" context="collection_next(pcollection anyarray, n numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric" unique-suffix="(pcollection anyarray, n numeric)" routine-number="23288" is-returning-set="f" ret-datatype="int4" function-arguments="pcollection anyarray, n numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23288" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pcollection anyarray, n numeric" overload-function-count="3" proc-language="plpgsql" function-signature="collection_next(pcollection anyarray, n numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;

    RETURN
        CASE
            WHEN n::INTEGER < 1 THEN
                1
            WHEN ARRAY_UPPER(pcollection, 1) IS NULL THEN
                NULL
            WHEN n::INTEGER >= ARRAY_UPPER(pcollection, 1) THEN
                NULL
            ELSE
                n::INTEGER + 1
        END;
END;
]]></complex-attribute>
                        <category _I_D="326bf92d-be5c-4abe-8d3b-5045a4eb7b29" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dc57cf16-fc45-4ba1-b5eb-ae562c398d22" name="collection_next" is-trigger-function="0" unique-function-name="collection_next(pcollection anyarray, n text)" is-aggregate="f" language-name="sql" context="collection_next(pcollection anyarray, n text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,text" unique-suffix="(pcollection anyarray, n text)" routine-number="23289" is-returning-set="f" ret-datatype="int4" function-arguments="pcollection anyarray, n text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23289" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pcollection anyarray, n text" overload-function-count="3" proc-language="sql" function-signature="collection_next(pcollection anyarray, n text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_next(pcollection, n::NUMERIC);
]]></complex-attribute>
                        <category _I_D="951a3dd3-7385-4a39-9397-b520a20c9323" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="15013335-7c14-489e-973b-3321650faa85" name="collection_prior" is-trigger-function="0" unique-function-name="collection_prior(pcollection anyarray, n double precision)" is-aggregate="f" language-name="plpgsql" context="collection_prior(pcollection anyarray, n double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,double precision" unique-suffix="(pcollection anyarray, n double precision)" routine-number="23290" is-returning-set="f" ret-datatype="int4" function-arguments="pcollection anyarray, n double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23290" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pcollection anyarray, n double precision" overload-function-count="3" proc-language="plpgsql" function-signature="collection_prior(pcollection anyarray, n double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;

    RETURN
        CASE
            WHEN n::INTEGER <= 1 THEN
                NULL
            WHEN ARRAY_UPPER(pcollection, 1) IS NULL THEN
                NULL
            WHEN n::INTEGER > ARRAY_UPPER(pcollection, 1) THEN
                ARRAY_UPPER(pcollection, 1)
            ELSE
                n::INTEGER - 1
        END;
        
END;
]]></complex-attribute>
                        <category _I_D="d0b63601-50ef-434b-bf86-a399b412ed1e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="aee662fb-6b08-4ac8-bbe5-ceca842a1447" name="collection_prior" is-trigger-function="0" unique-function-name="collection_prior(pcollection anyarray, n numeric)" is-aggregate="f" language-name="plpgsql" context="collection_prior(pcollection anyarray, n numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric" unique-suffix="(pcollection anyarray, n numeric)" routine-number="23291" is-returning-set="f" ret-datatype="int4" function-arguments="pcollection anyarray, n numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23291" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pcollection anyarray, n numeric" overload-function-count="3" proc-language="plpgsql" function-signature="collection_prior(pcollection anyarray, n numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;

    RETURN
        CASE
            WHEN n::INTEGER <= 1 THEN
                NULL
            WHEN ARRAY_UPPER(pcollection, 1) IS NULL THEN
                NULL
            WHEN n::INTEGER > ARRAY_UPPER(pcollection, 1) THEN
                ARRAY_UPPER(pcollection, 1)
            ELSE
                n::INTEGER - 1
        END;
        
END;
]]></complex-attribute>
                        <category _I_D="5ce0ef8f-48f3-4ce7-877d-38d2eef8c2b0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="139b5419-ac25-4df0-87c5-275282152de6" name="collection_prior" is-trigger-function="0" unique-function-name="collection_prior(pcollection anyarray, n text)" is-aggregate="f" language-name="sql" context="collection_prior(pcollection anyarray, n text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,text" unique-suffix="(pcollection anyarray, n text)" routine-number="23292" is-returning-set="f" ret-datatype="int8" function-arguments="pcollection anyarray, n text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23292" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pcollection anyarray, n text" overload-function-count="3" proc-language="sql" function-signature="collection_prior(pcollection anyarray, n text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_prior(pcollection, n::NUMERIC);
]]></complex-attribute>
                        <category _I_D="a7ae7307-f39d-4caf-a65e-05627ebc6a1a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="40f38d6a-7fea-4b90-9999-63ebf65987ae" name="collection_trim" is-trigger-function="0" unique-function-name="collection_trim(pcollection anyarray)" is-aggregate="f" language-name="sql" context="collection_trim(pcollection anyarray)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray" unique-suffix="(pcollection anyarray)" routine-number="23255" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23255" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray" overload-function-count="8" proc-language="sql" function-signature="collection_trim(pcollection anyarray)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_trim
    (
        pcollection,
        NULL::NUMERIC[],
        1::NUMERIC
    );
]]></complex-attribute>
                        <category _I_D="0e3a23a0-de59-4784-a7b5-e77c9f6b2a91" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="561749e5-cd7e-401e-98c9-f3d777cc4341" name="collection_trim" is-trigger-function="0" unique-function-name="collection_trim(pcollection anyarray, pn double precision)" is-aggregate="f" language-name="sql" context="collection_trim(pcollection anyarray, pn double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,double precision" unique-suffix="(pcollection anyarray, pn double precision)" routine-number="23256" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pn double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23256" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pn double precision" overload-function-count="8" proc-language="sql" function-signature="collection_trim(pcollection anyarray, pn double precision)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_trim
    (
        pcollection,
        NULL::NUMERIC[],
        pn
    );
]]></complex-attribute>
                        <category _I_D="8285fafb-0fd1-4060-abbf-3e70cc5ae16b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2f240792-e97e-46da-90ca-e743840effb9" name="collection_trim" is-trigger-function="0" unique-function-name="collection_trim(pcollection anyarray, pn numeric)" is-aggregate="f" language-name="sql" context="collection_trim(pcollection anyarray, pn numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric" unique-suffix="(pcollection anyarray, pn numeric)" routine-number="23257" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pn numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23257" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pn numeric" overload-function-count="8" proc-language="sql" function-signature="collection_trim(pcollection anyarray, pn numeric)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_trim
    (
        pcollection,
        NULL::NUMERIC[],
        pn
    );
]]></complex-attribute>
                        <category _I_D="eb9c24a3-6e8f-4637-830c-6188e48d562d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="453eea5e-baa7-4c9f-a47e-a1be97264cea" name="collection_trim" is-trigger-function="0" unique-function-name="collection_trim(pcollection anyarray, pn text)" is-aggregate="f" language-name="sql" context="collection_trim(pcollection anyarray, pn text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,text" unique-suffix="(pcollection anyarray, pn text)" routine-number="23258" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pn text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23258" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pn text" overload-function-count="8" proc-language="sql" function-signature="collection_trim(pcollection anyarray, pn text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_trim
    (
        pcollection,
        NULL::NUMERIC[],
        pn::NUMERIC
    );
]]></complex-attribute>
                        <category _I_D="05ae1459-da1f-439e-8100-268bf4812069" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="758b601f-94aa-4adc-aa3d-9ec1ec66774a" name="collection_trim" is-trigger-function="0" unique-function-name="collection_trim(pcollection anyarray, ppath numeric[])" is-aggregate="f" language-name="sql" context="collection_trim(pcollection anyarray, ppath numeric[])" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[]" unique-suffix="(pcollection anyarray, ppath numeric[])" routine-number="23253" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[]" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23253" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[]" overload-function-count="8" proc-language="sql" function-signature="collection_trim(pcollection anyarray, ppath numeric[])">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_trim
    (
        pcollection,
        ppath,
        1::NUMERIC
    )
]]></complex-attribute>
                        <category _I_D="ae8b50d8-0183-4e21-8da8-028b6c8af539" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="46b839d3-2946-4732-9f57-4774750e5d0d" name="collection_trim" is-trigger-function="0" unique-function-name="collection_trim(pcollection anyarray, ppath numeric[], pn double precision)" is-aggregate="f" language-name="plpgsql" context="collection_trim(pcollection anyarray, ppath numeric[], pn double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],double precision" unique-suffix="(pcollection anyarray, ppath numeric[], pn double precision)" routine-number="23251" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pn double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23251" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pn double precision" overload-function-count="8" proc-language="plpgsql" function-signature="collection_trim(pcollection anyarray, ppath numeric[], pn double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pn::INTEGER < 0 THEN

        RAISE data_exception USING
            MESSAGE = 'PL/SQL: numeric or value error: %s',
            HINT = aws_oracle_ext.get_ora_sqlcode('VALUE_ERROR');

    END IF;

    IF CARDINALITY(ppath) > 1 THEN

        pcollection[ppath[1]::NUMERIC(10, 0)::INTEGER] := aws_oracle_ext.collection_trim
        (
            pcollection => pcollection[ppath[1]::NUMERIC(10, 0)::INTEGER],
            ppath => ppath[2:]::NUMERIC(10, 0)[]
        );

    ELSIF ppath IS NOT NULL THEN

        pcollection[ppath[1]::NUMERIC(10, 0)::INTEGER] := aws_oracle_ext.collection_trim_make
        (
            pcollection => pcollection[ppath[1]::NUMERIC(10, 0)::INTEGER],
            pn => pn::INTEGER
        );

    ELSE

        pcollection := aws_oracle_ext.collection_trim_make
        (
            pcollection => pcollection,
            pn => pn::INTEGER
        );

    END IF;

    RETURN pcollection;

end;
]]></complex-attribute>
                        <category _I_D="43a97bdd-568b-4af3-874e-fbf58fd3615e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8f6ee70f-7669-4832-afdd-095adc3de585" name="collection_trim" is-trigger-function="0" unique-function-name="collection_trim(pcollection anyarray, ppath numeric[], pn numeric)" is-aggregate="f" language-name="plpgsql" context="collection_trim(pcollection anyarray, ppath numeric[], pn numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],numeric" unique-suffix="(pcollection anyarray, ppath numeric[], pn numeric)" routine-number="23252" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pn numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23252" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pn numeric" overload-function-count="8" proc-language="plpgsql" function-signature="collection_trim(pcollection anyarray, ppath numeric[], pn numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pn::INTEGER < 0 THEN

        RAISE data_exception USING
            MESSAGE = 'PL/SQL: numeric or value error: %s',
            HINT = aws_oracle_ext.get_ora_sqlcode('VALUE_ERROR');

    END IF;

    IF CARDINALITY(ppath) > 1 THEN

        pcollection[ppath[1]::NUMERIC(10, 0)::INTEGER] := aws_oracle_ext.collection_trim
        (
            pcollection => pcollection[ppath[1]::NUMERIC(10, 0)::INTEGER],
            ppath => ppath[2:]::NUMERIC(10, 0)[]
        );

    ELSIF ppath IS NOT NULL THEN

        pcollection[ppath[1]::NUMERIC(10, 0)::INTEGER] := aws_oracle_ext.collection_trim_make
        (
            pcollection => pcollection[ppath[1]::NUMERIC(10, 0)],
            pn => pn::INTEGER
        );

    ELSE

        pcollection := aws_oracle_ext.collection_trim_make
        (
            pcollection => pcollection,
            pn => pn::INTEGER
        );

    END IF;

    RETURN pcollection;

end;
]]></complex-attribute>
                        <category _I_D="3aba1f58-6842-4572-a59b-bdbc521dcb11" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="751e0fb1-0e35-4836-8502-60d74d4b8f18" name="collection_trim" is-trigger-function="0" unique-function-name="collection_trim(pcollection anyarray, ppath numeric[], pn text)" is-aggregate="f" language-name="sql" context="collection_trim(pcollection anyarray, ppath numeric[], pn text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric[],text" unique-suffix="(pcollection anyarray, ppath numeric[], pn text)" routine-number="23254" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, ppath numeric[], pn text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23254" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, ppath numeric[], pn text" overload-function-count="8" proc-language="sql" function-signature="collection_trim(pcollection anyarray, ppath numeric[], pn text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.collection_trim
    (
        pcollection,
        ppath,
        pn::NUMERIC
    )
]]></complex-attribute>
                        <category _I_D="5c905565-3498-47ce-8d63-13da67c1d510" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="09c544fd-da4b-4125-8ad2-02c5f1262da1" name="collection_trim_make" is-trigger-function="0" unique-function-name="collection_trim_make" is-aggregate="f" language-name="plpgsql" context="collection_trim_make" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,integer" is-returning-set="f" ret-datatype="anyarray" function-arguments="pcollection anyarray, pn integer DEFAULT 1" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23250" volatility="VOLATILE" is-window="f" function-identity-arguments="pcollection anyarray, pn integer" overload-function-count="1" proc-language="plpgsql" function-signature="collection_trim_make(pcollection anyarray, pn integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pcollection IS NULL THEN

        RAISE null_value_not_allowed USING
            MESSAGE = 'Reference to uninitialized collection',
            HINT = aws_oracle_ext.get_ora_sqlcode('COLLECTION_IS_NULL');

    END IF;
    
    IF CARDINALITY(pcollection) >= pn THEN

        pcollection := pcollection[1: CARDINALITY(pcollection) - pn];

    ELSE

        RAISE array_subscript_error USING
            MESSAGE = 'Subscript beyond count',
            HINT = aws_oracle_ext.get_ora_sqlcode('SUBSCRIPT_BEYOND_COUNT');

    END IF;

    RETURN pcollection;

END;
]]></complex-attribute>
                        <category _I_D="3e8763fd-7188-46cc-94ff-38247cb8bf6b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d9f64830-ae90-4d0d-9970-e427dca8dabe" name="context_upsert" is-trigger-function="0" unique-function-name="context_upsert" is-aggregate="f" language-name="sql" context="context_upsert" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="c_namespace text, c_type text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22992" volatility="VOLATILE" is-window="f" function-identity-arguments="c_namespace text, c_type text" overload-function-count="1" proc-language="sql" function-signature="context_upsert(c_namespace text, c_type text)">
                        <complex-attribute name="sql"><![CDATA[
	create schema if not exists aws_oracle_context;
	create table if not exists aws_oracle_context.context(
		context_namespace varchar(30) not null, 
		context_type varchar(22) not null,
		constraint pk_context primary key (context_namespace)
	);
	
	INSERT INTO aws_oracle_context.context VALUES 
	(
		aws_oracle_ext.format_identifier_case($1), 
		UPPER($2)
	)
	ON CONFLICT(context_namespace) DO UPDATE
	SET context_type =  UPPER($2);
]]></complex-attribute>
                        <category _I_D="6f3d3669-ffed-4c39-91af-f2e70c3fe34b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="94714f04-68f5-4e5e-afa4-bc5ebe23cc73" name="current_date" is-trigger-function="0" unique-function-name="current_date" is-aggregate="f" language-name="sql" context="current_date" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="timestamp" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22285" volatility="STABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="current_date()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT LOCALTIMESTAMP(0);
    
]]></complex-attribute>
                        <category _I_D="e7d305be-bc8b-493b-9e6e-38e1cbeab7d7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ff7358ab-7e44-4126-94b1-0b6046cdf1a0" name="current_timestamp" is-trigger-function="0" unique-function-name="current_timestamp" is-aggregate="f" language-name="sql" context="current_timestamp" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer" is-returning-set="f" ret-datatype="timestamptz" function-arguments="p_precision integer DEFAULT 6" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22286" volatility="STABLE" is-window="f" function-identity-arguments="p_precision integer" overload-function-count="1" proc-language="sql" function-signature="current_timestamp(p_precision integer)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT 
    CASE
    
        WHEN p_precision = 0 THEN CURRENT_TIMESTAMP(0)
        WHEN p_precision = 1 THEN CURRENT_TIMESTAMP(1)
        WHEN p_precision = 2 THEN CURRENT_TIMESTAMP(3)
        WHEN p_precision = 4 THEN CURRENT_TIMESTAMP(4)
        WHEN p_precision = 5 THEN CURRENT_TIMESTAMP(5)

        ELSE CURRENT_TIMESTAMP

    END;
        
    
]]></complex-attribute>
                        <category _I_D="288f3aa2-b632-489c-8481-5f2f6a9cd879" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3e5bcf48-0d0a-4780-a94e-c12c9284149d" name="dbms_application_info$read_client_info" is-trigger-function="0" unique-function-name="dbms_application_info$read_client_info" is-aggregate="f" language-name="sql" context="dbms_application_info$read_client_info" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="varchar" function-arguments="OUT client_info character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23133" volatility="VOLATILE" is-window="f" function-identity-arguments="OUT client_info character varying" overload-function-count="1" proc-language="sql" function-signature="dbms_application_info$read_client_info(OUT client_info character varying)">
                        <complex-attribute name="sql"><![CDATA[
  select aws_oracle_ext.get_extpack_variable(variable_name => 'CLIENT_INFO'); 
]]></complex-attribute>
                        <category _I_D="4e1c30df-640d-4f63-af42-4a3aea63167c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b16733cb-bb62-4d0c-a0d8-2a1532d6662b" name="dbms_application_info$read_module" is-trigger-function="0" unique-function-name="dbms_application_info$read_module" is-aggregate="f" language-name="plpgsql" context="dbms_application_info$read_module" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying" is-returning-set="f" ret-datatype="record" function-arguments="OUT module_name character varying, OUT action_name character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23134" volatility="VOLATILE" is-window="f" function-identity-arguments="OUT module_name character varying, OUT action_name character varying" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_application_info$read_module(OUT module_name character varying, OUT action_name character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare l_app_name jsonb;
begin
  execute 'show application_name' into strict l_app_name;	 
  module_name := l_app_name->>'module';
  action_name := l_app_name->>'action';
  exception 
    when invalid_text_representation then 
      begin
        module_name := null;
        action_name := null;	      
      end;  
end;
]]></complex-attribute>
                        <category _I_D="ce43d6da-d291-4153-bc25-fcb07f42ec8e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2e70627a-87ba-48ce-9ad3-eed552b6876b" name="dbms_application_info$set_action" is-trigger-function="0" unique-function-name="dbms_application_info$set_action" is-aggregate="f" language-name="plpgsql" context="dbms_application_info$set_action" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="void" function-arguments="action_name character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23136" volatility="VOLATILE" is-window="f" function-identity-arguments="action_name character varying" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_application_info$set_action(action_name character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare l_app_name jsonb;
begin
	l_app_name := jsonb_set(aws_oracle_ext.get_application_name(), 
   							'{action}', 
   							coalesce(to_json(action_name::text),'null')::jsonb, 
   							true);
    perform aws_oracle_ext.set_application_name(l_app_name);
end;
]]></complex-attribute>
                        <category _I_D="0a0971c3-40c4-4d66-a8f1-41afc58f5a89" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2d38220e-b07b-48f1-b23c-f68ef531bdf3" name="dbms_application_info$set_client_info" is-trigger-function="0" unique-function-name="dbms_application_info$set_client_info" is-aggregate="f" language-name="sql" context="dbms_application_info$set_client_info" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="void" function-arguments="client_info character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23137" volatility="VOLATILE" is-window="f" function-identity-arguments="client_info character varying" overload-function-count="1" proc-language="sql" function-signature="dbms_application_info$set_client_info(client_info character varying)">
                        <complex-attribute name="sql"><![CDATA[
  select aws_oracle_ext.set_extpack_variable
    (
	  variable_name => 'CLIENT_INFO', 
	  variable_value => client_info
	);  
]]></complex-attribute>
                        <category _I_D="427c4ac4-e007-432d-80d2-197b9d252a0b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="65689190-1e5d-45db-870f-82bccc5e8863" name="dbms_application_info$set_module" is-trigger-function="0" unique-function-name="dbms_application_info$set_module" is-aggregate="f" language-name="plpgsql" context="dbms_application_info$set_module" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="module_name text, action_name text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23138" volatility="VOLATILE" is-window="f" function-identity-arguments="module_name text, action_name text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_application_info$set_module(module_name text, action_name text)">
                        <complex-attribute name="sql"><![CDATA[
declare l_app_name jsonb;
begin
    l_app_name := aws_oracle_ext.get_application_name();

    l_app_name := jsonb_set(l_app_name, 
   							'{module}', 
   							coalesce(to_json(module_name),'null')::jsonb, 
   							true);
    
    l_app_name := jsonb_set(l_app_name, 
   							'{action}', 
   							coalesce(to_json(action_name),'null')::jsonb, 
   							true);
    perform aws_oracle_ext.set_application_name(l_app_name);
end;   
]]></complex-attribute>
                        <category _I_D="b3651290-a753-426d-9998-fb72523ad1e2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="97b0c371-55b1-446b-94f3-bef4c804a3f5" name="dbms_application_info$set_session_longops" is-trigger-function="0" unique-function-name="dbms_application_info$set_session_longops" is-aggregate="f" language-name="plpgsql" context="dbms_application_info$set_session_longops" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer,text,integer,integer,integer,integer,text,text" is-returning-set="f" ret-datatype="record" function-arguments="INOUT rindex integer, INOUT slno integer, op_name text DEFAULT NULL::text, target integer DEFAULT 0, context integer DEFAULT 0, sofar integer DEFAULT 0, totalwork integer DEFAULT 0, target_desc text DEFAULT 'unknown target'::text, units text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="9" function-id="23140" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT rindex integer, INOUT slno integer, op_name text, target integer, context integer, sofar integer, totalwork integer, target_desc text, units text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_application_info$set_session_longops(INOUT rindex integer, INOUT slno integer, op_name text, target integer, context integer, sofar integer, totalwork integer, target_desc text, units text)">
                        <complex-attribute name="sql"><![CDATA[
declare l_app_name jsonb;
begin
    l_app_name := jsonb_set(
    						aws_oracle_ext.get_application_name(), 
   							'{longops}', 
   							jsonb_build_object(
   								'rindex', rindex,
   								'slno', slno,
   								'op_name', op_name,
   								'target', target,
   								'context', context,
   								'sofar', sofar,
   								'totalwork', totalwork,
   								'target_desc', target_desc,
   								'units', units
   							), 
   							true);
    
    -- perform aws_oracle_ext.set_application_name(l_app_name); 
    -- value is TO LONG for application_name (max is 64)
    perform aws_oracle_ext.set_extpack_variable
	  (
	    variable_name => 'SESSION_LONGOPS', 
		variable_value => l_app_name::text
	  );  
end;   
]]></complex-attribute>
                        <category _I_D="37d0b6ab-3ca4-44c2-9f5c-feb7d0e6de62" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="37a3f3b8-7ff3-4509-822d-395633f6a931" name="dbms_application_info$set_session_longops_nohint" is-trigger-function="0" unique-function-name="dbms_application_info$set_session_longops_nohint" is-aggregate="f" language-name="sql" context="dbms_application_info$set_session_longops_nohint" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23139" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_application_info$set_session_longops_nohint()">
                        <complex-attribute name="sql"><![CDATA[
  -- set_session_longops_nohint constant BINARY_INTEGER := -1;
  select -1
]]></complex-attribute>
                        <category _I_D="67958a33-e03d-4236-80fe-57a9a542dc3f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3acd5a47-827e-4299-960e-dcc912b30e6c" name="dbms_aq$dequeue" is-trigger-function="0" unique-function-name="dbms_aq$dequeue" is-aggregate="f" language-name="plpgsql" context="dbms_aq$dequeue" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,json,json,json,bytea" is-returning-set="f" ret-datatype="record" function-arguments="queue_name text, dequeue_options json, OUT message_properties json, OUT payload json, OUT msgid bytea" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22890" volatility="VOLATILE" is-window="f" function-identity-arguments="queue_name text, dequeue_options json, OUT message_properties json, OUT payload json, OUT msgid bytea" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_aq$dequeue(queue_name text, dequeue_options json, OUT message_properties json, OUT payload json, OUT msgid bytea)">
                        <complex-attribute name="sql"><![CDATA[
declare
	lvqueueurl text;
	lvreceipthandle text;
begin
	lvqueueurl := aws_oracle_ext.sqs_lu_inited_queueurl(queue_name);

	select receipthandle, messageid, body, null::json
	  into lvreceipthandle, msgid, payload, message_properties
	  from aws_oracle_ext.sqs_aq_get_messages_body(lvqueueurl);
	/*default dequeue_mode REMOVE*/
	if  lvreceipthandle is null then
		raise exception 'timeout or end-of-fetch during message dequeue from %', queue_name
		using hint  = '-25228'; --'ora_code must be here';
	else
		perform aws_oracle_ext.sqs_aq_delete_message(lvqueueurl, lvreceipthandle);
		perform aws_oracle_ext.sqs_lu_delete_queue_message(queue_name, msgid::text);
 	end if;
end;
]]></complex-attribute>
                        <category _I_D="7cacc3e2-bc4d-4724-801f-b070b920896d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7f0ab6b6-3214-448a-8ca1-5399b2683e42" name="dbms_aq$enqueue" is-trigger-function="0" unique-function-name="dbms_aq$enqueue" is-aggregate="f" language-name="plpgsql" context="dbms_aq$enqueue" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,json,json,json,bytea" is-returning-set="f" ret-datatype="bytea" function-arguments="queue_name text, enqueue_options json, message_properties json, payload json, OUT msgid bytea" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22891" volatility="VOLATILE" is-window="f" function-identity-arguments="queue_name text, enqueue_options json, message_properties json, payload json, OUT msgid bytea" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_aq$enqueue(queue_name text, enqueue_options json, message_properties json, payload json, OUT msgid bytea)">
                        <complex-attribute name="sql"><![CDATA[
declare
	lvResponse text;
	lQueueUrl text;
	lrT sqs_queues_tables%rowtype;
	lrM sqs_queue_record;
begin

	lrT :=  sqs_lu_inited_queuetbl(queue_name);

	if lrT.id = -1 then
		lQueueUrl := sqs_lu_inited_queueurl(queue_name);

		lvResponse := sqs_aq_send_message(lQueueUrl, payload::text);

		msgid := trim(both '"' from json_extract_path(json_extract_path(lvResponse::json, 'body')::json, 'MessageId')::text)::bytea;

		lrM.msgid := msgid;
		lrM.q_name := queue_name;
		lrM.user_data = payload;

		perform sqs_lu_insert_queue_table(to_json(lrT), to_json(lrM));
	end if;
end;
]]></complex-attribute>
                        <category _I_D="93be09b5-8ef0-4aec-8666-e8a85124fb92" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5c9c72c6-b076-4512-b0fe-f131c76f717a" name="dbms_aqadm$create_queue" is-trigger-function="0" unique-function-name="dbms_aqadm$create_queue" is-aggregate="f" language-name="plpgsql" context="dbms_aqadm$create_queue" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,integer,double precision,double precision,double precision,boolean,text,boolean" is-returning-set="f" ret-datatype="void" function-arguments="queue_name text, queue_table text, queue_type integer DEFAULT aws_oracle_ext.sqs_normal_queue(), max_retries double precision DEFAULT NULL::double precision, retry_delay double precision DEFAULT 0, retention_time double precision DEFAULT 0, dependency_tracking boolean DEFAULT false, comment text DEFAULT NULL::text, auto_commit boolean DEFAULT true" schema-id="21999" function-type="RET_SCALAR" count-arguments="9" function-id="22892" volatility="VOLATILE" is-window="f" function-identity-arguments="queue_name text, queue_table text, queue_type integer, max_retries double precision, retry_delay double precision, retention_time double precision, dependency_tracking boolean, comment text, auto_commit boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_aqadm$create_queue(queue_name text, queue_table text, queue_type integer, max_retries double precision, retry_delay double precision, retention_time double precision, dependency_tracking boolean, comment text, auto_commit boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
	USER_DATA constant text = 'user_data';
	lResult json;
	lrQ aws_oracle_ext.sqs_queues_settings%rowtype;
	lrT aws_oracle_ext.sqs_queues_tables%rowtype;
	lStatusCode varchar(200);
begin

	select ovschemaname, ovtablename
	  into lrT.tschema, lrT.tname
	  from aws_oracle_ext.sqs_lu_define_table(queue_table);

	with q as (select u.table_schema,
					  u.table_name,
					  u.udt_schema,
					  u.udt_name
			     from information_schema.tables t join information_schema.column_udt_usage u on t.table_schema = u.table_schema
				                                                                            and t.table_name  = u.table_name
				 where t.table_schema = lrT.tschema
				   and t.table_name = lrT.tname
				   and u.column_name = USER_DATA
			   )
	 select t.id,
	        q.udt_schema,
	        q.udt_name,
	   into lrT.id
	   		lrT.tdatatypeschema,
	   		lrT.tdatatypename
      from aws_oracle_ext.sqs_queues_tables t join q on t.tschema = q.table_schema
								     and t.tname = q.table_name
								     and t.tdatatypeschema = q.udt_schema
								     and t.tdatatypename =q.udt_name;


	if lrT.id is null then
		raise exception 'invalid value NULL, QUEUE_TABLE should be defined'
		using hint  = 'Please check your user Queue table';
	end if;

	lResult := aws_oracle_ext.sqs_aq_create_queue(pvqueuename => queue_name)::json;
	lStatusCode := json_extract_path(lResult, 'statusCode');

	if lStatusCode::int = 200 then
		lrQ.Url := trim(both '"' from json_extract_path(lResult, 'QueueUrl')::text);
		lrQ.QPureName := reverse(split_part(reverse(lrQ.Url), '/',1));
		lrQ.QName := lrQ.QPureName;

		lrQ.QType := substr(lrQ.QPureName, length(lrQ.QPureName) - 3, 4);

		if lrQ.QType = aws_oracle_ext.sqs_queue_fifo() then
			lrQ.QName := replace(lrQ.QName, concat('.', aws_oracle_ext.sqs_queue_fifo()), '');
		end if;

		if lower(substring(lrQ.Url, 1, 8)) = 'https://' then
			lrQ.Arn := concat('arn:', replace(substring(lrQ.Url, 9), '/', ':'));
		end if;

		insert into aws_oracle_ext.sqs_queues_settings(qname, qpurename, url, arn, qtype, tableid)
		      select lrQ.qname, lrQ.qpurename, lrQ.url, lrQ.arn, lrQ.qtype, lrT.id;
	end if;
end;
]]></complex-attribute>
                        <category _I_D="3a55d425-1f2d-4ca3-84e2-c1e29f180e33" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6d5b0f11-7706-4090-b0c1-08f4df3799cb" name="dbms_aqadm$create_queue_table" is-trigger-function="0" unique-function-name="dbms_aqadm$create_queue_table" is-aggregate="f" language-name="plpgsql" context="dbms_aqadm$create_queue_table" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,boolean,integer,text,boolean,integer,integer,integer,boolean" is-returning-set="f" ret-datatype="void" function-arguments="queue_table text, queue_payload_type text, storage_clause text DEFAULT NULL::text, sort_list text DEFAULT NULL::text, multiple_consumers boolean DEFAULT false, message_grouping integer DEFAULT aws_oracle_ext.sqs_none(), comment text DEFAULT NULL::text, auto_commit boolean DEFAULT true, primary_instance integer DEFAULT 0, secondary_instance integer DEFAULT 0, compatible integer DEFAULT NULL::integer, secure boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="12" function-id="22893" volatility="VOLATILE" is-window="f" function-identity-arguments="queue_table text, queue_payload_type text, storage_clause text, sort_list text, multiple_consumers boolean, message_grouping integer, comment text, auto_commit boolean, primary_instance integer, secondary_instance integer, compatible integer, secure boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_aqadm$create_queue_table(queue_table text, queue_payload_type text, storage_clause text, sort_list text, multiple_consumers boolean, message_grouping integer, comment text, auto_commit boolean, primary_instance integer, secondary_instance integer, compatible integer, secure boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
	lrT aws_oracle_ext.sqs_queues_tables%rowtype;
begin

	select lower(a.ovschemaname), lower(a.ovtablename)
	  into lrT.tschema, lrT.tname
 	from aws_oracle_ext.sqs_lu_define_table(queue_table) a;

	select lower(a.ovschemaname), lower(a.ovtypename)
	  into lrT.tdatatypeschema, lrT.tdatatypename
 	from aws_oracle_ext.sqs_lu_define_type(queue_payload_type) a;

	perform aws_oracle_ext.sqs_lu_create_queue_table(pvtablename := lrT.tname,
                                                      pvtypename := lrT.tdatatypename,
                                                      pvtableschema :=lrT.tschema,
                                                      pvtypeschema := lrT.tdatatypeschema
                                                     );
end;
]]></complex-attribute>
                        <category _I_D="925721ab-d35d-42b7-b0ae-643a1d84934b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="27feaf90-e762-4fe0-a007-7f2e9da8cb29" name="dbms_aqadm$drop_queue" is-trigger-function="0" unique-function-name="dbms_aqadm$drop_queue" is-aggregate="f" language-name="plpgsql" context="dbms_aqadm$drop_queue" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,boolean" is-returning-set="f" ret-datatype="void" function-arguments="queue_name text, auto_commit boolean DEFAULT true" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22894" volatility="VOLATILE" is-window="f" function-identity-arguments="queue_name text, auto_commit boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_aqadm$drop_queue(queue_name text, auto_commit boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
	lResult text;
begin
	lResult := sqs_aq_delete_queue(sqs_lu_inited_queueurl(queue_name));
	perform sqs_lu_delete_queue_table(queue_name);
end;
]]></complex-attribute>
                        <category _I_D="ff719d24-3608-4b08-952a-d5fdac78a71a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="29c408c5-2c4f-41a6-8592-24a4b668964e" name="dbms_aqadm$drop_queue_table" is-trigger-function="0" unique-function-name="dbms_aqadm$drop_queue_table" is-aggregate="f" language-name="plpgsql" context="dbms_aqadm$drop_queue_table" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,boolean,boolean" is-returning-set="f" ret-datatype="void" function-arguments="queue_table text, force boolean DEFAULT false, auto_commit boolean DEFAULT true" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22895" volatility="VOLATILE" is-window="f" function-identity-arguments="queue_table text, force boolean, auto_commit boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_aqadm$drop_queue_table(queue_table text, force boolean, auto_commit boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
	lrT aws_oracle_ext.sqs_queues_tables%rowtype;
begin

	select lower(a.ovschemaname), lower(a.ovtablename)
	  into lrT.tschema, lrT.tname
 	from aws_oracle_ext.sqs_lu_define_table(queue_table) a;

	perform aws_oracle_ext.sqs_lu_drop_queue_table(pvtablename := lrT.tname, pvschemaname := lrT.tschema);
end;
]]></complex-attribute>
                        <category _I_D="ef38214e-c0fa-46cb-9d55-04eb1ee32285" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="aed59510-f36f-4967-b1fe-946b10c69ddd" name="dbms_assert$enquote_literal" is-trigger-function="0" unique-function-name="dbms_assert$enquote_literal" is-aggregate="f" language-name="plpgsql" context="dbms_assert$enquote_literal" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="This function verifies that all single quotes except leading and trailing characters are paired with adjacent single quotes. Also function adds leading and trailing single quotes to a string literal." is-returning-set="f" ret-datatype="text" function-arguments="p_str_literal text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22287" volatility="STABLE" is-window="f" function-identity-arguments="p_str_literal text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_assert$enquote_literal(p_str_literal text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    /* Requires functions to be installed in aws_oracle_ext schema:
       - regexp_count.
    */

    IF (mod(aws_oracle_ext.regexp_count(p_str_literal, ''''), 2) != 0) THEN
        RAISE USING MESSAGE := 'Numeric or value error.',
                    DETAIL := 'Single quotes without paired adjacent single quotes are found. Oracle error ORA-06502.',
                    HINT := 'Verify that all single quotes except leading and trailing characters are paired with adjacent single quotes.';
    END IF;

    RETURN concat('''', p_str_literal, '''');
END;
]]></complex-attribute>
                        <category _I_D="9c582cb6-e017-4a45-bb6f-17c8a9743bac" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="cbf74025-704d-448f-b65a-e495307f02d3" name="dbms_assert$enquote_name" is-trigger-function="0" unique-function-name="dbms_assert$enquote_name" is-aggregate="f" language-name="plpgsql" context="dbms_assert$enquote_name" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,boolean" comment="This function encloses the input string within double quotes, unless they are already present." is-returning-set="f" ret-datatype="text" function-arguments="p_str_sqlname text, p_capitalize boolean DEFAULT true" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22288" volatility="STABLE" is-window="f" function-identity-arguments="p_str_sqlname text, p_capitalize boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_assert$enquote_name(p_str_sqlname text, p_capitalize boolean)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_dblquote_count SMALLINT;
    v_str_sqlname TEXT := p_str_sqlname;
BEGIN
    /* Requires functions to be installed in aws_oracle_ext schema:
       - regexp_count.
    */

    v_dblquote_count := aws_oracle_ext.regexp_count(v_str_sqlname, '"');

    IF (mod(v_dblquote_count, 2) != 0) THEN
        RAISE USING MESSAGE := 'Invalid SQL name.',
                    DETAIL := 'Double quotes without paired adjacent double quotes are found. Oracle error ORA-44003.',
                    HINT := 'Input string literal must be corrected by removing unpaired double quotes or adding corresponding ones.';
    END IF;

    IF (char_length(coalesce(v_str_sqlname, '')) = 0) THEN
        v_str_sqlname := '""';
    ELSIF (left(v_str_sqlname, 1) != '"') THEN
        v_str_sqlname := concat('"', v_str_sqlname, '"');
    END IF;

    RETURN CASE
              WHEN p_capitalize AND v_dblquote_count = 0 THEN upper(v_str_sqlname)
              ELSE v_str_sqlname
           END;
END;
]]></complex-attribute>
                        <category _I_D="1356a0fd-0c3b-469f-ba13-ec787a9690f3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8c91b823-29d6-421a-b340-25b3fc155993" name="dbms_assert$qualified_sql_name" is-trigger-function="0" unique-function-name="dbms_assert$qualified_sql_name" is-aggregate="f" language-name="plpgsql" context="dbms_assert$qualified_sql_name" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="This function checks the input string conforms to the basic characteristics of a qualified SQL name. A qualified name can be made up of several simple SQL names representing the names of the schema, object and database links." is-returning-set="f" ret-datatype="text" function-arguments="p_str_sqlname_list text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22289" volatility="STABLE" is-window="f" function-identity-arguments="p_str_sqlname_list text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_assert$qualified_sql_name(p_str_sqlname_list text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_str_sqlname VARCHAR;
BEGIN
    FOREACH v_str_sqlname IN ARRAY regexp_split_to_array(p_str_sqlname_list, '[.@]')
    LOOP
        PERFORM aws_oracle_ext.dbms_assert$simple_sql_name(v_str_sqlname);
    END LOOP;

    RETURN p_str_sqlname_list;
EXCEPTION
    WHEN OTHERS THEN
        RAISE USING MESSAGE := 'Invalid qualified SQL name.',
                    DETAIL := 'Input string literal is not a valid qualified SQL name. Oracle error ORA-44004.',
                    HINT := 'Verify that supplied SQL name (compound name) represent a valid SQL name.';
END;
]]></complex-attribute>
                        <category _I_D="41cd8ef0-07dd-4482-814f-cde05ea31c67" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4c65a9f8-5864-4ebe-b2f1-c95f15c1c56a" name="dbms_assert$schema_name" is-trigger-function="0" unique-function-name="dbms_assert$schema_name" is-aggregate="f" language-name="plpgsql" context="dbms_assert$schema_name" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="This function verifies that the input string is an existing schema name. The function is case sensitive." is-returning-set="f" ret-datatype="text" function-arguments="p_schema_name text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22290" volatility="VOLATILE" is-window="f" function-identity-arguments="p_schema_name text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_assert$schema_name(p_schema_name text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_schema_name VARCHAR;
BEGIN
    SELECT nspname
      INTO v_schema_name
      FROM pg_catalog.pg_namespace
     WHERE nspname = p_schema_name;

    IF (NOT FOUND) THEN
        RAISE invalid_schema_name;
    END IF;

    RETURN v_schema_name;
EXCEPTION
    WHEN invalid_schema_name THEN
        RAISE USING MESSAGE := 'Invalid schema.',
                    DETAIL := format('Checking found that schema with name %s does not exist in the database. Oracle error ORA-44001.',
                                     CASE
                                        WHEN p_schema_name IS NOT NULL THEN quote_literal(p_schema_name)
                                        ELSE concat(quote_literal('NULL'), ' (empty name)')
                                     END),
                    HINT := 'Verify that schema with such name have to be exist in the database or correct supplied schema name.';
END;
]]></complex-attribute>
                        <category _I_D="d4474081-9a1f-4e44-9e8c-fce7f7a021a3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="941a6d3b-554a-4439-941c-1222bcc1da9c" name="dbms_assert$simple_sql_name" is-trigger-function="0" unique-function-name="dbms_assert$simple_sql_name" is-aggregate="f" language-name="plpgsql" context="dbms_assert$simple_sql_name" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="This function checks the input string conforms to the basic characteristics of a simple SQL name." is-returning-set="f" ret-datatype="text" function-arguments="p_str_sqlname text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22291" volatility="STABLE" is-window="f" function-identity-arguments="p_str_sqlname text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_assert$simple_sql_name(p_str_sqlname text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_str_sqlname VARCHAR := trim(p_str_sqlname);
BEGIN
    /* Requires functions to be installed in aws_oracle_ext schema:
       - regexp_count;
       - regexp_substr.
    */

    -- SQL name could not be blank (empty).
    IF (char_length(coalesce(v_str_sqlname, '')) = 0) THEN
        RAISE invalid_name;
    END IF;

    -- Determining if the sql name is quoted or not.
    IF (p_str_sqlname ~* '"') THEN
        -- All double quotes in the sql name should be paired.
        IF (mod(aws_oracle_ext.regexp_count(p_str_sqlname, '"'), 2) != 0) THEN
            RAISE invalid_name;
        -- Quoted identifier could not contain any other double quotes.
        ELSIF (aws_oracle_ext.regexp_substr(p_str_sqlname, '"(.+)"', 1, 1) ~* '"') THEN
            RAISE invalid_name;
        END IF;
    ELSE
        -- Nonquoted sql name allows only alphanumeric and _, $, # characters.
        IF (v_str_sqlname !~* '^[a-z_\$#]+$') THEN
            RAISE invalid_name;
        -- Nonquoted sql name must begin with an alphabetic character.
        ELSIF (left(v_str_sqlname, 1) !~* '[a-z]') THEN
            RAISE invalid_name;
        END IF;
    END IF;

    RETURN p_str_sqlname;
EXCEPTION
    WHEN invalid_name THEN
        RAISE USING MESSAGE := 'Invalid SQL name.',
                    DETAIL := 'Input string literal is not a valid simple SQL name. Oracle error ORA-44003.',
                    HINT := 'Verify that supplied SQL name represent a valid simple SQL name.';
END;
]]></complex-attribute>
                        <category _I_D="383cdb39-36a3-4ef0-bb69-7602f7b2c17e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f160693d-1e6e-4587-a26e-05f48829d09e" name="dbms_assert$sql_object_name" is-trigger-function="0" unique-function-name="dbms_assert$sql_object_name" is-aggregate="f" language-name="plpgsql" context="dbms_assert$sql_object_name" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="This function verifies that the input parameter string is a qualified SQL identifier of an existing SQL object." is-returning-set="f" ret-datatype="text" function-arguments="p_sql_object_name text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22292" volatility="VOLATILE" is-window="f" function-identity-arguments="p_sql_object_name text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_assert$sql_object_name(p_sql_object_name text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_schema_name TEXT;
    v_object_name TEXT;
    v_obj_exists BOOLEAN;
BEGIN
    IF (coalesce(p_sql_object_name, '') ~ '^\s*$' OR -- Object name could not be blank (empty)
        p_sql_object_name ~ '^\s*\.|\.\s*$' OR -- Object name could not start or end with a dot
        array_length(string_to_array(p_sql_object_name, '\.'), 1) - 1 > 1) -- Object name could not contain more than one dot
    THEN
        RAISE invalid_name;
    END IF;

    -- Extracting schema name from object name literal
    v_schema_name := trim(coalesce(substring(p_sql_object_name, '^\s*(.+)\s*\.'), current_schema));

    -- Extracting object name from object_name literal
    v_object_name := trim(coalesce(substring(p_sql_object_name, '\.\s*(.+)'), p_sql_object_name));

    -- Preparing schema name
    IF (v_schema_name ~ '"') THEN
        -- All double quotes in the schema name must be paired
        IF (mod(array_length(string_to_array(v_schema_name, '"'), 1) - 1, 2) != 0) THEN
            RAISE invalid_name;
        END IF;

        v_schema_name := substring(v_schema_name, '"(.+)"');
    ELSIF (v_schema_name IS NOT NULL)
    THEN
        v_schema_name := lower(v_schema_name);
    END IF;

    -- Preparing object name
    IF (v_object_name ~ '"') THEN
        -- All double quotes in the object name must be paired
        IF (mod(array_length(string_to_array(v_object_name, '"'), 1) - 1, 2) != 0) THEN
            RAISE invalid_name;
        END IF;

        v_object_name := substring(v_object_name, '"(.+)"');
    ELSIF (v_object_name IS NOT NULL)
    THEN
        v_object_name := lower(v_object_name);
    END IF;

    v_obj_exists :=
        CASE
           WHEN EXISTS(SELECT 1 -- TABLE, VIEW
                         FROM information_schema.tables
                        WHERE table_schema = v_schema_name
                          AND table_name = v_object_name)
           THEN TRUE
           WHEN EXISTS(SELECT 1 -- INDEX
                         FROM pg_catalog.pg_class AS cls1
                              INNER JOIN pg_catalog.pg_index AS idx ON (idx.indexrelid = cls1.oid)
                              INNER JOIN pg_catalog.pg_class AS cls2 ON (cls2.oid = idx.indrelid)
                              LEFT JOIN pg_catalog.pg_user AS usr1 ON (usr1.usesysid = cls1.relowner)
                              LEFT JOIN pg_catalog.pg_user AS usr2 ON (usr2.usesysid = cls2.relowner)
                              LEFT JOIN pg_catalog.pg_namespace AS nsp1 ON (nsp1.oid = cls1.relnamespace)
                              LEFT JOIN pg_catalog.pg_namespace AS nsp2 ON (nsp2.oid = cls2.relnamespace)
                              INNER JOIN information_schema.tables AS tbl ON (tbl.table_schema = nsp2.nspname AND
                                                                              tbl.table_name = cls2.relname)
                        WHERE cls1.relkind = 'i'
                          AND nsp1.nspname = v_schema_name
                          AND cls1.relname = v_object_name)
           THEN TRUE
           WHEN EXISTS(SELECT 1 -- CONSTRAINT
                         FROM information_schema.table_constraints
                        WHERE constraint_schema = v_schema_name
                          AND constraint_name = v_object_name)
           THEN TRUE
           WHEN EXISTS(SELECT 1 -- SEQUENCE
                         FROM information_schema.sequences
                        WHERE sequence_schema = v_schema_name
                          AND sequence_name = v_object_name)
           THEN TRUE
           WHEN EXISTS(SELECT 1 -- FUNCTION, PROCEDURE
                         FROM information_schema.routines
                        WHERE routine_schema = v_schema_name
                          AND routine_name = v_object_name)
           THEN TRUE
           WHEN EXISTS(SELECT 1 -- TRIGGER
                         FROM information_schema.triggers
                        WHERE trigger_schema = v_schema_name
                          AND trigger_name = v_object_name)
           THEN TRUE
           WHEN EXISTS(SELECT 1 -- DOMAIN
                         FROM information_schema.domains
                        WHERE domain_schema = v_schema_name
                          AND domain_name = v_object_name)
           THEN TRUE
           WHEN EXISTS(SELECT 1 -- COMPOSITE TYPE, MATERIALIZED VIEW
                         FROM pg_catalog.pg_class AS cls
                              INNER JOIN pg_catalog.pg_namespace AS nsp ON (nsp.oid = cls.relnamespace)
                        WHERE cls.relkind IN ('c', 'm')
                          AND nsp.nspname = v_schema_name
                          AND cls.relname = v_object_name)
           THEN TRUE
           ELSE FALSE
        END;

    IF (NOT v_obj_exists) THEN
        RAISE invalid_name;
    END IF;

    RETURN p_sql_object_name;
EXCEPTION
    WHEN invalid_name THEN
        RAISE USING MESSAGE := 'Invalid object name.',
                    DETAIL := 'Input string literal is not a qualified SQL identifier of an existing SQL object.',
                    HINT := '-44002';
END;
]]></complex-attribute>
                        <category _I_D="dc350a6b-3234-4e6f-95a9-a8288d933e55" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c5b953ac-0bda-4dab-95ea-e53bd2c257f0" name="dbms_job$broken" is-trigger-function="0" unique-function-name="dbms_job$broken" is-aggregate="f" language-name="plpgsql" context="dbms_job$broken" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,boolean,timestamp without time zone" is-returning-set="f" ret-datatype="void" function-arguments="job double precision, broken boolean, next_date timestamp without time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22293" volatility="VOLATILE" is-window="f" function-identity-arguments="job double precision, broken boolean, next_date timestamp without time zone" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_job$broken(job double precision, broken boolean, next_date timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  update aws_oracle_ext.jobs j
     set broken = case when dbms_job$broken.broken then 'Y' else 'N' end
   where j.job = dbms_job$broken.job;
END;
]]></complex-attribute>
                        <category _I_D="ece8a9cd-4027-40ce-af91-db6eb324b2db" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="509a0782-980c-4248-a1a1-7de2543308d8" name="dbms_job$change" is-trigger-function="0" unique-function-name="dbms_job$change" is-aggregate="f" language-name="plpgsql" context="dbms_job$change" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,character varying,timestamp without time zone,character varying,double precision,boolean" is-returning-set="f" ret-datatype="void" function-arguments="job double precision, what character varying, next_date timestamp without time zone DEFAULT now(), &quot;interval&quot; character varying DEFAULT 'null'::character varying, instance double precision DEFAULT NULL::double precision, force boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22294" volatility="VOLATILE" is-window="f" function-identity-arguments="job double precision, what character varying, next_date timestamp without time zone, &quot;interval&quot; character varying, instance double precision, force boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_job$change(job double precision, what character varying, next_date timestamp without time zone, &quot;interval&quot; character varying, instance double precision, force boolean)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  update aws_oracle_ext.jobs j
     set what = dbms_job$change.what
       , next_date = dbms_job$change.next_date
       , "interval" = dbms_job$change.interval
   where j.job = dbms_job$change.job;
END;
]]></complex-attribute>
                        <category _I_D="d2b3f17f-c033-4e9f-88d7-3d89fe7d1c98" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="532d77ee-fb8f-4a80-ab77-fcd9e34ea07f" name="dbms_job$instance" is-trigger-function="0" unique-function-name="dbms_job$instance" is-aggregate="f" language-name="plpgsql" context="dbms_job$instance" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,double precision,boolean" is-returning-set="f" ret-datatype="void" function-arguments="job double precision, instance double precision, force boolean" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22295" volatility="VOLATILE" is-window="f" function-identity-arguments="job double precision, instance double precision, force boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_job$instance(job double precision, instance double precision, force boolean)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  null;
END;
]]></complex-attribute>
                        <category _I_D="9a3c4ae2-cbd1-44fe-909d-81ccea37098f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ce6649fb-1b83-49a8-b31f-45be11707ab6" name="dbms_job$interval" is-trigger-function="0" unique-function-name="dbms_job$interval" is-aggregate="f" language-name="plpgsql" context="dbms_job$interval" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,character varying" is-returning-set="f" ret-datatype="void" function-arguments="job double precision, &quot;interval&quot; character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22296" volatility="VOLATILE" is-window="f" function-identity-arguments="job double precision, &quot;interval&quot; character varying" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_job$interval(job double precision, &quot;interval&quot; character varying)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  update aws_oracle_ext.jobs
     set "interval" = dbms_job$interval."interval"
   where jobs.job = dbms_job$interval.job;
END;
]]></complex-attribute>
                        <category _I_D="c629cae8-834a-4ca2-b8eb-fcfa80d1bd63" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c7950e1e-bbc8-4a43-a444-7419937e61e5" name="dbms_job$isubmit" is-trigger-function="0" unique-function-name="dbms_job$isubmit" is-aggregate="f" language-name="plpgsql" context="dbms_job$isubmit" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,character varying,timestamp without time zone,character varying,boolean,double precision,boolean" is-returning-set="f" ret-datatype="void" function-arguments="job double precision, what character varying, next_date timestamp without time zone DEFAULT now(), &quot;interval&quot; character varying DEFAULT 'null'::character varying, no_parse boolean DEFAULT false, instance double precision DEFAULT NULL::double precision, force boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="7" function-id="22297" volatility="VOLATILE" is-window="f" function-identity-arguments="job double precision, what character varying, next_date timestamp without time zone, &quot;interval&quot; character varying, no_parse boolean, instance double precision, force boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_job$isubmit(job double precision, what character varying, next_date timestamp without time zone, &quot;interval&quot; character varying, no_parse boolean, instance double precision, force boolean)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  insert into aws_oracle_ext.jobs( job, what, next_date, "interval" )
  values( job, what, next_date, "interval" );
END;
]]></complex-attribute>
                        <category _I_D="4ef6ed90-e29c-439e-8721-157baac3a1c8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3d71f884-cff7-437e-a7db-f3193b003004" name="dbms_job$next_date" is-trigger-function="0" unique-function-name="dbms_job$next_date" is-aggregate="f" language-name="plpgsql" context="dbms_job$next_date" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,timestamp without time zone" is-returning-set="f" ret-datatype="void" function-arguments="job double precision, next_date timestamp without time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22298" volatility="VOLATILE" is-window="f" function-identity-arguments="job double precision, next_date timestamp without time zone" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_job$next_date(job double precision, next_date timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  update aws_oracle_ext.jobs j
     set j.next_date = next_date
   where j.job = dbms_job$next_date.job;
END;
]]></complex-attribute>
                        <category _I_D="e08491cb-9c37-4ffb-b168-9fa5c48408f0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="827bea99-76fe-42f0-8543-361fa99a7d8c" name="dbms_job$remove" is-trigger-function="0" unique-function-name="dbms_job$remove" is-aggregate="f" language-name="plpgsql" context="dbms_job$remove" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision" is-returning-set="f" ret-datatype="void" function-arguments="job double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22299" volatility="VOLATILE" is-window="f" function-identity-arguments="job double precision" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_job$remove(job double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  delete from aws_oracle_ext.jobs j where j.job = dbms_job$remove.job;
END;
]]></complex-attribute>
                        <category _I_D="1ff74c81-ff61-4d9a-af81-72f65aaef61d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="87e58eb3-8246-4ba4-be2b-de795512b281" name="dbms_job$run" is-trigger-function="0" unique-function-name="dbms_job$run" is-aggregate="f" language-name="plpgsql" context="dbms_job$run" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,boolean" is-returning-set="f" ret-datatype="void" function-arguments="job double precision, force boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22300" volatility="VOLATILE" is-window="f" function-identity-arguments="job double precision, force boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_job$run(job double precision, force boolean)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  update aws_oracle_ext.jobs j
     set next_date = current_timestamp
       , broken = 'N'
   where j.job = dbms_job$run.job;
END;
]]></complex-attribute>
                        <category _I_D="31099d21-6794-4fcd-9371-25697faf82c8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b3d8d19c-849b-4115-a6a5-4d68a19249df" name="dbms_job$submit" is-trigger-function="0" unique-function-name="dbms_job$submit" is-aggregate="f" language-name="plpgsql" context="dbms_job$submit" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,character varying,timestamp without time zone,character varying,boolean,double precision,boolean" is-returning-set="f" ret-datatype="float8" function-arguments="OUT job double precision, what character varying, next_date timestamp without time zone DEFAULT now(), &quot;interval&quot; character varying DEFAULT 'null'::character varying, no_parse boolean DEFAULT false, instance double precision DEFAULT NULL::double precision, force boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22301" volatility="VOLATILE" is-window="f" function-identity-arguments="OUT job double precision, what character varying, next_date timestamp without time zone, &quot;interval&quot; character varying, no_parse boolean, instance double precision, force boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_job$submit(OUT job double precision, what character varying, next_date timestamp without time zone, &quot;interval&quot; character varying, no_parse boolean, instance double precision, force boolean)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  insert into aws_oracle_ext.jobs( job, what, next_date, "interval" )
  values( default, what, next_date, "interval" )
  returning jobs.job::double precision into dbms_job$submit.job;
END;
]]></complex-attribute>
                        <category _I_D="b5ee54f2-4c21-4998-8e63-04e3da791568" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2309d6f5-c430-4892-8e51-cde19c471920" name="dbms_job$user_export" is-trigger-function="0" unique-function-name="dbms_job$user_export(job double precision, INOUT mycall character varying)" is-aggregate="f" language-name="plpgsql" context="dbms_job$user_export(job double precision, INOUT mycall character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,character varying" unique-suffix="(job double precision, INOUT mycall character varying)" routine-number="22302" is-returning-set="f" ret-datatype="varchar" function-arguments="job double precision, INOUT mycall character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22302" volatility="VOLATILE" is-window="f" function-identity-arguments="job double precision, INOUT mycall character varying" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_job$user_export(job double precision, INOUT mycall character varying)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  select 'PERFORM aws_oracle_ext.dbms_job$isubmit( ' || j.job || ', ''' || replace( j.what, '''', '''''' ) || ''', to_timestamp( ''' || to_char( j.next_date, 'YYYYMMDDHH24MISS' ) || ''', ''YYYYMMDDHH24MISS'') , ''' || j.interval || ''' );'
    into mycall
    from aws_oracle_ext.jobs as j
   where j.job = job;
END;
]]></complex-attribute>
                        <category _I_D="bcc645ba-3c19-4290-8311-9c017740b9ca" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="99fb63e0-f2cc-4133-8749-98c27bada74e" name="dbms_job$user_export" is-trigger-function="0" unique-function-name="dbms_job$user_export(job double precision, INOUT mycall character varying, myinst character varying)" is-aggregate="f" language-name="plpgsql" context="dbms_job$user_export(job double precision, INOUT mycall character varying, myinst character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,character varying,character varying" unique-suffix="(job double precision, INOUT mycall character varying, myinst character varying)" routine-number="22303" is-returning-set="f" ret-datatype="varchar" function-arguments="job double precision, INOUT mycall character varying, myinst character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22303" volatility="VOLATILE" is-window="f" function-identity-arguments="job double precision, INOUT mycall character varying, myinst character varying" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_job$user_export(job double precision, INOUT mycall character varying, myinst character varying)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  mycall := aws_oracle_ext.dbms_job$user_export( job := job );
END;
]]></complex-attribute>
                        <category _I_D="a433f54f-1f79-4570-bfd8-6e3ffc160740" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ce0c6f3c-803f-4828-a521-3d5f430431e7" name="dbms_job$what" is-trigger-function="0" unique-function-name="dbms_job$what" is-aggregate="f" language-name="plpgsql" context="dbms_job$what" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,character varying" is-returning-set="f" ret-datatype="void" function-arguments="job double precision, what character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22304" volatility="VOLATILE" is-window="f" function-identity-arguments="job double precision, what character varying" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_job$what(job double precision, what character varying)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  update aws_oracle_ext.jobs j
     set j.what = what
   where j.job = job;
END;
]]></complex-attribute>
                        <category _I_D="4872d22f-f1ed-477c-b08f-e0fb9619b838" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c3cd48f6-04c1-4e3a-a352-0736fa81f55f" name="dbms_lob$call" is-trigger-function="0" unique-function-name="dbms_lob$call" is-aggregate="f" language-name="sql" context="dbms_lob$call" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.CALL package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23355" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$call()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.CALL package constant
SELECT 12;
]]></complex-attribute>
                        <category _I_D="6125efea-4c0c-4b31-af2b-de517d2d7b1a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2d8d7fcf-8aa5-4fbe-8110-b795ef714a7f" name="dbms_lob$compare" is-trigger-function="0" unique-function-name="dbms_lob$compare(lob_1 bytea, lob_2 bytea, amount numeric, offset_1 numeric, offset_2 numeric)" is-aggregate="f" language-name="plpgsql" context="dbms_lob$compare(lob_1 bytea, lob_2 bytea, amount numeric, offset_1 numeric, offset_2 numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea,bytea,numeric,numeric,numeric" comment="This function compares two entire binary LOBs or parts of two binary LOBs. Returns zero (0) if the comparison succeeds, nonzero (-1 or 1) if not." unique-suffix="(lob_1 bytea, lob_2 bytea, amount numeric, offset_1 numeric, offset_2 numeric)" routine-number="23314" is-returning-set="f" ret-datatype="numeric" function-arguments="lob_1 bytea, lob_2 bytea, amount numeric DEFAULT '18446744073709551615'::numeric, offset_1 numeric DEFAULT 1, offset_2 numeric DEFAULT 1" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="23314" volatility="IMMUTABLE" is-window="f" function-identity-arguments="lob_1 bytea, lob_2 bytea, amount numeric, offset_1 numeric, offset_2 numeric" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_lob$compare(lob_1 bytea, lob_2 bytea, amount numeric, offset_1 numeric, offset_2 numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_src_part BYTEA;
    v_trg_part BYTEA;
    v_amount INTEGER;
BEGIN
    -- Checking input arguments
    IF (amount < 1 OR
        offset_1 < 1 OR
        offset_2 < 1)
    THEN
        RETURN NULL;
    END IF;

    -- NUMERIC -> INTEGER DBMS_LOB.LOBMAXSIZE workaround
    v_amount := CASE amount
                   WHEN aws_oracle_ext.dbms_lob$lobmaxsize()
                   THEN 2147483647 -- Maximum positive value for data type INTEGER
                   ELSE amount
                END;

    -- Constructing first (source) part for upcoming comparison
    v_src_part := substr(lob_1, floor(offset_1)::INTEGER, v_amount);

    -- Constructing second (target) part for upcoming comparison
    v_trg_part := substr(lob_2, floor(offset_2)::INTEGER, v_amount);

    -- Return -1 if the source piece is less than the second, and 1 if it is greater.
    RETURN CASE /* 0 if the comparison succeeds */
              WHEN (v_src_part = v_trg_part) THEN 0
              WHEN (v_src_part > v_trg_part) THEN 1
              ELSE -1
           END;
END;
]]></complex-attribute>
                        <category _I_D="43b4465f-a513-48eb-8ab1-4198fe8da826" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a8bc536a-0568-4cbf-b121-eebc61136cdd" name="dbms_lob$compare" is-trigger-function="0" unique-function-name="dbms_lob$compare(lob_1 text, lob_2 text, amount numeric, offset_1 numeric, offset_2 numeric)" is-aggregate="f" language-name="plpgsql" context="dbms_lob$compare(lob_1 text, lob_2 text, amount numeric, offset_1 numeric, offset_2 numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,numeric,numeric,numeric" comment="This function compares two entire character LOBs or parts of two character LOBs. Returns zero (0) if the comparison succeeds, nonzero (-1 or 1) if not." unique-suffix="(lob_1 text, lob_2 text, amount numeric, offset_1 numeric, offset_2 numeric)" routine-number="23313" is-returning-set="f" ret-datatype="numeric" function-arguments="lob_1 text, lob_2 text, amount numeric DEFAULT '18446744073709551615'::numeric, offset_1 numeric DEFAULT 1, offset_2 numeric DEFAULT 1" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="23313" volatility="IMMUTABLE" is-window="f" function-identity-arguments="lob_1 text, lob_2 text, amount numeric, offset_1 numeric, offset_2 numeric" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_lob$compare(lob_1 text, lob_2 text, amount numeric, offset_1 numeric, offset_2 numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_src_part TEXT;
    v_trg_part TEXT;
    v_amount INTEGER;
BEGIN
    -- Checking input arguments
    IF (amount < 1 OR
        offset_1 < 1 OR
        offset_2 < 1)
    THEN
        RETURN NULL;
    END IF;

    -- NUMERIC -> INTEGER DBMS_LOB.LOBMAXSIZE workaround
    v_amount := CASE amount
                   WHEN aws_oracle_ext.dbms_lob$lobmaxsize()
                   THEN 2147483647 -- Maximum positive value for data type INTEGER
                   ELSE amount
                END;

    -- Constructing first (source) part for upcoming comparison
    v_src_part := substr(lob_1, floor(offset_1)::INTEGER, v_amount);

    -- Constructing second (target) part for upcoming comparison
    v_trg_part := substr(lob_2, floor(offset_2)::INTEGER, v_amount);

    -- Return -1 if the source piece is less than the second, and 1 if it is greater.
    RETURN CASE /* 0 if the comparison succeeds */
              WHEN (v_src_part = v_trg_part) THEN 0
              WHEN (v_src_part > v_trg_part) THEN 1
              ELSE -1
           END;
END;
]]></complex-attribute>
                        <category _I_D="3a89988c-c38f-4195-aaa9-2722001675f6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="12e9a03a-92f9-46b6-9287-6503f2f2b0a0" name="dbms_lob$compress_off" is-trigger-function="0" unique-function-name="dbms_lob$compress_off" is-aggregate="f" language-name="sql" context="dbms_lob$compress_off" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.COMPRESS_OFF package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23365" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$compress_off()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.COMPRESS_OFF package constant
SELECT 0;
]]></complex-attribute>
                        <category _I_D="2c5eed1f-fe8f-4bea-8708-7accd004ea3b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="60addd42-3e2c-4cf4-94b9-e538650c947a" name="dbms_lob$compress_on" is-trigger-function="0" unique-function-name="dbms_lob$compress_on" is-aggregate="f" language-name="sql" context="dbms_lob$compress_on" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.COMPRESS_ON package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23366" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$compress_on()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.COMPRESS_ON package constant
SELECT aws_oracle_ext.dbms_lob$opt_compress();
]]></complex-attribute>
                        <category _I_D="c218554e-c957-4010-8014-a14ce30d943d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="22177a02-1cc9-4dde-92c1-f4d8e1e195d0" name="dbms_lob$contenttype_max_size" is-trigger-function="0" unique-function-name="dbms_lob$contenttype_max_size" is-aggregate="f" language-name="sql" context="dbms_lob$contenttype_max_size" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.CONTENTTYPE_MAX_SIZE package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23377" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$contenttype_max_size()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.CONTENTTYPE_MAX_SIZE package constant
SELECT 128;
]]></complex-attribute>
                        <category _I_D="e61cb6ad-a9df-4955-b2c2-91069a3fb5b8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="acbb1149-933f-466b-aa6c-f9ae36630761" name="dbms_lob$dbfs_link_cache" is-trigger-function="0" unique-function-name="dbms_lob$dbfs_link_cache" is-aggregate="f" language-name="sql" context="dbms_lob$dbfs_link_cache" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.DBFS_LINK_CACHE package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23375" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$dbfs_link_cache()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.DBFS_LINK_CACHE package constant
SELECT 1;
]]></complex-attribute>
                        <category _I_D="6f85dc3b-ce71-415a-b3fc-34f004688db5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="306d7695-1bf1-4eb1-86ae-d39c2fd0960c" name="dbms_lob$dbfs_link_never" is-trigger-function="0" unique-function-name="dbms_lob$dbfs_link_never" is-aggregate="f" language-name="sql" context="dbms_lob$dbfs_link_never" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.DBFS_LINK_NEVER package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23371" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$dbfs_link_never()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.DBFS_LINK_NEVER package constant
SELECT 0;
]]></complex-attribute>
                        <category _I_D="a9fa1a59-c67b-4955-9255-c0adaf95590c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c85ad629-ff28-4559-a994-b86629463cfa" name="dbms_lob$dbfs_link_no" is-trigger-function="0" unique-function-name="dbms_lob$dbfs_link_no" is-aggregate="f" language-name="sql" context="dbms_lob$dbfs_link_no" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.DBFS_LINK_NO package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23373" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$dbfs_link_no()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.DBFS_LINK_NO package constant
SELECT 2;
]]></complex-attribute>
                        <category _I_D="da1bcb50-8f8b-4062-b580-fde77221fb40" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bf94462e-b503-43f4-8b6a-3e894860b222" name="dbms_lob$dbfs_link_nocache" is-trigger-function="0" unique-function-name="dbms_lob$dbfs_link_nocache" is-aggregate="f" language-name="sql" context="dbms_lob$dbfs_link_nocache" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.DBFS_LINK_NOCACHE package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23374" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$dbfs_link_nocache()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.DBFS_LINK_NOCACHE package constant
SELECT 0;
]]></complex-attribute>
                        <category _I_D="c3e3a11f-bd93-40b2-8b69-9abaf85d9fe8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d88ed605-1bf7-47e7-b52c-96fddd156128" name="dbms_lob$dbfs_link_path_max_size" is-trigger-function="0" unique-function-name="dbms_lob$dbfs_link_path_max_size" is-aggregate="f" language-name="sql" context="dbms_lob$dbfs_link_path_max_size" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.DBFS_LINK_PATH_MAX_SIZE package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23376" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$dbfs_link_path_max_size()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.DBFS_LINK_PATH_MAX_SIZE package constant
SELECT 1024;
]]></complex-attribute>
                        <category _I_D="75ccd4eb-ef5c-4b05-ab6a-50c9efd3cb24" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9d616eee-5f05-4668-bd38-bafbe3f0bfac" name="dbms_lob$dbfs_link_yes" is-trigger-function="0" unique-function-name="dbms_lob$dbfs_link_yes" is-aggregate="f" language-name="sql" context="dbms_lob$dbfs_link_yes" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.DBFS_LINK_YES package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23372" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$dbfs_link_yes()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.DBFS_LINK_YES package constant
SELECT 1;
]]></complex-attribute>
                        <category _I_D="fcdd64c8-5454-49f9-82a3-85829cee9fac" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2dacf258-bbf9-4dd5-ae9e-79f55c2c5377" name="dbms_lob$deduplicate_off" is-trigger-function="0" unique-function-name="dbms_lob$deduplicate_off" is-aggregate="f" language-name="sql" context="dbms_lob$deduplicate_off" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.DEDUPLICATE_OFF package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23369" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$deduplicate_off()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.DEDUPLICATE_OFF package constant
SELECT 0;
]]></complex-attribute>
                        <category _I_D="f894c8c5-699f-43fa-b0a8-8c124f72cea5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="75ef960f-12bf-4ce1-bdb0-559e35c80ca1" name="dbms_lob$deduplicate_on" is-trigger-function="0" unique-function-name="dbms_lob$deduplicate_on" is-aggregate="f" language-name="sql" context="dbms_lob$deduplicate_on" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.DEDUPLICATE_ON package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23370" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$deduplicate_on()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.DEDUPLICATE_ON package constant
SELECT aws_oracle_ext.dbms_lob$opt_deduplicate();
]]></complex-attribute>
                        <category _I_D="6af5aaf4-06bf-4de5-b198-1411321dd0ed" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7f0f6298-9c01-49ec-8003-2352d3ff347a" name="dbms_lob$default_csid" is-trigger-function="0" unique-function-name="dbms_lob$default_csid" is-aggregate="f" language-name="sql" context="dbms_lob$default_csid" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.DEFAULT_CSID package constant." is-returning-set="f" ret-datatype="numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23359" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$default_csid()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.DEFAULT_CSID package constant
SELECT 0;
]]></complex-attribute>
                        <category _I_D="470141a6-deab-4730-835b-a3b7ac98626e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5f1ede17-c1e4-49b4-8243-f210bb47efcf" name="dbms_lob$default_lang_ctx" is-trigger-function="0" unique-function-name="dbms_lob$default_lang_ctx" is-aggregate="f" language-name="sql" context="dbms_lob$default_lang_ctx" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.DEFAULT_LANG_CTX package constant." is-returning-set="f" ret-datatype="numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23360" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$default_lang_ctx()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.DEFAULT_LANG_CTX package constant
SELECT 0;
]]></complex-attribute>
                        <category _I_D="0185a64e-f1fb-40df-8e66-05f809befbf7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="75f4a973-f591-49a6-be03-ca237ee18487" name="dbms_lob$encrypt_off" is-trigger-function="0" unique-function-name="dbms_lob$encrypt_off" is-aggregate="f" language-name="sql" context="dbms_lob$encrypt_off" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.ENCRYPT_OFF package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23367" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$encrypt_off()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.ENCRYPT_OFF package constant
SELECT 0;
]]></complex-attribute>
                        <category _I_D="e884aaf2-2d6d-4e4a-a63b-d29afeca96f5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bf45d12a-771c-42ed-a24e-f315f003806e" name="dbms_lob$encrypt_on" is-trigger-function="0" unique-function-name="dbms_lob$encrypt_on" is-aggregate="f" language-name="sql" context="dbms_lob$encrypt_on" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.ENCRYPT_ON package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23368" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$encrypt_on()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.ENCRYPT_ON package constant
SELECT aws_oracle_ext.dbms_lob$opt_encrypt();
]]></complex-attribute>
                        <category _I_D="05cb9bd3-4d2c-45c4-aa94-ef115b4a2515" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="55cce8e1-b9ea-46a5-8164-851124e44665" name="dbms_lob$file_readonly" is-trigger-function="0" unique-function-name="dbms_lob$file_readonly" is-aggregate="f" language-name="sql" context="dbms_lob$file_readonly" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.FILE_READONLY package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23351" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$file_readonly()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.FILE_READONLY package constant
SELECT 0;
]]></complex-attribute>
                        <category _I_D="9381bcb5-24e1-4f68-90c3-5633a6bd8643" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="05ad71ce-3e69-4e4b-9b4c-ba2111da4635" name="dbms_lob$getlength" is-trigger-function="0" unique-function-name="dbms_lob$getlength(lob_loc bytea)" is-aggregate="f" language-name="sql" context="dbms_lob$getlength(lob_loc bytea)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea" comment="This function gets the length in bytes of the specified binary LOB." unique-suffix="(lob_loc bytea)" routine-number="23328" is-returning-set="f" ret-datatype="numeric" function-arguments="lob_loc bytea" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23328" volatility="IMMUTABLE" is-window="f" function-identity-arguments="lob_loc bytea" overload-function-count="2" proc-language="sql" function-signature="dbms_lob$getlength(lob_loc bytea)">
                        <complex-attribute name="sql"><![CDATA[
SELECT octet_length(lob_loc);
]]></complex-attribute>
                        <category _I_D="fa72ed3a-fb60-4ab3-9078-8b6f769da6e6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0da8f861-302d-421f-bde1-c06c704f18b4" name="dbms_lob$getlength" is-trigger-function="0" unique-function-name="dbms_lob$getlength(lob_loc text)" is-aggregate="f" language-name="sql" context="dbms_lob$getlength(lob_loc text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="This function gets the length in characters of the specified character LOB." unique-suffix="(lob_loc text)" routine-number="23327" is-returning-set="f" ret-datatype="numeric" function-arguments="lob_loc text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23327" volatility="IMMUTABLE" is-window="f" function-identity-arguments="lob_loc text" overload-function-count="2" proc-language="sql" function-signature="dbms_lob$getlength(lob_loc text)">
                        <complex-attribute name="sql"><![CDATA[
-- Replacing CR + LF to LF in lob_loc
SELECT char_length(regexp_replace(lob_loc, '\r\n', chr(10), 'g'));
]]></complex-attribute>
                        <category _I_D="7dfce3c6-d563-4087-ae06-dd1111768215" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="fe002baa-8c28-4759-b24b-048913b63299" name="dbms_lob$instr" is-trigger-function="0" unique-function-name="dbms_lob$instr(lob_loc bytea, pattern bytea, &quot;offset&quot; numeric, nth numeric)" is-aggregate="f" language-name="plpgsql" context="dbms_lob$instr(lob_loc bytea, pattern bytea, &quot;offset&quot; numeric, nth numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea,bytea,numeric,numeric" comment="This function returns the matching position of the nth occurrence of the pattern in the binary LOB, starting from the specified offset." unique-suffix="(lob_loc bytea, pattern bytea, &quot;offset&quot; numeric, nth numeric)" routine-number="23330" is-returning-set="f" ret-datatype="numeric" function-arguments="lob_loc bytea, pattern bytea, &quot;offset&quot; numeric DEFAULT 1, nth numeric DEFAULT 1" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="23330" volatility="IMMUTABLE" is-window="f" function-identity-arguments="lob_loc bytea, pattern bytea, &quot;offset&quot; numeric, nth numeric" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_lob$instr(lob_loc bytea, pattern bytea, &quot;offset&quot; numeric, nth numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_loc_len INTEGER;
    v_pat_len INTEGER;
    v_pos_idx NUMERIC;
    v_offset INTEGER;
    v_nth_occur NUMERIC;
    v_obj_offset INTEGER;
    v_occur_num NUMERIC := 0;
BEGIN
    -- Determining pattern length (bytes)
    v_pat_len := octet_length(pattern);

    -- Checking input arguments
    IF (v_pat_len = 0 OR
        "offset" < 1 OR
        nth < 1)
    THEN
        RETURN NULL;
    END IF;

    -- Extracting integer part of offset
    v_obj_offset := floor("offset");

    -- Extracting integer part of occurrence
    v_nth_occur := floor(nth);

    -- Using the "easy way" approach by default
    IF (v_obj_offset = 1 AND v_nth_occur = 1)
    THEN
        RETURN position(pattern in lob_loc);
    ELSE
        -- Determining object length (bytes)
        v_loc_len := octet_length(lob_loc);

        -- Calculating the index of the first occurrence
        v_pos_idx := v_obj_offset - 1 + position(pattern in substr(lob_loc, v_obj_offset));

        WHILE (v_pos_idx BETWEEN 1 AND v_loc_len)
        LOOP
            v_occur_num := v_occur_num + 1;

            IF (v_occur_num = v_nth_occur)
            THEN
                RETURN v_pos_idx;
            END IF;

            v_offset := v_obj_offset + v_pos_idx + v_pat_len;

            -- Calculating the index of the next occurrence
            v_pos_idx := v_offset - 1 + position(pattern in substr(lob_loc, v_offset));
        END LOOP;

        RETURN 0; -- Zero, if there are no occurrences
    END IF;
END;
]]></complex-attribute>
                        <category _I_D="b714dae3-8965-4295-8247-c71719780521" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ba79c00e-9ce7-4814-8555-79b1d019dfe8" name="dbms_lob$instr" is-trigger-function="0" unique-function-name="dbms_lob$instr(lob_loc text, pattern text, &quot;offset&quot; numeric, nth numeric)" is-aggregate="f" language-name="plpgsql" context="dbms_lob$instr(lob_loc text, pattern text, &quot;offset&quot; numeric, nth numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,numeric,numeric" comment="This function returns the matching position of the nth occurrence of the pattern in the character LOB, starting from the specified offset." unique-suffix="(lob_loc text, pattern text, &quot;offset&quot; numeric, nth numeric)" routine-number="23329" is-returning-set="f" ret-datatype="numeric" function-arguments="lob_loc text, pattern text, &quot;offset&quot; numeric DEFAULT 1, nth numeric DEFAULT 1" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="23329" volatility="IMMUTABLE" is-window="f" function-identity-arguments="lob_loc text, pattern text, &quot;offset&quot; numeric, nth numeric" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_lob$instr(lob_loc text, pattern text, &quot;offset&quot; numeric, nth numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_lob_loc TEXT;
    v_pattern TEXT;
    v_loc_len INTEGER;
    v_pat_len INTEGER;
    v_pos_idx INTEGER;
    v_offset INTEGER;
    v_nth_occur NUMERIC;
    v_obj_offset INTEGER;
    v_occur_num NUMERIC := 0;
BEGIN
    -- Determining pattern length (characters)
    v_pat_len := char_length(pattern);

    -- Checking input arguments
    IF (v_pat_len = 0 OR
        "offset" < 1 OR
        nth < 1)
    THEN
        RETURN NULL;
    END IF;

    -- Extracting integer part of offset
    v_obj_offset := floor("offset");

    -- Extracting integer part of occurrence
    v_nth_occur := floor(nth);

    -- Replacing CR + LF to LF in lob_loc
    v_lob_loc := regexp_replace(lob_loc, '\r\n', chr(10), 'g');

    -- Replacing CR + LF to LF in pattern
    v_pattern := regexp_replace(pattern, '\r\n', chr(10), 'g');

    -- Using the "easy way" approach by default
    IF (v_obj_offset = 1 AND v_nth_occur = 1)
    THEN
        RETURN strpos(v_lob_loc, v_pattern);
    ELSE
        -- Determining object length (characters)
        v_loc_len := char_length(v_lob_loc);

        -- Calculating the index of the first occurrence
        v_pos_idx := v_obj_offset - 1 + strpos(substr(v_lob_loc, v_obj_offset), v_pattern);

        WHILE (v_pos_idx BETWEEN 1 AND v_loc_len)
        LOOP
            v_occur_num := v_occur_num + 1;

            IF (v_occur_num = v_nth_occur)
            THEN
                RETURN v_pos_idx;
            END IF;

            v_offset := v_obj_offset + v_pos_idx + v_pat_len;

            -- Calculating the index of the next occurrence
            v_pos_idx := v_offset - 1 + strpos(substr(v_lob_loc, v_offset), v_pattern);
        END LOOP;

        RETURN 0; -- Zero, if there are no occurrences
    END IF;
END;
]]></complex-attribute>
                        <category _I_D="4be2d2d7-0915-410f-a42a-c3f568f91236" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c4ffa685-3847-460f-880d-82ff3dc1a3ba" name="dbms_lob$istemporary" is-trigger-function="0" unique-function-name="dbms_lob$istemporary(lob_loc bytea)" is-aggregate="f" language-name="sql" context="dbms_lob$istemporary(lob_loc bytea)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea" comment="This function determines whether a binary LOB instance is temporary." unique-suffix="(lob_loc bytea)" routine-number="23306" is-returning-set="f" ret-datatype="numeric" function-arguments="lob_loc bytea" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23306" volatility="IMMUTABLE" is-window="f" function-identity-arguments="lob_loc bytea" overload-function-count="2" proc-language="sql" function-signature="dbms_lob$istemporary(lob_loc bytea)">
                        <complex-attribute name="sql"><![CDATA[
SELECT 1;
]]></complex-attribute>
                        <category _I_D="952680b4-f700-4f39-b390-e2c0d42a915a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f4656d1f-e9fc-44a5-a29e-7d4f86812252" name="dbms_lob$istemporary" is-trigger-function="0" unique-function-name="dbms_lob$istemporary(lob_loc text)" is-aggregate="f" language-name="sql" context="dbms_lob$istemporary(lob_loc text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="This function determines whether a character LOB instance is temporary." unique-suffix="(lob_loc text)" routine-number="23305" is-returning-set="f" ret-datatype="numeric" function-arguments="lob_loc text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23305" volatility="IMMUTABLE" is-window="f" function-identity-arguments="lob_loc text" overload-function-count="2" proc-language="sql" function-signature="dbms_lob$istemporary(lob_loc text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT 1;
]]></complex-attribute>
                        <category _I_D="97e4e459-0a30-490e-90a0-a055b55b96e1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7aacfc89-707a-4865-aa5c-b43cd177e1ee" name="dbms_lob$lob_readonly" is-trigger-function="0" unique-function-name="dbms_lob$lob_readonly" is-aggregate="f" language-name="sql" context="dbms_lob$lob_readonly" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.LOB_READONLY package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23352" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$lob_readonly()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.LOB_READONLY package constant
SELECT 0;
]]></complex-attribute>
                        <category _I_D="26f12755-ce98-4ae2-b84e-454a73487343" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f99ff916-f296-497b-a8d6-adfa48bdde60" name="dbms_lob$lob_readwrite" is-trigger-function="0" unique-function-name="dbms_lob$lob_readwrite" is-aggregate="f" language-name="sql" context="dbms_lob$lob_readwrite" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.LOB_READWRITE package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23353" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$lob_readwrite()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.LOB_READWRITE package constant
SELECT 1;
]]></complex-attribute>
                        <category _I_D="de7b78e7-7edc-4bbd-a96b-b600fc7a07e6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f42d9eea-49cc-4c6f-bacf-46c7c016b29b" name="dbms_lob$lobmaxsize" is-trigger-function="0" unique-function-name="dbms_lob$lobmaxsize" is-aggregate="f" language-name="sql" context="dbms_lob$lobmaxsize" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.LOBMAXSIZE package constant." is-returning-set="f" ret-datatype="numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23354" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$lobmaxsize()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.LOBMAXSIZE package constant
SELECT 18446744073709551615;
]]></complex-attribute>
                        <category _I_D="19734b3e-47f8-40da-852b-b3be8aa80cf5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="26ce718a-0f19-4196-b3af-162b78876c5e" name="dbms_lob$no_warning" is-trigger-function="0" unique-function-name="dbms_lob$no_warning" is-aggregate="f" language-name="sql" context="dbms_lob$no_warning" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.NO_WARNING package constant." is-returning-set="f" ret-datatype="numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23361" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$no_warning()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.NO_WARNING package constant
SELECT 0;
]]></complex-attribute>
                        <category _I_D="c09e9b7e-79a3-489b-b344-1131ef1c8fd0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1d52df2e-e033-4ad1-b5ca-828d87c437ff" name="dbms_lob$opt_compress" is-trigger-function="0" unique-function-name="dbms_lob$opt_compress" is-aggregate="f" language-name="sql" context="dbms_lob$opt_compress" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.OPT_COMPRESS package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23362" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$opt_compress()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.OPT_COMPRESS package constant
SELECT 1;
]]></complex-attribute>
                        <category _I_D="17700446-b6ba-4304-9d45-a144abdb4df3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2a8641b3-abd3-4142-9858-fc49ccb426e9" name="dbms_lob$opt_deduplicate" is-trigger-function="0" unique-function-name="dbms_lob$opt_deduplicate" is-aggregate="f" language-name="sql" context="dbms_lob$opt_deduplicate" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.OPT_DEDUPLICATE package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23364" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$opt_deduplicate()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.OPT_DEDUPLICATE package constant
SELECT 4;
]]></complex-attribute>
                        <category _I_D="1caec582-3364-40d0-af18-0cc729e8058b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1211a550-866d-4d9d-b035-6fc47ac3d9dc" name="dbms_lob$opt_encrypt" is-trigger-function="0" unique-function-name="dbms_lob$opt_encrypt" is-aggregate="f" language-name="sql" context="dbms_lob$opt_encrypt" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.OPT_ENCRYPT package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23363" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$opt_encrypt()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.OPT_ENCRYPT package constant
SELECT 2;
]]></complex-attribute>
                        <category _I_D="83d653b3-cd25-406a-8290-ccdd3695920e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0f847986-5556-40e5-91df-34e1105da173" name="dbms_lob$session" is-trigger-function="0" unique-function-name="dbms_lob$session" is-aggregate="f" language-name="sql" context="dbms_lob$session" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.SESSION package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23357" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$session()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.SESSION package constant
SELECT 10;
]]></complex-attribute>
                        <category _I_D="04faf289-e454-4e13-8211-165df95d2476" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="83cbe04f-5c83-459d-9ab4-b8c1508e2833" name="dbms_lob$substr" is-trigger-function="0" unique-function-name="dbms_lob$substr(lob_loc bytea, amount numeric, &quot;offset&quot; numeric)" is-aggregate="f" language-name="plpgsql" context="dbms_lob$substr(lob_loc bytea, amount numeric, &quot;offset&quot; numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea,numeric,numeric" comment="This function returns amount bytes of a binary LOB, starting from an absolute offset from the beginning of the LOB." unique-suffix="(lob_loc bytea, amount numeric, &quot;offset&quot; numeric)" routine-number="23341" is-returning-set="f" ret-datatype="bytea" function-arguments="lob_loc bytea, amount numeric DEFAULT 32767, &quot;offset&quot; numeric DEFAULT 1" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23341" volatility="IMMUTABLE" is-window="f" function-identity-arguments="lob_loc bytea, amount numeric, &quot;offset&quot; numeric" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_lob$substr(lob_loc bytea, amount numeric, &quot;offset&quot; numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount NUMERIC;
BEGIN
    -- Extracting integer part of amount
    v_amount := floor(amount);

    RETURN CASE
              WHEN (v_amount BETWEEN 1 AND 32767 AND
                    "offset" >= 1)
              THEN substr(lob_loc, floor("offset")::INTEGER, v_amount::INTEGER)
           END;
END;
]]></complex-attribute>
                        <category _I_D="f8d8c3d8-e3b9-4dcb-a40e-0157ab7ed00f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="91d787c9-7ceb-4485-b3f4-92f611900f57" name="dbms_lob$substr" is-trigger-function="0" unique-function-name="dbms_lob$substr(lob_loc text, amount numeric, &quot;offset&quot; numeric)" is-aggregate="f" language-name="plpgsql" context="dbms_lob$substr(lob_loc text, amount numeric, &quot;offset&quot; numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,numeric" comment="This function returns amount bytes or characters of a character LOB, starting from an absolute offset from the beginning of the LOB." unique-suffix="(lob_loc text, amount numeric, &quot;offset&quot; numeric)" routine-number="23340" is-returning-set="f" ret-datatype="text" function-arguments="lob_loc text, amount numeric DEFAULT 32767, &quot;offset&quot; numeric DEFAULT 1" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23340" volatility="IMMUTABLE" is-window="f" function-identity-arguments="lob_loc text, amount numeric, &quot;offset&quot; numeric" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_lob$substr(lob_loc text, amount numeric, &quot;offset&quot; numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount NUMERIC;
BEGIN
    -- Extracting integer part of amount
    v_amount := floor(amount);

    RETURN CASE
              WHEN (v_amount BETWEEN 1 AND 32767 AND
                    "offset" >= 1)
              THEN substr(lob_loc, floor("offset")::INTEGER, v_amount::INTEGER)
           END;
END;
]]></complex-attribute>
                        <category _I_D="65d5c40b-c7c5-4ff4-bc95-be24173b9e91" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="854a5c3c-6ee3-4892-b687-502e96755bbf" name="dbms_lob$transaction" is-trigger-function="0" unique-function-name="dbms_lob$transaction" is-aggregate="f" language-name="sql" context="dbms_lob$transaction" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.TRANSACTION package constant." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23356" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$transaction()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.TRANSACTION package constant
SELECT 11;
]]></complex-attribute>
                        <category _I_D="8c69eba7-7276-492e-a875-a020a76b639d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d2237f93-55cf-4c8e-b1d6-67590a2ae27c" name="dbms_lob$warn_inconvertible_char" is-trigger-function="0" unique-function-name="dbms_lob$warn_inconvertible_char" is-aggregate="f" language-name="sql" context="dbms_lob$warn_inconvertible_char" subcategories-loading="none" object-loading="extended" comment="This function returns the value of the DBMS_LOB.WARN_INCONVERTIBLE_CHAR package constant." is-returning-set="f" ret-datatype="numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23358" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lob$warn_inconvertible_char()">
                        <complex-attribute name="sql"><![CDATA[
-- DBMS_LOB.WARN_INCONVERTIBLE_CHAR package constant
SELECT 1;
]]></complex-attribute>
                        <category _I_D="2db443e1-8f8a-4320-9f9f-580c3c5c80cf" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e4c15bf4-24f8-4aa4-95ef-74d05ca71f2e" name="dbms_lock$allocate_unique" is-trigger-function="0" unique-function-name="dbms_lock$allocate_unique" is-aggregate="f" language-name="plpgsql" context="dbms_lock$allocate_unique" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying" comment="This procedure allocates a unique lock identifier given a lock name. Lock identifiers are used to enable applications to coordinate their use of locks." is-returning-set="f" ret-datatype="varchar" function-arguments="lockname character varying, INOUT lockhandle character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22307" volatility="VOLATILE" is-window="f" function-identity-arguments="lockname character varying, INOUT lockhandle character varying" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_lock$allocate_unique(lockname character varying, INOUT lockhandle character varying)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    lockhandle := lower(lockname);
END;
]]></complex-attribute>
                        <category _I_D="b716317c-a614-4556-883d-429cf99e4636" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="88676961-6aa5-4a0e-b30c-ef9aa06053d9" name="dbms_lock$constant" is-trigger-function="0" unique-function-name="dbms_lock$constant" is-aggregate="f" language-name="plpgsql" context="dbms_lock$constant" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="This function returns DBMS_LOCK constant value by its name." is-returning-set="f" ret-datatype="int4" function-arguments="p_const_name text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22306" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_const_name text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_lock$constant(p_const_name text)">
                        <complex-attribute name="sql"><![CDATA[
declare l_consts jsonb = json_build_object(
                                              -- DBMS_LOCK Constants - Lock mode
                                              'NL_MODE',1,
                                              'SS_MODE',2,
                                              'SX_MODE',3,
                                              'S_MODE',4,
                                              'SSX_MODE',5,
                                              'X_MODE',6,
                                              -- MAXWAIT
                                              'MAXWAIT',32767
                                          );
begin
	if l_consts ?  upper(p_const_name) then
		return (l_consts->>upper(p_const_name))::integer;
	else
		raise exception 'Unknown DBMS_LOCK constant: %', p_const_name;
	end if;
end ]]></complex-attribute>
                        <category _I_D="c697e263-dca8-4ea9-8d60-df6422a1483b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b090505b-2459-4e5e-9cc9-4f5ee02616a8" name="dbms_lock$init" is-trigger-function="0" unique-function-name="dbms_lock$init" is-aggregate="f" language-name="sql" context="dbms_lock$init" subcategories-loading="none" object-loading="extended" comment="This function initializes DBMS_LOCK package." is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22305" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_lock$init()">
                        <complex-attribute name="sql"><![CDATA[
    -- A stub function.
    select null::void;
]]></complex-attribute>
                        <category _I_D="de2ae265-0c77-4823-be07-712779f32bee" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="85f41754-d218-408d-8d84-b3823849335d" name="dbms_lock$release" is-trigger-function="0" unique-function-name="dbms_lock$release(id bigint)" is-aggregate="f" language-name="plpgsql" context="dbms_lock$release(id bigint)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bigint" comment="This function explicitly releases a lock previously acquired using the `aws_oracle_ext.dbms_lock$request` function." unique-suffix="(id bigint)" routine-number="22308" is-returning-set="f" ret-datatype="int8" function-arguments="id bigint" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22308" volatility="VOLATILE" is-window="f" function-identity-arguments="id bigint" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_lock$release(id bigint)">
                        <complex-attribute name="sql"><![CDATA[
declare
  l_unlock boolean := true;
  l_exit_code int;
BEGIN
    if aws_oracle_ext.get_package_variable('aws_oracle_ext', 'dbms_lock', concat('lockmode_',id))::INTEGER=6 /* lockmode: X_MODE = Exclusive */ then
      l_unlock := pg_advisory_unlock(id);
    else
      l_unlock := pg_advisory_unlock_shared(id);
    end if;

    l_exit_code := case when l_unlock then 0 -- Success
                        else 5 -- Illegal lock handle
                end;
    return l_exit_code;
END;
]]></complex-attribute>
                        <category _I_D="73c25372-17e3-4f52-9bfc-761473e2854d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="343fd205-b007-4234-9abd-4b1b74e60800" name="dbms_lock$release" is-trigger-function="0" unique-function-name="dbms_lock$release(lockhandle character varying)" is-aggregate="f" language-name="sql" context="dbms_lock$release(lockhandle character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" comment="This function explicitly releases a lock previously acquired using the `aws_oracle_ext.dbms_lock$request` function." unique-suffix="(lockhandle character varying)" routine-number="22309" is-returning-set="f" ret-datatype="int8" function-arguments="lockhandle character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22309" volatility="VOLATILE" is-window="f" function-identity-arguments="lockhandle character varying" overload-function-count="2" proc-language="sql" function-signature="dbms_lock$release(lockhandle character varying)">
                        <complex-attribute name="sql"><![CDATA[
    select aws_oracle_ext.dbms_lock$release(id => aws_oracle_ext.get_id_by_name(lockhandle::text));
]]></complex-attribute>
                        <category _I_D="197c77ca-7d88-4807-b9e2-62f72fc2289e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1226e474-08a8-4681-9dff-62a9fd1056a9" name="dbms_lock$request" is-trigger-function="0" unique-function-name="dbms_lock$request(id bigint, lockmode integer, timeout integer, release_on_commit boolean)" is-aggregate="f" language-name="plpgsql" context="dbms_lock$request(id bigint, lockmode integer, timeout integer, release_on_commit boolean)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bigint,integer,integer,boolean" comment="This function requests a lock with a given mode." unique-suffix="(id bigint, lockmode integer, timeout integer, release_on_commit boolean)" routine-number="22310" is-returning-set="f" ret-datatype="int8" function-arguments="id bigint, lockmode integer DEFAULT 6, timeout integer DEFAULT 32767, release_on_commit boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22310" volatility="VOLATILE" is-window="f" function-identity-arguments="id bigint, lockmode integer, timeout integer, release_on_commit boolean" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_lock$request(id bigint, lockmode integer, timeout integer, release_on_commit boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
  l_getlock boolean := true;
  l_result  int;
BEGIN
    /* lockmode is implemented only for values
     *   6 - Exclusive
     *   not 6 - Shared
     *
     * timeout is implemented only for values
     *   0 - no wait
     *   not 0 - wait untill free
     */
    perform aws_oracle_ext.set_package_variable('aws_oracle_ext', 'dbms_lock', concat('lockmode_', id), lockmode);

    case when not release_on_commit and lockmode = 6 and timeout = 0 then l_getlock := pg_try_advisory_lock(id);
         when not release_on_commit and lockmode = 6 and timeout != 0 then perform pg_advisory_lock(id);
         when not release_on_commit and lockmode != 6 and timeout = 0 then l_getlock := pg_try_advisory_lock_shared(id);
         when not release_on_commit and lockmode != 6 and timeout != 0 then perform pg_advisory_lock_shared(id);
         when release_on_commit and lockmode = 6 and timeout = 0 then l_getlock := pg_try_advisory_xact_lock(id);
         when release_on_commit and lockmode = 6 and timeout != 0 then perform pg_advisory_xact_lock(id);
         when release_on_commit and lockmode != 6 and timeout = 0 then l_getlock := pg_try_advisory_xact_lock_shared(id);
         when release_on_commit and lockmode != 6 and timeout != 0 then perform pg_advisory_xact_lock_shared(id);
         else l_getlock := false;
    end case;

    l_result := case when l_getlock then 0 -- Success
                     else 1 -- Timeout
                end;
    return l_result;
END;
]]></complex-attribute>
                        <category _I_D="e264b9b5-d1ef-4fbb-974c-8ff56d6de3d0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="151904d4-b0f7-4bd0-87ee-1ec9d50a9e07" name="dbms_lock$request" is-trigger-function="0" unique-function-name="dbms_lock$request(lockhandle character varying, lockmode integer, timeout integer, release_on_commit boolean)" is-aggregate="f" language-name="sql" context="dbms_lock$request(lockhandle character varying, lockmode integer, timeout integer, release_on_commit boolean)" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,integer,integer,boolean" comment="This function requests a lock with a given mode." unique-suffix="(lockhandle character varying, lockmode integer, timeout integer, release_on_commit boolean)" routine-number="22311" is-returning-set="f" ret-datatype="int8" function-arguments="lockhandle character varying, lockmode integer DEFAULT 6, timeout integer DEFAULT 32767, release_on_commit boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22311" volatility="VOLATILE" is-window="f" function-identity-arguments="lockhandle character varying, lockmode integer, timeout integer, release_on_commit boolean" overload-function-count="2" proc-language="sql" function-signature="dbms_lock$request(lockhandle character varying, lockmode integer, timeout integer, release_on_commit boolean)">
                        <complex-attribute name="sql"><![CDATA[
    select aws_oracle_ext.dbms_lock$request(id => aws_oracle_ext.get_id_by_name(lockhandle::text),
                                            lockmode => lockmode,
                                            timeout => timeout,
                                            release_on_commit => release_on_commit
                                            );
]]></complex-attribute>
                        <category _I_D="9f6250d2-1f74-48b0-b81d-9e47f2d65ec6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="25d1fcf0-1e95-46e1-9cbc-e1ba4c999328" name="dbms_obfuscation_toolkit$desdecrypt" is-trigger-function="0" unique-function-name="dbms_obfuscation_toolkit$desdecrypt(input bytea, key bytea)" is-aggregate="f" language-name="plpgsql" context="dbms_obfuscation_toolkit$desdecrypt(input bytea, key bytea)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea,bytea" comment="Generate the decrypted form of the input data" unique-suffix="(input bytea, key bytea)" routine-number="22313" is-returning-set="f" ret-datatype="bytea" function-arguments="input bytea, key bytea" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22313" volatility="VOLATILE" is-window="f" function-identity-arguments="input bytea, key bytea" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_obfuscation_toolkit$desdecrypt(input bytea, key bytea)">
                        <complex-attribute name="sql"><![CDATA[
  BEGIN
    return decrypt(input, key, 'des-cbc/pad:none');
  END;
]]></complex-attribute>
                        <category _I_D="f7dbaffd-59f8-4934-a0b6-e614976fe435" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dd858585-2adf-4808-828c-8f20d09ac57c" name="dbms_obfuscation_toolkit$desdecrypt" is-trigger-function="0" unique-function-name="dbms_obfuscation_toolkit$desdecrypt(input bytea, key bytea, INOUT decrypted_data bytea)" is-aggregate="f" language-name="plpgsql" context="dbms_obfuscation_toolkit$desdecrypt(input bytea, key bytea, INOUT decrypted_data bytea)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea,bytea,bytea" comment="Generate the decrypted form of the input data" unique-suffix="(input bytea, key bytea, INOUT decrypted_data bytea)" routine-number="22312" is-returning-set="f" ret-datatype="bytea" function-arguments="input bytea, key bytea, INOUT decrypted_data bytea" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22312" volatility="VOLATILE" is-window="f" function-identity-arguments="input bytea, key bytea, INOUT decrypted_data bytea" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_obfuscation_toolkit$desdecrypt(input bytea, key bytea, INOUT decrypted_data bytea)">
                        <complex-attribute name="sql"><![CDATA[
  BEGIN
    decrypted_data := decrypt(input, key, 'des-cbc/pad:none');
  END;
]]></complex-attribute>
                        <category _I_D="100c5b06-ecf7-4484-9de8-fe542cdf3a1f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3b810f20-15e8-4666-88cc-b43317735ff5" name="dbms_obfuscation_toolkit$desencrypt" is-trigger-function="0" unique-function-name="dbms_obfuscation_toolkit$desencrypt(input bytea, key bytea)" is-aggregate="f" language-name="plpgsql" context="dbms_obfuscation_toolkit$desencrypt(input bytea, key bytea)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea,bytea" comment="Generate the encrypted form of the input data" unique-suffix="(input bytea, key bytea)" routine-number="22315" is-returning-set="f" ret-datatype="bytea" function-arguments="input bytea, key bytea" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22315" volatility="VOLATILE" is-window="f" function-identity-arguments="input bytea, key bytea" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_obfuscation_toolkit$desencrypt(input bytea, key bytea)">
                        <complex-attribute name="sql"><![CDATA[
  BEGIN
    return encrypt(input, key, 'des-cbc/pad:none');
  END;
]]></complex-attribute>
                        <category _I_D="74731443-e3c2-4de9-8111-e2b1bff18820" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f0f9e836-b799-4f2f-b16a-d28f3c93b253" name="dbms_obfuscation_toolkit$desencrypt" is-trigger-function="0" unique-function-name="dbms_obfuscation_toolkit$desencrypt(input bytea, key bytea, INOUT encrypted_data bytea)" is-aggregate="f" language-name="plpgsql" context="dbms_obfuscation_toolkit$desencrypt(input bytea, key bytea, INOUT encrypted_data bytea)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea,bytea,bytea" comment="Generate the encrypted form of the input data" unique-suffix="(input bytea, key bytea, INOUT encrypted_data bytea)" routine-number="22314" is-returning-set="f" ret-datatype="bytea" function-arguments="input bytea, key bytea, INOUT encrypted_data bytea" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22314" volatility="VOLATILE" is-window="f" function-identity-arguments="input bytea, key bytea, INOUT encrypted_data bytea" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_obfuscation_toolkit$desencrypt(input bytea, key bytea, INOUT encrypted_data bytea)">
                        <complex-attribute name="sql"><![CDATA[
  BEGIN
    encrypted_data := encrypt(input, key, 'des-cbc/pad:none');
  END;
]]></complex-attribute>
                        <category _I_D="a345788f-a3c0-4849-96e9-f3c2c5c7069a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a0f53b31-aa13-4848-9dbe-cf7aa85d1555" name="dbms_obfuscation_toolkit$desgetkey" is-trigger-function="0" unique-function-name="dbms_obfuscation_toolkit$desgetkey(seed text)" is-aggregate="f" language-name="plpgsql" context="dbms_obfuscation_toolkit$desgetkey(seed text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="Take a value from seed and use it to generate an encryption key" unique-suffix="(seed text)" routine-number="22316" is-returning-set="f" ret-datatype="text" function-arguments="seed text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22316" volatility="VOLATILE" is-window="f" function-identity-arguments="seed text" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_obfuscation_toolkit$desgetkey(seed text)">
                        <complex-attribute name="sql"><![CDATA[
  BEGIN
    return crypt(seed, gen_salt('des'));
  END;
]]></complex-attribute>
                        <category _I_D="f782acbb-b96e-4318-bc8d-e12c3dbd37ad" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c2518647-44dc-4610-b915-5d58c1af8bd0" name="dbms_obfuscation_toolkit$desgetkey" is-trigger-function="0" unique-function-name="dbms_obfuscation_toolkit$desgetkey(seed text, INOUT key text)" is-aggregate="f" language-name="plpgsql" context="dbms_obfuscation_toolkit$desgetkey(seed text, INOUT key text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" comment="Take a value from seed and use it to generate an encryption key" unique-suffix="(seed text, INOUT key text)" routine-number="22317" is-returning-set="f" ret-datatype="text" function-arguments="seed text, INOUT key text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22317" volatility="VOLATILE" is-window="f" function-identity-arguments="seed text, INOUT key text" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_obfuscation_toolkit$desgetkey(seed text, INOUT key text)">
                        <complex-attribute name="sql"><![CDATA[
  BEGIN
    key := crypt(seed, gen_salt('des'));
  END;
]]></complex-attribute>
                        <category _I_D="8cfd117f-35a6-4c75-8f0c-a17c8fa7363a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="102a63ea-8ccb-445c-92af-c455fecc43fc" name="dbms_obfuscation_toolkit$md5" is-trigger-function="0" unique-function-name="dbms_obfuscation_toolkit$md5(input bytea)" is-aggregate="f" language-name="plpgsql" context="dbms_obfuscation_toolkit$md5(input bytea)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea" comment="Generate MD5 hashes of data" unique-suffix="(input bytea)" routine-number="22319" is-returning-set="f" ret-datatype="bytea" function-arguments="input bytea" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22319" volatility="VOLATILE" is-window="f" function-identity-arguments="input bytea" overload-function-count="4" proc-language="plpgsql" function-signature="dbms_obfuscation_toolkit$md5(input bytea)">
                        <complex-attribute name="sql"><![CDATA[
  BEGIN
    return md5(input);
  END;
]]></complex-attribute>
                        <category _I_D="52316818-c76d-4194-a8c8-7a51c5b636e2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="768ac738-cfe8-437e-8789-2ededb962ea7" name="dbms_obfuscation_toolkit$md5" is-trigger-function="0" unique-function-name="dbms_obfuscation_toolkit$md5(input bytea, INOUT checksum bytea)" is-aggregate="f" language-name="plpgsql" context="dbms_obfuscation_toolkit$md5(input bytea, INOUT checksum bytea)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea,bytea" comment="Generate MD5 hashes of data" unique-suffix="(input bytea, INOUT checksum bytea)" routine-number="22318" is-returning-set="f" ret-datatype="bytea" function-arguments="input bytea, INOUT checksum bytea" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22318" volatility="VOLATILE" is-window="f" function-identity-arguments="input bytea, INOUT checksum bytea" overload-function-count="4" proc-language="plpgsql" function-signature="dbms_obfuscation_toolkit$md5(input bytea, INOUT checksum bytea)">
                        <complex-attribute name="sql"><![CDATA[
  BEGIN
    checksum := md5(input);
  END;
]]></complex-attribute>
                        <category _I_D="8a058241-e299-49c5-abbb-c5c6fd36d00d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f82881ce-c2cf-4823-9bcf-8bb7c71ff140" name="dbms_obfuscation_toolkit$md5" is-trigger-function="0" unique-function-name="dbms_obfuscation_toolkit$md5(input_string text)" is-aggregate="f" language-name="plpgsql" context="dbms_obfuscation_toolkit$md5(input_string text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="Generate MD5 hashes of data" unique-suffix="(input_string text)" routine-number="22320" is-returning-set="f" ret-datatype="text" function-arguments="input_string text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22320" volatility="VOLATILE" is-window="f" function-identity-arguments="input_string text" overload-function-count="4" proc-language="plpgsql" function-signature="dbms_obfuscation_toolkit$md5(input_string text)">
                        <complex-attribute name="sql"><![CDATA[
  BEGIN
    return md5(input_string);
  END;
]]></complex-attribute>
                        <category _I_D="30271825-0cca-4386-84be-74bdd69519ee" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="067bc5dc-ba68-44ce-846c-a1c66a3e5911" name="dbms_obfuscation_toolkit$md5" is-trigger-function="0" unique-function-name="dbms_obfuscation_toolkit$md5(input_string text, INOUT checksum_string text)" is-aggregate="f" language-name="plpgsql" context="dbms_obfuscation_toolkit$md5(input_string text, INOUT checksum_string text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" comment="Generate MD5 hashes of data" unique-suffix="(input_string text, INOUT checksum_string text)" routine-number="22321" is-returning-set="f" ret-datatype="text" function-arguments="input_string text, INOUT checksum_string text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22321" volatility="VOLATILE" is-window="f" function-identity-arguments="input_string text, INOUT checksum_string text" overload-function-count="4" proc-language="plpgsql" function-signature="dbms_obfuscation_toolkit$md5(input_string text, INOUT checksum_string text)">
                        <complex-attribute name="sql"><![CDATA[
  BEGIN
    checksum_string := md5(input_string);
  END;
]]></complex-attribute>
                        <category _I_D="e7028613-1a16-40fd-9efd-c1682c9336b0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="76389906-2782-4cdc-bae4-98d873bc38f7" name="dbms_random$initialize" is-trigger-function="0" unique-function-name="dbms_random$initialize" is-aggregate="f" language-name="plpgsql" context="dbms_random$initialize" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" comment="This function initializes the random number generator with a seed value." is-returning-set="f" ret-datatype="void" function-arguments="p_seed numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22322" volatility="VOLATILE" is-window="f" function-identity-arguments="p_seed numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_random$initialize(p_seed numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    PERFORM aws_oracle_ext.dbms_random$seed(p_seed);
END;
]]></complex-attribute>
                        <category _I_D="2e690ca6-995e-47b8-9af1-8f3b578093d0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2ebd2030-9298-48bd-b24b-6e66643dacfc" name="dbms_random$normal" is-trigger-function="0" unique-function-name="dbms_random$normal" is-aggregate="f" language-name="plpgsql" context="dbms_random$normal" subcategories-loading="none" object-loading="extended" comment="This function returns random numbers in a standard normal distribution." is-returning-set="f" ret-datatype="float8" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22323" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_random$normal()">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_u DOUBLE PRECISION;
    v_v DOUBLE PRECISION;
    v_s DOUBLE PRECISION;
BEGIN
    LOOP
        -- Range -1.0 <= u | v < 1.0
        v_u = random() * 2 - 1;
        v_v = random() * 2 - 1;
        v_s = power(v_u, 2) + power(v_v, 2);

        CONTINUE WHEN NOT (v_s != 0 AND v_s < 1);
        RETURN sqrt(-2 * ln(v_s) / v_s) * v_u;
    END LOOP;
END;
]]></complex-attribute>
                        <category _I_D="9020c476-b6b3-420c-90df-359f03379197" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bcfcccbf-edda-4932-b431-15db604794ea" name="dbms_random$random" is-trigger-function="0" unique-function-name="dbms_random$random" is-aggregate="f" language-name="plpgsql" context="dbms_random$random" subcategories-loading="none" object-loading="extended" comment="This function generates and returns a random number. A random value greater than or equal to -power(2,31) and less than power(2,31)." is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22324" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_random$random()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN round((random() * 4294967296 - 2147483648)::NUMERIC, 0);
END;
]]></complex-attribute>
                        <category _I_D="d9a98829-09fa-4a0b-a21f-06d473c441f2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3406ed95-9e77-4df7-9c59-d8655bb1c283" name="dbms_random$seed" is-trigger-function="0" unique-function-name="dbms_random$seed(p_seed numeric)" is-aggregate="f" language-name="plpgsql" context="dbms_random$seed(p_seed numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" comment="This procedure resets the seed used in generating a random number." unique-suffix="(p_seed numeric)" routine-number="22325" is-returning-set="f" ret-datatype="void" function-arguments="p_seed numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22325" volatility="VOLATILE" is-window="f" function-identity-arguments="p_seed numeric" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_random$seed(p_seed numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_seedsign INTEGER := sign(p_seed);
    v_seedstr VARCHAR := rpad(to_char(abs(p_seed), 'FM9999999999'), 15, '0');
BEGIN
    PERFORM setseed(to_number(concat('0.', v_seedstr), '9.FM999999999999999999') * v_seedsign);
END;
]]></complex-attribute>
                        <category _I_D="af0ec186-61b9-45e4-8817-51d73f1613f8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="863fee9d-daad-463d-ad3c-6f7f03fe9a5c" name="dbms_random$seed" is-trigger-function="0" unique-function-name="dbms_random$seed(p_seed text)" is-aggregate="f" language-name="plpgsql" context="dbms_random$seed(p_seed text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="This procedure resets the seed used in generating a random number." unique-suffix="(p_seed text)" routine-number="22326" is-returning-set="f" ret-datatype="void" function-arguments="p_seed text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22326" volatility="VOLATILE" is-window="f" function-identity-arguments="p_seed text" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_random$seed(p_seed text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_seedstr TEXT := substring(translate(upper(md5(p_seed)), 'ABCDEF', '123456'), 1, 15);
BEGIN
    PERFORM setseed(to_number(concat('0.', v_seedstr), '9.FM999999999999999999'));
END;
]]></complex-attribute>
                        <category _I_D="cebc7a48-4fa5-43d6-a66f-5cc60333f0f0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e9f0c780-dc18-4b97-b0c7-a99d822092a1" name="dbms_random$string" is-trigger-function="0" unique-function-name="dbms_random$string(opt text, len double precision)" is-aggregate="f" language-name="plpgsql" context="dbms_random$string(opt text, len double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,double precision" comment="This function generates and returns a random string. You can specify what the returning string will look like, as well as the length (double precision) of the returned string." unique-suffix="(opt text, len double precision)" routine-number="22328" is-returning-set="f" ret-datatype="text" function-arguments="opt text, len double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22328" volatility="VOLATILE" is-window="f" function-identity-arguments="opt text, len double precision" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_random$string(opt text, len double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN aws_oracle_ext.dbms_random$string(opt => opt,
                                             len => len::NUMERIC);
END;
]]></complex-attribute>
                        <category _I_D="6a9ef99d-ef70-422f-8ac1-e94a3467ef70" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="161770d6-ab28-4a69-bb58-3b16d364881b" name="dbms_random$string" is-trigger-function="0" unique-function-name="dbms_random$string(opt text, len numeric)" is-aggregate="f" language-name="plpgsql" context="dbms_random$string(opt text, len numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric" comment="This function generates and returns a random string. You can specify what the returning string will look like, as well as the length (numeric) of the returned string." unique-suffix="(opt text, len numeric)" routine-number="22327" is-returning-set="f" ret-datatype="text" function-arguments="opt text, len numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22327" volatility="VOLATILE" is-window="f" function-identity-arguments="opt text, len numeric" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_random$string(opt text, len numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_ccs TEXT;
    v_res_val TEXT := '';
BEGIN
    IF (char_length(opt) > 1)
    THEN
        -- The string type to be generated (opt) must be less than or equal to one character.
        RAISE USING MESSAGE := 'Numeric or value error: character string buffer too small.',
                    DETAIL := 'The string type to be generated (opt) exceeds one character.',
                    HINT := '-6502';
    ELSIF (len IS NULL)
    THEN
        -- The length of the returned string (len) must not be null.
        RAISE USING MESSAGE := 'Numeric or value error.',
                    DETAIL := 'The length of the returned string (len) must not be null.',
                    HINT := '-6502';
    ELSIF (len::INTEGER < 1)
    THEN
        RETURN null;
    END IF;

    v_ccs := -- A subset of candidate characters to use as a source for generating random strings.
        CASE lower(opt)
           WHEN 'u' THEN 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' -- Upper case alpha characters only.
           WHEN 'l' THEN 'abcdefghijklmnopqrstuvwxyz' -- Lower case alpha characters only.
           WHEN 'a' THEN 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' -- Alpha characters only (mixed case).
           WHEN 'x' THEN '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' -- Any alpha-numeric characters (upper).
           WHEN 'p' THEN ' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~' -- Any printable char (ASCII subset).
           ELSE 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' -- Upper case alpha characters only (default).
        END;

    -- Generating random string of the specified length.
    FOR i IN 1..least(len, 4000)
    LOOP
        v_res_val := v_res_val || substring(v_ccs from (ceil(random() * char_length(v_ccs)))::INTEGER for 1);
    END LOOP;

    RETURN v_res_val;
END;
]]></complex-attribute>
                        <category _I_D="9589be21-b403-4391-b375-475d41e2e6f7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ee16eb0f-1871-445c-a854-e35072c0a6b1" name="dbms_random$terminate" is-trigger-function="0" unique-function-name="dbms_random$terminate" is-aggregate="f" language-name="plpgsql" context="dbms_random$terminate" subcategories-loading="none" object-loading="extended" comment="This function terminates the package. It should be invoked when the user is finished with the package." is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22329" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_random$terminate()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    PERFORM setseed(random());
END;
]]></complex-attribute>
                        <category _I_D="56b96b14-5927-475e-aab1-1622ac09753d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b7011373-0f2b-4c87-af0e-d0d269d64418" name="dbms_random$value" is-trigger-function="0" unique-function-name="dbms_random$value" is-aggregate="f" language-name="plpgsql" context="dbms_random$value" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,double precision" comment="The function generates a random number &quot;x&quot;, where &quot;x&quot; is greater than or equal to a specified lower limit and less than a specified higher limit." is-returning-set="f" ret-datatype="float8" function-arguments="p_start double precision DEFAULT 0, p_high double precision DEFAULT 1" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22330" volatility="VOLATILE" is-window="f" function-identity-arguments="p_start double precision, p_high double precision" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_random$value(p_start double precision, p_high double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    RETURN random() * (p_high - p_start) + p_start;
END;
]]></complex-attribute>
                        <category _I_D="4440e1f0-b08d-46eb-b8c5-aec8583de032" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7cc24923-1c66-4ed8-ae58-d290e1fa11a9" name="dbms_session$clear_all_context" is-trigger-function="0" unique-function-name="dbms_session$clear_all_context" is-aggregate="f" language-name="sql" context="dbms_session$clear_all_context" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="void" function-arguments="namespace character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22337" volatility="VOLATILE" is-window="f" function-identity-arguments="namespace character varying" overload-function-count="1" proc-language="sql" function-signature="dbms_session$clear_all_context(namespace character varying)">
                        <complex-attribute name="sql"><![CDATA[
  select aws_oracle_ext.dbms_session$clear_context($1);
]]></complex-attribute>
                        <category _I_D="d6d1d5d6-800d-49f4-b19b-90a97ca8c2fb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f654b17a-befa-467d-a2cd-3f54eab3ce4d" name="dbms_session$clear_context" is-trigger-function="0" unique-function-name="dbms_session$clear_context" is-aggregate="f" language-name="plpgsql" context="dbms_session$clear_context" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying" is-returning-set="f" ret-datatype="void" function-arguments="namespace character varying, client_id character varying DEFAULT NULL::character varying, attribute character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22336" volatility="VOLATILE" is-window="f" function-identity-arguments="namespace character varying, client_id character varying, attribute character varying" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_session$clear_context(namespace character varying, client_id character varying, attribute character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare
  l_namespace text;
  l_attribute text;
begin	
   l_namespace := aws_oracle_ext.format_identifier_case(namespace);
   l_attribute := aws_oracle_ext.format_identifier_case(attribute);
  
   if l_namespace is null then 
   		raise exception 'input value for argument namespace is not valid';    
   end if;
  
  if l_namespace = 'CLIENTCONTEXT' then
    raise exception 'CLIENTCONTEXT namespace will be cleared automatically in the end of the session. Can not be cleared manually';    
  end if;
  
  case aws_oracle_ext.get_context_type(l_namespace) 
    when 'ACCESSED GLOBALLY' then 
    	delete from aws_oracle_context.context_global cg
    	where cg.context_namespace = l_namespace
    	and coalesce(cg.cliend_id, '') = coalesce($2, '')
    	and cg.attribute_name = coalesce(l_attribute, cg.attribute_name);         		        	
    when 'ACCESSED LOCALLY' then 
    	delete from context_local where context_namespace = l_namespace and coalesce(attribute_name, '') = coalesce(l_attribute, '');
    else raise exception 'Unsupported context type';   
  end case;
 
end;
]]></complex-attribute>
                        <category _I_D="58143294-c853-4ba8-bac0-9d0bea5d5e70" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f2022d12-f250-4b58-b2f9-ae5379a3d342" name="dbms_session$clear_identifier" is-trigger-function="0" unique-function-name="dbms_session$clear_identifier" is-aggregate="f" language-name="plpgsql" context="dbms_session$clear_identifier" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22332" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_session$clear_identifier()">
                        <complex-attribute name="sql"><![CDATA[
begin
  perform aws_oracle_ext.set_extpack_variable
    (
	  variable_name => 'CLIENT_IDENTIFIER', 
	  variable_value => null::text
	);
END;
]]></complex-attribute>
                        <category _I_D="4a173378-9e1e-4a38-bb6e-e22fe9f89427" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="df7eb1ca-6ea9-4be1-9007-00745ba21e61" name="dbms_session$free_all_resources" is-trigger-function="0" unique-function-name="dbms_session$free_all_resources" is-aggregate="f" language-name="sql" context="dbms_session$free_all_resources" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23230" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_session$free_all_resources()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT 1::INTEGER;

]]></complex-attribute>
                        <category _I_D="9d9ff1f6-a9aa-41f7-8295-8f0629e2de6c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="77639100-8274-4c07-bc96-e3f86cee762e" name="dbms_session$is_role_enabled" is-trigger-function="0" unique-function-name="dbms_session$is_role_enabled" is-aggregate="f" language-name="plpgsql" context="dbms_session$is_role_enabled" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="bool" function-arguments="rolename character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22333" volatility="VOLATILE" is-window="f" function-identity-arguments="rolename character varying" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_session$is_role_enabled(rolename character varying)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  return exists (select 1 from information_schema.enabled_roles where role_name = rolename);
END;
]]></complex-attribute>
                        <category _I_D="eb6f8094-393a-46d2-b31e-e10d8ef45ec2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9ac375a4-7015-41c8-a516-65dd12d33944" name="dbms_session$is_session_alive" is-trigger-function="0" unique-function-name="dbms_session$is_session_alive" is-aggregate="f" language-name="plpgsql" context="dbms_session$is_session_alive" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer" is-returning-set="f" ret-datatype="bool" function-arguments="uniqueid integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22334" volatility="VOLATILE" is-window="f" function-identity-arguments="uniqueid integer" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_session$is_session_alive(uniqueid integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  return ((select state from pg_stat_activity where pid = uniqueid) = 'active'::text);
END;
]]></complex-attribute>
                        <category _I_D="f3dc1fd4-38cc-401d-b540-154d80e81394" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="66a33aaf-1867-4254-afcf-13f08c4ac93a" name="dbms_session$reinitialize" is-trigger-function="0" unique-function-name="dbms_session$reinitialize" is-aggregate="f" language-name="sql" context="dbms_session$reinitialize" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23231" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_session$reinitialize()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT 2::INTEGER;

]]></complex-attribute>
                        <category _I_D="5b53f84b-d692-45dc-adca-a8feaee4a7a2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="67ea46a5-313d-4bdd-b4f1-048f0b730fc9" name="dbms_session$set_context" is-trigger-function="0" unique-function-name="dbms_session$set_context" is-aggregate="f" language-name="plpgsql" context="dbms_session$set_context" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying,character varying,character varying" is-returning-set="f" ret-datatype="void" function-arguments="namespace character varying, attribute character varying, value character varying, username character varying DEFAULT NULL::character varying, client_id character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22997" volatility="VOLATILE" is-window="f" function-identity-arguments="namespace character varying, attribute character varying, value character varying, username character varying, client_id character varying" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_session$set_context(namespace character varying, attribute character varying, value character varying, username character varying, client_id character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  l_key text;
  l_context_type text; 
  l_crypted text;
  l_interval text;
  l_namespace text;
  l_attribute text;
BEGIN
  if namespace is null or attribute is null then 
    raise exception 'invalid input values';  
  end if; 
  
  
  l_namespace := aws_oracle_ext.format_identifier_case(namespace);
  l_attribute := aws_oracle_ext.format_identifier_case(attribute);
  
  if l_namespace = 'CLIENTCONTEXT' then 
    perform  aws_oracle_ext.set_extpack_variable
                                (
                                 variable_name => l_namespace||'_'||l_attribute, 
                                 variable_value => value
                                );
  else 
   	perform aws_oracle_ext.init_context_struct();  
    l_key := aws_oracle_ext.get_context_param('key');  
    l_context_type := aws_oracle_ext.get_context_type(l_namespace);   
    l_crypted := crypt(value || ':' || l_key, gen_salt('bf'));   
 	
   	
   	case upper(l_context_type) 
	  	when 'ACCESSED LOCALLY' then 
	  		begin
				insert into context_local(
				  context_namespace, 
				  attribute_name, 
				  attribute_value, 
				  user_name, 
				  cliend_id, 
				  signature
				)
				values (
				  l_namespace, 
				  l_attribute, 
				  $3, 
				  $4, 
				  coalesce($5, aws_oracle_ext.sys_context_userenv('CLIENT_IDENTIFIER')), 
				  l_crypted
				) 
				on conflict (context_namespace, attribute_name) do 
				update set 
					attribute_value = excluded.attribute_value,
					signature = excluded.signature;
		  	end;
	  	when 'ACCESSED GLOBALLY' then	  
	  		begin
					
				delete from aws_oracle_context.context_global 
			    where backend_start <= now()::timestamp - (coalesce(aws_oracle_ext.get_context_param('auto_clean_interval'), '1 day'))::interval;

				insert into aws_oracle_context.context_global(
				  context_namespace, 
				  attribute_name, 
				  attribute_value, 
				  user_name, 
				  cliend_id, 
				  signature
				)
				values (
				  l_namespace, 
				  l_attribute, 
				  $3, 
				  $4, 
				  coalesce($5, aws_oracle_ext.sys_context_userenv('CLIENT_IDENTIFIER')), 
				  l_crypted
				) 
				on conflict (context_namespace, attribute_name, cliend_id) do 
				update set 
					attribute_value = excluded.attribute_value,
					signature = excluded.signature;
		  	end;  
	  	else 
			-- INITIALIZED EXTERNALLY, INITIALIZED GLOBALLY  	
	  		raise exception 'unsupported context type: %', l_context_type;
	  end case;    
  end if;
 
  exception 
    when no_data_found then raise exception 'Context % is not found', l_namespace;  
END;
]]></complex-attribute>
                        <category _I_D="0982836a-2747-458c-b29a-702e0954a158" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d17c9389-bcbb-42ce-a325-96f9fe53a104" name="dbms_session$set_identifier" is-trigger-function="0" unique-function-name="dbms_session$set_identifier" is-aggregate="f" language-name="plpgsql" context="dbms_session$set_identifier" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="void" function-arguments="client_id character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22331" volatility="VOLATILE" is-window="f" function-identity-arguments="client_id character varying" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_session$set_identifier(client_id character varying)">
                        <complex-attribute name="sql"><![CDATA[
begin
  perform  aws_oracle_ext.set_extpack_variable
   (
      variable_name => 'CLIENT_IDENTIFIER', 
      variable_value => client_id
   ); 
END;
]]></complex-attribute>
                        <category _I_D="1096ef6f-1660-4d59-b3b4-74998f670738" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9b5ce5d2-4d9a-45b7-a5f9-c82d65ab0091" name="dbms_session$set_nls" is-trigger-function="0" unique-function-name="dbms_session$set_nls" is-aggregate="f" language-name="plpgsql" context="dbms_session$set_nls" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying" is-returning-set="f" ret-datatype="void" function-arguments="param character varying, val character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22335" volatility="VOLATILE" is-window="f" function-identity-arguments="param character varying, val character varying" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_session$set_nls(param character varying, val character varying)">
                        <complex-attribute name="sql"><![CDATA[
begin
  perform  aws_oracle_ext.set_extpack_variable
   (
      variable_name => upper(param), 
      variable_value => val
   ); 
	
	
  if upper(param) = 'NLS_LANGUAGE' then
   
    perform  aws_oracle_ext.set_extpack_variable
     (
        variable_name => 'NLS_DATE_LANGUAGE', 
        variable_value => val
     );    

    
    perform  aws_oracle_ext.set_extpack_variable
     (
        variable_name => 'NLS_SORT', 
        variable_value => val
     );    
    
  end if;
END;
]]></complex-attribute>
                        <category _I_D="9d7cd174-5c0d-4139-bf5f-9e4b2ab3ca2f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="49b5f828-6378-49ee-b19d-387311f40a1a" name="dbms_sql$bind_variable" is-trigger-function="0" unique-function-name="dbms_sql$bind_variable" is-aggregate="f" language-name="plpgsql" context="dbms_sql$bind_variable" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,text,anyelement,integer,boolean" comment="This function binds a given value to a given variable in a cursor, based on the name or list of placeholders, of the variable in the statement." is-returning-set="f" ret-datatype="void" function-arguments="p_cursor_id integer, p_var_name text, p_var_value anyelement, p_value_size integer DEFAULT NULL::integer, p_check_var_exists boolean DEFAULT true" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22345" volatility="VOLATILE" is-window="f" function-identity-arguments="p_cursor_id integer, p_var_name text, p_var_value anyelement, p_value_size integer, p_check_var_exists boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$bind_variable(p_cursor_id integer, p_var_name text, p_var_value anyelement, p_value_size integer, p_check_var_exists boolean)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_var_pos INTEGER;
    v_var_info TEXT[];
    v_chr_val TEXT;
    v_num_val NUMERIC;
    v_dprec_val DOUBLE PRECISION;
    v_money_val MONEY;
    v_tstamp_val TIMESTAMP WITHOUT TIME ZONE;
    v_tstamptz_val TIMESTAMP WITH TIME ZONE;
    v_timetz_val TIME WITH TIME ZONE;
    v_interval_val INTERVAL;
    v_bool_val BOOLEAN;
    v_xml_val XML;
    v_bin_val BYTEA;
    v_var_size INTEGER;
    v_value_size INTEGER;
    v_is_fixed SMALLINT;
    v_sql_statement TEXT;
    v_cur_metadata JSONB;
    v_out_var_base_t TEXT;
    v_out_var_data_t TEXT;
    v_current_user_oid BIGINT;
BEGIN
    -- Checking that cursor is opened (exit if it is not)
    IF (NOT aws_oracle_ext.dbms_sql$is_open(p_cursor_id))
    THEN
        RAISE invalid_cursor_state;
    -- Variable name should not be empty or blank (null)
    ELSIF (NOT p_check_var_exists AND
           nullif(trim(p_var_name), '') IS NULL)
    THEN
        RAISE null_value_not_allowed;
    END IF;

    -- Obtaining current user OID
    v_current_user_oid := aws_oracle_ext.get_user_oid_by_name(current_user);

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    /* Checking that effective user OID (current_user) of the caller on this cursor is the same
       as that of the caller of the most recent parse operation on this cursor.
       Actual for cursors opened with security level 1 or 2 */
    IF ((v_cur_metadata ->> 'security_level')::SMALLINT IN (1, 2) AND
        (v_cur_metadata ->> 'parse_user_oid')::BIGINT != v_current_user_oid)
    THEN
        RAISE invalid_role_specification;
    END IF;

    BEGIN
        -- Getting SQL-PL/pgSQL statement by cursor id
        SELECT sql_statement
          INTO v_sql_statement
          FROM dbms_sql$cursor
         WHERE cursor_id = p_cursor_id;
    EXCEPTION
        WHEN insufficient_privilege THEN
            -- Effective userid changed
            RAISE invalid_cursor_state;
    END;

    -- Checking whether statement parsed
    IF (v_sql_statement IS NULL) THEN
        RAISE sql_statement_not_yet_complete;
    END IF;

    -- Extracting variable info (label in statement code and general name) from supplied string
    v_var_info := regexp_matches(p_var_name, '^((?:\s*\$\d+\s*(?:[\|,;\-_])?)+)*\s*[\:|\|]?([[:alnum:]_]+)\s*$', 'gi');
    v_var_info[1] := regexp_replace(regexp_replace(v_var_info[1], '\s*[\|,;\-_]\s*', '|', 'g'), '^\s*|\s*[\|,;\-_]$', '', 'gi');

    /* Checking that variable, either by name or any of its markers,
       exists in the corresponding SQL statement */
    IF ((v_var_info[2] IS NULL OR
         v_sql_statement !~* coalesce(v_var_info[2], '')) AND
        coalesce(p_check_var_exists, true)) -- variable name
    THEN
        IF (v_var_info[1] IS NULL OR
            v_sql_statement !~* replace(concat('(', v_var_info[1], ')(?!\d)'), '$', '\$')) -- markers list
        THEN
            RAISE null_value_not_allowed;
        END IF;
    END IF;

    v_out_var_data_t := upper(pg_typeof(p_var_value)::TEXT);

    -- Determining base data type of passed variable
    v_out_var_base_t := aws_oracle_ext.get_base_type_by_dtype(v_out_var_data_t);

    CASE v_out_var_base_t
       WHEN 'TEXT' THEN
           v_chr_val := p_var_value::TEXT;
           v_var_size := coalesce(length(p_var_value::BYTEA, pg_client_encoding()), 0);
           v_value_size := coalesce(p_value_size, v_var_size);
       WHEN 'NUMERIC' THEN
           v_num_val := p_var_value::NUMERIC;
       WHEN 'DOUBLE PRECISION' THEN
           v_dprec_val := p_var_value::DOUBLE PRECISION;
       WHEN 'MONEY' THEN
           v_money_val := p_var_value;
       WHEN 'TIMESTAMP WITHOUT TIME ZONE' THEN
           IF (v_out_var_data_t = 'TIME WITHOUT TIME ZONE') THEN
               v_tstamp_val := to_char(p_var_value, '2001-01-01 hh24:mi:ss.us')::TIMESTAMP;
           ELSE
               v_tstamp_val := p_var_value;
           END IF;
       WHEN 'TIMESTAMP WITH TIME ZONE' THEN
           v_tstamptz_val := p_var_value;
       WHEN 'TIME WITH TIME ZONE' THEN
           v_timetz_val := p_var_value;
       WHEN 'INTERVAL' THEN
           v_interval_val := p_var_value;
       WHEN 'BOOLEAN' THEN
           v_bool_val := p_var_value;
       WHEN 'XML' THEN
           v_xml_val := p_var_value;
       WHEN 'BYTEA' THEN
           v_bin_val := p_var_value;
           v_var_size := coalesce(octet_length(p_var_value), 0);
           v_value_size := p_value_size;
       ELSE RETURN;
    END CASE;

    -- Determining next variable position
    SELECT coalesce(MAX(var_pos), 0) + 1
      INTO v_var_pos
      FROM dbms_sql$bind_variable
     WHERE cursor_id = p_cursor_id;

    -- Binding variable to cursor (identified by cursor_id)
    INSERT INTO dbms_sql$bind_variable (cursor_id,
                                        var_pos,
                                        var_name,
                                        var_label,
                                        data_type,
                                        base_type,
                                        var_size,
                                        value_size,
                                        is_fixed,
                                        chr_val,
                                        num_val,
                                        dprec_val,
                                        money_val,
                                        tstamp_val,
                                        tstamptz_val,
                                        timetz_val,
                                        interval_val,
                                        bool_val,
                                        xml_val,
                                        bin_val)
         VALUES (p_cursor_id,
                 v_var_pos,
                 v_var_info[2], -- Variable name
                 v_var_info[1], -- Variable label list
                 v_out_var_data_t,
                 v_out_var_base_t,
                 v_var_size,
                 v_value_size,
                 v_is_fixed,
                 v_chr_val,
                 v_num_val,
                 v_dprec_val,
                 v_money_val,
                 v_tstamp_val,
                 v_tstamptz_val,
                 v_timetz_val,
                 v_interval_val,
                 v_bool_val,
                 v_xml_val,
                 v_bin_val)
    ON CONFLICT (cursor_id, var_name)
    DO UPDATE SET var_label = v_var_info[1],
                  data_type = v_out_var_data_t,
                  base_type = v_out_var_base_t,
                  var_size = v_var_size,
                  value_size = v_value_size,
                  is_fixed = v_is_fixed,
                  chr_val = v_chr_val,
                  num_val = v_num_val,
                  dprec_val = v_dprec_val,
                  money_val = v_money_val,
                  tstamp_val = v_tstamp_val,
                  tstamptz_val = v_tstamptz_val,
                  timetz_val = v_timetz_val,
                  interval_val = v_interval_val,
                  bool_val = v_bool_val,
                  xml_val = v_xml_val,
                  bin_val = v_bin_val;
EXCEPTION
    -- Cursor is not opened or does not exist
    WHEN invalid_cursor_state THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';

    -- Bind variable does not exist
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Bind variable does not exist.',
                    DETAIL := 'Call for a bind variable that was not listed in the corresponding SQL statement.',
                    HINT := '-1006';

    -- No statement previously parsed
    WHEN sql_statement_not_yet_complete THEN
        RAISE USING MESSAGE := 'No statement parsed.',
                    DETAIL := 'Attempting to reference a cursor with the SQL statement associated not parsed.',
                    HINT := '-1003';

    -- Effective userid (OID) changed since cursor parse
    WHEN invalid_role_specification THEN
        RAISE USING MESSAGE := 'Effective userid is not the same as when cursor was parsed.',
                    DETAIL := 'The effective userid on this call to DBMS_SQL is not the same as that at the time the cursor was parsed.',
                    HINT := '-29470';
END;
]]></complex-attribute>
                        <category _I_D="51f1da8e-0ca2-4af1-bbb9-627b9a07b9ca" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3212e19c-dc44-4f3c-b605-1d69da1ba797" name="dbms_sql$bind_variable_char" is-trigger-function="0" unique-function-name="dbms_sql$bind_variable_char" is-aggregate="f" language-name="plpgsql" context="dbms_sql$bind_variable_char" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,text,anyelement,integer,boolean" comment="This function binds a given CHAR value to a given variable in a cursor, based on the name or list of placeholders, of the variable in the statement." is-returning-set="f" ret-datatype="void" function-arguments="p_cursor_id integer, p_var_name text, p_var_value anyelement, p_value_size integer DEFAULT NULL::integer, p_check_var_exists boolean DEFAULT true" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22343" volatility="VOLATILE" is-window="f" function-identity-arguments="p_cursor_id integer, p_var_name text, p_var_value anyelement, p_value_size integer, p_check_var_exists boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$bind_variable_char(p_cursor_id integer, p_var_name text, p_var_value anyelement, p_value_size integer, p_check_var_exists boolean)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_var_pos INTEGER;
    v_var_info TEXT[];
    v_chr_val TEXT;
    v_var_size INTEGER;
    v_value_size INTEGER;
    v_datetime_mask TEXT;
    v_out_var_data_t TEXT;
    v_sql_statement TEXT;
    v_cur_metadata JSONB;
    v_is_fixed SMALLINT := 1;
    v_current_user_oid BIGINT;
    v_bind_var_base_t TEXT := 'TEXT';
    v_bind_var_data_t TEXT := 'CHARACTER VARYING';
BEGIN
    -- Checking that cursor is opened (exit if it is not)
    IF (NOT aws_oracle_ext.dbms_sql$is_open(p_cursor_id))
    THEN
        RAISE invalid_cursor_state;
    -- Variable name should not be empty or blank (null)
    ELSIF (NOT p_check_var_exists AND
           nullif(trim(p_var_name), '') IS NULL)
    THEN
        RAISE null_value_not_allowed;
    END IF;

    -- Obtaining current user OID
    v_current_user_oid := aws_oracle_ext.get_user_oid_by_name(current_user);

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    /* Checking that effective user OID (current_user) of the caller on this cursor is the same
       as that of the caller of the most recent parse operation on this cursor.
       Actual for cursors opened with security level 1 or 2 */
    IF ((v_cur_metadata ->> 'security_level')::SMALLINT IN (1, 2) AND
        (v_cur_metadata ->> 'parse_user_oid')::BIGINT != v_current_user_oid)
    THEN
        RAISE invalid_role_specification;
    END IF;

    BEGIN
        -- Getting SQL-PL/pgSQL statement by cursor id
        SELECT sql_statement
          INTO v_sql_statement
          FROM dbms_sql$cursor
         WHERE cursor_id = p_cursor_id;
    EXCEPTION
        WHEN insufficient_privilege THEN
            -- Effective userid changed
            RAISE invalid_cursor_state;
    END;

    -- Checking whether statement parsed
    IF (v_sql_statement IS NULL) THEN
        RAISE sql_statement_not_yet_complete;
    END IF;

    -- Extracting variable info (label in statement code and general name) from supplied string
    v_var_info := regexp_matches(p_var_name, '^((?:\s*\$\d+\s*(?:[\|,;\-_])?)+)*\s*[\:|\|]?([[:alnum:]_]+)\s*$', 'gi');
    v_var_info[1] := regexp_replace(regexp_replace(v_var_info[1], '\s*[\|,;\-_]\s*', '|', 'g'), '^\s*|\s*[\|,;\-_]$', '', 'gi');

    /* Checking that variable, either by name or any of its markers,
       exists in the corresponding SQL statement */
    IF ((v_var_info[2] IS NULL OR
         v_sql_statement !~* coalesce(v_var_info[2], '')) AND
        coalesce(p_check_var_exists, true)) -- variable name
    THEN
        IF (v_var_info[1] IS NULL OR
            v_sql_statement !~* replace(concat('(', v_var_info[1], ')(?!\d)'), '$', '\$')) -- markers list
        THEN
            RAISE null_value_not_allowed;
        END IF;
    END IF;

    v_out_var_data_t := upper(pg_typeof(p_var_value)::TEXT);

    -- Casting input value to a character string
    IF (v_out_var_data_t IN ('TEXT',
                             'CHARACTER',
                             'CHARACTER VARYING'))
    THEN
        v_bind_var_data_t := v_out_var_data_t;
        v_chr_val := p_var_value::TEXT;
        v_var_size := coalesce(length(p_var_value::BYTEA, pg_client_encoding()), 0);
    ELSIF (v_out_var_data_t IN ('XML',
                                'MONEY',
                                'REAL',
                                'BIGINT',
                                'INTEGER',
                                'NUMERIC',
                                'SMALLINT',
                                'INTERVAL',
                                'DOUBLE PRECISION',
                                'TIME WITH TIME ZONE'))
    THEN
        v_chr_val := p_var_value::TEXT;
    ELSIF (v_out_var_data_t = 'BOOLEAN')
    THEN
        v_chr_val := upper(p_var_value::TEXT);
    ELSIF (v_out_var_data_t IN ('DATE',
                                'TIME WITHOUT TIME ZONE',
                                'TIMESTAMP WITHOUT TIME ZONE',
                                'TIMESTAMP WITH TIME ZONE'))
    THEN
        -- Picking up the right datetime mask
        v_datetime_mask := CASE v_out_var_data_t
                              WHEN 'DATE' THEN 'dd-MON-yy'
                              WHEN 'TIME WITHOUT TIME ZONE' THEN 'hh24:mi:ss.us AM'
                              WHEN 'TIMESTAMP WITHOUT TIME ZONE' THEN 'dd-MON-yy hh24:mi:ss.us AM'
                              ELSE 'dd-MON-yy hh24:mi:ss.us AM OF:00'
                           END;

        v_chr_val := to_char(p_var_value, v_datetime_mask);
    ELSIF (v_out_var_data_t = 'BYTEA')
    THEN
        v_bind_var_data_t := 'TEXT';
        v_chr_val := upper(encode(p_var_value, 'hex'));
    ELSE RETURN;
    END IF;

    v_var_size := coalesce(v_var_size, coalesce(char_length(v_chr_val), 0));

    -- Determining next variable position
    SELECT coalesce(MAX(var_pos), 0) + 1
      INTO v_var_pos
      FROM dbms_sql$bind_variable
     WHERE cursor_id = p_cursor_id;

    -- Binding variable to cursor (identified by cursor_id)
    INSERT INTO dbms_sql$bind_variable (cursor_id,
                                        var_pos,
                                        var_name,
                                        var_label,
                                        data_type,
                                        base_type,
                                        var_size,
                                        value_size,
                                        is_fixed,
                                        chr_val)
         VALUES (p_cursor_id,
                 v_var_pos,
                 v_var_info[2], -- Variable name
                 v_var_info[1], -- Variable label list
                 v_bind_var_data_t,
                 v_bind_var_base_t,
                 v_var_size,
                 p_value_size,
                 v_is_fixed,
                 v_chr_val)
    ON CONFLICT (cursor_id, var_name)
    DO UPDATE SET var_label = v_var_info[1],
                  data_type = v_bind_var_data_t,
                  base_type = v_bind_var_base_t,
                  value_size = p_value_size,
                  is_fixed = v_is_fixed,
                  chr_val = v_chr_val;
EXCEPTION
    -- Cursor is not opened or does not exist
    WHEN invalid_cursor_state THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';

    -- Bind variable does not exist
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Bind variable does not exist.',
                    DETAIL := 'Call for a bind variable that was not listed in the corresponding SQL statement.',
                    HINT := '-1006';

    -- No statement previously parsed
    WHEN sql_statement_not_yet_complete THEN
        RAISE USING MESSAGE := 'No statement parsed.',
                    DETAIL := 'Attempting to reference a cursor with the SQL statement associated not parsed.',
                    HINT := '-1003';

    -- Effective userid (OID) changed since cursor parse
    WHEN invalid_role_specification THEN
        RAISE USING MESSAGE := 'Effective userid is not the same as when cursor was parsed.',
                    DETAIL := 'The effective userid on this call to DBMS_SQL is not the same as that at the time the cursor was parsed.',
                    HINT := '-29470';
END;
]]></complex-attribute>
                        <category _I_D="a6d4f8f6-edcb-44a4-8cb1-abfba8794552" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="efafe5cb-7ab2-4aba-9877-7c1b8271ee74" name="dbms_sql$close_cursor" is-trigger-function="0" unique-function-name="dbms_sql$close_cursor" is-aggregate="f" language-name="plpgsql" context="dbms_sql$close_cursor" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" comment="The procedure closes a given cursor. The memory allocated to the cursor is released and one can no longer fetch from that cursor." is-returning-set="f" ret-datatype="numeric" function-arguments="INOUT p_cursor_id numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22347" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT p_cursor_id numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$close_cursor(INOUT p_cursor_id numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_cursor_id INTEGER := p_cursor_id;
BEGIN
    /* Close DBMS_SQL cursor only if it is opened.
       This prevents a secondary exception raising when trying
       to close DBMS_SQL cursor in EXCEPTION section.
    */
    IF (aws_oracle_ext.dbms_sql$is_open(v_cursor_id))
    THEN
        -- Deleting related data from all temp tables
        DELETE FROM dbms_sql$cursor
              WHERE cursor_id = v_cursor_id;

        -- Nulling cursor metadata (JSON) object
        PERFORM set_config(format('sct$dbms_sql.cursor_id_%s_metadata', v_cursor_id), null, false);

        -- Setting `last_affected_cursor_id` variable
        PERFORM set_config('sct$dbms_sql.last_affected_cursor_id', v_cursor_id::TEXT, false);

        -- Nulling `last_row_count` variable
        PERFORM set_config('sct$dbms_sql.last_row_count', null, false);
    END IF;

    p_cursor_id := null;
EXCEPTION
    -- Effective userid (OID) changed since solution initialization
    WHEN insufficient_privilege THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';
END;
]]></complex-attribute>
                        <category _I_D="9a15ba0e-f3fe-4273-b58d-6dfb348d0a9f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8413066a-de33-44e2-9cc0-da8778591be0" name="dbms_sql$column_value" is-trigger-function="0" unique-function-name="dbms_sql$column_value" is-aggregate="f" language-name="plpgsql" context="dbms_sql$column_value" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer,anyelement,numeric,numeric,numeric" comment="This procedure returns the value of the cursor element for a given position in a given cursor. This procedure is used to access the data fetched by calling `dbms_sql$fetch_rows` function." is-returning-set="f" ret-datatype="record" function-arguments="p_cursor_id integer, p_column_pos integer, INOUT p_column_val anyelement, INOUT p_column_err numeric DEFAULT NULL::numeric, INOUT p_actual_len numeric DEFAULT NULL::numeric, INOUT p_typvar_len numeric DEFAULT NULL::numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22352" volatility="STABLE" is-window="f" function-identity-arguments="p_cursor_id integer, p_column_pos integer, INOUT p_column_val anyelement, INOUT p_column_err numeric, INOUT p_actual_len numeric, INOUT p_typvar_len numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$column_value(p_cursor_id integer, p_column_pos integer, INOUT p_column_val anyelement, INOUT p_column_err numeric, INOUT p_actual_len numeric, INOUT p_typvar_len numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_chr_val TEXT;
    v_num_val NUMERIC;
    v_dprec_val DOUBLE PRECISION;
    v_money_val MONEY;
    v_tstamp_val TIMESTAMP WITHOUT TIME ZONE;
    v_tstamptz_val TIMESTAMP WITH TIME ZONE;
    v_timetz_val TIME WITH TIME ZONE;
    v_interval_val INTERVAL;
    v_bool_val BOOLEAN;
    v_xml_val XML;
    v_bin_val BYTEA;
    v_col_size INTEGER;
    v_defcol_data JSONB;
    v_curcol_data JSONB;
    v_cur_metadata JSONB;
    v_curcol_data_t TEXT;
    v_curcol_base_t TEXT;
    v_defcol_data_t TEXT;
    v_defcol_base_t TEXT;
    v_out_var_base_t TEXT;
    v_out_var_data_t TEXT;
    v_current_user_oid BIGINT;
BEGIN
    -- Checking that cursor is opened (exit if it is not)
    IF (NOT aws_oracle_ext.dbms_sql$is_open(p_cursor_id)) THEN
        RAISE invalid_cursor_state;
    END IF;

    -- Obtaining current user OID
    v_current_user_oid := aws_oracle_ext.get_user_oid_by_name(current_user);

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    /* Checking that effective user OID (current_user) of the caller on this cursor is the same
       as that of the caller of the most recent parse operation on this cursor.
       Actual for cursors opened with security level 2 */
    IF ((v_cur_metadata ->> 'security_level')::SMALLINT = 2 AND
        (v_cur_metadata ->> 'parse_user_oid')::BIGINT != v_current_user_oid)
    THEN
        RAISE invalid_role_specification;
    END IF;

    -- Getting dynamic SQL statement defined and actual columns info (JSON)
    v_defcol_data := (v_cur_metadata #> format('{defcols_data, col_%s}', p_column_pos)::TEXT[]);
    v_curcol_data := (v_cur_metadata #> format('{curcols_data, col_%s}', p_column_pos)::TEXT[]);

    v_defcol_data_t := (v_defcol_data ->> 'data_type'); -- Column (defined) data type
    v_defcol_base_t := (v_defcol_data ->> 'base_type'); -- Column (defined) base data type
    v_curcol_data_t := (v_curcol_data ->> 'data_type'); -- Column (actual) data type
    v_curcol_base_t := (v_curcol_data ->> 'base_type'); -- Column (actual) base data type

    v_col_size := (v_defcol_data ->> 'col_size'); -- Column size in characters

    v_out_var_data_t := upper(pg_typeof(p_column_val)::TEXT);

    -- Determining base data type of passed variable
    v_out_var_base_t := aws_oracle_ext.get_base_type_by_dtype(v_out_var_data_t);

    -- Default vars states
    p_column_val := null;
    p_column_err := 0;
    p_actual_len := 0;
    p_typvar_len := 0;

    -- Column position should be declared in SELECT list
    IF (v_defcol_base_t IS NULL) THEN
        RAISE null_value_not_allowed;
    -- Check if OUT argument base type matches declared column base type (with some exclusions)
    ELSIF ((substring(v_out_var_base_t, 1, 14) != substring(v_defcol_base_t, 1, 14) AND -- TIMESTAMPs
            substring(v_out_var_base_t, 1, 5) != substring(v_defcol_base_t, 1, 5) AND -- TIMEs
            (substring(v_out_var_data_t, 1, 5) != 'TIME ' AND
             substring(v_defcol_data_t, 1, 10) != 'TIMESTAMP ') AND
            NOT (v_defcol_base_t IN ('NUMERIC',
                                     'DOUBLE PRECISION') AND
                 v_out_var_base_t IN ('NUMERIC',
                                      'DOUBLE PRECISION'))) OR
           (substring(v_defcol_data_t, 1, 5) = 'TIME ' AND
            (substring(v_out_var_data_t, 1, 10) = 'TIMESTAMP ' OR
             v_out_var_data_t = 'DATE')))
    THEN
        RAISE datatype_mismatch;
    -- Variable should not be declared using `dbms_sql$define_column_char`
    ELSIF ((v_defcol_data ->> 'is_fixed')::SMALLINT = 1) THEN
        RAISE datatype_mismatch;
    -- If current row not specified, then nothing to return
    ELSIF ((v_cur_metadata ->> 'curr_row') IS NULL) THEN
        RETURN;
    END IF;

    BEGIN
        /* Extracting row data from execution results
           table `dbms_sql$recordset`
           (by cursor id, row number, column position) */
        SELECT chr_val,
               num_val,
               dprec_val,
               money_val,
               tstamp_val,
               tstamptz_val,
               timetz_val,
               interval_val,
               bool_val,
               xml_val,
               bin_val
          INTO v_chr_val,
               v_num_val,
               v_dprec_val,
               v_money_val,
               v_tstamp_val,
               v_tstamptz_val,
               v_timetz_val,
               v_interval_val,
               v_bool_val,
               v_xml_val,
               v_bin_val
          FROM dbms_sql$recordset
         WHERE cursor_id = p_cursor_id
           AND rownum = (v_cur_metadata ->> 'curr_row')::INTEGER
           AND column_pos = p_column_pos;
    EXCEPTION
        WHEN insufficient_privilege THEN
            -- Effective userid changed
            RAISE invalid_cursor_state;
    END;

    -- Casting data type and copying value into the OUT argument
    IF (v_out_var_base_t = 'TEXT')
    THEN
        -- Actual length of the data (chars)
        IF (v_chr_val IS NOT NULL) THEN
            p_typvar_len :=
                CASE v_curcol_data_t
                   WHEN 'CHARACTER' THEN (v_curcol_data ->> 'chr_max_len')::INTEGER
                   ELSE char_length(v_chr_val)
                END;
        END IF;

        IF (v_col_size IS NULL) THEN
            p_column_val := v_chr_val;
        ELSE
            p_column_val := substring(v_chr_val, 1, v_col_size);

            IF (v_col_size != 0 AND v_col_size < p_typvar_len)
            THEN
                p_column_err := 1406;
            END IF;
        END IF;

        /* Internal representation (bytes).
           4 bytes + length of text */
        IF (v_chr_val IS NOT NULL) THEN
            p_actual_len :=
                CASE v_curcol_data_t
                   WHEN 'CHARACTER' THEN (v_curcol_data ->> 'chr_byte_len')::INTEGER
                   ELSE pg_column_size(v_chr_val)
                END;
        END IF;
    ELSIF (v_out_var_base_t IN ('NUMERIC',
                                'DOUBLE PRECISION'))
    THEN
        -- Determining data source column
        IF (v_curcol_base_t = 'NUMERIC') THEN
            p_column_val := v_num_val;
        ELSE
            p_column_val := v_dprec_val;
        END IF;

        -- Internal representation (bytes)
        IF (p_column_val IS NOT NULL) THEN
            p_actual_len :=
                CASE v_curcol_data_t
                   WHEN 'SMALLINT' THEN 2 -- 2 bytes
                   WHEN 'INTEGER' THEN 4 -- 4 bytes
                   WHEN 'BIGINT' THEN 8 -- 8 bytes
                   WHEN 'REAL' THEN 4 -- 4 bytes
                   WHEN 'DOUBLE PRECISION' THEN 8 -- 8 bytes
                   WHEN 'NUMERIC' THEN pg_column_size(p_column_val)
                END;
        END IF;

        /* Actual length of the data (bytes).
           Same as internal representation */
        p_typvar_len := p_actual_len;
    ELSIF (v_out_var_base_t = 'MONEY')
    THEN
        p_column_val := v_money_val;

        -- Internal representation, 8 bytes
        p_actual_len := CASE
                           WHEN p_column_val IS NOT NULL
                           THEN 8
                        END;

        /* Actual length of the data (bytes).
           Same as internal representation */
        p_typvar_len := p_actual_len;
    ELSIF (v_out_var_base_t IN ('TIMESTAMP WITHOUT TIME ZONE',
                                'TIMESTAMP WITH TIME ZONE'))
    THEN
        CASE v_curcol_base_t
           WHEN 'TIMESTAMP WITHOUT TIME ZONE' THEN
               p_column_val := v_tstamp_val;
           WHEN 'TIMESTAMP WITH TIME ZONE' THEN
               p_column_val := v_tstamptz_val;
           ELSE
               p_column_val := v_timetz_val;
        END CASE;

        -- Internal representation (bytes)
        p_actual_len := CASE
                           WHEN p_column_val IS NOT NULL
                           THEN CASE v_curcol_data_t
                                   WHEN 'DATE' THEN 4
                                   WHEN 'TIME WITH TIME ZONE' THEN 12
                                   ELSE 8
                                END
                        END;

        /* Actual length of the data (bytes).
           Same as internal representation */
        p_typvar_len := p_actual_len;
    ELSIF (v_out_var_base_t = 'TIME WITH TIME ZONE')
    THEN
        p_column_val := CASE v_curcol_base_t
                           WHEN 'TIMESTAMP WITHOUT TIME ZONE' THEN v_tstamp_val::TIME::TIMETZ
                           WHEN 'TIMESTAMP WITH TIME ZONE' THEN v_tstamptz_val::TIMETZ
                           ELSE v_timetz_val
                        END;

        -- Internal representation (bytes)
        p_actual_len := CASE
                           WHEN p_column_val IS NOT NULL
                           THEN CASE v_curcol_data_t
                                   WHEN 'DATE' THEN 4
                                   WHEN 'TIME WITH TIME ZONE' THEN 12
                                   ELSE 8
                                END
                        END;

        /* Actual length of the data (bytes).
           Same as internal representation */
        p_typvar_len := p_actual_len;
    ELSIF (v_out_var_base_t = 'INTERVAL')
    THEN
        p_column_val := v_interval_val;

        -- Internal representation, 16 bytes
        p_actual_len := CASE
                           WHEN p_column_val IS NOT NULL
                           THEN 16
                        END;

        /* Actual length of the data (bytes).
           Same as internal representation */
        p_typvar_len := p_actual_len;
    ELSIF (v_out_var_base_t = 'BOOLEAN')
    THEN
        p_column_val := v_bool_val;

        /* Internal representation (bytes).
           1 byte, for TRUE or FALSE value */
        p_actual_len := CASE
                           WHEN p_column_val IS NOT NULL
                           THEN 1
                        END;

        /* Actual length of the data (bytes).
           Same as internal representation */
        p_typvar_len := p_actual_len;
    ELSIF (v_out_var_base_t = 'XML')
    THEN
        p_column_val := v_xml_val;

        -- Internal representation (bytes)
        p_actual_len := pg_column_size(p_column_val);

        -- Actual length of the data (chars)
        p_typvar_len := char_length(p_column_val::TEXT);
    ELSIF (v_out_var_base_t = 'BYTEA')
    THEN
        p_column_val := CASE
                           WHEN v_col_size IS NULL THEN v_bin_val
                           ELSE substring(v_bin_val from 1 for v_col_size)
                        END;

        /* Internal representation (bytes).
           4 bytes + actual length of the data */
        p_actual_len := pg_column_size(v_bin_val);

        -- Actual length of the data (bytes)
        p_typvar_len := octet_length(v_bin_val);

        IF (v_col_size != 0 AND v_col_size < p_typvar_len)
        THEN
            p_column_err := 1406;
        END IF;
    END IF;

    IF (p_column_val IS NULL) THEN
        p_column_err := 1405;
    END IF;

    p_actual_len := coalesce(p_actual_len, 0);
    p_typvar_len := coalesce(p_typvar_len, 0);
EXCEPTION
    -- Cursor is not opened or does not exist
    WHEN invalid_cursor_state THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';

    -- Column position is not declared in SELECT list
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Column not in select list.',
                    DETAIL := 'A reference was made to a column not listed in the SELECT clause.',
                    HINT := '-1007';

    /* OUT argument base type does not match declared column base type.
       Possible column was declared through `dbms_sql$define_column_char` */
    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := 'Type of OUT argument does not match declared column type.',
                    DETAIL := 'Attempting to get the value of a column but the type of the given OUT argument is different from the type of column that was defined previously.',
                    HINT := '-6562';

    -- Effective userid (OID) changed since cursor parse
    WHEN invalid_role_specification THEN
        RAISE USING MESSAGE := 'Effective userid is not the same as when cursor was parsed.',
                    DETAIL := 'The effective userid on this call to DBMS_SQL is not the same as that at the time the cursor was parsed.',
                    HINT := '-29470';
END;
]]></complex-attribute>
                        <category _I_D="b5b8b44c-d9e1-4904-bf95-d555934bcc73" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="07c8dac8-b6a1-470c-88d6-06585abcbbc9" name="dbms_sql$column_value_char" is-trigger-function="0" unique-function-name="dbms_sql$column_value_char" is-aggregate="f" language-name="plpgsql" context="dbms_sql$column_value_char" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer,anyelement,numeric,numeric,numeric" comment="This procedure returns the value of the cursor element for a given position in a given cursor. This procedure is used to access the data fetched by calling `dbms_sql$fetch_rows` function." is-returning-set="f" ret-datatype="record" function-arguments="p_cursor_id integer, p_column_pos integer, INOUT p_column_val anyelement, INOUT p_column_err numeric DEFAULT NULL::numeric, INOUT p_actual_len numeric DEFAULT NULL::numeric, INOUT p_typvar_len numeric DEFAULT NULL::numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22348" volatility="STABLE" is-window="f" function-identity-arguments="p_cursor_id integer, p_column_pos integer, INOUT p_column_val anyelement, INOUT p_column_err numeric, INOUT p_actual_len numeric, INOUT p_typvar_len numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$column_value_char(p_cursor_id integer, p_column_pos integer, INOUT p_column_val anyelement, INOUT p_column_err numeric, INOUT p_actual_len numeric, INOUT p_typvar_len numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_cur_metadata JSONB;
    v_defcol_data JSONB;
    v_curcol_data JSONB;
    v_col_size INTEGER;
    v_chr_val TEXT;
    v_num_val NUMERIC;
    v_dprec_val DOUBLE PRECISION;
    v_money_val MONEY;
    v_tstamp_val TIMESTAMP WITHOUT TIME ZONE;
    v_tstamptz_val TIMESTAMP WITH TIME ZONE;
    v_timetz_val TIME WITH TIME ZONE;
    v_interval_val INTERVAL;
    v_bool_val BOOLEAN;
    v_xml_val XML;
    v_bin_val BYTEA;
    v_curcol_data_t TEXT;
    v_curcol_base_t TEXT;
    v_defcol_base_t TEXT;
    v_datetime_mask TEXT;
    v_out_var_size INTEGER;
    v_current_user_oid BIGINT;
    v_out_var_data_t TEXT := upper(pg_typeof(p_column_val)::TEXT);
BEGIN
    -- Checking that cursor is opened (exit if it is not)
    IF (NOT aws_oracle_ext.dbms_sql$is_open(p_cursor_id)) THEN
        RAISE invalid_cursor_state;
    END IF;

    -- Obtaining current user OID
    v_current_user_oid := aws_oracle_ext.get_user_oid_by_name(current_user);

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    /* Checking that effective user OID (current_user) of the caller on this cursor is the same
       as that of the caller of the most recent parse operation on this cursor.
       Actual for cursors opened with security level 2 */
    IF ((v_cur_metadata ->> 'security_level')::SMALLINT = 2 AND
        (v_cur_metadata ->> 'parse_user_oid')::BIGINT != v_current_user_oid)
    THEN
        RAISE invalid_role_specification;
    END IF;

    -- Getting dynamic SQL statement defined and actual columns info (JSON)
    v_defcol_data := (v_cur_metadata #> format('{defcols_data, col_%s}', p_column_pos)::TEXT[]);
    v_curcol_data := (v_cur_metadata #> format('{curcols_data, col_%s}', p_column_pos)::TEXT[]);

    v_curcol_data_t := (v_curcol_data ->> 'data_type'); -- Column (actual) data type
    v_curcol_base_t := (v_curcol_data ->> 'base_type'); -- Column (actual) base data type
    v_defcol_base_t := (v_defcol_data ->> 'base_type'); -- Column (defined) base data type

    v_col_size := (v_defcol_data ->> 'col_size'); -- Column size in characters

    -- Default vars states
    p_column_err := 0;
    p_actual_len := 0;
    p_typvar_len := 0;

    -- Column position should be declared in SELECT list
    IF (v_defcol_base_t IS NULL) THEN
        RAISE null_value_not_allowed;
    -- Variable should not be declared using `dbms_sql$define_column`
    ELSIF (coalesce((v_defcol_data ->> 'is_fixed')::SMALLINT, 0) != 1) THEN
        RAISE most_specific_type_mismatch;
    -- If current row not specified, then nothing to return
    ELSIF ((v_cur_metadata ->> 'curr_row') IS NULL) THEN
        RETURN;
    END IF;

    BEGIN
        /* Extracting row data from execution results
           table `dbms_sql$recordset`
           (by cursor id, row number, column position) */
        SELECT chr_val,
               num_val,
               dprec_val,
               money_val,
               tstamp_val,
               tstamptz_val,
               timetz_val,
               interval_val,
               bool_val,
               xml_val,
               bin_val
          INTO v_chr_val,
               v_num_val,
               v_dprec_val,
               v_money_val,
               v_tstamp_val,
               v_tstamptz_val,
               v_timetz_val,
               v_interval_val,
               v_bool_val,
               v_xml_val,
               v_bin_val
          FROM dbms_sql$recordset
         WHERE cursor_id = p_cursor_id
           AND rownum = (v_cur_metadata ->> 'curr_row')::INTEGER
           AND column_pos = p_column_pos;
    EXCEPTION
        WHEN insufficient_privilege THEN
            -- Effective userid changed
            RAISE invalid_cursor_state;
    END;

    /* Casting column data to a character string.
       Copying value into the OUT argument */
    IF (v_curcol_data_t = 'CHARACTER' AND
        v_chr_val IS NOT NULL)
    THEN
        -- Internal representation (bytes)
        p_actual_len := (v_curcol_data ->> 'chr_byte_len');

        -- Actual length of the data (bytes)
        p_typvar_len := (v_curcol_data ->> 'chr_max_len');
    ELSIF (v_curcol_base_t = 'TEXT')
    THEN
        /* Internal representation (bytes).
           4 bytes + length of text */
        p_actual_len := pg_column_size(v_chr_val);

        -- Actual length of the data (chars)
        p_typvar_len := char_length(v_chr_val);
    ELSIF (v_curcol_base_t = 'NUMERIC')
    THEN
        v_chr_val := v_num_val::TEXT;

        -- Internal representation (bytes)
        IF (v_chr_val IS NOT NULL) THEN
            p_actual_len :=
                CASE v_curcol_data_t
                   WHEN 'SMALLINT' THEN 2 -- 2 bytes
                   WHEN 'INTEGER' THEN 4 -- 4 bytes
                   WHEN 'BIGINT' THEN 8 -- 8 bytes
                   WHEN 'NUMERIC' THEN pg_column_size(v_num_val)
                END;
        END IF;

        /* Actual length of the data (bytes).
           Same as internal representation */
        p_typvar_len := p_actual_len;
    ELSIF (v_curcol_base_t = 'DOUBLE PRECISION')
    THEN
        v_chr_val := v_dprec_val::TEXT;

        -- Internal representation (bytes)
        IF (v_chr_val IS NOT NULL) THEN
            p_actual_len :=
                CASE v_curcol_data_t
                   WHEN 'REAL' THEN 4 -- 4 bytes
                   WHEN 'DOUBLE PRECISION' THEN 8 -- 8 bytes
                END;
        END IF;

        /* Actual length of the data (bytes).
           Same as internal representation */
        p_typvar_len := p_actual_len;
    ELSIF (v_curcol_base_t = 'MONEY')
    THEN
        v_chr_val := v_money_val::TEXT;

        -- Internal representation, 8 bytes
        p_actual_len := CASE
                           WHEN v_chr_val IS NOT NULL
                           THEN 8
                        END;

        /* Actual length of the data (bytes).
           Same as internal representation */
        p_typvar_len := p_actual_len;
    ELSIF (v_curcol_base_t IN ('TIMESTAMP WITHOUT TIME ZONE',
                               'TIMESTAMP WITH TIME ZONE',
                               'TIME WITH TIME ZONE'))
    THEN
        -- Picking up the right datetime mask
        v_datetime_mask := CASE v_curcol_data_t
                              WHEN 'DATE' THEN 'dd-MON-yy'
                              WHEN 'TIME WITHOUT TIME ZONE' THEN 'hh24:mi:ss.us AM'
                              WHEN 'TIMESTAMP WITHOUT TIME ZONE' THEN 'dd-MON-yy hh24:mi:ss.us AM'
                              ELSE 'dd-MON-yy hh24:mi:ss.us AM OF:00'
                           END;

        v_chr_val := CASE v_curcol_base_t
                        WHEN 'TIMESTAMP WITHOUT TIME ZONE' THEN to_char(v_tstamp_val, v_datetime_mask)
                        WHEN 'TIME WITH TIME ZONE' THEN v_timetz_val::TEXT
                        ELSE to_char(v_tstamptz_val, v_datetime_mask)
                     END;

        /* Internal representation,
           4 bytes for DATE, 8 bytes for other types */
        p_actual_len := CASE
                           WHEN v_chr_val IS NOT NULL
                           THEN CASE v_curcol_data_t
                                   WHEN 'DATE' THEN 4
                                   WHEN 'TIME WITH TIME ZONE' THEN 12
                                   ELSE 8
                                END
                        END;

        /* Actual length of the data (bytes).
           Same as internal representation */
        p_typvar_len := p_actual_len;
    ELSIF (v_curcol_base_t = 'INTERVAL')
    THEN
        v_chr_val := v_interval_val::TEXT;

        -- Internal representation, 16 bytes
        p_actual_len := CASE
                           WHEN v_chr_val IS NOT NULL
                           THEN 16
                        END;

        /* Actual length of the data (bytes).
           Same as internal representation */
        p_typvar_len := p_actual_len;
    ELSIF (v_curcol_base_t = 'BOOLEAN')
    THEN
        v_chr_val := upper(v_bool_val::TEXT);

        /* Internal representation (bytes).
           1 byte, for TRUE or FALSE value */
        p_actual_len := CASE
                           WHEN v_chr_val IS NOT NULL
                           THEN 1
                        END;

        /* Actual length of the data (bytes).
           Same as internal representation */
        p_typvar_len := p_actual_len;
    ELSIF (v_curcol_base_t = 'XML')
    THEN
        v_chr_val := v_xml_val::TEXT;

        -- Internal representation (bytes)
        p_actual_len := pg_column_size(v_xml_val);

        -- Actual length of the data (chars)
        p_typvar_len := char_length(v_chr_val);
    ELSIF (v_curcol_base_t = 'BYTEA')
    THEN
        v_chr_val := upper(encode(v_bin_val, 'hex'));

        /* Internal representation (bytes).
           4 bytes + actual length of the data */
        p_actual_len := pg_column_size(v_bin_val);

        -- Actual length of the data (bytes)
        p_typvar_len := octet_length(v_bin_val);
    END IF;

    IF (v_col_size != 0 AND
        v_col_size < char_length(v_chr_val))
    THEN
        p_column_err := 1406;
    END IF;

    v_chr_val := CASE
                    WHEN v_col_size IS NULL THEN v_chr_val
                    ELSE substring(v_chr_val, 1, v_col_size)
                 END;

    -- Copying value into the OUT argument
    IF (v_out_var_data_t IN ('TEXT',
                             'CHARACTER',
                             'CHARACTER VARYING'))
    THEN
        v_out_var_size := coalesce(length(p_column_val::BYTEA, pg_client_encoding()), 0);

        IF (v_out_var_size != 0 AND
            v_out_var_size < p_actual_len)
        THEN
            RAISE string_data_length_mismatch;
        END IF;

        p_column_val := v_chr_val;
    ELSIF (v_out_var_data_t IN ('BIGINT',
                                'INTEGER',
                                'NUMERIC',
                                'SMALLINT'))
    THEN
        p_column_val := v_chr_val::NUMERIC;
    ELSIF (v_out_var_data_t IN ('REAL',
                                'DOUBLE PRECISION'))
    THEN
        p_column_val := v_chr_val::DOUBLE PRECISION;
    ELSIF (v_out_var_data_t = 'MONEY')
    THEN
        p_column_val := v_chr_val::MONEY;
    ELSIF (v_out_var_data_t = 'DATE')
    THEN
        IF (char_length(v_chr_val) < 8) THEN
            RAISE invalid_datetime_format;
        END IF;

        p_column_val := to_date(v_chr_val, 'dd-MON-yy');
    ELSIF (v_out_var_data_t IN ('TIME WITHOUT TIME ZONE',
                                'TIME WITH TIME ZONE'))
    THEN
        v_chr_val := regexp_replace(v_chr_val, '\s*[AP]M', '', 'i');

        IF (char_length(v_chr_val) < 8) THEN
            RAISE invalid_datetime_format;
        END IF;

        IF (v_out_var_data_t = 'TIME WITHOUT TIME ZONE') THEN
            p_column_val := v_chr_val::TIME;
        ELSE
            p_column_val := v_chr_val::TIMETZ;
        END IF;
    ELSIF (v_out_var_data_t = 'TIMESTAMP WITHOUT TIME ZONE')
    THEN
        v_chr_val := regexp_replace(v_chr_val, '\s*[AP]M', '', 'i');

        IF (char_length(v_chr_val) < 17) THEN
            RAISE invalid_datetime_format;
        END IF;

        p_column_val := v_chr_val::TIMESTAMP;
    ELSIF (v_out_var_data_t = 'TIMESTAMP WITH TIME ZONE')
    THEN
        v_chr_val := regexp_replace(v_chr_val, '\s*[AP]M', '', 'i');

        IF (char_length(v_chr_val) < 17) THEN
            RAISE invalid_datetime_format;
        END IF;

        p_column_val := to_timestamp(v_chr_val, 'dd-MON-yy hh24:mi:ss.us');
    ELSIF (v_out_var_data_t = 'INTERVAL')
    THEN
        p_column_val := v_chr_val::INTERVAL;
    ELSIF (v_out_var_data_t = 'BOOLEAN')
    THEN
        p_column_val := v_chr_val::BOOLEAN;
    ELSIF (v_out_var_data_t = 'BYTEA') THEN
        BEGIN
            p_column_val := decode(v_chr_val, 'hex');
        EXCEPTION
            WHEN OTHERS THEN
            RAISE invalid_binary_representation;
        END;
    ELSIF (v_out_var_data_t = 'XML') THEN
        BEGIN
            p_column_val := v_chr_val::XML;
        EXCEPTION
            WHEN OTHERS THEN
            RAISE invalid_xml_document;
        END;
    ELSE
        p_column_val := NULL;
    END IF;

    IF (v_chr_val IS NULL) THEN
        p_column_err := 1405;
    END IF;

    p_actual_len := coalesce(p_actual_len, 0);
    p_typvar_len := coalesce(p_typvar_len, 0);
EXCEPTION
    -- Cursor is not opened or does not exist
    WHEN invalid_cursor_state THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';

    -- Column position is not declared in SELECT list
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Column not in select list.',
                    DETAIL := 'A reference was made to a column not listed in the SELECT clause.',
                    HINT := '-1007';

    /* OUT argument base type does not match declared column base type.
       Possible column was declared through `dbms_sql$define_column` */
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Type of OUT argument does not match declared column type.',
                    DETAIL := 'Attempting to get the value of a column but the type of the given OUT argument is different from the type of column that was defined previously.',
                    HINT := '-6562';

    -- Length of OUT argument is too small
    WHEN string_data_length_mismatch THEN
        RAISE USING MESSAGE := 'Character string buffer too small.',
                    DETAIL := 'Length of OUT argument is too small to store bind variable value.',
                    HINT := '-6502';

    -- Effective userid (OID) changed since cursor parse
    WHEN invalid_role_specification THEN
        RAISE USING MESSAGE := 'Effective userid is not the same as when cursor was parsed.',
                    DETAIL := 'The effective userid on this call to DBMS_SQL is not the same as that at the time the cursor was parsed.',
                    HINT := '-29470';

    -- Possible data type conversion error (char to numeric\money)
    WHEN invalid_text_representation THEN
        RAISE USING MESSAGE := 'Error during column value conversion (from char to numeric\money).',
                    DETAIL := format('Value %s is not correct for conversion to numeric\money.',
                                     quote_literal(v_chr_val));

    -- Possible data type conversion error (char to datetime\interval)
    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := 'Error during column value conversion (from char to datetime\interval).',
                    DETAIL := format('Value %s is not correct for conversion to datetime\interval.',
                                     quote_literal(v_chr_val));

    -- Possible data type conversion error (char to binary data)
    WHEN invalid_binary_representation THEN
        RAISE USING MESSAGE := 'Error during column value conversion (from char to binary data).',
                    DETAIL := format('Value %s is not correct for conversion to binary data.',
                                     quote_literal(v_chr_val));

    -- Possible data type conversion error (char to XML document)
    WHEN invalid_xml_document THEN
        RAISE USING MESSAGE := 'Error during column value conversion (from char to XML document).',
                    DETAIL := format('Value %s is not correct for conversion to XML document.',
                                     quote_literal(v_chr_val));
END;
]]></complex-attribute>
                        <category _I_D="530bc444-9361-4061-b140-3b29f4fa2af4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="406401cc-babc-44bc-aa0a-2e79d67a9393" name="dbms_sql$column_value_long" is-trigger-function="0" unique-function-name="dbms_sql$column_value_long" is-aggregate="f" language-name="plpgsql" context="dbms_sql$column_value_long" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer,integer,integer,text,numeric,numeric" comment="This procedure returns part of the value of a TEXT column for a given position, offset, and size in a given cursor. This procedure is used to access the data fetched by calling `dbms_sql$fetch_rows` function." is-returning-set="f" ret-datatype="record" function-arguments="p_cursor_id integer, p_column_pos integer, p_byte_len integer, p_offset integer, INOUT p_column_val text, INOUT p_length_val numeric, INOUT p_typvar_len numeric DEFAULT NULL::numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="7" function-id="22350" volatility="STABLE" is-window="f" function-identity-arguments="p_cursor_id integer, p_column_pos integer, p_byte_len integer, p_offset integer, INOUT p_column_val text, INOUT p_length_val numeric, INOUT p_typvar_len numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$column_value_long(p_cursor_id integer, p_column_pos integer, p_byte_len integer, p_offset integer, INOUT p_column_val text, INOUT p_length_val numeric, INOUT p_typvar_len numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_chr_val TEXT;
    v_chr_binval BYTEA;
    v_defcol_data JSONB;
    v_cur_metadata JSONB;
    v_defcol_base_t TEXT;
    v_current_user_oid BIGINT;
    v_out_var_base_t TEXT := 'TEXT';
BEGIN
    -- Checking that cursor is opened (exit if it is not)
    IF (NOT aws_oracle_ext.dbms_sql$is_open(p_cursor_id)) THEN
        RAISE invalid_cursor_state;
    -- Length of the segment to retrieve (in bytes) should be 1 or above
    ELSIF (coalesce(p_byte_len, 0) = 0) THEN
        RAISE zero_length_character_string;
    END IF;

    -- Obtaining current user OID
    v_current_user_oid := aws_oracle_ext.get_user_oid_by_name(current_user);

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    /* Checking that effective user OID (current_user) of the caller on this cursor is the same
       as that of the caller of the most recent parse operation on this cursor.
       Actual for cursors opened with security level 2 */
    IF ((v_cur_metadata ->> 'security_level')::SMALLINT = 2 AND
        (v_cur_metadata ->> 'parse_user_oid')::BIGINT != v_current_user_oid)
    THEN
        RAISE invalid_role_specification;
    END IF;

    -- Getting dynamic SQL statement defined columns info (JSON)
    v_defcol_data := (v_cur_metadata #> format('{defcols_data, col_%s}', p_column_pos)::TEXT[]);

    v_defcol_base_t := (v_defcol_data ->> 'base_type'); -- Column base data type

    -- Check if data is previously fetched from cursor
    IF ((v_cur_metadata ->> 'curr_row') IS NULL) THEN
        RAISE null_value_not_allowed;
    -- Column position should be declared in SELECT list
    ELSIF (v_defcol_base_t IS NULL) THEN
        RAISE too_many_columns;
    -- Check if OUT argument base type matches declared column base type
    ELSIF (v_out_var_base_t != substring(v_defcol_base_t, 1, 14)) THEN
        RAISE datatype_mismatch;
    -- Column should not be declared using `dbms_sql$define_column_char`
    ELSIF ((v_defcol_data ->> 'is_fixed')::SMALLINT = 1) THEN
        RAISE datatype_mismatch;
    END IF;

    BEGIN
        /* Extracting row data from execution results
           table `dbms_sql$recordset`
           (by cursor id, row number, column position) */
        SELECT chr_val
          INTO v_chr_val
          FROM dbms_sql$recordset
         WHERE cursor_id = p_cursor_id
           AND rownum = (v_cur_metadata ->> 'curr_row')::INTEGER
           AND column_pos = p_column_pos;
    EXCEPTION
        WHEN insufficient_privilege THEN
            -- Effective userid changed
            RAISE invalid_cursor_state;
    END;

    -- Extracting data from binary string and copying it into the OUT argument
    v_chr_binval := substring(v_chr_val::BYTEA from (p_offset + 1) for p_byte_len);
    p_column_val := convert_from(v_chr_binval, pg_client_encoding());

    /* Internal representation (bytes).
       4 bytes + actual length of the data */
    p_length_val := coalesce(pg_column_size(v_chr_binval), 0);

    -- Actual length of the data (bytes)
    p_typvar_len := coalesce(octet_length(v_chr_binval), 0);
EXCEPTION
    -- Cursor is not opened or does not exist
    WHEN invalid_cursor_state THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';

    -- Length of the segment to retrieve (in bytes) is zero or less
    WHEN zero_length_character_string THEN
        RAISE USING MESSAGE := 'Numeric or value error.',
                    DETAIL := 'Length of the segment to retrieve (in bytes) must be 1 or above.',
                    HINT := '-6502';

    -- Resulting data was not previously fetched from cursor
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'This function can be called only after a fetch.',
                    DETAIL := 'The function was called before the fetch operation on cursor.',
                    HINT := '-1016';

    -- Column position is not declared in SELECT list
    WHEN too_many_columns THEN
        RAISE USING MESSAGE := 'Column not in select list.',
                    DETAIL := 'A reference was made to a column not listed in the SELECT clause.',
                    HINT := '-1007';

    /* OUT argument base type does not match declared column base type.
       Possible column was declared through `dbms_sql$define_column_char` */
    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := 'Type of OUT argument does not match declared column type.',
                    DETAIL := 'Attempting to get the value of a column but the type of the given OUT argument is different from the type of column that was defined previously.',
                    HINT := '-6562';

    -- Effective userid (OID) changed since cursor parse
    WHEN invalid_role_specification THEN
        RAISE USING MESSAGE := 'Effective userid is not the same as when cursor was parsed.',
                    DETAIL := 'The effective userid on this call to DBMS_SQL is not the same as that at the time the cursor was parsed.',
                    HINT := '-29470';
END;
]]></complex-attribute>
                        <category _I_D="b7ade0c6-5092-4244-b925-eb7dbed102e6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c8aeda1d-7c52-4b91-86d9-b5506617db24" name="dbms_sql$define_column" is-trigger-function="0" unique-function-name="dbms_sql$define_column" is-aggregate="f" language-name="plpgsql" context="dbms_sql$define_column" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer,anyelement,integer" comment="The procedure defines a column to be selected from the given cursor, used only with SELECT statements. The column being defined is identified by its relative position in the SELECT list of the statement in the given cursor." is-returning-set="f" ret-datatype="void" function-arguments="p_cursor_id integer, p_column_pos integer, p_column_var anyelement, p_col_size integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22356" volatility="VOLATILE" is-window="f" function-identity-arguments="p_cursor_id integer, p_column_pos integer, p_column_var anyelement, p_col_size integer" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$define_column(p_cursor_id integer, p_column_pos integer, p_column_var anyelement, p_col_size integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_cur_metadata JSONB;
    v_defcols_data JSONB;
    v_col_size INTEGER;
    v_colvar_len INTEGER;
    v_defcol_base_t TEXT;
    v_current_user_oid BIGINT;
    v_defcol_data_t TEXT := upper(pg_typeof(p_column_var)::TEXT);
BEGIN
    -- Checking that cursor is opened
    IF (NOT aws_oracle_ext.dbms_sql$is_open(p_cursor_id)) THEN
        RAISE invalid_cursor_state;
    END IF;

    -- Obtaining current user OID
    v_current_user_oid := aws_oracle_ext.get_user_oid_by_name(current_user);

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    /* Checking that effective user OID (current_user) of the caller on this cursor is the same
       as that of the caller of the most recent parse operation on this cursor.
       Actual for cursors opened with security level 2 */
    IF ((v_cur_metadata ->> 'security_level')::SMALLINT = 2 AND
        (v_cur_metadata ->> 'parse_user_oid')::BIGINT != v_current_user_oid)
    THEN
        RAISE invalid_role_specification;
    END IF;

    -- Column position must be within the range 1..cols_count
    IF (p_column_pos NOT BETWEEN 1 AND (v_cur_metadata ->> 'cols_count')::SMALLINT) THEN
        RAISE check_violation;
    END IF;

    -- Determining base data type of passed variable
    v_defcol_base_t := aws_oracle_ext.get_base_type_by_dtype(v_defcol_data_t);

    IF (v_defcol_base_t = 'TEXT')
    THEN
        v_colvar_len := coalesce(length(p_column_var::BYTEA, pg_client_encoding()), 0);
        v_col_size := CASE
                         WHEN p_col_size IS NOT NULL THEN p_col_size
                         WHEN v_colvar_len > 0 THEN v_colvar_len
                      END;
    ELSIF (v_defcol_base_t = 'BYTEA')
    THEN
        v_col_size := p_col_size;
    END IF;

    BEGIN
        -- Saving defined columns data into temp table
        INSERT INTO dbms_sql$define_column (cursor_id,
                                            column_pos,
                                            data_type,
                                            base_type,
                                            col_size,
                                            is_fixed)
             VALUES (p_cursor_id,
                     p_column_pos,
                     v_defcol_data_t,
                     v_defcol_base_t,
                     v_col_size,
                     null)
        ON CONFLICT (cursor_id, column_pos)
        DO UPDATE SET data_type = v_defcol_data_t,
                      base_type = v_defcol_base_t,
                      col_size = v_col_size,
                      is_fixed = null;
    EXCEPTION
        WHEN insufficient_privilege THEN
            -- Effective userid changed
            RAISE invalid_cursor_state;
    END;

    -- Serializing defined columns data into JSON object
    SELECT jsonb_object_agg(concat('col_', defcol_data.column_pos),
                            defcol_data.column_data)
      INTO v_defcols_data
      FROM (SELECT defcol3.column_pos,
                   (SELECT to_jsonb(defcol2.*)
                      FROM (SELECT defcol1.data_type,
                                   defcol1.base_type,
                                   defcol1.col_size,
                                   defcol1.is_fixed
                              FROM dbms_sql$define_column AS defcol1
                             WHERE defcol1.cursor_id = defcol3.cursor_id
                               AND defcol1.column_pos = defcol3.column_pos
                           ) AS defcol2
                   ) AS column_data
              FROM dbms_sql$define_column AS defcol3
             WHERE defcol3.cursor_id = p_cursor_id
           ) AS defcol_data;

    -- Setting "defcols_data" (JSON) cursor property
    v_cur_metadata := jsonb_set(v_cur_metadata, '{defcols_data}', v_defcols_data);

    -- Saving cursor metadata (JSON) object
    PERFORM set_config(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id),
                       v_cur_metadata::TEXT,
                       false);
EXCEPTION
    -- Cursor is not opened or does not exist
    WHEN invalid_cursor_state THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';

    -- Column position lies outside of range 1..cols_count
    WHEN check_violation THEN
        RAISE USING MESSAGE := 'Column not in select list.',
                    DETAIL := 'Reference to a column not listed in the SELECT clause.',
                    HINT := '-1007';

    -- Effective userid (OID) changed since cursor parse
    WHEN invalid_role_specification THEN
        RAISE USING MESSAGE := 'Effective userid is not the same as when cursor was parsed.',
                    DETAIL := 'The effective userid on this call to DBMS_SQL is not the same as that at the time the cursor was parsed.',
                    HINT := '-29470';
END;
]]></complex-attribute>
                        <category _I_D="219f1466-ca25-40c8-94fa-7d26b9d8fd67" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="545dad57-2981-4d9a-963c-6a71f961a9e6" name="dbms_sql$define_column_char" is-trigger-function="0" unique-function-name="dbms_sql$define_column_char" is-aggregate="f" language-name="plpgsql" context="dbms_sql$define_column_char" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer,anyelement,integer" comment="The procedure defines a fixed-length CHAR column to be selected from the given cursor, used only with SELECT statements. The column being defined is identified by its relative position in the SELECT list of the statement in the given cursor." is-returning-set="f" ret-datatype="void" function-arguments="p_cursor_id integer, p_column_pos integer, p_column_var anyelement, p_col_size integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22354" volatility="VOLATILE" is-window="f" function-identity-arguments="p_cursor_id integer, p_column_pos integer, p_column_var anyelement, p_col_size integer" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$define_column_char(p_cursor_id integer, p_column_pos integer, p_column_var anyelement, p_col_size integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_cur_metadata JSONB;
    v_defcols_data JSONB;
    v_is_fixed SMALLINT := 1;
    v_current_user_oid BIGINT;
    v_defcol_base_t TEXT := 'TEXT';
BEGIN
    -- Checking that cursor is opened
    IF (NOT aws_oracle_ext.dbms_sql$is_open(p_cursor_id)) THEN
        RAISE invalid_cursor_state;
    END IF;

    -- Obtaining current user OID
    v_current_user_oid := aws_oracle_ext.get_user_oid_by_name(current_user);

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    /* Checking that effective user OID (current_user) of the caller on this cursor is the same
       as that of the caller of the most recent parse operation on this cursor.
       Actual for cursors opened with security level 2 */
    IF ((v_cur_metadata ->> 'security_level')::SMALLINT = 2 AND
        (v_cur_metadata ->> 'parse_user_oid')::BIGINT != v_current_user_oid)
    THEN
        RAISE invalid_role_specification;
    END IF;

    -- Column position must be within the range 1..cols_count
    IF (p_column_pos NOT BETWEEN 1 AND (v_cur_metadata ->> 'cols_count')::SMALLINT) THEN
        RAISE check_violation;
    END IF;

    BEGIN
        -- Saving defined columns data into temp table
        INSERT INTO dbms_sql$define_column (cursor_id,
                                            column_pos,
                                            data_type,
                                            base_type,
                                            col_size,
                                            is_fixed)
             VALUES (p_cursor_id,
                     p_column_pos,
                     v_defcol_base_t,
                     v_defcol_base_t,
                     p_col_size,
                     v_is_fixed)
        ON CONFLICT (cursor_id, column_pos)
        DO UPDATE SET data_type = v_defcol_base_t,
                      base_type = v_defcol_base_t,
                      col_size = p_col_size,
                      is_fixed = v_is_fixed;
    EXCEPTION
        WHEN insufficient_privilege THEN
            -- Effective userid changed
            RAISE invalid_cursor_state;
    END;

    -- Serializing defined columns data into JSON object
    SELECT jsonb_object_agg(concat('col_', defcol_data.column_pos),
                            defcol_data.column_data)
      INTO v_defcols_data
      FROM (SELECT defcol3.column_pos,
                   (SELECT to_jsonb(defcol2.*)
                      FROM (SELECT defcol1.data_type,
                                   defcol1.base_type,
                                   defcol1.col_size,
                                   defcol1.is_fixed
                              FROM dbms_sql$define_column AS defcol1
                             WHERE defcol1.cursor_id = defcol3.cursor_id
                               AND defcol1.column_pos = defcol3.column_pos
                           ) AS defcol2
                   ) AS column_data
              FROM dbms_sql$define_column AS defcol3
             WHERE defcol3.cursor_id = p_cursor_id
           ) AS defcol_data;

    -- Setting "defcols_data" (JSON) cursor property
    v_cur_metadata := jsonb_set(v_cur_metadata, '{defcols_data}', v_defcols_data);

    -- Saving cursor metadata (JSON) object
    PERFORM set_config(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id),
                       v_cur_metadata::TEXT,
                       false);
EXCEPTION
    -- Cursor is not opened or does not exist
    WHEN invalid_cursor_state THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';

    -- Column position lies outside of range 1..cols_count
    WHEN check_violation THEN
        RAISE USING MESSAGE := 'Column not in select list.',
                    DETAIL := 'Reference to a column not listed in the SELECT clause.',
                    HINT := '-1007';

    -- Effective userid (OID) changed since cursor parse
    WHEN invalid_role_specification THEN
        RAISE USING MESSAGE := 'Effective userid is not the same as when cursor was parsed.',
                    DETAIL := 'The effective userid on this call to DBMS_SQL is not the same as that at the time the cursor was parsed.',
                    HINT := '-29470';
END;
]]></complex-attribute>
                        <category _I_D="066ca7d9-36c1-4333-bf34-c313cccbaa5d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d3064928-1d26-47d9-ba7b-1d13a233268b" name="dbms_sql$define_column_long" is-trigger-function="0" unique-function-name="dbms_sql$define_column_long" is-aggregate="f" language-name="plpgsql" context="dbms_sql$define_column_long" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer" comment="The procedure defines a TEXT column to be selected from the given cursor, used only with SELECT statements. The column being defined is identified by its relative position in the SELECT list of the statement in the given cursor." is-returning-set="f" ret-datatype="void" function-arguments="p_cursor_id integer, p_column_pos integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22355" volatility="VOLATILE" is-window="f" function-identity-arguments="p_cursor_id integer, p_column_pos integer" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$define_column_long(p_cursor_id integer, p_column_pos integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    PERFORM aws_oracle_ext.dbms_sql$define_column(p_cursor_id,
                                                  p_column_pos,
                                                  ''::TEXT);
END;
]]></complex-attribute>
                        <category _I_D="1e736a61-bbe5-4ae4-a111-0d7fe3b60dc0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3e564ad2-8660-46bf-bf2d-627dccb7ee0e" name="dbms_sql$execute" is-trigger-function="0" unique-function-name="dbms_sql$execute" is-aggregate="f" language-name="plpgsql" context="dbms_sql$execute" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer" comment="The function executes a statement associated with a given cursor and returns the number of rows processed (for INSERT, UPDATE, DELETE statements)." is-returning-set="f" ret-datatype="numeric" function-arguments="p_cursor_id integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22359" volatility="VOLATILE" is-window="f" function-identity-arguments="p_cursor_id integer" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$execute(p_cursor_id integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_cur_metadata JSONB;
    v_curcols_data JSONB;
    v_colscount_block TEXT;
    v_colstype_block TEXT;
    v_prepdynsql_block TEXT;
    v_sql_statement TEXT;
    v_cols_count SMALLINT;
    v_cases_list TEXT;
    v_rows_count INTEGER;
    v_vars_sync_sql TEXT;
    v_col_aliases1 TEXT;
    v_col_aliases2 TEXT;
    v_coldtype_cases TEXT;
    v_into_clause TEXT;
    v_bind_var RECORD;
    v_bindvar_val TEXT;
    v_bindvar_col TEXT;
    v_bind_varstr TEXT;
    v_datatypes_rec RECORD;
    v_err_message TEXT;
    v_err_stack TEXT;
    v_defcols_hash TEXT;
    v_sql_cmd_type TEXT;
    v_sql_function_code SMALLINT;
    v_colstype_table_name TEXT;
    v_current_user_oid BIGINT;
    v_debug_mode BOOLEAN := 0; -- {1:ON, 0:OFF}. If set to "ON", engine logs all dynamically generated scripts into `dbms_sql$cursor` table
BEGIN
    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    /* If cursor was transformed from a REFCURSOR
       than it could not be executed */
    IF ((v_cur_metadata ->> 'from_refcursor')::BOOLEAN)
    THEN
        RAISE invalid_cursor_definition;
    -- Checking that cursor is opened (exit if it is not)
    ELSIF (NOT aws_oracle_ext.dbms_sql$is_open(p_cursor_id))
    THEN
        RAISE invalid_cursor_state;
    END IF;

    -- Obtaining current user OID
    v_current_user_oid := aws_oracle_ext.get_user_oid_by_name(current_user);

    /* Checking that effective user OID (current_user) of the caller on this cursor is the same
       as that of the caller of the most recent parse operation on this cursor.
       Actual for cursors opened with security level 1 and 2 */
    IF ((v_cur_metadata ->> 'security_level')::SMALLINT IN (1, 2) AND
        (v_cur_metadata ->> 'parse_user_oid')::BIGINT != v_current_user_oid)
    THEN
        RAISE invalid_role_specification;
    END IF;

    -- Getting dynamic SQL function code from cursor metadata (JSON)
    v_sql_function_code := (v_cur_metadata ->> 'sql_func_code');

    -- Determining SQL command type from cursor metadata (JSON)
    v_sql_cmd_type := (v_cur_metadata ->> 'sql_cmd_type');

    BEGIN
        -- Getting SQL-PL/pgSQL statement by cursor id
        SELECT rtrim(sql_statement, ';')
          INTO v_sql_statement
          FROM dbms_sql$cursor
         WHERE cursor_id = p_cursor_id;
    EXCEPTION
        WHEN insufficient_privilege THEN
            -- Effective userid changed
            RAISE invalid_cursor_state;
    END;

    /* Associated SQL statement (PL/pgSQL blobk)
       should not be empty (NULL) or invalid (not recognized) */
    IF (coalesce(v_sql_statement, '') = '' OR
        v_sql_cmd_type IS NULL)
    THEN -- ORA-01003: no statement parsed
        RAISE null_value_not_allowed;
    END IF;

    -- Conditional execution by SQL command type
    IF (v_sql_cmd_type = 'DML')
    THEN
        /* Wrapper to resolve an issue with SELECT-INTO statement,
           where INTO clause supplied at the end of the statement string */
        IF (v_sql_statement ~* '^(WITH\s+.*\s+AS\s+\(.*\s*)?SELECT\s+.*\s+INTO\s+([\$\:][[:alnum:]_$#\.]+(,\s*)?)+\s*$' AND
            v_sql_function_code NOT IN (3, -- INSERT
                                        5, -- UPDATE
                                        9)) -- DELETE
        THEN
            -- Extracting "INTO" clause (and related "$1, $2, $n" markers) from the end of the statement string
            v_into_clause := aws_oracle_ext.regexp_substr(v_sql_statement, '(\s*INTO\s*([\$\:][[:alnum:]_]+(,\s*)?)+)\s*$', 1, 1, 'i');

            -- Removing "INTO" clause from the end of the statement string
            v_sql_statement := replace(v_sql_statement, v_into_clause, '');

            -- Replacing "INTO" with "INTO STRICT" in order to emulate NO_DATA_FOUND & TOO_MANY_ROWS logic
            v_into_clause := regexp_replace(v_into_clause, 'INTO', 'INTO STRICT', 'gi');

            -- Inserting "INTO" clause (and related "$1, $2, $n" markers) before "FROM" clause
            v_sql_statement := overlay(v_sql_statement placing concat(' ', ltrim(v_into_clause), ' ')
                                                          from position('FROM' in upper(v_sql_statement)) - 1
                                                           for 1);
        ELSIF (v_sql_statement ~* 'RETURNING' AND
               v_sql_function_code IN (3, -- INSERT
                                       5, -- UPDATE
                                       9)) -- DELETE
        THEN
            -- Replacing "RETURNING col_name; INTO" with "RETURNING col_name INTO"
            v_sql_statement := regexp_replace(v_sql_statement, '(?:;)\s*INTO', ' INTO', 'gi');
        END IF;

        /* Binding local variables (instead of placeholders)
           associated with dynamic SQL query (PL/pgSQL block) */
        FOR v_bind_var IN
        (SELECT *
           FROM dbms_sql$bind_variable
          WHERE cursor_id = p_cursor_id
          ORDER BY var_pos)
        LOOP
            CASE v_bind_var.base_type
               WHEN 'TEXT'
               THEN
                   v_bindvar_col := 'chr_val';
                   v_bindvar_val := CASE
                                       WHEN v_bind_var.chr_val IS NOT NULL
                                       THEN quote_literal(CASE v_bind_var.data_type
                                                             WHEN 'CHARACTER' THEN rpad(v_bind_var.chr_val, v_bind_var.value_size, ' ')
                                                             ELSE substring(v_bind_var.chr_val, 1, v_bind_var.value_size)
                                                          END)
                                       ELSE null
                                    END;
               WHEN 'NUMERIC'
               THEN
                   v_bindvar_col := 'num_val';
                   v_bindvar_val := CASE
                                       WHEN v_bind_var.num_val IS NOT NULL
                                       THEN v_bind_var.num_val::TEXT
                                       ELSE null
                                    END;
               WHEN 'DOUBLE PRECISION'
               THEN
                   v_bindvar_col := 'dprec_val';
                   v_bindvar_val := CASE
                                       WHEN v_bind_var.dprec_val IS NOT NULL
                                       THEN v_bind_var.dprec_val::TEXT
                                       ELSE null
                                    END;
               WHEN 'MONEY'
               THEN
                   v_bindvar_col := 'money_val';
                   v_bindvar_val := CASE
                                       WHEN v_bind_var.money_val IS NOT NULL
                                       THEN format('MONEY ''%s''', v_bind_var.money_val::TEXT)
                                       ELSE null
                                    END;
               WHEN 'TIMESTAMP WITHOUT TIME ZONE'
               THEN
                   v_bindvar_col := 'tstamp_val';
                   v_bindvar_val := CASE
                                       WHEN v_bind_var.tstamp_val IS NOT NULL
                                       THEN CASE v_bind_var.data_type
                                               WHEN 'DATE' THEN format('DATE ''%s''',
                                                                       to_char(v_bind_var.tstamp_val, 'yyyy-mm-dd'))
                                               WHEN 'TIME WITHOUT TIME ZONE' THEN format('TIME ''%s''',
                                                                                         to_char(v_bind_var.tstamp_val, 'hh24:mi:ss.us'))
                                               ELSE format('TIMESTAMP ''%s''',
                                                           to_char(v_bind_var.tstamp_val, 'yyyy-mm-dd hh24:mi:ss.us'))
                                            END
                                       ELSE null
                                    END;
               WHEN 'TIMESTAMP WITH TIME ZONE'
               THEN
                   v_bindvar_col := 'tstamptz_val';
                   v_bindvar_val := CASE
                                       WHEN v_bind_var.tstamptz_val IS NOT NULL
                                       THEN format('TIMESTAMPTZ ''%s''', to_char(v_bind_var.tstamptz_val, 'yyyy-mm-dd hh24:mi:ss.usOF'))
                                       ELSE null
                                    END;
               WHEN 'TIME WITH TIME ZONE'
               THEN
                   v_bindvar_col := 'timetz_val';
                   v_bindvar_val := CASE
                                       WHEN v_bind_var.timetz_val IS NOT NULL
                                       THEN format('TIMETZ ''%s''', v_bind_var.timetz_val::TEXT)
                                       ELSE null
                                    END;
               WHEN 'INTERVAL'
               THEN
                   v_bindvar_col := 'interval_val';
                   v_bindvar_val := CASE
                                       WHEN v_bind_var.interval_val IS NOT NULL
                                       THEN format('INTERVAL ''%s''', v_bind_var.interval_val::TEXT)
                                       ELSE null
                                    END;
               WHEN 'BOOLEAN'
               THEN
                   v_bindvar_col := 'bool_val';
                   v_bindvar_val := CASE
                                       WHEN v_bind_var.bool_val IS NOT NULL
                                       THEN upper(v_bind_var.bool_val::TEXT)
                                       ELSE null
                                    END;
               WHEN 'XML'
               THEN
                   v_bindvar_col := 'xml_val';
                   v_bindvar_val := CASE
                                       WHEN v_bind_var.xml_val IS NOT NULL
                                       THEN quote_literal(v_bind_var.xml_val)
                                       ELSE null
                                    END;
               WHEN 'BYTEA'
               THEN
                   v_bindvar_col := 'bin_val';
                   v_bindvar_val := CASE
                                       WHEN v_bind_var.bin_val IS NOT NULL
                                       THEN format('decode(%s, ''hex'')',
                                                   quote_literal(encode(v_bind_var.bin_val, 'hex')))
                                       ELSE null
                                    END;
            ELSE CONTINUE;
            END CASE;

            -- Constructing dynamic block variables declaration
            v_bind_varstr := concat_ws(chr(10),
                                       v_bind_varstr,
                                       format('    v_%s %s%s', -- Variable declaration mask
                                       v_bind_var.var_name, -- Variable name
                                       CASE v_bind_var.data_type
                                          WHEN 'CHARACTER' THEN 'CHARACTER VARYING'
                                          ELSE v_bind_var.data_type
                                       END, -- Variable data type
                                       CASE -- Variable default value
                                          WHEN v_bindvar_val IS NULL THEN ';'
                                          ELSE format(' := %s;', v_bindvar_val)
                                       END));

            -- Replacing all bind ":var_label" labels with proper `outer_block.v_var_name` vars
            v_sql_statement := regexp_replace(v_sql_statement,
                                              ':' || v_bind_var.var_name,
                                              'outer_block.v_' || v_bind_var.var_name,
                                              'gi');

            /* Replacing all bind "$1[|,;-_]$2[|,;-_]$n" markers
               with the corresponding `outer_block.v_var_name` variable */
            IF (v_bind_var.var_label IS NOT NULL)
            THEN
                v_sql_statement := regexp_replace(v_sql_statement,
                                                  replace(concat('(', v_bind_var.var_label, ')(?!\d)'), '$', '\$'),
                                                  'outer_block.v_' || v_bind_var.var_name,
                                                  'gi');
            END IF;

            -- Generating bind variable (stored in `dbms_sql$bind_variable`) update scripts
            v_vars_sync_sql := concat_ws(chr(10),
                                         v_vars_sync_sql,
                                         '',
                                         format('-- Updating "%s" bind variable value', v_bind_var.var_name),
                                         'UPDATE dbms_sql$bind_variable',
                                         format('   SET %s = %s', v_bindvar_col,
                                                CASE
                                                   WHEN v_bind_var.data_type = 'TIME WITHOUT TIME ZONE'
                                                   THEN format('to_char(outer_block.v_%s, ''2001-01-01 hh24:mi:ss.us'')::TIMESTAMP',
                                                               v_bind_var.var_name)
                                                   ELSE 'outer_block.v_' || v_bind_var.var_name
                                                END),
                                         ' WHERE cursor_id = outer_block.v_cursor_id',
                                         format('   AND var_name = %s;', quote_literal(v_bind_var.var_name)));
        END LOOP;

        -- Getting dynamic SQL statement expected columns count
        v_cols_count := (v_cur_metadata ->> 'cols_count')::INTEGER;

        IF (v_cols_count IS NULL AND -- Columns count variable is NULL
            (v_cur_metadata ->> 'colinfo_refresh')::SMALLINT = 1) -- Columns info needs to be refreshed
        THEN
            IF (v_sql_function_code = 4) -- SELECT
            THEN
                -- Determining the number of columns in dynamic SQL statement
                v_colscount_block :=
                    concat_ws(chr(10),
                        'DO $dbms_sql$',
                        '<<outer_block>>',
                        'DECLARE',
                        '    v_cur_metadata JSONB;',
                        '    v_dynsql_row RECORD;',
                        '    v_cols_count SMALLINT;',
                        format('    v_cursor_id INTEGER := %s;', p_cursor_id),
                        v_bind_varstr, -- Cursor vars declaration
                        'BEGIN',
                        '-- Obtaining dynamic query structure',
                        'SELECT src.*',
                        '  INTO outer_block.v_dynsql_row',
                        '  FROM (',
                        '--------------- Dynamic SQL statement ---------------',
                        v_sql_statement,
                        '--------------- Dynamic SQL statement ---------------',
                        '       ) AS src',
                        ' WHERE 1 = 2;',
                        '',
                        '-- Calculating dymamic sql statement columns count',
                        'SELECT COUNT(1)',
                        '  INTO outer_block.v_cols_count',
                        '  FROM json_object_keys(row_to_json(outer_block.v_dynsql_row));',
                        '',
                        '-- Getting cursor metadata (JSON) object',
                        'outer_block.v_cur_metadata :=',
                        '    nullif(current_setting(format(''sct$dbms_sql.cursor_id_%s_metadata'',',
                        '                                  outer_block.v_cursor_id), true), '''');',
                        '',
                        'outer_block.v_cur_metadata := -- Setting "cols_count" (JSON) cursor property',
                        '    jsonb_set(outer_block.v_cur_metadata, ''{cols_count}'', to_jsonb(outer_block.v_cols_count));',
                        '',
                        '-- Saving cursor metadata (JSON) object',
                        'PERFORM set_config(format(''sct$dbms_sql.cursor_id_%s_metadata'', outer_block.v_cursor_id),',
                        '                   outer_block.v_cur_metadata::TEXT, -- cursor metadata object',
                        '                   false);',
                        'END; $dbms_sql$');

                EXECUTE v_colscount_block; -- Will be saved into `dbms_sql$cursor` ("colscount_block" column) if "v_debug_mode" set to "ON" (1)

                -- Getting updated cursor metadata (JSON) object
                v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

                -- Getting dynamic SQL statement updated columns count
                v_cols_count := (v_cur_metadata ->> 'cols_count')::INTEGER;
            ELSE v_cols_count := 0;
            END IF;
        END IF;

        /* Dynsql execution SELECT (v_cols_count > 0, results in rowset)
           or PL/pgSQL anonymous block (v_cols_count = 0 or is NULL) */
        IF (v_cols_count > 0)
        THEN
            -- Generating list of consecutive column aliases (col_1, col_2, ...)
            SELECT string_agg(concat(repeat(' ', 10), 'col_', colnum),
                              concat(',', chr(10))),
                   string_agg(concat(repeat(' ', 28), 'col_', colnum),
                              concat(',', chr(10)))
              INTO v_col_aliases1,
                   v_col_aliases2
              FROM generate_series(1, v_cols_count) AS colnum;

            -- Refresh cursor columns data type info only if SQL statement was changed
            IF ((v_cur_metadata ->> 'colinfo_refresh')::SMALLINT = 1)
            THEN
                -- Generating unique temp table name
                v_colstype_table_name :=
                    format('dynsql_colstype_%s',
                           lower(substring((SELECT string_agg(md5(random()::TEXT), '')
                                              FROM generate_series(1, ceil(14 / 32.)::INTEGER)
                                           ), 1, 14)));

                -- Determining data type of columns in dynamic SQL statement
                v_colstype_block :=
                    concat_ws(chr(10),
                        'DO $dbms_sql$',
                        '<<outer_block>>',
                        'DECLARE',
                        format('    v_cursor_id INTEGER := %s;', p_cursor_id),
                        v_bind_varstr, -- Cursor vars declaration
                        'BEGIN',
                        '-- Deleting previous dynamic sql execution results',
                        'DELETE FROM dbms_sql$recordset',
                        '      WHERE cursor_id = outer_block.v_cursor_id;',
                        '',
                        '-- Deleting previous dynamic sql columns info',
                        'DELETE FROM dbms_sql$cursor_column',
                        '      WHERE cursor_id = outer_block.v_cursor_id;',
                        '',
                        '-- Creating temp table in order to reflect the columns structure',
                        'BEGIN',
                        format('CREATE TEMP TABLE %s', v_colstype_table_name),
                        'WITH (OIDS = false)',
                        'ON COMMIT DROP',
                        'AS',
                        'SELECT src.* FROM (',
                        '--------------- Dynamic SQL statement ---------------',
                        v_sql_statement, -- Dynamic SQL statement where placeholders replaced with v_block vars
                        '--------------- Dynamic SQL statement ---------------',
                        ') AS src',
                        'WITH NO DATA;', -- Obtaining only dynamic query structure
                        '',
                        '/* Using column aliases instead of names',
                        '   in case if any duplicate columns found */',
                        'EXCEPTION',
                        'WHEN duplicate_column THEN',
                        '',
                        format('CREATE TEMP TABLE %s', v_colstype_table_name),
                        'WITH (OIDS = false)',
                        'ON COMMIT DROP',
                        'AS',
                        'SELECT src.* FROM (',
                        '--------------- Dynamic SQL statement ---------------',
                        v_sql_statement, -- Dynamic SQL statement where placeholders replaced with v_block vars
                        '--------------- Dynamic SQL statement ---------------',
                        format(') AS src (%s)', trim(v_col_aliases1)), -- Consecutive column aliases list
                        'WITH NO DATA;', -- Get only dynamic query structure
                        'END;',
                        '',
                        concat_ws(chr(10), '-- Saving detailed column data (name, type, precision, etc.)',
                        'INSERT INTO dbms_sql$cursor_column (cursor_id,',
                        '                                    column_pos,',
                        '                                    col_name,',
                        '                                    data_type,',
                        '                                    base_type,',
                        '                                    is_nullable,',
                        '                                    chr_max_len,',
                        '                                    chr_byte_len,',
                        '                                    num_precision,',
                        '                                    num_scale,',
                        '                                    tstamp_precision,',
                        '                                    interval_type,',
                        '                                    interval_precision)',
                        'SELECT outer_block.v_cursor_id,',
                        '       ordinal_position,',
                        '       column_name,',
                        '       upper(data_type),',
                        '       aws_oracle_ext.get_base_type_by_dtype(upper(data_type)),',
                        '       CASE is_nullable',
                        '          WHEN ''YES'' THEN true',
                        '          ELSE false',
                        '       END,',
                        '       character_maximum_length,',
                        '       character_octet_length,',
                        '       numeric_precision,',
                        '       numeric_scale,',
                        '       datetime_precision,',
                        '       interval_type,',
                        '       interval_precision',
                        '  FROM information_schema.columns'),
                        format(' WHERE table_name = ''%s''', v_colstype_table_name),
                        ' ORDER BY ordinal_position ASC;',
                        '',
                        '-- Dropping temp table since its not needed anymore',
                        format('DROP TABLE %s;', v_colstype_table_name),
                        'END; $dbms_sql$');

                EXECUTE v_colstype_block; -- Will be saved into `dbms_sql$cursor` ("colstype_block" column) if "v_debug_mode" set to "ON" (1)

                -- Serializing dynamic statement columns data into JSON object
                SELECT jsonb_object_agg(concat('col_', curcol_data.column_pos),
                                        curcol_data.column_data)
                  INTO v_curcols_data
                  FROM (SELECT curcol3.column_pos,
                               (SELECT to_jsonb(curcol2.*)
                                  FROM (SELECT curcol1.data_type,
                                               curcol1.base_type,
                                               curcol1.chr_max_len,
                                               curcol1.chr_byte_len
                                          FROM dbms_sql$cursor_column AS curcol1
                                         WHERE curcol1.cursor_id = curcol3.cursor_id
                                           AND curcol1.column_pos = curcol3.column_pos
                                       ) AS curcol2
                               ) AS column_data
                          FROM dbms_sql$cursor_column AS curcol3
                         WHERE curcol3.cursor_id = p_cursor_id
                       ) AS curcol_data;

                -- Setting "curcols_data" (JSON) cursor property
                v_cur_metadata := jsonb_set(v_cur_metadata, '{curcols_data}', v_curcols_data);

                -- Setting "colinfo_refresh" (JSON) cursor property
                v_cur_metadata := jsonb_set(v_cur_metadata, '{colinfo_refresh}', to_jsonb(0));
            END IF;

            -- Getting defined columns data hash
            v_defcols_hash := md5(v_cur_metadata ->> 'defcols_data');

            IF (v_defcols_hash IS NOT NULL AND
                v_defcols_hash != coalesce(v_cur_metadata ->> 'defcols_hash', ''))
            THEN
                -- Setting "defcols_hash" (JSON) cursor property
                v_cur_metadata := jsonb_set(v_cur_metadata, '{defcols_hash}', to_jsonb(v_defcols_hash));

                /* Checking for correspondence between actual and declared column base data types.
                   Oracle ORA-00932: INCONSISTENT_TYPE error is raised if the type of the given OUT parameter
                   value is different from the actual type of the value.

                   This type was given when the column was defined by calling `dbms_sql$define_column` procedure.
                */
                FOR v_datatypes_rec IN
                (SELECT curcol.column_pos,
                        curcol.data_type AS cur_data_type,
                        curcol.base_type AS cur_base_type,
                        defcol.data_type AS def_data_type,
                        defcol.base_type AS def_base_type
                   FROM dbms_sql$cursor_column AS curcol
                        INNER JOIN dbms_sql$define_column AS defcol ON (defcol.cursor_id = curcol.cursor_id AND
                                                                        defcol.column_pos = curcol.column_pos AND
                                                                        (defcol.base_type != curcol.base_type OR
                                                                         (substring(curcol.data_type, 1, 5) = 'TIME ' AND
                                                                          defcol.base_type = 'TIMESTAMP WITHOUT TIME ZONE') OR
                                                                         (substring(defcol.data_type, 1, 5) = 'TIME ' AND
                                                                          curcol.base_type = 'TIMESTAMP WITHOUT TIME ZONE')) AND
                                                                        coalesce(defcol.is_fixed, 0) != 1)
                  WHERE curcol.cursor_id = p_cursor_id)
                LOOP
                    /* Next data types are not implicitly convertible:
                       - TIMESTAMP WITHOUT TIME ZONE to TIMESTAMP WITH TIME ZONE (and vice versa)
                       - TIME WITHOUT TIME ZONE to TIME WITH TIME ZONE (and vice versa)
                       - NUMERIC to DOUBLE PRECISION (and vice versa)

                       Thus, they must not generate an INCONSISTENT_TYPE error since they could be
                       explicitly casted to each other with `dbms_sql$column_value` function
                    */
                    CONTINUE WHEN substring(v_datatypes_rec.cur_data_type, 1, 14) = substring(v_datatypes_rec.def_data_type, 1, 14) OR -- TIMESTAMPs
                                  substring(v_datatypes_rec.cur_data_type, 1, 5) = substring(v_datatypes_rec.def_data_type, 1, 5) OR -- TIMEs
                                  (v_datatypes_rec.cur_base_type IN ('NUMERIC',
                                                                     'DOUBLE PRECISION') AND
                                   v_datatypes_rec.def_base_type IN ('NUMERIC',
                                                                     'DOUBLE PRECISION')) OR
                                  ((v_datatypes_rec.cur_data_type = 'DATE' AND
                                    v_datatypes_rec.def_base_type = 'TIMESTAMP WITH TIME ZONE') OR
                                   (v_datatypes_rec.def_data_type = 'DATE' AND
                                    v_datatypes_rec.cur_base_type = 'TIMESTAMP WITH TIME ZONE'));

                    -- Inconsistent datatypes (Oracle error 'ORA-00932')
                    RAISE datatype_mismatch;
                END LOOP;
            END IF;

            /* Constructing CASEs to distribute dynamic query execution results
               through INSERT-SELECT into `dbms_sql$recordset` table */
            WITH dtypes_order AS
            (SELECT 'TEXT' AS base_type, 1 AS dtype_order
              UNION ALL
             SELECT 'NUMERIC', 2
              UNION ALL
             SELECT 'DOUBLE PRECISION', 3
              UNION ALL
             SELECT 'MONEY', 4
              UNION ALL
             SELECT 'TIMESTAMP WITHOUT TIME ZONE', 5
              UNION ALL
             SELECT 'TIMESTAMP WITH TIME ZONE', 6
              UNION ALL
             SELECT 'TIME WITH TIME ZONE', 7
              UNION ALL
             SELECT 'INTERVAL', 8
              UNION ALL
             SELECT 'BOOLEAN', 9
              UNION ALL
             SELECT 'XML', 10
              UNION ALL
             SELECT 'BYTEA', 11),
            -- Attaching current columns data
            curcols_data AS
            (SELECT base_type,
                    array_agg(concat_ws(':', column_pos, data_type)) AS colpos_list
               FROM dbms_sql$cursor_column
              WHERE cursor_id = p_cursor_id
              GROUP BY base_type)

            SELECT string_agg(
                   coalesce('       CASE colpos' || chr(10) ||
                   (SELECT string_agg(format('          WHEN %s THEN %s',
                                             colpos,
                                             CASE dtype
                                                WHEN 'TIME WITHOUT TIME ZONE' -- List of types that require special conversion
                                                THEN format('to_char(col_%s, ''2001-01-01 hh24:mi:ss.us'')::TIMESTAMP', colpos)
                                                ELSE 'col_' || colpos
                                             END),
                                      chr(10))
                      FROM (SELECT substring(colpos, '^(\d+):?') AS colpos,
                                   substring(colpos, ':(.+)$') AS dtype
                              FROM unnest(cdt.colpos_list) AS colpos) AS cols) || chr(10) || '       END',
                                       '       null'),
                   ',' || chr(10) ORDER BY dto.dtype_order ASC)
              INTO v_coldtype_cases
              FROM dtypes_order dto
                   LEFT JOIN curcols_data cdt ON (cdt.base_type = dto.base_type);

            /* Constructing INSERT-SELECT (into `dbms_sql$recordset` table),
               required to distribute dynamic query execution results */
            v_sql_statement :=
                concat_ws(chr(10),
                    '-- Deleting previous dynamic SQL execution results',
                    'DELETE FROM dbms_sql$recordset',
                    '      WHERE cursor_id = outer_block.v_cursor_id;',
                    '',
                    '/* Execution of dynamic SQL statement and inserting its',
                    '   resulting data into temp table dbms_sql$recordset */',
                    'INSERT INTO dbms_sql$recordset (cursor_id,',
                    '                                rownum,',
                    '                                column_pos,',
                    '                                chr_val,',
                    '                                num_val,',
                    '                                dprec_val,',
                    '                                money_val,',
                    '                                tstamp_val,',
                    '                                tstamptz_val,',
                    '                                timetz_val,',
                    '                                interval_val,',
                    '                                bool_val,',
                    '                                xml_val,',
                    '                                bin_val)',
                    'SELECT outer_block.v_cursor_id,',
                    '       rownum,',
                    '       colpos,',
                    v_coldtype_cases, -- Coltypes distribution CASEs
                    '  FROM (SELECT row_number() over (order by 1) AS rownum,',
                    '               generate_series(1, outer_block.v_cols_count) AS colpos,',
                    '               dynsql.*',
                    '          FROM (',
                    '--------------- Dynamic SQL statement ---------------',
                    v_sql_statement, -- Dynamic SQL statement
                    '--------------- Dynamic SQL statement ---------------',
                    format('               ) AS dynsql (%s)', trim(v_col_aliases2)), -- List of consecutive column aliases
                    '       ) AS dynsql2;');
        END IF;

        -- Removing "$$" and "LANGUAGE" markers in order to embed block into <<outer_block>>
        IF (v_sql_function_code = 34) -- PL/SQL (PL/pgSQL) block
        THEN
            -- Removing "$$" and "LANGUAGE" markers from the start of the statement
            v_sql_statement := regexp_replace(v_sql_statement,
                '(^\s*DO(:?\s+LANGUAGE\s+[[:alnum:]]+\s+)?\s*\$(\w*)?\$\s*(:?<<.+>>)?\s*)',
                concat(substring(v_sql_statement, '<<.+>>'), chr(10)), 'gi');

            -- Removing "$$" and "LANGUAGE" markers from the end of the statement
            v_sql_statement := regexp_replace(v_sql_statement,
                '(END\s*(;)?\s*\$(\w*)?\$\s*(:?\s+LANGUAGE\s+[[:alnum:]]+)?\s*$)', 'END;', 'gi');

            -- Removing any unnecessary blank strings (spaces) from the beginning and the end of SQL statement
            v_sql_statement := regexp_replace(v_sql_statement, '^\s*(?=\S*)|(?<=\S*)\s*$', '', 'gi');
        END IF;

        -- Saving cursor metadata (JSON) object
        PERFORM set_config(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id),
                           v_cur_metadata::TEXT, -- cursor metadata object
                           false);

        IF (v_sql_function_code = 27) -- EXPLAIN
        THEN
            -- Creating special `explain_plan` bind variable to store query EXPLAIN plan
            PERFORM aws_oracle_ext.dbms_sql$bind_variable(p_cursor_id, 'explain_plan', ''::TEXT,
                                                          p_check_var_exists => false);

            -- Dynamic EXPLAIN plan execution wrapper
            v_prepdynsql_block :=
                concat_ws(chr(10),
                    'DO $dbms_sql$',
                    '<<outer_block>>',
                    'DECLARE',
                    '    v_exp_plan TEXT;',
                    '    v_exp_plan_arr TEXT[];',
                    '    r_explain_plan RECORD;',
                    format('    v_cursor_id INTEGER := %s;', p_cursor_id),
                    v_bind_varstr, -- Cursor vars declaration
                    'BEGIN',
                    'FOR r_explain_plan IN',
                    '----------- Dynamic EXPLAIN plan statement -----------',
                    v_sql_statement, -- Dynamic EXPLAIN statement, placeholders replaced with v_block vars
                    '----------- Dynamic EXPLAIN plan statement -----------',
                    'LOOP',
                    '    v_exp_plan_arr := array_append(v_exp_plan_arr, r_explain_plan."QUERY PLAN");',
                    'END LOOP;',
                    '',
                    '-- Updating "explain_plan" bind variable value',
                    'UPDATE dbms_sql$bind_variable',
                    '   SET chr_val = array_to_string(v_exp_plan_arr, chr(10))',
                    ' WHERE cursor_id = outer_block.v_cursor_id',
                    '   AND var_name = ''explain_plan'';',
                    'END; $dbms_sql$');
        ELSE
            -- Dynamic PL/pgSQL block (or DML with INTO clause) execution wrapper
            v_prepdynsql_block :=
                concat_ws(chr(10),
                    'DO $dbms_sql$',
                    '<<outer_block>>',
                    'DECLARE',
                    '    v_cur_metadata JSONB;',
                    '    v_rows_count INTEGER;',
                    format('    v_cols_count SMALLINT := %s;', v_cols_count),
                    format('    v_cursor_id INTEGER := %s;', p_cursor_id),
                    v_bind_varstr, -- Cursor vars declaration
                    'BEGIN',
                    '------- Dynamic PL/pgSQL block (SQL statement) -------',
                    concat(v_sql_statement, -- Dynamic SQL or PL/pgSQL statement, placeholders replaced with v_block vars
                    CASE 
                       WHEN v_sql_statement !~ ';$' THEN ';'
                    END),
                    '------- Dynamic PL/pgSQL block (SQL statement) -------',
                    '',
                    'GET DIAGNOSTICS outer_block.v_rows_count := ROW_COUNT;', -- Count of rows affected by dynamic query execution
                    '',
                    '-- Getting cursor metadata (JSON) object',
                    'outer_block.v_cur_metadata :=',
                    '    nullif(current_setting(format(''sct$dbms_sql.cursor_id_%s_metadata'',',
                    '                                  outer_block.v_cursor_id), true), '''');',
                    '',
                    '-- Setting "rows_count" (JSON) cursor property',
                    'outer_block.v_cur_metadata :=',
                    '    jsonb_set(outer_block.v_cur_metadata,',
                    '              ''{rows_count}'',',
                    '              CASE outer_block.v_cols_count',
                    '                 WHEN 0 THEN to_jsonb(outer_block.v_rows_count)',
                    '                 ELSE to_jsonb(outer_block.v_rows_count / outer_block.v_cols_count)',
                    '              END);',
                    '',
                    '-- Setting "curr_row" (JSON) cursor property',
                    'outer_block.v_cur_metadata := jsonb_set(outer_block.v_cur_metadata, ''{curr_row}'', JSONB ''null'');',
                    '',
                    '-- Saving cursor metadata (JSON) object',
                    'PERFORM set_config(format(''sct$dbms_sql.cursor_id_%s_metadata'', outer_block.v_cursor_id),',
                    '                   outer_block.v_cur_metadata::TEXT, -- cursor metadata object',
                    '                   false);',
                    v_vars_sync_sql, -- Update `dbms_sql$bind_variable` table with new values for binded vars
                    'END; $dbms_sql$');
        END IF;

        EXECUTE v_prepdynsql_block; -- Will be saved into `dbms_sql$cursor` ("prepdynsql_block" column) if "v_debug_mode" set to "ON" (1)

        /* Logging of all dynamically generated scripts
           into `dbms_sql$cursor` if "v_debug_mode" set to "ON" (1) */
        IF (v_debug_mode) THEN
            UPDATE dbms_sql$cursor
               SET colscount_block = coalesce(v_colscount_block, colscount_block),
                   colstype_block = coalesce(v_colstype_block, colstype_block),
                   prepdynsql_block = v_prepdynsql_block
             WHERE cursor_id = p_cursor_id;
        END IF;
    ELSIF (v_sql_cmd_type = 'SCL')
    THEN -- Skipping DDL, DCL, TCL, SCS
        EXECUTE v_sql_statement;
    END IF;

    -- Setting `last_affected_cursor_id` variable
    PERFORM set_config('sct$dbms_sql.last_affected_cursor_id', p_cursor_id::TEXT, false);

    -- Nulling `last_row_count` variable
    PERFORM set_config('sct$dbms_sql.last_row_count', null, false);

    -- Getting updated cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    RETURN CASE v_sql_function_code
              WHEN 4 -- SELECT
              THEN 0 -- Executing a SQL SELECT query returns 0 rows
              ELSE coalesce((v_cur_metadata ->> 'rows_count')::NUMERIC, 0)
           END;
EXCEPTION
    -- Cursor is not opened or does not exist
    WHEN invalid_cursor_state THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';

    -- Trying to execute a REFCURSOR-sourced cursor
    WHEN invalid_cursor_definition THEN
        RAISE USING MESSAGE := 'Invalid cursor.',
                    DETAIL := 'Can not repeatedly execute a REFCURSOR-sourced cursor.',
                    HINT := '-1001';

    -- Associated SQL statement is empty (NULL) or invalid
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'No statement parsed.',
                    DETAIL := 'No valid SQL statement associated with DBMS_SQL cursor.',
                    HINT := '-1003';

    -- Effective userid (OID) changed since cursor parse
    WHEN invalid_role_specification THEN
        RAISE USING MESSAGE := 'Effective userid is not the same as when cursor was parsed.',
                    DETAIL := 'The effective userid on this call to DBMS_SQL is not the same as that at the time the cursor was parsed.',
                    HINT := '-29470';

    -- Actual and declared base data types of a column do not match
    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := format('Inconsistent datatypes: expected %s got %s.',
                                      v_datatypes_rec.def_data_type,
                                      v_datatypes_rec.cur_data_type),
                    DETAIL := format('Actual and declared data types for column in position %s do not match.',
                                     v_datatypes_rec.column_pos),
                    HINT := '-932';

    -- Undefined parameter in dynamic SELECT statement
    WHEN undefined_parameter THEN
        IF (v_sql_function_code = 4) -- SELECT
        THEN
            -- Not all variables bound
            RAISE USING MESSAGE := 'Not all variables bound.',
                        DETAIL := 'SQL statement (PL/pgSQL block) containing bind variables was attempted to execute without all variables bound.',
                        HINT := '-1008';
        ELSE RAISE;
        END IF;

    -- Some syntax error occurred
    WHEN syntax_error THEN
        GET STACKED DIAGNOSTICS
            v_err_message = MESSAGE_TEXT,
            v_err_stack = PG_EXCEPTION_CONTEXT;

        IF ((v_err_message ~* '^syntax error at or near ":|\$\d+"$' OR
             v_err_message ~* '^"\$\d+" is not a known variable$') AND
             v_sql_cmd_type IN ('DML', 'SCL'))
        THEN
            IF (v_sql_cmd_type = 'DML')
            THEN
                -- Not all variables bound
                RAISE USING MESSAGE := 'Not all variables bound.',
                            DETAIL := 'SQL statement (PL/pgSQL block) containing bind variables was attempted to execute without all variables bound.',
                            HINT := '-1008';
            ELSIF (v_sql_cmd_type = 'SCL')
            THEN
                -- Bind variables not allowed for SCL
                RAISE USING MESSAGE := 'Bind variables not allowed for SCL operations.',
                            DETAIL := 'Bind variables are not allowed for session control language operations.',
                            HINT := '-1027';
            END IF;
        ELSIF (v_sql_function_code = 27) -- EXPLAIN
        THEN
            -- Invalid EXPLAIN statement
            RAISE USING MESSAGE := 'EXPLAIN statement is not valid.',
                        DETAIL := 'EXPLAIN statement contains syntax or execution errors.',
                        HINT := 'Correct the statement and try to perform `dbms_sql$execute` procedure again.';
        ELSE
            RAISE USING MESSAGE := 'Syntax error has occured while trying to execute dynamic SQL statement.',
                        DETAIL := concat(v_err_message, '.'),
                        HINT := concat_ws(chr(10), '(Call Stack)', v_err_stack);
        END IF;
END;
]]></complex-attribute>
                        <category _I_D="c8bc09dc-2ad3-430d-80e1-e450e2b4d64b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0a46dbab-eb20-46f5-ad35-7043b6276509" name="dbms_sql$execute_and_fetch" is-trigger-function="0" unique-function-name="dbms_sql$execute_and_fetch" is-aggregate="f" language-name="plpgsql" context="dbms_sql$execute_and_fetch" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,boolean" comment="This function executes the given cursor and fetches rows. Raise an exception if the number of rows matching the query differs from one." is-returning-set="f" ret-datatype="numeric" function-arguments="p_cursor_id integer, p_exact_match boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22358" volatility="VOLATILE" is-window="f" function-identity-arguments="p_cursor_id integer, p_exact_match boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$execute_and_fetch(p_cursor_id integer, p_exact_match boolean)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_cur_metadata JSONB;
    v_rows_count INTEGER;
    v_rows_fetched INTEGER;
BEGIN
    -- Executing a statement associated with the given cursor
    PERFORM aws_oracle_ext.dbms_sql$execute(p_cursor_id);

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    -- Getting the count of rows of a statement after it has been executed
    v_rows_count := coalesce((v_cur_metadata ->> 'rows_count')::INTEGER, 0);

    -- Fetching a row from the given cursor
    v_rows_fetched := aws_oracle_ext.dbms_sql$fetch_rows(p_cursor_id);

    /* Raise an exception if the number of rows actually matching the query differs from 1.
       This behaviour is actual if "p_exact_match" param passed value is TRUE.
       -----------------------------------------------------------------------
       "ORA-01403: no data found" - if `v_rows_count` value is NULL or zero.
       "ORA-01422: exact fetch returns more than requested number of rows" - if `v_rows_count` value is more than one.
    */
    IF (p_exact_match)
    THEN
        IF (v_rows_count > 1)
        THEN
            -- ORA-01422
            RAISE too_many_rows;
        ELSIF (coalesce(v_rows_count, 0) = 0)
        THEN
            -- ORA-01403
            RAISE no_data_found;
        END IF;
    END IF;

    RETURN v_rows_fetched;
EXCEPTION
    -- Cursor fetch returns more than one row
    WHEN too_many_rows THEN
        RAISE USING MESSAGE := 'Exact fetch returns more than requested number of rows.',
                    DETAIL := 'The number specified in exact fetch is less than the rows returned.',
                    HINT := '-1422';

    -- Fetch from cursor results in zero rows
    WHEN no_data_found THEN
        RAISE USING MESSAGE := 'No data found.',
                    DETAIL := 'Fetch from cursor results in zero rows.',
                    HINT := '-1403';
END;
]]></complex-attribute>
                        <category _I_D="70e3d687-4b08-47ad-82cd-db4b9725d596" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ed436a63-815e-408c-bc46-4ec3aa37cf00" name="dbms_sql$fetch_rows" is-trigger-function="0" unique-function-name="dbms_sql$fetch_rows" is-aggregate="f" language-name="plpgsql" context="dbms_sql$fetch_rows" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer" comment="This function fetches a row from a given cursor, and returns the number of rows actually fetched." is-returning-set="f" ret-datatype="numeric" function-arguments="p_cursor_id integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22361" volatility="VOLATILE" is-window="f" function-identity-arguments="p_cursor_id integer" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$fetch_rows(p_cursor_id integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_cur_metadata JSONB;
    v_curr_row INTEGER;
    v_rows_count INTEGER;
    v_datatypes_rec RECORD;
    v_defcols_hash VARCHAR;
    v_last_row_count INTEGER;
    v_defcols_prevhash VARCHAR;
    v_current_user_oid BIGINT;
    v_rows_fetched INTEGER := 0;
BEGIN
    -- Checking that cursor is opened (exit if it is not)
    IF (NOT aws_oracle_ext.dbms_sql$is_open(p_cursor_id)) THEN
        RAISE invalid_cursor_state;
    END IF;

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    -- Obtaining current user OID
    v_current_user_oid := aws_oracle_ext.get_user_oid_by_name(current_user);

    /* Checking that effective user OID (current_user) of the caller on this cursor is the same
       as that of the caller of the most recent parse operation on this cursor.
       Actual for cursors opened with security level 2 */
    IF ((v_cur_metadata ->> 'security_level')::SMALLINT = 2 AND
        (v_cur_metadata ->> 'parse_user_oid')::BIGINT != v_current_user_oid)
    THEN
        RAISE invalid_role_specification;
    END IF;

    /* Additional check and operations if cursor
       was transformed from a REFCURSOR */
    IF ((v_cur_metadata ->> 'from_refcursor')::BOOLEAN) THEN
        -- Getting defined columns data hash
        v_defcols_hash := md5(v_cur_metadata ->> 'defcols_data');

        IF (v_defcols_hash IS NOT NULL AND
            v_defcols_hash != coalesce(v_cur_metadata ->> 'defcols_hash', ''))
        THEN
            -- Setting `defcols_hash` (JSON) cursor property
            v_cur_metadata := jsonb_set(v_cur_metadata, '{defcols_hash}', to_jsonb(v_defcols_hash));

            BEGIN
                /* Checking for correspondence between actual and declared column base data types
                   Oracle ORA-00932: INCONSISTENT_TYPE error is raised if the type of the given OUT parameter value
                   is different from the actual type of the value.
                   This type was the given type when the column was defined by calling `dbms_sql$define_column`.
                */
                FOR v_datatypes_rec IN
                (SELECT curcol.column_pos,
                        curcol.data_type AS cur_data_type,
                        defcol.data_type AS def_data_type
                   FROM dbms_sql$cursor_column AS curcol
                        INNER JOIN dbms_sql$define_column AS defcol ON (defcol.cursor_id = curcol.cursor_id AND
                                                                        defcol.column_pos = curcol.column_pos AND
                                                                        (defcol.base_type != curcol.base_type OR
                                                                         defcol.data_type IN ('TIMESTAMP WITHOUT TIME ZONE',
                                                                                              'TIMESTAMP WITH TIME ZONE') AND
                                                                         curcol.data_type IN ('TIME WITHOUT TIME ZONE',
                                                                                              'TIME WITH TIME ZONE')) AND
                                                                        coalesce(defcol.is_fixed, 0) != 1)
                  WHERE curcol.cursor_id = p_cursor_id)
                LOOP
                    -- Data types TIMESTAMP WITHOUT TIME ZONE and TIMESTAMP WITH TIME ZONE are interconvertible, thus they should not generate an error
                    CONTINUE WHEN substring(v_datatypes_rec.cur_data_type, 1, 14) = substring(v_datatypes_rec.def_data_type, 1, 14);

                    RAISE datatype_mismatch;
                END LOOP;
            EXCEPTION
                WHEN insufficient_privilege THEN
                    -- Effective userid changed
                    RAISE invalid_cursor_state;
            END;
        END IF;

        -- Getting `last_row_count` variable value
        v_last_row_count := nullif(current_setting('sct$dbms_sql.last_row_count', true), '');

        -- Setting `last_row_count` variable
        PERFORM set_config('sct$dbms_sql.last_row_count', (v_last_row_count + 1)::TEXT, false);
    END IF;

    -- Perform fetching while there are rows to fetch
    IF (coalesce((v_cur_metadata ->> 'curr_row')::INTEGER, 0) <= (v_cur_metadata ->> 'rows_count')::INTEGER)
    THEN
        -- Fetch: 1 {curr_row < rows_count}, 0 {curr_row = rows_count}
        v_rows_fetched := (coalesce((v_cur_metadata ->> 'curr_row')::INTEGER, 0) < (v_cur_metadata ->> 'rows_count')::INTEGER)::INTEGER;

        -- Setting `curr_row` (JSON) cursor property
        v_cur_metadata := jsonb_set(v_cur_metadata, '{curr_row}', to_jsonb(coalesce((v_cur_metadata ->> 'curr_row')::INTEGER, 0) + 1));
    ELSE
        -- ORA-01002: fetch out of sequence
        RAISE null_value_not_allowed;
    END IF;

    -- Saving cursor metadata (JSON) object
    PERFORM set_config(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id),
                       v_cur_metadata::TEXT,
                       false);

    RETURN v_rows_fetched;
EXCEPTION
    -- Cursor is not opened or does not exist
    WHEN invalid_cursor_state THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';

    -- Actual and declared base data types of a column do not match
    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := format('Inconsistent datatypes: expected %s got %s.',
                                      v_datatypes_rec.def_data_type,
                                      v_datatypes_rec.cur_data_type),
                    DETAIL := format('Actual and declared data types for column in position %s do not match.',
                                     v_datatypes_rec.column_pos),
                    HINT := '-932';

    -- Fetch from invalid cursor
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Fetch out of sequence.',
                    DETAIL := 'A fetch has been attempted from a cursor which is no longer valid.',
                    HINT := '-1002';

    -- Effective userid (OID) changed since cursor parse
    WHEN invalid_role_specification THEN
        RAISE USING MESSAGE := 'Effective userid is not the same as when cursor was parsed.',
                    DETAIL := 'The effective userid on this call to DBMS_SQL is not the same as that at the time the cursor was parsed.',
                    HINT := '-29470';
END;
]]></complex-attribute>
                        <category _I_D="cbf2d090-59ab-4918-8e89-96c3bfc6305b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d00bacfd-7bb0-4793-9906-b09bd4e06a94" name="dbms_sql$init" is-trigger-function="0" unique-function-name="dbms_sql$init" is-aggregate="f" language-name="plpgsql" context="dbms_sql$init" subcategories-loading="none" object-loading="extended" comment="The function initializes DBMS_SQL package and creates all necessary temporary tables required for this emulation solution." is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22363" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$init()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    -- Creating all necessary temp tables if they're not created before
    IF (NOT coalesce(nullif(current_setting('sct$dbms_sql.temp_tables_init', true), ''), 'false')::BOOLEAN)
    THEN
        -- Explicit tables dropping, to remove existing ones
        DROP TABLE IF EXISTS dbms_sql$cursor_column CASCADE;

        DROP TABLE IF EXISTS dbms_sql$cursor CASCADE;
        
        DROP TABLE IF EXISTS dbms_sql$define_column;
        
        DROP TABLE IF EXISTS dbms_sql$bind_variable;

        DROP TABLE IF EXISTS dbms_sql$recordset;

        -- Temp table for storing cursor data (id, SQL statement etc.)
        CREATE TEMP TABLE dbms_sql$cursor
        (
            cursor_id INTEGER,
            sql_statement TEXT,
            colscount_block TEXT,
            colstype_block TEXT,
            prepdynsql_block TEXT,
            CONSTRAINT pk_cursor PRIMARY KEY (cursor_id)
        ) WITH (OIDS = false)
        ON COMMIT PRESERVE ROWS;

        -- Temp table for storing defined columns data (position, data type etc.)
        CREATE TEMP TABLE dbms_sql$define_column
        (
            cursor_id INTEGER,
            column_pos INTEGER,
            data_type VARCHAR,
            base_type VARCHAR,
            col_size INTEGER,
            is_fixed SMALLINT,
            CONSTRAINT pk_def_column PRIMARY KEY (cursor_id, column_pos),
            CONSTRAINT fk_defcol_cursor FOREIGN KEY
               (cursor_id)
                REFERENCES dbms_sql$cursor (cursor_id) ON DELETE CASCADE
        ) WITH (OIDS = false)
        ON COMMIT PRESERVE ROWS;

        -- Temp table for storing actual columns data (position, data type etc.)
        CREATE TEMP TABLE dbms_sql$cursor_column
        (
            cursor_id INTEGER,
            column_pos INTEGER,
            col_name VARCHAR,
            data_type VARCHAR,
            base_type VARCHAR,
            is_nullable BOOLEAN,
            chr_max_len INTEGER,
            chr_byte_len INTEGER,
            num_precision SMALLINT,
            num_scale SMALLINT,
            tstamp_precision SMALLINT,
            interval_type VARCHAR,
            interval_precision SMALLINT,
            CONSTRAINT pk_cur_column PRIMARY KEY (cursor_id, column_pos),
            CONSTRAINT fk_curcol_cursor FOREIGN KEY
               (cursor_id)
                REFERENCES dbms_sql$cursor (cursor_id) ON DELETE CASCADE
        ) WITH (OIDS = false)
        ON COMMIT PRESERVE ROWS;

        -- Temp table for storing binded variables data (name, data type, value etc.)
        CREATE TEMP TABLE dbms_sql$bind_variable
        (
            cursor_id INTEGER,
            var_pos INTEGER,
            var_name VARCHAR,
            var_label VARCHAR,
            data_type VARCHAR,
            base_type VARCHAR,
            var_size INTEGER,
            value_size INTEGER,
            is_fixed SMALLINT,
            chr_val TEXT,
            num_val NUMERIC,
            dprec_val DOUBLE PRECISION,
            money_val MONEY,
            tstamp_val TIMESTAMP WITHOUT TIME ZONE,
            tstamptz_val TIMESTAMP WITH TIME ZONE,
            timetz_val TIME WITH TIME ZONE,
            interval_val INTERVAL,
            bool_val BOOLEAN,
            xml_val XML,
            bin_val BYTEA,
            CONSTRAINT pk_bind_var PRIMARY KEY (cursor_id, var_name),
            CONSTRAINT fk_bindvar_cur FOREIGN KEY
               (cursor_id)
                REFERENCES dbms_sql$cursor (cursor_id) ON DELETE CASCADE
        ) WITH (OIDS = false)
        ON COMMIT PRESERVE ROWS;

        -- Temp table for storing dynamic statement execution results (parsed SQL record sets)
        CREATE TEMP TABLE dbms_sql$recordset
        (
            cursor_id INTEGER,
            rownum INTEGER,
            column_pos INTEGER,
            chr_val TEXT,
            num_val NUMERIC,
            dprec_val DOUBLE PRECISION,
            money_val MONEY,
            tstamp_val TIMESTAMP WITHOUT TIME ZONE,
            tstamptz_val TIMESTAMP WITH TIME ZONE,
            timetz_val TIME WITH TIME ZONE,
            interval_val INTERVAL,
            bool_val BOOLEAN,
            xml_val XML,
            bin_val BYTEA,
            CONSTRAINT pk_record_set PRIMARY KEY (cursor_id, rownum, column_pos),
            CONSTRAINT fk_recset_cursor FOREIGN KEY
               (cursor_id)
                REFERENCES dbms_sql$cursor (cursor_id) ON DELETE CASCADE,
            CONSTRAINT fk_recset_curcol FOREIGN KEY
               (cursor_id, column_pos)
                REFERENCES dbms_sql$cursor_column (cursor_id, column_pos)
        ) WITH (OIDS = false)
        ON COMMIT PRESERVE ROWS;

        -- Marking package "dbms_sql" as initialized
        PERFORM set_config('sct$dbms_sql.temp_tables_init', 'true', false);
    END IF;
EXCEPTION
    -- Effective userid (OID) changed
    WHEN insufficient_privilege THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';
END;
]]></complex-attribute>
                        <category _I_D="182a9bce-27b1-4d48-a559-af08b2b3ad48" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="cf245735-ece0-4773-a51c-42b557affdbd" name="dbms_sql$is_open" is-trigger-function="0" unique-function-name="dbms_sql$is_open" is-aggregate="f" language-name="plpgsql" context="dbms_sql$is_open" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer" comment="The function checks if the cursor with given cursor id (cursor_id) is currently opened. Returns TRUE if the cursor with given cursor id is opened." is-returning-set="f" ret-datatype="bool" function-arguments="p_cursor_id integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22364" volatility="VOLATILE" is-window="f" function-identity-arguments="p_cursor_id integer" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$is_open(p_cursor_id integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    -- Checking if cursor metadata (JSON) exists, thus cursor is opened
    RETURN nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '') IS NOT NULL;
END;
]]></complex-attribute>
                        <category _I_D="fd1d1f66-b1e9-4f2b-bf0c-0083a7f8812b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0afd6a45-dbe6-4313-a84a-6f919e54078c" name="dbms_sql$last_row_count" is-trigger-function="0" unique-function-name="dbms_sql$last_row_count" is-aggregate="f" language-name="plpgsql" context="dbms_sql$last_row_count" subcategories-loading="none" object-loading="extended" comment="This function returns the total number (cumulative count) of rows fetched at that point from the most recent cursor." is-returning-set="f" ret-datatype="numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22365" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$last_row_count()">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_field_name VARCHAR;
    v_cur_metadata JSONB;
    v_last_row_count INTEGER;
    v_sql_function_code SMALLINT;
    v_last_affected_cursor_id INTEGER;
BEGIN
    /* Getting the most recently changed cursor id,
       affected by DBMS_SQL procs or funcs:

       OPEN, CLOSE
       EXECUTE, EXECUTE_AND_FETCH
       TO_CURSOR_NUMBER, TO_REFCURSOR
    */
    v_last_affected_cursor_id := nullif(current_setting('sct$dbms_sql.last_affected_cursor_id', true), '');

    -- Getting `last_row_count` variable value
    v_last_row_count := nullif(current_setting('sct$dbms_sql.last_row_count', true), '');

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata',
                                                    v_last_affected_cursor_id), true), '');

    -- Getting dynamic SQL function code from cursor metadata (JSON)
    v_sql_function_code := (v_cur_metadata ->> 'sql_func_code');

    -- func_code 4 for SELECT
    v_field_name := CASE v_sql_function_code
                       WHEN 4 THEN 'curr_row'
                       ELSE 'rows_count'
                    END;

    RETURN coalesce(v_last_row_count,
                    coalesce((v_cur_metadata ->> v_field_name)::NUMERIC, 0));
END;
]]></complex-attribute>
                        <category _I_D="9b8efe1e-9ce5-4b35-be7d-e3f3d6cda57e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="73fbcb24-4fbb-44c0-8b45-a3b4f98aa4a2" name="dbms_sql$last_sql_function_code" is-trigger-function="0" unique-function-name="dbms_sql$last_sql_function_code" is-aggregate="f" language-name="plpgsql" context="dbms_sql$last_sql_function_code" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer" comment="This function returns a SQL function code of the parsed dynamic statement." is-returning-set="f" ret-datatype="numeric" function-arguments="p_cursor_id integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22366" volatility="STABLE" is-window="f" function-identity-arguments="p_cursor_id integer" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$last_sql_function_code(p_cursor_id integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_cursor_id INTEGER;
    v_sql_statement TEXT;
    v_cur_metadata JSONB;
    v_actual_cursor_id INTEGER;
    v_function_code INTEGER := 0;
    v_last_parsed_cur_id INTEGER;
    v_last_opened_cur_id INTEGER;
    v_last_cursor_func_code NUMERIC;
BEGIN
    -- Getting the most recently parsed cursor id
    v_last_parsed_cur_id := nullif(current_setting('sct$dbms_sql.last_parsed_cursor_id', true), '');

    -- Getting the most recently opened cursor id
    v_last_opened_cur_id := coalesce(nullif(current_setting('sct$dbms_sql.last_opened_cursor_id', true), '')::INTEGER, 0);

    -- Recently opened cursor id is preferred over the last parsed one
    v_actual_cursor_id := greatest(v_last_opened_cur_id, v_last_parsed_cur_id);

    -- Getting last parsed (opened) cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', v_actual_cursor_id), true), '');

    -- Getting `last_cursor_func_code` variable
    v_last_cursor_func_code := nullif(current_setting('sct$dbms_sql.last_cursor_func_code', true), '');

    IF (p_cursor_id IS NULL AND
        v_cur_metadata IS NULL AND
        v_last_cursor_func_code IS NOT NULL)
    THEN
        RETURN v_last_cursor_func_code;
    ELSE
        v_cursor_id := coalesce(p_cursor_id, v_actual_cursor_id);
    END IF;

    /* If the cursor is not opened,
       exit the function with code 0 */
    IF (NOT aws_oracle_ext.dbms_sql$is_open(v_cursor_id))
    THEN
        RETURN v_function_code;
    END IF;

    -- Getting SQL-PL/pgSQL statement by cursor id
    SELECT sql_statement
      INTO v_sql_statement
      FROM dbms_sql$cursor
     WHERE cursor_id = v_cursor_id;

    /* See list of possible function codes here:
       https://docstore.mik.ua/orelly/oracle/bipack/ch02_03.htm
    */
    IF (v_sql_statement ~* '^\s*(CREATE\s+(?:(?:GLOBAL\s+)|(?:LOCAL\s+))?TEMPORARY\s+TABLE\s+)|(CREATE\s+(?:(?:GLOBAL\s+)|(?:LOCAL\s+))?TEMP\s+TABLE\s+)|(CREATE\s+(?:UNLOGGED\s+)?TABLE\s+)')
    THEN -- CREATE TABLE
        v_function_code := 1;
    ELSIF (v_sql_statement ~* '^\s*(SET\s+ROLE)\s+')
    THEN -- SET ROLE
        v_function_code := 2;
    ELSIF (v_sql_statement ~* '^\s*INSERT\s+INTO\s+')
    THEN -- INSERT INTO
        v_function_code := 3;
    ELSIF (v_sql_statement ~* '^\s*(WITH\s+.*\s+AS\s+\(.*\s*)?SELECT\s+.*\s+FROM\s+' AND
           v_sql_statement !~* '^\s*(WITH\s+.*\s+AS\s+\(.*\s*)?SELECT\s+.*\s+INTO\s+([\$\:][[:alnum:]_$#\.]+(,\s*)?)+\s*;?\s*$')
    THEN -- [CTE ]SELECT
        v_function_code := 4;
    ELSIF (v_sql_statement ~* '^\s*UPDATE\s+.*\s+SET\s+')
    THEN -- UPDATE
        v_function_code := 5;
    ELSIF (v_sql_statement ~* '^\s*MERGE\s+INTO\s+')
    THEN -- MERGE
        v_function_code := 189;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+ROLE)\s+')
    THEN -- DROP ROLE
        v_function_code := 6;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+VIEW)\s+')
    THEN -- DROP VIEW
        v_function_code := 7;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+TABLE\s+)')
    THEN -- DROP TABLE
        v_function_code := 8;
    ELSIF (v_sql_statement ~* '^\s*(DELETE)\s+')
    THEN -- DELETE
        v_function_code := 9;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:OR\s+REPLACE\s+)?(?:TEMP\s+)?(?:TEMPORARY\s+)?VIEW)\s+')
    THEN -- CREATE (OR REPLACE) (TEMPORARY | TEMP) VIEW
        v_function_code := 10;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+USER)\s+|(DROP\s+SCHEMA)\s+')
    THEN -- DROP USER
        v_function_code := 11;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+ROLE)\s+')
    THEN -- CREATE ROLE
        v_function_code := 12;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:TEMPORARY\s+)?SEQUENCE)|(CREATE\s+(?:TEMP\s+)?SEQUENCE)\s+')
    THEN -- CREATE (TEMPORARY | TEMP) SEQUENCE
        v_function_code := 13;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+SEQUENCE)\s+')
    THEN -- ALTER SEQUENCE
        v_function_code := 14;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+SEQUENCE)\s+')
    THEN -- DROP SEQUENCE
        v_function_code := 16;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+CLUSTER)\s+')
    THEN -- CREATE CLUSTER
        v_function_code := 18;
    ELSIF (v_sql_statement ~* '^\s*CREATE\s+(USER|SCHEMA)\s+')
    THEN -- CREATE USER
        v_function_code := 19;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:UNIQUE\s+)?INDEX)|(CREATE\s+(?:BITMAP\s+)?INDEX)\s+')
    THEN -- CREATE INDEX
        v_function_code := 20;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+INDEX)\s+')
    THEN -- DROP INDEX
        v_function_code := 21;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+CLUSTER)\s+')
    THEN -- DROP CLUSTER
        v_function_code := 22;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:OR\s+REPLACE\s+)?PROCEDURE)\s+')
    THEN -- CREATE (OR REPLACE) PROCEDURE
        v_function_code := 24;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+PROCEDURE)\s+')
    THEN -- ALTER PROCEDURE
        v_function_code := 25;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+TABLE\s+)')
    THEN -- ALTER TABLE
        v_function_code := 26;
    ELSIF (v_sql_statement ~* '^\s*EXPLAIN\s+')
    THEN -- EXPLAIN
        v_function_code := 27;
    ELSIF (v_sql_statement ~* '^\s*(GRANT)\s+')
    THEN -- GRANT
        v_function_code := 28;
    ELSIF (v_sql_statement ~* '^\s*(REVOKE)\s+')
    THEN -- REVOKE
        v_function_code := 29;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:OR\s+REPLACE\s+)?(?:PUBLIC\s+)?SYNONYM)\s+')
    THEN -- CREATE (OR REPLACE) (PUBLIC) SYNONYM
        v_function_code := 30;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+(?:PUBLIC\s+)?SYNONYM)\s+')
    THEN -- DROP (PUBLIC) SYNONYM
        v_function_code := 31;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+SYSTEM)\s+')
    THEN -- ALTER SYSTEM
        v_function_code := 32;
    ELSIF (v_sql_statement ~* '^\s*(SET\s+TRANSACTION)\s+')
    THEN -- SET TRANSACTION
        v_function_code := 33;
    ELSIF (v_sql_statement ~* '^\s*SET\s+CONSTRAINT[S]?\s+')
    THEN -- SET CONSTRAINTS
        v_function_code := 90;
    ELSIF (v_sql_statement ~* '(^\s*(?:<<.+>>)?\s*(BEGIN|DECLARE)\s+)|(^\s*DO(:?\s+LANGUAGE\s+[[:alpha:]]+\s+)?\s*\$([[:alnum:]_]*)?\$\s*(:<<.+>>)?\s*)' OR
           v_sql_statement ~* '^\s*(WITH\s+.*\s+AS\s+\(.*\s*)?SELECT\s+.*\s+INTO\s+([\$\:][[:alnum:]_$#\.]+(,\s*)?)+\s*;?\s*$')
    THEN -- PL/SQL EXECUTE
        v_function_code := 34;
    ELSIF (v_sql_statement ~* '^\s*LOCK\s+')
    THEN -- LOCK
        v_function_code := 35;
    ELSIF (v_sql_statement ~* '^\s*RENAME\s+')
    THEN -- RENAME
        v_function_code := 37;
    ELSIF (v_sql_statement ~* '^\s*(COMMENT\s+ON)\s+')
    THEN -- COMMENT
        v_function_code := 38;
    ELSIF (v_sql_statement ~* '^\s*AUDIT\s+')
    THEN -- AUDIT
        v_function_code := 39;
    ELSIF (v_sql_statement ~* '^\s*NOAUDIT\s+')
    THEN -- NOAUDIT
        v_function_code := 40;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+INDEX)\s+')
    THEN -- ALTER INDEX
        v_function_code := 41;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+DATABASE)\s+')
    THEN -- CREATE DATABASE
        v_function_code := 44;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+DATABASE)\s+')
    THEN -- ALTER DATABASE
        v_function_code := 45;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:PUBLIC\s+)?ROLLBACK\s+SEGMENT)\s+')
    THEN -- CREATE (OR REPLACE) (PUBLIC) ROLLBACK SEGMENT
        v_function_code := 46;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+ROLLBACK\s+SEGMENT)\s+')
    THEN -- ALTER ROLLBACK SEGMENT
        v_function_code := 47;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+ROLLBACK\s+SEGMENT)\s+')
    THEN -- DROP ROLLBACK SEGMENT
        v_function_code := 48;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:(?:SMALLFILE\s+)|(?:BIGFILE\s+)|(?:UNDO\s+)|(?:TEMPORARY\s+))?TABLESPACE)\s+')
    THEN -- CREATE (SMALLFILE | BIGFILE | UNDO | TEMPORARY) TABLESPACE
        v_function_code := 49;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+TABLESPACE)\s+')
    THEN -- ALTER TABLESPACE
        v_function_code := 50;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+TABLESPACE)\s+')
    THEN -- DROP TABLESPACE
        v_function_code := 51;
    ELSIF (v_sql_statement ~* '^\s*ALTER\s+SESSION\s+|^\s*RESET\s+' OR
           (v_sql_statement ~* '^\s*SET\s+[[:alnum:]_$#]+\s+' AND v_sql_statement !~* '^\s*SET\s+LOCAL\s+'))
    THEN -- ALTER SESSION
        v_function_code := 52;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+USER)\s+|(ALTER\s+SCHEMA)\s+')
    THEN -- ALTER USER
        v_function_code := 53;
    ELSIF (v_sql_statement ~* '^\s*COMMIT(?:\s+WORK)?\s*$')
    THEN -- COMMIT[ WORK]
        v_function_code := 54;
    ELSIF (v_sql_statement ~* '^\s*ROLLBACK(?:\s+WORK)?\s*$')
    THEN -- ROLLBACK[ WORK]
        v_function_code := 55;
    ELSIF (v_sql_statement ~* '^\s*SAVEPOINT\s+')
    THEN -- SAVEPOINT
        v_function_code := 56;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+CONTROLFILE)\s+')
    THEN -- CREATE CONTROL FILE
        v_function_code := 57;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:OR\s+REPLACE\s+)?(?:CONSTRAINT\s+)?TRIGGER)\s+')
    THEN -- CREATE TRIGGER
        v_function_code := 59;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+TRIGGER)\s+')
    THEN -- ALTER TRIGGER
        v_function_code := 60;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+TRIGGER)\s+')
    THEN -- DROP TRIGGER
        v_function_code := 61;
    ELSIF (v_sql_statement ~* '^\s*ANALYZE\s+TABLE\s+')
    THEN -- ANALYZE TABLE
        v_function_code := 62;
    ELSIF (v_sql_statement ~* '^\s*ANALYZE\s+INDEX\s+')
    THEN -- ANALYZE INDEX
        v_function_code := 63;
    ELSIF (v_sql_statement ~* '^\s*ANALYZE\s+CLUSTER\s+')
    THEN -- ANALYZE CLUSTER
        v_function_code := 64;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+PROFILE)\s+')
    THEN -- CREATE PROFILE
        v_function_code := 65;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+PROFILE)\s+')
    THEN -- DROP PROFILE
        v_function_code := 66;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+PROFILE)\s+')
    THEN -- ALTER PROFILE
        v_function_code := 67;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+PROCEDURE)\s+')
    THEN -- DROP PROCEDURE
        v_function_code := 68;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+RESOURCE\s+COST)\s+')
    THEN -- ALTER RESOURCE COST
        v_function_code := 70;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(MATERIALIZED\s+VIEW|SNAPSHOT)\s+LOG\s+ON)\s+')
    THEN -- CREATE SNAPSHOT LOG
        v_function_code := 71;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+(MATERIALIZED\s+VIEW|SNAPSHOT)\s+LOG\s+ON)\s+')
    THEN -- ALTER SNAPSHOT LOG
        v_function_code := 72;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+(MATERIALIZED\s+VIEW|SNAPSHOT)\s+LOG\s+ON)\s+')
    THEN -- DROP SNAPSHOT LOG
        v_function_code := 73;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(MATERIALIZED\s+VIEW|SNAPSHOT))\s+')
    THEN -- CREATE SNAPSHOT
        v_function_code := 74;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+(MATERIALIZED\s+VIEW|SNAPSHOT))\s+')
    THEN -- ALTER SNAPSHOT
        v_function_code := 75;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+(MATERIALIZED\s+VIEW|SNAPSHOT))\s+')
    THEN -- DROP SNAPSHOT
        v_function_code := 76;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:OR\s+REPLACE\s+)?TYPE)\s+(?!BODY)')
    THEN -- CREATE[ OR REPLACE] TYPE
        v_function_code := 77;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+TYPE)\s+(?!BODY)')
    THEN -- DROP TYPE
        v_function_code := 78;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+ROLE)\s+')
    THEN -- ALTER ROLE
        v_function_code := 79;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+TYPE)\s+' AND v_sql_statement !~* 'BODY')
    THEN -- ALTER TYPE
        v_function_code := 80;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:OR\s+REPLACE\s+)?TYPE\s+BODY)\s+')
    THEN -- CREATE[ OR REPLACE] TYPE BODY
        v_function_code := 81;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+TYPE\s+(?:.)*\s+COMPILE\s+(?:DEBUG\s+)?BODY)')
    THEN -- ALTER TYPE COMPILE (DEBUG) BODY
        v_function_code := 82;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+TYPE\s+BODY)\s+')
    THEN -- DROP TYPE BODY
        v_function_code := 83;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+LIBRARY)\s+')
    THEN -- DROP LIBRARY
        v_function_code := 84;
    ELSIF (v_sql_statement ~* '^\s*(TRUNCATE\s+TABLE)\s+')
    THEN -- TRUNCATE TABLE
        v_function_code := 85;
    ELSIF (v_sql_statement ~* '^\s*(TRUNCATE\s+CLUSTER)\s+')
    THEN -- TRUNCATE CLUSTER
        v_function_code := 86;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+BITMAPFILE)\s+')
    THEN -- CREATE BITMAPFILE
        v_function_code := 87;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+VIEW)\s+')
    THEN -- ALTER VIEW
        v_function_code := 88;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+BITMAPFILE)\s+')
    THEN -- DROP BITMAPFILE
        v_function_code := 89;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:OR\s+REPLACE\s+)?FUNCTION\s+(?:.)*(RETURN|RETURNS))\s+')
    THEN -- CREATE (OR REPLACE) FUNCTION
        v_function_code := 91;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+FUNCTION)\s+')
    THEN -- ALTER FUNCTION
        v_function_code := 92;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+FUNCTION)\s+')
    THEN -- DROP FUNCTION
        v_function_code := 93;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:OR\s+REPLACE\s+)?PACKAGE)\s+' AND v_sql_statement !~* 'BODY')
    THEN -- CREATE (OR REPLACE) PACKAGE
        v_function_code := 94;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+PACKAGE)\s+' AND v_sql_statement !~* 'BODY')
    THEN -- ALTER PACKAGE
        v_function_code := 95;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+PACKAGE)\s+' AND v_sql_statement !~* 'BODY')
    THEN -- DROP PACKAGE
        v_function_code := 96;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:OR\s+REPLACE\s+)?PACKAGE\s+BODY)\s+')
    THEN -- CREATE (OR REPLACE) PACKAGE BODY
        v_function_code := 97;
    ELSIF (v_sql_statement ~* '^\s*(ALTER\s+PACKAGE)\s+' AND v_sql_statement ~* 'BODY')
    THEN -- ALTER PACKAGE BODY
        v_function_code := 98;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+PACKAGE\s+BODY)\s+')
    THEN -- DROP PACKAGE BODY
        v_function_code := 99;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:OR\s+REPLACE\s+)?DIRECTORY)\s+')
    THEN -- CREATE (OR REPLACE) DIRECTORY
        v_function_code := 157;
    ELSIF (v_sql_statement ~* '^\s*(DROP\s+DIRECTORY)\s+')
    THEN -- DROP DIRECTORY
        v_function_code := 158;
    ELSIF (v_sql_statement ~* '^\s*(CREATE\s+(?:OR\s+REPLACE\s+)?LIBRARY)\s+')
    THEN -- CREATE (OR REPLACE) LIBRARY
        v_function_code := 159;
    ELSIF (v_sql_statement ~* '^\s*CALL\s+')
    THEN -- CALL METHOD
        v_function_code := 170;
    ELSIF (v_sql_statement ~* '^\s*PURGE\s+RECYCLEBIN\s*[;]?\s*$')
    THEN -- PURGE RECYCLEBIN
        v_function_code := 197;
    ELSIF (v_sql_statement ~* '^\s*PURGE\s+DBA_RECYCLEBIN\s*[;]?\s*$')
    THEN -- PURGE DBA_RECYCLEBIN
        v_function_code := 198;
    ELSIF (v_sql_statement ~* '^\s*PURGE\s+TABLESPACE\s+')
    THEN -- PURGE TABLESPACE
        v_function_code := 199;
    ELSIF (v_sql_statement ~* '^\s*PURGE\s+TABLE\s+')
    THEN -- PURGE TABLE
        v_function_code := 200;
    ELSIF (v_sql_statement ~* '^\s*PURGE\s+INDEX\s+')
    THEN -- PURGE INDEX
        v_function_code := 201;
    ELSIF (v_sql_statement ~* '^\s*FLASHBACK\s+.*\s+BEFORE\s+DROP')
    THEN -- UNDROP (FLASHBACK)
        v_function_code := 202;
    ELSIF (v_sql_statement ~* '^\s*DROP\s+DATABASE\s*[;]?\s*')
    THEN -- DROP DATABASE
        v_function_code := 203;
    ELSIF (v_sql_statement ~* '^\s*CREATE\s+(?:OR\s+REPLACE\s+)?ATTRIBUTE\s+DIMENSION\s+')
    THEN -- CREATE[ OR REPLACE] ATTRIBUTE DIMENSION
        v_function_code := 243;
    ELSIF (v_sql_statement ~* '^\s*ALTER\s+ATTRIBUTE\s+DIMENSION\s+')
    THEN -- ALTER ATTRIBUTE DIMENSION
        v_function_code := 244;
    ELSIF (v_sql_statement ~* '^\s*DROP\s+ATTRIBUTE\s+DIMENSION\s+')
    THEN -- DROP ATTRIBUTE DIMENSION
        v_function_code := 245;
    ELSIF (v_sql_statement ~* '^\s*CREATE\s+(?:OR\s+REPLACE\s+)?HIERARCHY\s+')
    THEN -- CREATE[ OR REPLACE] HIERARCHY
        v_function_code := 246;
    ELSIF (v_sql_statement ~* '^\s*ALTER\s+HIERARCHY\s+')
    THEN -- ALTER HIERARCHY
        v_function_code := 247;
    ELSIF (v_sql_statement ~* '^\s*DROP\s+HIERARCHY\s+')
    THEN -- DROP HIERARCHY
        v_function_code := 248;
    ELSIF (v_sql_statement ~* '^\s*CREATE\s+(?:OR\s+REPLACE\s+)?ANALYTIC\s+VIEW\s+')
    THEN -- CREATE[ OR REPLACE] ANALYTIC VIEW
        v_function_code := 249;
    ELSIF (v_sql_statement ~* '^\s*ALTER\s+ANALYTIC\s+VIEW\s+')
    THEN -- ALTER ANALYTIC VIEW
        v_function_code := 250;
    ELSIF (v_sql_statement ~* '^\s*DROP\s+ANALYTIC\s+VIEW\s+')
    THEN -- DROP ANALYTIC VIEW
        v_function_code := 251;
    END IF;

    IF (p_cursor_id IS NULL)
    THEN
        -- Setting `last_cursor_func_code` variable
        PERFORM set_config('sct$dbms_sql.last_cursor_func_code', v_function_code::TEXT, false);
    END IF;

    RETURN v_function_code;
EXCEPTION
    -- Effective userid (OID) changed since cursor parse
    WHEN insufficient_privilege THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';
END;
]]></complex-attribute>
                        <category _I_D="73a6b06e-e58f-4d42-b285-2151c6e247d2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="737cf770-805e-4792-859a-5e7bcec77e54" name="dbms_sql$open_cursor" is-trigger-function="0" unique-function-name="dbms_sql$open_cursor" is-aggregate="f" language-name="plpgsql" context="dbms_sql$open_cursor" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" comment="The function opens up a cursor and returns a unique cursor id which lives through the session and used as a reference for processing the dynamic statement." is-returning-set="f" ret-datatype="numeric" function-arguments="p_security_level numeric DEFAULT 1" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22368" volatility="VOLATILE" is-window="f" function-identity-arguments="p_security_level numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$open_cursor(p_security_level numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_cursor_id INTEGER;
    v_security_level NUMERIC;
BEGIN
    -- Security level is 1 when passed NULL
    v_security_level := coalesce(floor(p_security_level), 1);

    -- Checking that security level lies into valid range
    IF (v_security_level NOT BETWEEN 0 AND 2)
    THEN
        RAISE numeric_value_out_of_range;
    END IF;

    -- Checking security level for allowed values
    IF (v_security_level = 0)
    THEN
        RAISE invalid_parameter_value;
    END IF;

    -- Initializing solution temp tables
    PERFORM aws_oracle_ext.dbms_sql$init();

    -- Generating unpredictable, randomized, cursor number
    WHILE (v_cursor_id IS NULL)
    LOOP
        BEGIN
            INSERT INTO dbms_sql$cursor (cursor_id)
                 VALUES (abs(aws_oracle_ext.dbms_random$random()))
              RETURNING cursor_id
                   INTO v_cursor_id;
        EXCEPTION
            WHEN insufficient_privilege THEN
                -- Effective userid changed
                RAISE invalid_role_specification;
            WHEN unique_violation THEN
                NULL;
        END;
    END LOOP;

    -- Saving cursor metadata (JSON) object
    PERFORM set_config(format('sct$dbms_sql.cursor_id_%s_metadata', v_cursor_id),
                       jsonb_build_object('cursor_id', v_cursor_id,
                                          'security_level', v_security_level,
                                          'from_refcursor', false)::TEXT,
                       false);

    -- Nulling `last_cursor_func_code` variable
    PERFORM set_config('sct$dbms_sql.last_cursor_func_code', null, false);

    -- Setting `last_opened_cursor_id` variable
    PERFORM set_config('sct$dbms_sql.last_opened_cursor_id', v_cursor_id::TEXT, false);

    -- Setting `last_affected_cursor_id` variable
    PERFORM set_config('sct$dbms_sql.last_affected_cursor_id', v_cursor_id::TEXT, false);

    -- Nulling `last_row_count` variable
    PERFORM set_config('sct$dbms_sql.last_row_count', null, false);

    RETURN v_cursor_id;
EXCEPTION
    -- Incorrect security level value
    WHEN numeric_value_out_of_range THEN
        RAISE USING MESSAGE := 'Security level is outside the valid range of 0 to 2.',
                    DETAIL := 'An invalid security level value was specified.',
                    HINT := '-29472';

    -- Disabled security level value
    WHEN invalid_parameter_value THEN
        RAISE USING MESSAGE := 'Security level of 0 is not allowed.',
                    DETAIL := 'This level of security is disabled by default.',
                    HINT := '-29474';

    -- Effective userid (OID) changed since solution initialization
    WHEN invalid_role_specification THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';
END;
]]></complex-attribute>
                        <category _I_D="675cab57-3384-4fde-ab74-311a5c55fc44" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="844eac40-6f1c-4290-a993-d55dbcd4fdb0" name="dbms_sql$parse" is-trigger-function="0" unique-function-name="dbms_sql$parse" is-aggregate="f" language-name="plpgsql" context="dbms_sql$parse" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,text,integer" comment="This function parses the given statement in the given cursor. DDL and DCL statements are run immediately when parsed." is-returning-set="f" ret-datatype="void" function-arguments="p_cursor_id integer, p_sql_statement text, p_cols_count integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22369" volatility="VOLATILE" is-window="f" function-identity-arguments="p_cursor_id integer, p_sql_statement text, p_cols_count integer" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$parse(p_cursor_id integer, p_sql_statement text, p_cols_count integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_err_message TEXT;
    v_sql_cmd_type TEXT;
    v_cur_metadata JSONB;
    v_sql_statement TEXT;
    v_statement_hash TEXT;
    v_current_user_oid BIGINT;
    v_sql_function_code SMALLINT;
BEGIN
    -- Checking that cursor is opened (exit if it is not)
    IF (NOT aws_oracle_ext.dbms_sql$is_open(p_cursor_id))
    THEN
        RAISE invalid_cursor_state;
    ELSIF (coalesce(p_sql_statement, '') = '')
    THEN
        -- ORA-06561: given statement is not supported by package DBMS_SQL
        RAISE sql_statement_not_yet_complete;
    END IF;

    -- Calculating unique statement hash
    v_statement_hash := coalesce(md5(p_sql_statement), '');

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    -- Getting dynamic SQL function code from cursor metadata (JSON)
    v_sql_function_code := (v_cur_metadata ->> 'sql_func_code');

    -- Determining SQL command type from cursor metadata (JSON)
    v_sql_cmd_type := (v_cur_metadata ->> 'sql_cmd_type');

    -- Setting SELECT statement columns count (if passed in)
    v_cur_metadata := jsonb_set(v_cur_metadata, '{cols_count}', coalesce(to_jsonb(p_cols_count), JSONB 'null'));

    -- If cursor (cursor_id) was transformed from a REFCURSOR then remove "from_refcursor" flag
    IF ((v_cur_metadata ->> 'from_refcursor')::BOOLEAN)
    THEN
        -- Setting "from_refcursor" cursor property to FALSE
        v_cur_metadata := jsonb_set(v_cur_metadata, '{from_refcursor}', JSONB 'false');
    END IF;

    -- Updating cursor info refresh flags if statement is a new one
    IF (v_statement_hash <> coalesce(v_cur_metadata ->> 'statement_hash', ''))
    THEN
        -- Setting "statement_hash" (JSON) cursor property
        v_cur_metadata := jsonb_set(v_cur_metadata, '{statement_hash}', to_jsonb(v_statement_hash));

        -- Setting "colinfo_refresh" (JSON) cursor property
        v_cur_metadata := jsonb_set(v_cur_metadata, '{colinfo_refresh}', to_jsonb(1));

        /* Removing comments from SQL statement (both single and multi-line),
           validating multi-line comment opening and closure tags */
        v_sql_statement := aws_oracle_ext.strip_sql_comments(p_sql_statement,
                                                             p_adv_quote_tags => ARRAY['$q$','$Q$'], -- Advanced quoting marker list
                                                             p_validate_multiline => true);
        BEGIN
            -- Associating SQL statement with cursor id
            UPDATE dbms_sql$cursor
               SET sql_statement = v_sql_statement
             WHERE cursor_id = p_cursor_id;
        EXCEPTION
            WHEN insufficient_privilege THEN
                -- Effective userid changed
                RAISE invalid_cursor_state;
        END;

        -- Getting dynamic SQL function code
        v_sql_function_code := aws_oracle_ext.dbms_sql$last_sql_function_code(p_cursor_id);

        -- Determining SQL command type (DDL, DML, DCL, TCL, SCL, SCS) by function code
        v_sql_cmd_type := aws_oracle_ext.get_cmd_type_by_sql_func_code(v_sql_function_code);

        -- Checking SQL statement for correctness
        IF (v_sql_cmd_type IS NULL)
        THEN
            -- ORA-00900: invalid SQL statement
            RAISE invalid_sql_statement_name;
        END IF;
    END IF;

    /* DDL and DCL statements are executed when they are parsed
       and the function DBMS_SQL.EXECUTE need not be used on them.

       Command type execution map:
       ---------------------------
       DDL - PARSE (DBMS_SQL.PARSE)
       DML - EXECUTE (DBMS_SQL.EXECUTE)
       DCL - PARSE
       TCL - EXECUTE
       SCL - EXECUTE
       SCS - EXECUTE
    */
    IF (v_sql_cmd_type IN ('DDL', 'DCL'))
    THEN
        BEGIN
            EXECUTE v_sql_statement;
        EXCEPTION
            WHEN undefined_parameter THEN
                -- ORA-01027: bind variables not allowed for DDL / DCL
                RAISE invalid_prepared_statement_definition;
            WHEN syntax_error THEN
                GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;

                -- ORA-01027: bind variables not allowed for DDL / DCL
                IF (v_err_message = 'syntax error at or near ":"')
                THEN
                    RAISE invalid_prepared_statement_definition;
                ELSE
                    -- SQL statement is not valid (with desc.)
                    RAISE invalid_sql_statement_name;
                END IF;
        END;
    END IF;

    -- Setting `last_parsed_cursor_id` variable value
    PERFORM set_config('sct$dbms_sql.last_parsed_cursor_id', p_cursor_id::TEXT, false);

    -- Setting `sql_func_code` (JSON) cursor property
    v_cur_metadata := jsonb_set(v_cur_metadata, '{sql_func_code}', to_jsonb(v_sql_function_code));

    -- Setting `sql_cmd_type` (JSON) cursor property
    v_cur_metadata := jsonb_set(v_cur_metadata, '{sql_cmd_type}', to_jsonb(v_sql_cmd_type));

    -- Obtaining current user OID
    v_current_user_oid := aws_oracle_ext.get_user_oid_by_name(current_user);

    -- Setting `parse_role_oid` (JSON) cursor property
    v_cur_metadata := jsonb_set(v_cur_metadata, '{parse_user_oid}', to_jsonb(v_current_user_oid));

    -- Saving cursor metadata (JSON) object
    PERFORM set_config(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id),
                       v_cur_metadata::TEXT, -- cursor metadata object
                       false);
EXCEPTION
    -- Cursor is not opened or does not exist
    WHEN invalid_cursor_state THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';

    -- SQL statement is empty
    WHEN sql_statement_not_yet_complete THEN
        RAISE USING MESSAGE := 'Given statement is not supported by package DBMS_SQL.',
                    DETAIL := 'Attempting to parse an unsupported SQL statement.',
                    HINT := '-6561';

    -- SQL statement is not valid
    WHEN invalid_sql_statement_name THEN
        RAISE USING MESSAGE := 'Invalid SQL statement.',
                    DETAIL := 'The statement is not recognized as a valid SQL statement or PL/pgSQL block.',
                    HINT := '-900';

    -- Bind variables not allowed for DDL / DCL
    WHEN invalid_prepared_statement_definition THEN
        RAISE USING MESSAGE := 'Bind variables not allowed for data definition operations.',
                    DETAIL := 'Bind variables are not allowed for both DDL and DCL operations.',
                    HINT := '-1027';
END;
]]></complex-attribute>
                        <category _I_D="2cabb4d1-fbd6-45a6-bf2a-ea644b5a0832" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e6ad02f6-68e9-468f-8695-f3f823e90bb4" name="dbms_sql$to_cursor_number" is-trigger-function="0" unique-function-name="dbms_sql$to_cursor_number" is-aggregate="f" language-name="plpgsql" context="dbms_sql$to_cursor_number" subcategories-loading="none" object-loading="extended" arguments-datatypes="refcursor" comment="This function takes an opened REFCURSOR and transforms it into a DBMS_SQL cursor number. Once the REFCURSOR is transformed into a DBMS_SQL cursor number, the REFCURSOR is no longer accessible by any native dynamic SQL operations." is-returning-set="f" ret-datatype="int4" function-arguments="p_refcursor refcursor" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22371" volatility="VOLATILE" is-window="f" function-identity-arguments="p_refcursor refcursor" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$to_cursor_number(p_refcursor refcursor)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_cur_metadata JSONB;
    v_curcols_data JSONB;
    v_cursor_id INTEGER;
    v_sql_statement TEXT;
    v_cols_count SMALLINT;
    v_col_names1 TEXT;
    v_col_names2 TEXT;
    v_col_aliases TEXT;
    v_colstype_block TEXT;
    v_prepdynsql_block TEXT;
    v_coldtype_cases TEXT;
    v_err_message TEXT;
    v_err_stack TEXT;
    v_refcur_rec RECORD;
    v_refcur_rec_json JSONB;
    v_is_scrollable BOOLEAN;
    v_last_row_count INTEGER;
    v_colstype_table_name TEXT;
    v_debug_mode SMALLINT := 0; -- {1:ON, 0:OFF}. If set to "ON", engine logs all dynamically generated scripts into `dbms_sql$cursor` table
BEGIN
    -- Extracting REFRUCSOR metadata
    BEGIN
        SELECT statement,
               is_scrollable
          INTO STRICT
               v_sql_statement,
               v_is_scrollable
          FROM pg_catalog.pg_cursors
         WHERE name = p_refcursor::TEXT;
    EXCEPTION
        WHEN OTHERS THEN
        -- ORA-01001: invalid cursor
        RAISE invalid_cursor_state;
    END;

    -- Getting `last_row_count` variable value
    v_last_row_count := nullif(current_setting('sct$dbms_sql.last_row_count', true), '');

    /* Fetching row into record from REFCURSOR
       in order to determine columns count */
    IF (v_is_scrollable) THEN
        FETCH NEXT
         FROM p_refcursor
         INTO v_refcur_rec;

        MOVE BACKWARD
        FROM p_refcursor;
    ELSE
        FETCH FIRST
         FROM p_refcursor
         INTO v_refcur_rec;
    END IF;

    -- Getting REFCURSOR columns count
    SELECT COUNT(1)
      INTO v_cols_count
      FROM json_object_keys(row_to_json(v_refcur_rec));

    -- Opening new DBMS_SQL cursor for data storage
    v_cursor_id := aws_oracle_ext.dbms_sql$open_cursor();

    -- Assigning SQL statement and exact columns count to DBMS_SQL cursor
    PERFORM aws_oracle_ext.dbms_sql$parse(v_cursor_id, v_sql_statement, v_cols_count);

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', v_cursor_id), true), '');

    -- Generating list of column names
    SELECT string_agg(format('outer_block.v_refcur_rec."%s"', colname),
                      concat(',', chr(10), repeat(' ', 7))),
           string_agg(format('      outer_block.v_refcur_rec."%s"', colname),
                      concat(',', chr(10)))
      INTO v_col_names1,
           v_col_names2
      FROM json_object_keys(row_to_json(v_refcur_rec)) AS colname;

    -- Generating unique temp table name
    v_colstype_table_name :=
        format('dynsql_colstype_%s',
               lower(substring((SELECT string_agg(md5(random()::TEXT), '')
                                  FROM generate_series(1, ceil(14 / 32.)::INTEGER)
                               ), 1, 14)));

    -- Determining REFCURSOR column data types
    v_colstype_block :=
        concat_ws(chr(10),
            'DO $dbms_sql$',
            '<<outer_block>>',
            'DECLARE',
            '    v_refcur_rec RECORD;',
            format('    v_cursor_id INTEGER := %s;', v_cursor_id),
            format('    v_is_scrollable BOOLEAN := %s;',
            CASE
               WHEN v_is_scrollable THEN 'true'
               ELSE 'false'
            END),
            format('    v_refcursor REFCURSOR := %s;', quote_literal(p_refcursor)),
            'BEGIN',
            '-- Fetching row into RECORD variable',
            'IF (outer_block.v_is_scrollable) THEN',
            '    FETCH NEXT',
            '     FROM outer_block.v_refcursor',
            '     INTO outer_block.v_refcur_rec;',
            '',
            '    MOVE BACKWARD',
            '    FROM outer_block.v_refcursor;',
            'ELSE',
            '    FETCH FIRST',
            '     FROM outer_block.v_refcursor',
            '     INTO outer_block.v_refcur_rec;',
            'END IF;',
            '',
            '-- Creating temp table in order to reflect the columns structure',
            format('CREATE TEMP TABLE %s', v_colstype_table_name),
            'WITH (OIDS = false)',
            'ON COMMIT DROP',
            'AS',
            concat('SELECT ', v_col_names1),
            'WITH NO DATA;',
            '',
            concat_ws(chr(10), '-- Saving detailed column data (name, type, precision, etc.)',
            'INSERT INTO dbms_sql$cursor_column (cursor_id,',
            '                                    column_pos,',
            '                                    col_name,',
            '                                    data_type,',
            '                                    base_type,',
            '                                    is_nullable,',
            '                                    chr_max_len,',
            '                                    chr_byte_len,',
            '                                    num_precision,',
            '                                    num_scale,',
            '                                    tstamp_precision,',
            '                                    interval_type,',
            '                                    interval_precision)',
            'SELECT outer_block.v_cursor_id,',
            '       ordinal_position,',
            '       column_name,',
            '       upper(data_type),',
            '       aws_oracle_ext.get_base_type_by_dtype(upper(data_type)),',
            '       CASE is_nullable',
            '          WHEN ''YES'' THEN TRUE',
            '          ELSE FALSE',
            '       END,',
            '       character_maximum_length,',
            '       character_octet_length,',
            '       numeric_precision,',
            '       numeric_scale,',
            '       datetime_precision,',
            '       interval_type,',
            '       interval_precision',
            '  FROM information_schema.columns'),
            format(' WHERE table_name = ''%s''', v_colstype_table_name),
            ' ORDER BY ordinal_position ASC;',
            '',
            '-- Dropping temp table since its not needed anymore',
            format('DROP TABLE %s;', v_colstype_table_name),
            'END; $dbms_sql$');

    EXECUTE v_colstype_block; -- Will be saved into `dbms_sql$cursor` table if "v_debug_mode" is set to "ON" (1)

    -- Serializing dynamic statement columns data into JSON object
    SELECT jsonb_object_agg(concat('col_', curcol_data.column_pos),
                            curcol_data.column_data)
      INTO v_curcols_data
      FROM (SELECT curcol3.column_pos,
                   (SELECT to_jsonb(curcol2.*)
                      FROM (SELECT curcol1.data_type,
                                   curcol1.base_type,
                                   curcol1.chr_max_len,
                                   curcol1.chr_byte_len
                              FROM dbms_sql$cursor_column AS curcol1
                             WHERE curcol1.cursor_id = curcol3.cursor_id
                               AND curcol1.column_pos = curcol3.column_pos
                           ) AS curcol2
                   ) AS column_data
              FROM dbms_sql$cursor_column AS curcol3
             WHERE curcol3.cursor_id = v_cursor_id
           ) AS curcol_data;

    -- Setting `curcols_data` (JSON) cursor property
    v_cur_metadata := jsonb_set(v_cur_metadata, '{curcols_data}', v_curcols_data);

    -- Setting `from_refcursor` (JSON) cursor property
    v_cur_metadata := jsonb_set(v_cur_metadata, '{from_refcursor}', JSONB 'true');

    -- Saving cursor metadata (JSON) object
    PERFORM set_config(format('sct$dbms_sql.cursor_id_%s_metadata', v_cursor_id),
                       v_cur_metadata::TEXT, -- cursor metadata object
                       FALSE);

    /* Constructing CASEs to distribute dynamic query execution results
       through INSERT-SELECT into `dbms_sql$recordset` table */
    WITH dtypes_order AS
    (SELECT 'TEXT' AS base_type, 1 AS dtype_order
      UNION ALL
     SELECT 'NUMERIC', 2
      UNION ALL
     SELECT 'DOUBLE PRECISION', 3
      UNION ALL
     SELECT 'MONEY', 4
      UNION ALL
     SELECT 'TIMESTAMP WITHOUT TIME ZONE', 5
      UNION ALL
     SELECT 'TIMESTAMP WITH TIME ZONE', 6
      UNION ALL
     SELECT 'TIME WITH TIME ZONE', 7
      UNION ALL
     SELECT 'INTERVAL', 8
      UNION ALL
     SELECT 'BOOLEAN', 9
      UNION ALL
     SELECT 'XML', 10
      UNION ALL
     SELECT 'BYTEA', 11),
     -- Attaching current columns data
     curcols_data AS
     (SELECT base_type,
             array_agg(concat_ws(':', column_pos, data_type)) AS colpos_list
        FROM dbms_sql$cursor_column
       WHERE cursor_id = v_cursor_id
       GROUP BY base_type)

     SELECT string_agg(
            coalesce('       CASE colpos' || chr(10) ||
            (SELECT string_agg(format('          WHEN %s THEN %s',
                                      colpos,
                                      CASE dtype
                                         WHEN 'TIME WITHOUT TIME ZONE' -- List of types that require special conversion
                                         THEN format('to_char(col_%s, ''2001-01-01 hh24:mi:ss.us'')::TIMESTAMP', colpos)
                                         ELSE 'col_' || colpos
                                      END),
                               chr(10))
               FROM (SELECT substring(colpos, '^(\d+):?') AS colpos,
                            substring(colpos, ':(.+)$') AS dtype
                      FROM unnest(cdt.colpos_list) AS colpos) AS cols) || chr(10) || '       END',
                               '       null'),
            ',' || chr(10) ORDER BY dto.dtype_order ASC)
       INTO v_coldtype_cases
       FROM dtypes_order dto
            LEFT JOIN curcols_data cdt ON (cdt.base_type = dto.base_type);

    -- Generating list of consecutive column aliases (col_1, col_2, ...)
    SELECT string_agg(concat(repeat(' ', 29), 'col_', colnum),
                      concat(',', chr(10)))
      INTO v_col_aliases
      FROM generate_series(1, v_cols_count) AS colnum;

    -- Distributing REFRUCSOR data into `dbms_sql$recordset` table
    v_prepdynsql_block :=
        concat_ws(chr(10),
            'DO $dbms_sql$',
            '<<outer_block>>',
            'DECLARE',
            '    v_cur_metadata JSONB;',
            '    v_refcur_rec RECORD;',
            format('    v_cursor_id INTEGER := %s;', v_cursor_id),
            format('    v_cols_count SMALLINT := %s;', v_cols_count),
            '    v_rows_fetched INTEGER := 0;',
            format('    v_is_scrollable BOOLEAN := %s;',
            CASE
               WHEN v_is_scrollable THEN 'true'
               ELSE 'false'
            END),
            format('    v_refcursor REFCURSOR := %s;', quote_literal(p_refcursor)),
            'BEGIN',
            'LOOP',
            '-- Fetching row into RECORD variable',
            'IF (outer_block.v_rows_fetched = 0 AND',
            '    NOT outer_block.v_is_scrollable)',
            'THEN',
            '    FETCH FIRST',
            '     FROM outer_block.v_refcursor',
            '     INTO outer_block.v_refcur_rec;',
            'ELSE',
            '    FETCH NEXT',
            '     FROM outer_block.v_refcursor',
            '     INTO outer_block.v_refcur_rec;',
            'END IF;',
            '',
            '-- Exit when no more rows to fetch',
            'EXIT WHEN NOT FOUND;',
            'outer_block.v_rows_fetched := outer_block.v_rows_fetched + 1;',
            '',
            '-- Inserting column value into "dbms_sql$recordset" table',
            'EXECUTE',
            quote_literal(concat_ws(chr(10),
            'INSERT INTO dbms_sql$recordset (cursor_id,',
            '                                 rownum,',
            '                                 column_pos,',
            '                                 chr_val,',
            '                                 num_val,',
            '                                 dprec_val,',
            '                                 money_val,',
            '                                 tstamp_val,',
            '                                 tstamptz_val,',
            '                                 timetz_val,',
            '                                 interval_val,',
            '                                 bool_val,',
            '                                 xml_val,',
            '                                 bin_val)',
            ' SELECT $1,',
            '        $2,',
            '        colpos,',
            v_coldtype_cases, -- Coltypes distribution CASEs
            '   FROM (SELECT generate_series(1, $3) AS colpos,',
            '                dynsql.*',
            concat('           FROM (SELECT ',
            (SELECT string_agg(concat('$', col_num), concat(',', chr(10), repeat(' ', 24)))
               FROM generate_series(4, v_cols_count + 3) AS col_num)), -- List of consecutive column placeholders ($4, $5, ...)
            format('                ) AS dynsql (%s)', trim(v_col_aliases)), -- List of consecutive column aliases
            '        ) AS dynsql2')),
            'USING outer_block.v_cursor_id,',
            '      outer_block.v_rows_fetched,',
            '      outer_block.v_cols_count,',
            concat(v_col_names2, ';'),
            'END LOOP;',
            '',
            '-- Getting cursor metadata (JSON) object',
            'outer_block.v_cur_metadata :=',
            '    nullif(current_setting(format(''sct$dbms_sql.cursor_id_%s_metadata'',',
            '                                  outer_block.v_cursor_id), true), '''');',
            '',
            '-- Setting "rows_count" (JSON) cursor property',
            'outer_block.v_cur_metadata := jsonb_set(outer_block.v_cur_metadata, ''{rows_count}'',',
            '                                        to_jsonb(outer_block.v_rows_fetched));',
            '',
            '-- Saving cursor metadata (JSON) object',
            'PERFORM set_config(format(''sct$dbms_sql.cursor_id_%s_metadata'', outer_block.v_cursor_id),',
            '                   outer_block.v_cur_metadata::TEXT, -- cursor metadata object',
            '                   false);',
            'END; $dbms_sql$');

    EXECUTE v_prepdynsql_block; -- Will be saved into `dbms_sql$cursor` table if "v_debug_mode" is set to "ON" (1)

    -- Closing source REFCURSOR
    CLOSE p_refcursor;

    /* Logging of all dynamically generated scripts
       into `dbms_sql$cursor` if debug mode is "ON" */
    IF (v_debug_mode) THEN
        UPDATE dbms_sql$cursor
           SET colstype_block = v_colstype_block,
               prepdynsql_block = v_prepdynsql_block
         WHERE cursor_id = v_cursor_id;
    END IF;

    -- Setting `last_affected_cursor_id` variable
    PERFORM set_config('sct$dbms_sql.last_affected_cursor_id', v_cursor_id::TEXT, false);

    -- Setting `last_row_count` variable
    PERFORM set_config('sct$dbms_sql.last_row_count', v_last_row_count::TEXT, false);

    RETURN v_cursor_id;
EXCEPTION
    -- The REFCURSOR is not opened or NULL
    WHEN invalid_cursor_state THEN
        RAISE USING MESSAGE := 'Invalid cursor.',
                    DETAIL := 'Could not transform a not opened REFCURSOR into DBMS_SQL cursor number.',
                    HINT := '-1001';

    -- Duplicate column names in REFCURSOR
    WHEN duplicate_column THEN
        RAISE USING MESSAGE := 'Duplicate column name.',
                    DETAIL := 'The same column name was listed in REFCURSOR more than once, or some columns do not have assigned names.',
                    HINT := '-957';

    -- Some syntax error occurred
    WHEN syntax_error THEN
        GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT,
                                v_err_stack = PG_EXCEPTION_CONTEXT;

        RAISE USING MESSAGE := 'Syntax error has occured while trying to transform REFCURSOR into a DBMS_SQL cursor number.',
                    DETAIL := concat(v_err_message, '.'),
                    HINT := concat('(Call Stack)', chr(10), v_err_stack);
END;
]]></complex-attribute>
                        <category _I_D="1e12a8c7-cb2b-4769-8fc2-451817f41317" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="16a98a00-63b8-4644-bb8f-879e1181e738" name="dbms_sql$to_refcursor" is-trigger-function="0" unique-function-name="dbms_sql$to_refcursor" is-aggregate="f" language-name="plpgsql" context="dbms_sql$to_refcursor" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer" comment="This function takes an opened, parsed and executed cursor and transforms/migrates it into a PL/pgSQL manageable REFCURSOR that can be consumed by any PL/pgSQL function. This subprogram is only used with SELECT cursors." is-returning-set="f" ret-datatype="refcursor" function-arguments="p_cursor_id integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22373" volatility="VOLATILE" is-window="f" function-identity-arguments="p_cursor_id integer" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$to_refcursor(p_cursor_id integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_cur_metadata JSONB;
    v_curr_row INTEGER;
    v_rows_fetched INTEGER;
    v_coldtype_casts VARCHAR;
    v_colnames_cases VARCHAR;
    v_colnames_list VARCHAR;
    v_resrecset_sql TEXT;
    v_current_user_oid BIGINT;
    v_sql_function_code SMALLINT;
    v_res_refcursor REFCURSOR := format('sct-dbms_sql$cur_id_%s_recset', p_cursor_id);
BEGIN
    -- Checking that cursor is opened (exit if it is not)
    IF (NOT aws_oracle_ext.dbms_sql$is_open(p_cursor_id)) THEN
        RAISE invalid_cursor_state;
    END IF;

    -- Obtaining current user OID
    v_current_user_oid := aws_oracle_ext.get_user_oid_by_name(current_user);

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    /* Checking that effective user OID (current_user) of the caller on this cursor is the same
       as that of the caller of the most recent parse operation on this cursor.
       Actual for cursors opened with security level 2 */
    IF ((v_cur_metadata ->> 'security_level')::SMALLINT = 2 AND
        (v_cur_metadata ->> 'parse_user_oid')::BIGINT != v_current_user_oid)
    THEN
        RAISE invalid_role_specification;
    END IF;

    -- Getting dynamic SQL function code
    v_sql_function_code := aws_oracle_ext.dbms_sql$last_sql_function_code(p_cursor_id);

    /* Cursor rows count should not be empty (NULL),
       or of type other than SELECT (func_code 4) */
    IF ((v_cur_metadata ->> 'rows_count') IS NULL OR
         v_sql_function_code != 4)
    THEN
        -- ORA-01001: invalid cursor
        RAISE null_value_not_allowed;
    END IF;

    -- Getting num of rows already fetched from DBMS_SQL cursor
    v_rows_fetched := coalesce((v_cur_metadata ->> 'curr_row')::INTEGER, 0);

    BEGIN
        -- Getting column info (list of names, data type casts, column position cases)
        SELECT string_agg(format('CAST("%s" AS %s)',
                                 col_name,
                                 CASE
                                    WHEN data_type IN ('CHARACTER',
                                                       'CHARACTER VARYING')
                                    THEN concat(data_type, '(' || chr_max_len || ')')
                                    WHEN (data_type ~* '^\s*TIME' OR
                                          data_type = 'INTERVAL')
                                    THEN format(CASE data_type
                                                   WHEN 'TIMESTAMP WITHOUT TIME ZONE' THEN 'TIMESTAMP(%s) WITHOUT TIME ZONE'
                                                   WHEN 'TIMESTAMP WITH TIME ZONE' THEN 'TIMESTAMP(%s) WITH TIME ZONE'
                                                   WHEN 'TIME WITHOUT TIME ZONE' THEN 'TIME(%s) WITHOUT TIME ZONE'
                                                   WHEN 'TIME WITH TIME ZONE' THEN 'TIME(%s) WITH TIME ZONE'
                                                   ELSE 'INTERVAL(%s)'
                                                END, /* default precision for time fraction is 6 */
                                                coalesce(tstamp_precision, interval_precision, 6))
                                    ELSE data_type
                                 END),
                          concat(',', chr(10), repeat(' ', 7))),
               string_agg(format(concat_ws(chr(10),
                                           '(array_agg(CASE column_pos',
                                           repeat(' ', 28) || 'WHEN %s THEN %s',
                                           repeat(' ', 26) || 'END))[%s]'),
                                 column_pos,
                                 CASE base_type
                                    WHEN 'TEXT' THEN 'chr_val'
                                    WHEN 'NUMERIC' THEN 'num_val'
                                    WHEN 'DOUBLE PRECISION' THEN 'dprec_val'
                                    WHEN 'MONEY' THEN 'money_val'
                                    WHEN 'TIMESTAMP WITHOUT TIME ZONE' THEN 'tstamp_val'
                                    WHEN 'TIMESTAMP WITH TIME ZONE' THEN 'tstamptz_val'
                                    WHEN 'TIME WITH TIME ZONE' THEN 'timetz_val'
                                    WHEN 'INTERVAL' THEN 'interval_val'
                                    WHEN 'BOOLEAN' THEN 'bool_val'
                                    WHEN 'XML' THEN 'xml_val'
                                    WHEN 'BYTEA' THEN 'bin_val'
                                 END,
                                 column_pos),
                          concat(',', chr(10), repeat(' ', 15))),
               string_agg(format('"%s"', col_name),
                          concat(',', chr(10), repeat(' ', 24)))
          INTO v_coldtype_casts,
               v_colnames_cases,
               v_colnames_list -- Comma-separated list of column names
          FROM dbms_sql$cursor_column
         WHERE cursor_id = p_cursor_id;
    EXCEPTION
        WHEN insufficient_privilege THEN
            -- Effective userid changed
            RAISE invalid_cursor_state;
    END;

    -- Constructing query to extract data (as dataset) into REFCURSOR
    v_resrecset_sql :=
        format(concat_ws(chr(10),
                   'SELECT ' || v_coldtype_casts,
                   '  FROM (SELECT ' || v_colnames_cases,
                   '          FROM dbms_sql$recordset',
                   '         WHERE cursor_id = %s',
                   '           AND rownum > %s',
                   '         GROUP BY rownum',
                   '       ) AS record_set (%s)'),
               p_cursor_id,
               v_rows_fetched,
               v_colnames_list);

    -- Opening REFCURSOR for dymanic SQL query resulting data
    OPEN v_res_refcursor SCROLL FOR EXECUTE v_resrecset_sql;

    -- Closing the DBMS_SQL cursor and nulling its context
    PERFORM aws_oracle_ext.dbms_sql$close_cursor(p_cursor_id);

    -- Setting `last_row_count` variable
    PERFORM set_config('sct$dbms_sql.last_row_count', v_rows_fetched::TEXT, false);

    RETURN v_res_refcursor;
EXCEPTION
    -- Cursor is not opened or does not exist
    WHEN invalid_cursor_state THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';

    -- DBMS_SQL cursor rows count is NULL or func_code != 4 (SELECT)
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid cursor.',
                    DETAIL := 'Dynamic SQL statement was not executed or is not a valid SELECT query.',
                    HINT := '-1001';

    -- Effective userid (OID) changed since cursor parse
    WHEN invalid_role_specification THEN
        RAISE USING MESSAGE := 'Effective userid is not the same as when cursor was parsed.',
                    DETAIL := 'The effective userid on this call to DBMS_SQL is not the same as that at the time the cursor was parsed.',
                    HINT := '-29470';
END;
]]></complex-attribute>
                        <category _I_D="9fc2558f-2951-4cf2-9fa1-b2c797722f5c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2dac3116-e1b1-44a7-9485-e37500e9eb63" name="dbms_sql$variable_value" is-trigger-function="0" unique-function-name="dbms_sql$variable_value" is-aggregate="f" language-name="plpgsql" context="dbms_sql$variable_value" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,text,anyelement" comment="This procedure returns the value of the named variable for a given cursor. It is used to return the values of bind variables inside PL/pgSQL blocks or DML statements with returning clause." is-returning-set="f" ret-datatype="anyelement" function-arguments="p_cursor_id integer, p_var_name text, INOUT p_var_value anyelement" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22377" volatility="STABLE" is-window="f" function-identity-arguments="p_cursor_id integer, p_var_name text, INOUT p_var_value anyelement" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$variable_value(p_cursor_id integer, p_var_name text, INOUT p_var_value anyelement)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_var_info TEXT[];
    v_chr_val TEXT;
    v_num_val NUMERIC;
    v_dprec_val DOUBLE PRECISION;
    v_money_val MONEY;
    v_tstamp_val TIMESTAMP WITHOUT TIME ZONE;
    v_tstamptz_val TIMESTAMP WITH TIME ZONE;
    v_timetz_val TIME WITH TIME ZONE;
    v_interval_val INTERVAL;
    v_bool_val BOOLEAN;
    v_xml_val XML;
    v_bin_val BYTEA;
    v_is_fixed SMALLINT;
    v_value_size INTEGER;
    v_out_var_size INTEGER;
    v_bind_var_data_t TEXT;
    v_bind_var_base_t TEXT;
    v_out_var_base_t TEXT;
    v_out_var_data_t TEXT;
    v_cur_metadata JSONB;
    v_current_user_oid BIGINT;
BEGIN
    -- Checking that cursor is opened (exit if it is not)
    IF (NOT aws_oracle_ext.dbms_sql$is_open(p_cursor_id)) THEN
        RAISE invalid_cursor_state;
    -- Variable name should not be empty or blank (null)
    ELSIF (nullif(trim(p_var_name), '') IS NULL) THEN
        RAISE no_data_found;
    END IF;

    -- Obtaining current user OID
    v_current_user_oid := aws_oracle_ext.get_user_oid_by_name(current_user);

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    /* Checking that effective user OID (current_user) of the caller on this cursor is the same
       as that of the caller of the most recent parse operation on this cursor.
       Actual for cursors opened with security level 2 */
    IF ((v_cur_metadata ->> 'security_level')::SMALLINT = 2 AND
        (v_cur_metadata ->> 'parse_user_oid')::BIGINT != v_current_user_oid)
    THEN
        RAISE invalid_role_specification;
    END IF;

    v_out_var_data_t := upper(pg_typeof(p_var_value)::TEXT);

    -- Determining base data type of passed variable
    v_out_var_base_t := aws_oracle_ext.get_base_type_by_dtype(v_out_var_data_t);

    -- Extracting variable info (label in statement code and general name) from supplied string
    v_var_info := regexp_matches(p_var_name, '^((?:\s*\$\d+\s*(?:\|)?)+)*\s*\:?([[:alnum:]_]+)\s*$', 'gi');

    BEGIN
        /* Extracting var data from `dbms_sql$bind_variable`
           (by cursor id and variable name) */
        SELECT data_type,
               base_type,
               value_size,
               is_fixed,
               chr_val,
               num_val,
               dprec_val,
               money_val,
               tstamp_val,
               tstamptz_val,
               timetz_val,
               interval_val,
               bool_val,
               xml_val,
               bin_val
          INTO STRICT
               v_bind_var_data_t,
               v_bind_var_base_t,
               v_value_size,
               v_is_fixed,
               v_chr_val,
               v_num_val,
               v_dprec_val,
               v_money_val,
               v_tstamp_val,
               v_tstamptz_val,
               v_timetz_val,
               v_interval_val,
               v_bool_val,
               v_xml_val,
               v_bin_val
          FROM dbms_sql$bind_variable
         WHERE cursor_id = p_cursor_id
           AND var_name = v_var_info[2]; -- Variable name
    EXCEPTION
        WHEN insufficient_privilege THEN
            -- Effective userid changed
            RAISE invalid_cursor_state;
    END;

    -- Check if OUT argument base type matches declared bind variable base type
    IF ((substring(v_out_var_base_t, 1, 14) != substring(v_bind_var_base_t, 1, 14) AND -- TIMESTAMPs
         substring(v_out_var_base_t, 1, 5) != substring(v_bind_var_base_t, 1, 5) AND -- TIMEs
         (substring(v_out_var_data_t, 1, 5) != 'TIME ' AND
          substring(v_bind_var_data_t, 1, 10) != 'TIMESTAMP ') AND
         NOT (v_bind_var_base_t IN ('NUMERIC',
                                    'DOUBLE PRECISION') AND
              v_out_var_base_t IN ('NUMERIC',
                                   'DOUBLE PRECISION'))) OR
           (substring(v_bind_var_data_t, 1, 5) = 'TIME ' AND
            (substring(v_out_var_data_t, 1, 10) = 'TIMESTAMP ' OR
             v_out_var_data_t = 'DATE')))
    THEN
        RAISE datatype_mismatch;
    -- Variable should not be declared using `dbms_sql$bind_variable_char`
    ELSIF (v_is_fixed = 1) THEN
        RAISE datatype_mismatch;
    END IF;

    -- Copying value into the OUT argument
    CASE v_out_var_base_t
       WHEN 'TEXT' THEN
           IF (v_value_size != 0 AND v_value_size < char_length(v_chr_val)) THEN
               -- ORA-06502: PL/SQL: numeric or value error
               RAISE numeric_value_out_of_range;
           END IF;

           IF (v_out_var_data_t = 'CHARACTER') THEN
               v_out_var_size := coalesce(length(p_var_value::BYTEA, pg_client_encoding()), 0);

               IF (v_out_var_size != 0 AND v_out_var_size < char_length(v_chr_val)) THEN
                   /* ORA-06502: PL/SQL: numeric or value error.
                      Character string buffer too small */
                   RAISE string_data_length_mismatch;
               END IF;
           END IF;

           p_var_value := v_chr_val;
       WHEN 'NUMERIC' THEN
           IF (v_bind_var_base_t = 'NUMERIC') THEN
               p_var_value := v_num_val;
           ELSE
               p_var_value := v_dprec_val;
           END IF;
       WHEN 'DOUBLE PRECISION' THEN
           IF (v_bind_var_base_t = 'DOUBLE PRECISION') THEN
               p_var_value := v_dprec_val;
           ELSE
               p_var_value := v_num_val;
           END IF;
       WHEN 'MONEY' THEN
           p_var_value := v_money_val;
       WHEN 'TIMESTAMP WITHOUT TIME ZONE' THEN
           CASE v_bind_var_base_t
              WHEN 'TIMESTAMP WITHOUT TIME ZONE' THEN
                  p_var_value := v_tstamp_val;
              WHEN 'TIMESTAMP WITH TIME ZONE' THEN
                  p_var_value := v_tstamptz_val;
              ELSE
                  p_var_value := v_timetz_val;
           END CASE;
       WHEN 'TIMESTAMP WITH TIME ZONE' THEN
           p_var_value := CASE v_bind_var_base_t
                             WHEN 'TIMESTAMP WITHOUT TIME ZONE' THEN v_tstamp_val::TIMESTAMPTZ
                             ELSE v_tstamptz_val
                          END;
       WHEN 'TIME WITH TIME ZONE' THEN
           p_var_value := CASE v_bind_var_base_t
                             WHEN 'TIMESTAMP WITHOUT TIME ZONE' THEN v_tstamp_val::TIME::TIMETZ
                             WHEN 'TIMESTAMP WITH TIME ZONE' THEN v_tstamptz_val::TIMETZ
                             ELSE v_timetz_val
                          END;
       WHEN 'INTERVAL' THEN
           p_var_value := v_interval_val;
       WHEN 'BOOLEAN' THEN
           p_var_value := v_bool_val;
       WHEN 'XML' THEN
           p_var_value := v_xml_val;
       WHEN 'BYTEA' THEN
           p_var_value := CASE
                             WHEN v_value_size IS NULL THEN v_bin_val
                             ELSE substring(v_bin_val from 1 for v_value_size)
                          END;
       ELSE
           p_var_value := null;
    END CASE;
EXCEPTION
    -- Cursor is not opened or does not exist
    WHEN invalid_cursor_state THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';

    -- Bind variable does not exist
    WHEN no_data_found THEN
        RAISE USING MESSAGE := 'Bind variable does not exist.',
                    DETAIL := 'Call for a bind variable that was not listed in the corresponding SQL statement.',
                    HINT := '-1006';

    /* OUT argument base type does not match bind variable declared base type.
       Variable was declared through `dbms_sql$bind_variable_char` */
    WHEN datatype_mismatch THEN
        RAISE USING MESSAGE := 'Type of OUT argument does not match declared type of bind variable.',
                    DETAIL := 'Attempting to get the value of a bind variable but the type of the given OUT argument is different from the type of bind variable that was defined previously.',
                    HINT := '-6562';

    -- Variable value length exceeds declared OUT value size
    WHEN numeric_value_out_of_range THEN
        RAISE USING MESSAGE := 'Variable value length exceeds declared OUT value size.',
                    DETAIL := format('Variable value length: %s, declared variable OUT value size: %s.',
                                     char_length(v_chr_val), v_value_size),
                    HINT := '-6502';

    -- Length of OUT argument is too small
    WHEN string_data_length_mismatch THEN
        RAISE USING MESSAGE := 'Character string buffer too small.',
                    DETAIL := 'Length of OUT argument is too small to store bind variable value.',
                    HINT := '-6502';

    -- Effective userid (OID) changed since cursor parse
    WHEN invalid_role_specification THEN
        RAISE USING MESSAGE := 'Effective userid is not the same as when cursor was parsed.',
                    DETAIL := 'The effective userid on this call to DBMS_SQL is not the same as that at the time the cursor was parsed.',
                    HINT := '-29470';
END;
]]></complex-attribute>
                        <category _I_D="9b4f337c-68c0-4d16-abb7-3237447e6767" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="946f608c-3402-40a8-be8a-92129719ddab" name="dbms_sql$variable_value_char" is-trigger-function="0" unique-function-name="dbms_sql$variable_value_char" is-aggregate="f" language-name="plpgsql" context="dbms_sql$variable_value_char" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,text,anyelement" comment="This procedure returns the value of the named variable for a given cursor. It is used to return the values of bind variables inside PL/pgSQL blocks or DML statements with returning clause." is-returning-set="f" ret-datatype="anyelement" function-arguments="p_cursor_id integer, p_var_name text, INOUT p_var_value anyelement" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22375" volatility="STABLE" is-window="f" function-identity-arguments="p_cursor_id integer, p_var_name text, INOUT p_var_value anyelement" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_sql$variable_value_char(p_cursor_id integer, p_var_name text, INOUT p_var_value anyelement)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_var_info TEXT[];
    v_chr_val TEXT;
    v_is_fixed SMALLINT;
    v_var_size INTEGER;
    v_value_size INTEGER;
    v_out_var_size INTEGER;
    v_out_var_base_t TEXT;
    v_out_var_data_t TEXT;
    v_cur_metadata JSONB;
    v_current_user_oid BIGINT;
BEGIN
    -- Checking that cursor is opened (exit if it is not)
    IF (NOT aws_oracle_ext.dbms_sql$is_open(p_cursor_id)) THEN
        RAISE invalid_cursor_state;
    -- Variable name should not be empty or blank (null)
    ELSIF (nullif(trim(p_var_name), '') IS NULL) THEN
        RAISE no_data_found;
    END IF;

    -- Obtaining current user OID
    v_current_user_oid := aws_oracle_ext.get_user_oid_by_name(current_user);

    -- Getting cursor metadata (JSON) object
    v_cur_metadata := nullif(current_setting(format('sct$dbms_sql.cursor_id_%s_metadata', p_cursor_id), true), '');

    /* Checking that effective user OID (current_user) of the caller on this cursor is the same
       as that of the caller of the most recent parse operation on this cursor.
       Actual for cursors opened with security level 2 */
    IF ((v_cur_metadata ->> 'security_level')::SMALLINT = 2 AND
        (v_cur_metadata ->> 'parse_user_oid')::BIGINT != v_current_user_oid)
    THEN
        RAISE invalid_role_specification;
    END IF;

    v_out_var_data_t := upper(pg_typeof(p_var_value)::TEXT);

    -- Determining base data type of passed variable
    v_out_var_base_t := aws_oracle_ext.get_base_type_by_dtype(v_out_var_data_t);

    -- Extracting variable info (label in statement code and general name) from supplied string
    v_var_info := regexp_matches(p_var_name, '^((?:\s*\$\d+\s*(?:\|)?)+)*\s*\:?([[:alnum:]_]+)\s*$', 'gi');

    BEGIN
        /* Extracting var data from "dbms_sql$bind_variable"
           (by cursor id and variable name) */
        SELECT var_size,
               value_size,
               is_fixed,
               chr_val
          INTO STRICT
               v_var_size,
               v_value_size,
               v_is_fixed,
               v_chr_val
          FROM dbms_sql$bind_variable
         WHERE cursor_id = p_cursor_id
           AND var_name = v_var_info[2]; -- Variable name
    EXCEPTION
        WHEN insufficient_privilege THEN
            -- Effective userid changed
            RAISE invalid_cursor_state;
    END;

    -- Variable should not be declared using `dbms_sql$bind_variable`
    IF (coalesce(v_is_fixed, 0) != 1) THEN
        RAISE most_specific_type_mismatch;
    END IF;

    -- Copying value into the OUT argument
    CASE v_out_var_base_t
       WHEN 'TEXT' THEN
           IF (v_value_size != 0 AND v_value_size < char_length(v_chr_val)) THEN
               -- ORA-06502: PL/SQL: numeric or value error
               RAISE numeric_value_out_of_range;
           END IF;

           IF (v_out_var_data_t = 'CHARACTER') THEN
               v_out_var_size := coalesce(length(p_var_value::BYTEA, pg_client_encoding()), 0);

               IF (v_out_var_size != 0 AND v_out_var_size < char_length(v_chr_val)) THEN
                   /* ORA-06502: PL/SQL: numeric or value error.
                      Character string buffer too small */
                   RAISE string_data_length_mismatch;
               END IF;
           END IF;

           p_var_value := v_chr_val;
       WHEN 'NUMERIC' THEN
           p_var_value := v_chr_val::NUMERIC;
       WHEN 'DOUBLE PRECISION' THEN
           p_var_value := v_chr_val::DOUBLE PRECISION;
       WHEN 'MONEY' THEN
           p_var_value := v_chr_val::MONEY;
       WHEN 'TIMESTAMP WITHOUT TIME ZONE' THEN
           CASE v_out_var_data_t
              WHEN 'DATE'
              THEN
                  v_chr_val := regexp_replace(v_chr_val, '\s+', '', 'gi');

                  IF (char_length(v_chr_val) < 8) THEN
                      RAISE invalid_datetime_format;
                  END IF;

                  p_var_value := to_date(v_chr_val, 'dd-MON-yy');
              WHEN 'TIME WITHOUT TIME ZONE'
              THEN
                  v_chr_val := regexp_replace(v_chr_val, '\s*[AP]M', '', 'i');

                  IF (char_length(v_chr_val) < 8) THEN
                      RAISE invalid_datetime_format;
                  END IF;

                  p_var_value := v_chr_val::TIME;
              ELSE -- TIMESTAMP WITHOUT TIME ZONE
                  v_chr_val := trim(regexp_replace(v_chr_val, '\s*[AP]M', '', 'i'));

                  IF (char_length(v_chr_val) < 17) THEN
                      RAISE invalid_datetime_format;
                  END IF;

                  p_var_value := v_chr_val::TIMESTAMP;
              END CASE;
       WHEN 'TIMESTAMP WITH TIME ZONE' THEN
           v_chr_val := trim(regexp_replace(v_chr_val, '\s*[AP]M', '', 'i'));

           IF (char_length(v_chr_val) < 17) THEN
               RAISE invalid_datetime_format;
           END IF;

           p_var_value := to_timestamp(v_chr_val, 'dd-MON-yy hh24:mi:ss.us');
       WHEN 'TIME WITH TIME ZONE' THEN
           IF (char_length(v_chr_val) < 8) THEN
               RAISE invalid_datetime_format;
           END IF;

           p_var_value := v_chr_val::TIMETZ;
       WHEN 'INTERVAL' THEN
           p_var_value := v_chr_val::INTERVAL;
       WHEN 'BOOLEAN' THEN
           p_var_value := v_chr_val::BOOLEAN;
       WHEN 'XML' THEN
           BEGIN
               p_var_value := v_chr_val::XML;
           EXCEPTION
               WHEN OTHERS THEN
               RAISE invalid_xml_document;
           END;
       WHEN 'BYTEA' THEN
           BEGIN
               p_var_value := decode(v_chr_val, 'hex');
           EXCEPTION
               WHEN OTHERS THEN
               RAISE invalid_binary_representation;
           END;
       ELSE
           p_var_value := null;
    END CASE;
EXCEPTION
    -- Cursor is not opened or does not exist
    WHEN invalid_cursor_state THEN
        RAISE USING MESSAGE := 'DBMS_SQL access denied.',
                    DETAIL := 'DBMS_SQL access was denied due to security concerns.',
                    HINT := '-29471';

    -- Bind variable does not exist
    WHEN no_data_found THEN
        RAISE USING MESSAGE := 'Bind variable does not exist.',
                    DETAIL := 'Call for a bind variable that was not listed in the corresponding SQL statement.',
                    HINT := '-1006';

    -- Length of OUT argument is too small
    WHEN string_data_length_mismatch THEN
        RAISE USING MESSAGE := 'Character string buffer too small.',
                    DETAIL := 'Length of OUT argument is too small to store bind variable value.',
                    HINT := '-6502';

    -- Variable value length exceeds declared OUT value size
    WHEN numeric_value_out_of_range THEN
        RAISE USING MESSAGE := 'Variable value length exceeds declared OUT value size.',
                    DETAIL := format('Variable value length: %s, declared variable OUT value size: %s.',
                                     char_length(v_chr_val), v_value_size),
                    HINT := '-6502';

    /* OUT argument base type does not match bind variable declared base type.
       Variable was declared through `dbms_sql$bind_variable` */
    WHEN most_specific_type_mismatch THEN
        RAISE USING MESSAGE := 'Type of OUT argument does not match declared type of bind variable.',
                    DETAIL := 'Attempting to get the value of a bind variable but the type of the given OUT argument is different from the type of bind variable that was defined previously.',
                    HINT := '-6562';

    -- Effective userid (OID) changed since cursor parse
    WHEN invalid_role_specification THEN
        RAISE USING MESSAGE := 'Effective userid is not the same as when cursor was parsed.',
                    DETAIL := 'The effective userid on this call to DBMS_SQL is not the same as that at the time the cursor was parsed.',
                    HINT := '-29470';

    -- Possible data type conversion error (char to numeric\money)
    WHEN invalid_text_representation THEN
        RAISE USING MESSAGE := 'Error during variable value conversion (from char to numeric\money).',
                    DETAIL := format('Value %s is not correct for conversion to numeric\money.',
                                     quote_literal(v_chr_val));

    -- Possible data type conversion error (char to datetime\interval)
    WHEN invalid_datetime_format THEN
        RAISE USING MESSAGE := 'Error during variable value conversion (from char to datetime\interval).',
                    DETAIL := format('Value %s is not correct for conversion to datetime\interval.',
                                     quote_literal(v_chr_val));

    -- Possible data type conversion error (char to binary data)
    WHEN invalid_binary_representation THEN
        RAISE USING MESSAGE := 'Error during variable value conversion (from char to binary data).',
                    DETAIL := format('Value %s is not correct for conversion to binary data.',
                                     quote_literal(v_chr_val));

    -- Possible data type conversion error (char to XML document)
    WHEN invalid_xml_document THEN
        RAISE USING MESSAGE := 'Error during variable value conversion (from char to XML document).',
                    DETAIL := format('Value %s is not correct for conversion to XML document.',
                                     quote_literal(v_chr_val));
END;
]]></complex-attribute>
                        <category _I_D="d13335e2-1009-4c53-9d19-21fbf39c8000" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9c0d5697-e115-4da7-b8c4-f23d5da819bf" name="dbms_types" is-trigger-function="0" unique-function-name="dbms_types" is-aggregate="f" language-name="plpgsql" context="dbms_types" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" comment="Returns type code constant like DBMS_TYPES package" is-returning-set="f" ret-datatype="int4" function-arguments="typecode character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22379" volatility="IMMUTABLE" is-window="f" function-identity-arguments="typecode character varying" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_types(typecode character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  l_typecodes json = '{"TYPECODE_DATE":"12" 
		       ,"TYPECODE_NUMBER":"2"
		       ,"TYPECODE_RAW":"95"
		       ,"TYPECODE_CHAR":"96"
		       ,"TYPECODE_VARCHAR2":"9"
		       ,"TYPECODE_VARCHAR":"1"
		       ,"TYPECODE_MLSLABEL":"105"
		       ,"TYPECODE_BLOB":"113"
		       ,"TYPECODE_BFILE":"114"
		       ,"TYPECODE_CLOB":"112"
		       ,"TYPECODE_CFILE":"115"
		       ,"TYPECODE_TIMESTAMP":"187"
		       ,"TYPECODE_TIMESTAMP_TZ":"188"
		       ,"TYPECODE_TIMESTAMP_LTZ":"232"
		       ,"TYPECODE_INTERVAL_YM":"189"
		       ,"TYPECODE_INTERVAL_DS":"190"
		       ,"TYPECODE_REF":"110"
		       ,"TYPECODE_OBJECT":"108"
		       ,"TYPECODE_VARRAY":"247"
		       ,"TYPECODE_TABLE":"248"
		       ,"TYPECODE_NAMEDCOLLECTION":"122"
		       ,"TYPECODE_OPAQUE":"58"
		       ,"TYPECODE_NCHAR":"286"
		       ,"TYPECODE_NVARCHAR2":"287"
		       ,"TYPECODE_NCLOB":"288"
		       ,"TYPECODE_BFLOAT":"100"
		       ,"TYPECODE_BDOUBLE":"101"
		       ,"TYPECODE_UROWID":"104"
		       ,"SUCCESS":"0"
		       ,"NO_DATA":"100"
		       ,"oidvector":"247"
		       ,"int2vector":"247"		       		       
		       ,"date":"12"
		       ,"timestamptz":"188"		       		       
		       ,"timestamp":"187"
		       ,"numeric":"2"		       		       
		       ,"int8":"2"
		       ,"int4":"2"		       		       
		       ,"int2":"2"
		       ,"oid":"2"		       		       
		       ,"float4":"2"
		       ,"float8":"2"		       		       
		       ,"money":"2"
		       ,"varchar":"9"		       		       
		       ,"text":"112"
		       ,"bpchar":"96"		       		       
		       ,"interval":"189"		       		       
		       ,"tinterval":"189"
		       ,"varbit":"9"		       		       
		       ,"bit":"96"
		       ,"bytea":"112"		       		       
		       }'; 
BEGIN
  return l_typecodes->>TYPECODE;
END;
]]></complex-attribute>
                        <category _I_D="bda75dd9-28d4-4e29-a50f-130bcdef2895" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="04fdfc51-fdc6-4697-9e54-31aeebb73bde" name="dbms_utility$current_instance" is-trigger-function="0" unique-function-name="dbms_utility$current_instance" is-aggregate="f" language-name="sql" context="dbms_utility$current_instance" subcategories-loading="none" object-loading="extended" comment="This function returns the current connected instance number." is-returning-set="f" ret-datatype="numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22266" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_utility$current_instance()">
                        <complex-attribute name="sql"><![CDATA[
SELECT 1;
]]></complex-attribute>
                        <category _I_D="fad894e1-3189-4dc3-819a-c2c673cf2b2d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2571d2f9-15c0-4698-b2c7-997e35eaf020" name="dbms_utility$format_call_stack" is-trigger-function="0" unique-function-name="dbms_utility$format_call_stack" is-aggregate="f" language-name="plpgsql" context="dbms_utility$format_call_stack" subcategories-loading="none" object-loading="extended" arguments-datatypes="boolean" comment="This function formats the current call stack. This can be used on any function or stored procedure to access the call stack." is-returning-set="f" ret-datatype="text" function-arguments="p_ora_style boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22267" volatility="VOLATILE" is-window="f" function-identity-arguments="p_ora_style boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_utility$format_call_stack(p_ora_style boolean)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_server_pid TEXT;
    v_obj_handle TEXT;
    v_schema_name TEXT;
    v_routine_name TEXT;
    v_routine_type TEXT;
    v_routine_oid TEXT;
    i_param_type TEXT;
    v_call_stack TEXT[];
    v_call_info TEXT[];
    v_param_types TEXT;
    v_stack_header TEXT;
    v_search_path TEXT[];
    v_pg_call_stack TEXT;
    v_anonymous_block TEXT;
    v_call_stack_rec TEXT;
    v_full_search_path TEXT[];
    i_call_stack_rec RECORD;
BEGIN
    -- Determining call stack label depending on Oracle style param
    v_stack_header := CASE
                         WHEN p_ora_style THEN '------- PL/SQL Call Stack -------'
                         ELSE '------ PL/pgSQL Call Stack ------'
                      END;

    -- Determining anonymous block label depending on Oracle style param
    v_anonymous_block := CASE
                            WHEN p_ora_style THEN 'anonymous block'
                            ELSE 'inline_code_block'
                         END;

    -- Constructing call stack header
    v_call_stack := ARRAY[v_stack_header,
                          '    object       line  object',
                          '    handle     number  name'];

    -- Obtaining current search path
    v_search_path := regexp_split_to_array(replace(current_setting('search_path'),
                                                   '$user', current_user), '\s*,\s*');
    -- Getting server process ID
    v_server_pid = pg_backend_pid();

    -- Getting current call stack
    GET DIAGNOSTICS v_pg_call_stack = PG_CONTEXT;

    FOR i_call_stack_rec IN
    (SELECT t.*
       FROM regexp_split_to_table(v_pg_call_stack, chr(10))
       WITH ORDINALITY AS t(call_stack, line_num))
    LOOP
        CONTINUE WHEN i_call_stack_rec.line_num = 1 OR
                      i_call_stack_rec.call_stack !~ 'line \d+ at';

        -- Obtaining info regarding particular stack call
        v_call_info := regexp_matches(i_call_stack_rec.call_stack,
                                      '^[[:alnum:]_/]+\s+([a-z]+)\s+(.*)(?<=[^\s])\s+line\s+(\d+)', 'g');
        v_routine_oid := NULL;

        v_routine_type := v_call_info[1];

        -- Extracting param types list from routine signature
        v_param_types := substring(v_call_info[2], '\((.*)\)$');

        -- Extracting schema name from `schema.["]routine["]`
        v_schema_name := substring(v_call_info[2], '^(.+)\.');

        -- Extracting routine name from `schema.["]routine["]`(params)
        v_routine_name := regexp_replace(v_call_info[2], '^(.+)\.|\((.*)\)$', '', 'g');

        -- Emulating Oracle anonymous block label
        IF (p_ora_style) THEN
            v_routine_name := replace(v_routine_name, 'inline_code_block', 'anonymous block');
        END IF;

        -- Determining whether call routine is a function or a procedure
        IF (v_routine_type = 'function' AND v_routine_name != 'anonymous block')
        THEN
            -- Putting stack record schema name on top of search path
            v_full_search_path := CASE
                                     WHEN v_schema_name IS NULL THEN v_search_path
                                     ELSE array_prepend(v_schema_name, v_search_path)
                                  END;
            SELECT oid,
                   CASE prokind
                      WHEN 'p' THEN 'procedure'
                      ELSE 'function'
                   END,
                   pronamespace::REGNAMESPACE::TEXT
              INTO v_routine_oid,
                   v_routine_type,
                   v_schema_name
              FROM pg_catalog.pg_proc
             WHERE proname = substring(v_routine_name, '"?([^"]+)') -- routine name
               AND pronamespace::REGNAMESPACE::TEXT = ANY(v_full_search_path) -- schema names list
               AND proargtypes = coalesce(array_to_string(string_to_array(v_param_types, ',')::REGTYPE[]::OID[],
                                          ' '), '')::OIDVECTOR -- param OIDs list
             ORDER BY array_position(v_full_search_path, pronamespace::REGNAMESPACE::TEXT) ASC
             LIMIT 1;
        END IF;

        -- Constructing object handle (server_PID.object_OID)
        v_obj_handle := concat(v_server_pid, '.' || v_routine_oid);

        -- Constructing call stack record
        v_call_stack_rec :=
            concat(rpad(repeat(' ', (14 - char_length(v_obj_handle)) / 2) || v_obj_handle, 14), -- object handle
                   ' ', -- delimiter
                   lpad(v_call_info[3], 6, ' '), -- line number
                   '  ', -- delimiter
                   CASE
                      WHEN v_routine_name !~ '^(anonymous\s|inline_code_)block$'
                      THEN v_routine_type || ' ' -- routine type
                   END,
                   CASE
                      WHEN v_schema_name ~ '^"' THEN v_schema_name
                      ELSE CASE
                              WHEN p_ora_style THEN upper(v_schema_name)
                              ELSE v_schema_name
                           END
                   END || '.', -- schema name
                   CASE
                      WHEN v_routine_name ~ '^"' OR
                           v_routine_name ~ '^(anonymous\s|inline_code_)block$'
                      THEN v_routine_name
                      ELSE CASE
                              WHEN p_ora_style THEN upper(v_routine_name)
                              ELSE v_routine_name
                           END
                   END, -- routine name
                   CASE
                      WHEN v_routine_name !~ '^(anonymous\s|inline_code_)block$'
                      THEN CASE
                              WHEN NOT p_ora_style THEN concat('(', v_param_types, ')')
                              ELSE upper('(' || nullif(v_param_types, '') || ')')
                           END
                   END);

        v_call_stack := array_append(v_call_stack, v_call_stack_rec);
    END LOOP;

    -- SQL SELECT dbms_utility$format_call_stack()
    IF (array_length(v_call_stack, 1) = 3) THEN
        v_call_stack :=
            array_append(v_call_stack,
                         rpad(repeat(' ', (14 - char_length(v_server_pid)) / 2) || v_server_pid, 14)
                         || '      1  '
                         || v_anonymous_block);
    END IF;

    RETURN array_to_string(v_call_stack, chr(10));
END;
]]></complex-attribute>
                        <category _I_D="c87ab667-f4ec-4693-9955-96a04943e107" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="903d3657-9d60-4105-8706-d15a69f20685" name="dbms_xmlgen$closecontext" is-trigger-function="0" unique-function-name="dbms_xmlgen$closecontext" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$closecontext" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" is-returning-set="f" ret-datatype="void" function-arguments="ctx numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23030" volatility="VOLATILE" is-window="f" function-identity-arguments="ctx numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$closecontext(ctx numeric)">
                        <complex-attribute name="sql"><![CDATA[
declare
	lCtx aws_oracle_ext.dbms_xmlgen$tContext;
	lnCtxHdl int := trunc(ctx);
begin
    lCtx := aws_oracle_ext.dbms_xmlgen$getctxobj(ctxHdl => lnCtxHdl);

    if not lCtx is null then
        perform aws_oracle_ext.dbms_xmlgen$setctxvalue(ctxHdl => lCtx.ctxIdx,
                                                       ctxCursor => null,
                                                       ctxQuery => null,
                                                       ctxAttributes => null,
                                                       ctxNumRowsProcessed => null
                                                      );
    end if;
end; ]]></complex-attribute>
                        <category _I_D="02485046-ebc9-482b-b940-9f510cf982de" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="de7ef27f-e0cd-409c-ba57-87058953340b" name="dbms_xmlgen$context2obj" is-trigger-function="0" unique-function-name="dbms_xmlgen$context2obj(ctxhdl numeric)" is-aggregate="f" language-name="sql" context="dbms_xmlgen$context2obj(ctxhdl numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" unique-suffix="(ctxhdl numeric)" routine-number="23025" is-returning-set="f" ret-datatype="dbms_xmlgen$tcontext" function-arguments="ctxhdl numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23025" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric" overload-function-count="2" proc-language="sql" function-signature="dbms_xmlgen$context2obj(ctxhdl numeric)">
                        <complex-attribute name="sql"><![CDATA[ select dbms_xmlgen$context2obj(get_extpack_variable(variable_name => dbms_xmlgen$ctxIdx(trunc(ctxHdl)))) ]]></complex-attribute>
                        <category _I_D="2c2200bb-e7b3-40c9-a36e-111728fe79bc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0d3b0886-eb86-4a5f-91b9-8d574d59f089" name="dbms_xmlgen$context2obj" is-trigger-function="0" unique-function-name="dbms_xmlgen$context2obj(ctxvalue text)" is-aggregate="f" language-name="sql" context="dbms_xmlgen$context2obj(ctxvalue text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" unique-suffix="(ctxvalue text)" routine-number="23024" is-returning-set="f" ret-datatype="dbms_xmlgen$tcontext" function-arguments="ctxvalue text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23024" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxvalue text" overload-function-count="2" proc-language="sql" function-signature="dbms_xmlgen$context2obj(ctxvalue text)">
                        <complex-attribute name="sql"><![CDATA[ select * from json_populate_record(null::dbms_xmlgen$TContext, ctxValue::json) ]]></complex-attribute>
                        <category _I_D="a8e77342-a5dd-45e1-981f-4522ee2164a0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b121dcb9-1c24-4767-8823-93ea1d0c2450" name="dbms_xmlgen$context2text" is-trigger-function="0" unique-function-name="dbms_xmlgen$context2text(ctxhdl numeric, ctxcursor refcursor, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;, ctxnumrowsprocessed integer)" is-aggregate="f" language-name="sql" context="dbms_xmlgen$context2text(ctxhdl numeric, ctxcursor refcursor, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;, ctxnumrowsprocessed integer)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,refcursor,text,aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;,integer" unique-suffix="(ctxhdl numeric, ctxcursor refcursor, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;, ctxnumrowsprocessed integer)" routine-number="23021" is-returning-set="f" ret-datatype="text" function-arguments="ctxhdl numeric, ctxcursor refcursor, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot; DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;, ctxnumrowsprocessed integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="23021" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, ctxcursor refcursor, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;, ctxnumrowsprocessed integer" overload-function-count="2" proc-language="sql" function-signature="dbms_xmlgen$context2text(ctxhdl numeric, ctxcursor refcursor, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;, ctxnumrowsprocessed integer)">
                        <complex-attribute name="sql"><![CDATA[ select dbms_xmlgen$context2text((ctxHdl,
                                       ctxCursor,
                                       ctxQuery,
                                       coalesce(ctxAttributes, dbms_xmlgen$contextAttr2obj()),
                                       ctxNumRowsProcessed
                                       )::dbms_xmlgen$TContext)::text ]]></complex-attribute>
                        <category _I_D="5ea4722f-11a0-4a39-b2d7-f236a2bb1cf8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2679933e-4458-4ba0-a7e9-f28de472ce3b" name="dbms_xmlgen$context2text" is-trigger-function="0" unique-function-name="dbms_xmlgen$context2text(ctxvalue aws_oracle_ext.&quot;dbms_xmlgen$tcontext&quot;)" is-aggregate="f" language-name="sql" context="dbms_xmlgen$context2text(ctxvalue aws_oracle_ext.&quot;dbms_xmlgen$tcontext&quot;)" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;dbms_xmlgen$tcontext&quot;" unique-suffix="(ctxvalue aws_oracle_ext.&quot;dbms_xmlgen$tcontext&quot;)" routine-number="23020" is-returning-set="f" ret-datatype="text" function-arguments="ctxvalue aws_oracle_ext.&quot;dbms_xmlgen$tcontext&quot;" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23020" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxvalue aws_oracle_ext.&quot;dbms_xmlgen$tcontext&quot;" overload-function-count="2" proc-language="sql" function-signature="dbms_xmlgen$context2text(ctxvalue aws_oracle_ext.&quot;dbms_xmlgen$tcontext&quot;)">
                        <complex-attribute name="sql"><![CDATA[ select row_to_json(ctxValue)::text ]]></complex-attribute>
                        <category _I_D="f7c83fcc-f181-43ed-9b5d-1fbaf0f72e88" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ea7776b3-1079-42c5-9251-21519d0f000f" name="dbms_xmlgen$contextattr2obj" is-trigger-function="0" unique-function-name="dbms_xmlgen$contextattr2obj" is-aggregate="f" language-name="sql" context="dbms_xmlgen$contextattr2obj" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="dbms_xmlgen$tctxattributes" function-arguments="ctxattr text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23019" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxattr text" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$contextattr2obj(ctxattr text)">
                        <complex-attribute name="sql"><![CDATA[ select *
            from json_populate_record(null::dbms_xmlgen$TctxAttributes,
                                      coalesce(ctxAttr, dbms_xmlgen$contextAttr2text())::json
                                     ) ]]></complex-attribute>
                        <category _I_D="e99b26b7-111a-4009-b526-edcddf1be263" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8192d3fe-4941-4ab7-ab9d-325a898eeecd" name="dbms_xmlgen$contextattr2text" is-trigger-function="0" unique-function-name="dbms_xmlgen$contextattr2text(ctxattrvalue aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;)" is-aggregate="f" language-name="sql" context="dbms_xmlgen$contextattr2text(ctxattrvalue aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;)" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;" unique-suffix="(ctxattrvalue aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;)" routine-number="23017" is-returning-set="f" ret-datatype="text" function-arguments="ctxattrvalue aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23017" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxattrvalue aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;" overload-function-count="2" proc-language="sql" function-signature="dbms_xmlgen$contextattr2text(ctxattrvalue aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;)">
                        <complex-attribute name="sql"><![CDATA[ select row_to_json(ctxAttrValue)::text ]]></complex-attribute>
                        <category _I_D="e79c102a-cbeb-4875-ac5d-418f57b291ff" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dcbb37b9-fbc1-4804-aac0-344ee309d897" name="dbms_xmlgen$contextattr2text" is-trigger-function="0" unique-function-name="dbms_xmlgen$contextattr2text(ctxconvertspecialchars boolean, ctxmaxrows numeric, ctxnullhandling numeric, ctxrowsettag text, ctxrowtag text, ctxskiprows numeric, ctxusenullattributeindicator boolean, ctxuseitemtagsforcoll boolean)" is-aggregate="f" language-name="sql" context="dbms_xmlgen$contextattr2text(ctxconvertspecialchars boolean, ctxmaxrows numeric, ctxnullhandling numeric, ctxrowsettag text, ctxrowtag text, ctxskiprows numeric, ctxusenullattributeindicator boolean, ctxuseitemtagsforcoll boolean)" subcategories-loading="none" object-loading="extended" arguments-datatypes="boolean,numeric,numeric,text,text,numeric,boolean,boolean" unique-suffix="(ctxconvertspecialchars boolean, ctxmaxrows numeric, ctxnullhandling numeric, ctxrowsettag text, ctxrowtag text, ctxskiprows numeric, ctxusenullattributeindicator boolean, ctxuseitemtagsforcoll boolean)" routine-number="23018" is-returning-set="f" ret-datatype="text" function-arguments="ctxconvertspecialchars boolean DEFAULT NULL::boolean, ctxmaxrows numeric DEFAULT NULL::numeric, ctxnullhandling numeric DEFAULT NULL::numeric, ctxrowsettag text DEFAULT NULL::text, ctxrowtag text DEFAULT NULL::text, ctxskiprows numeric DEFAULT NULL::numeric, ctxusenullattributeindicator boolean DEFAULT NULL::boolean, ctxuseitemtagsforcoll boolean DEFAULT NULL::boolean" schema-id="21999" function-type="RET_SCALAR" count-arguments="8" function-id="23018" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxconvertspecialchars boolean, ctxmaxrows numeric, ctxnullhandling numeric, ctxrowsettag text, ctxrowtag text, ctxskiprows numeric, ctxusenullattributeindicator boolean, ctxuseitemtagsforcoll boolean" overload-function-count="2" proc-language="sql" function-signature="dbms_xmlgen$contextattr2text(ctxconvertspecialchars boolean, ctxmaxrows numeric, ctxnullhandling numeric, ctxrowsettag text, ctxrowtag text, ctxskiprows numeric, ctxusenullattributeindicator boolean, ctxuseitemtagsforcoll boolean)">
                        <complex-attribute name="sql"><![CDATA[ select dbms_xmlgen$contextAttr2text((ctxConvertSpecialChars,
                                            ctxMaxRows,
                                            ctxNullHandling,
                                            coalesce(ctxRowSetTag, dbms_xmlgen$default_rowsettag()),
	                                        coalesce(ctxRowTag, dbms_xmlgen$default_rowtag()),
	                                        coalesce(ctxSkipRows, 0),
                                            ctxUseNullattributeIndicator,
                                            ctxUseItemTagsForColl
	                                      )::dbms_xmlgen$TctxAttributes)::text ]]></complex-attribute>
                        <category _I_D="db5f138c-0aa1-42ea-8038-b35bca705635" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9efe4c8c-988a-49b8-a3fd-82307cd7a91a" name="dbms_xmlgen$convert" is-trigger-function="0" unique-function-name="dbms_xmlgen$convert" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$convert" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric" is-returning-set="f" ret-datatype="text" function-arguments="xmldata text, flag numeric DEFAULT aws_oracle_ext.&quot;dbms_xmlgen$entity_encode&quot;()" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23045" volatility="VOLATILE" is-window="f" function-identity-arguments="xmldata text, flag numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$convert(xmldata text, flag numeric)">
                        <complex-attribute name="sql"><![CDATA[
declare
	escChars text[5][2] := array[array['&quot;', '"'], array['&apos;', ''''], array['&lt;', '<'], array['&gt;', '>'], array['&amp;', '&']];
    i int;
    lvResult text;
begin
	if flag >= aws_oracle_ext.dbms_xmlgen$entity_decode() then
		begin
			lvResult := xmlData;
			for i in 1 .. 5 loop
				lvResult := replace(lvResult, escChars[i][1], escChars[i][2]);
			end loop;
   	    exception when others then
			lvResult := null;
		    raise;
		end;
	elsif flag = aws_oracle_ext.dbms_xmlgen$entity_encode() then
		lvResult := xmlserialize(content (xpath('.', xmlelement(name dummy, xmlData), array[array['xsi', 'http://www.w3.org/2001/XMLSchema-instance']]))[1] as text);
	else
		raise exception 'XML processing error. Nagative value [%] was readed', flag using hint = '22063';
	end if;
    return lvResult;
end; ]]></complex-attribute>
                        <category _I_D="b2e50c83-4409-40dd-9585-cd3963599a8a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6705f419-bddf-48bb-9732-6690204e538c" name="dbms_xmlgen$crisopened" is-trigger-function="0" unique-function-name="dbms_xmlgen$crisopened" is-aggregate="f" language-name="sql" context="dbms_xmlgen$crisopened" subcategories-loading="none" object-loading="extended" arguments-datatypes="refcursor" is-returning-set="f" ret-datatype="bool" function-arguments="pcr refcursor" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23016" volatility="STABLE" is-window="f" function-identity-arguments="pcr refcursor" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$crisopened(pcr refcursor)">
                        <complex-attribute name="sql"><![CDATA[
  select exists(select 1 from pg_cursors where name = pCr::text);
]]></complex-attribute>
                        <category _I_D="d2899caa-ae9c-4851-b602-fd45a985b6c6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="cc19060c-50fd-40e8-a6f5-57a77d3b59a7" name="dbms_xmlgen$ctxhdl2uidrec" is-trigger-function="0" unique-function-name="dbms_xmlgen$ctxhdl2uidrec" is-aggregate="f" language-name="sql" context="dbms_xmlgen$ctxhdl2uidrec" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" is-returning-set="f" ret-datatype="record" function-arguments="ctxhdl numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23022" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctxhdl numeric" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$ctxhdl2uidrec(ctxhdl numeric)">
                        <complex-attribute name="sql"><![CDATA[ select ctxHdl, concat('dbms_xmlgen$context_query_', coalesce(trunc(ctxHdl)::text, '')) ]]></complex-attribute>
                        <category _I_D="f9bdbafd-2de4-45b2-b414-3260fe95dec7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="25264f19-9599-4d1a-bc7b-495d3ab90a0a" name="dbms_xmlgen$ctxidx" is-trigger-function="0" unique-function-name="dbms_xmlgen$ctxidx" is-aggregate="f" language-name="sql" context="dbms_xmlgen$ctxidx" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" is-returning-set="f" ret-datatype="varchar" function-arguments="ctxhdl numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23023" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctxhdl numeric" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$ctxidx(ctxhdl numeric)">
                        <complex-attribute name="sql"><![CDATA[ select ctxIdx from dbms_xmlgen$ctxHdl2uidRec(ctxHdl) as (Idx numeric, ctxIdx character varying) ]]></complex-attribute>
                        <category _I_D="d41dcdea-1d3f-4abd-9dc9-98aeae7065d8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5a8ee23d-2cc5-4325-bc02-e27252a8a662" name="dbms_xmlgen$default_rowsettag" is-trigger-function="0" unique-function-name="dbms_xmlgen$default_rowsettag" is-aggregate="f" language-name="sql" context="dbms_xmlgen$default_rowsettag" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23014" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$default_rowsettag()">
                        <complex-attribute name="sql"><![CDATA[ select 'ROWSET' ]]></complex-attribute>
                        <category _I_D="8ed00553-3c86-4eff-882f-f6241efc0f5d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bb78e01d-71cb-4445-be49-f043d32a1858" name="dbms_xmlgen$default_rowtag" is-trigger-function="0" unique-function-name="dbms_xmlgen$default_rowtag" is-aggregate="f" language-name="sql" context="dbms_xmlgen$default_rowtag" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23015" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$default_rowtag()">
                        <complex-attribute name="sql"><![CDATA[ select 'ROW' ]]></complex-attribute>
                        <category _I_D="116dec5a-9e7d-4941-aebc-eb59f479fe8d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="56abef31-0beb-4afe-8145-400cb9ea55f7" name="dbms_xmlgen$drop_nulls" is-trigger-function="0" unique-function-name="dbms_xmlgen$drop_nulls" is-aggregate="f" language-name="sql" context="dbms_xmlgen$drop_nulls" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23006" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$drop_nulls()">
                        <complex-attribute name="sql"><![CDATA[ select 0 ]]></complex-attribute>
                        <category _I_D="e0293928-40d0-4b52-b8ef-c5ed1cd4c72e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9c3614cd-a0e1-43fa-843e-3b8a5f55f17b" name="dbms_xmlgen$dtd" is-trigger-function="0" unique-function-name="dbms_xmlgen$dtd" is-aggregate="f" language-name="sql" context="dbms_xmlgen$dtd" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23007" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$dtd()">
                        <complex-attribute name="sql"><![CDATA[ select 1 ]]></complex-attribute>
                        <category _I_D="0c72d0c8-e2e4-49be-8b3f-ccb985ea0cce" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a0ce7485-a97e-496a-8a41-72aafeba230c" name="dbms_xmlgen$empty_tag" is-trigger-function="0" unique-function-name="dbms_xmlgen$empty_tag" is-aggregate="f" language-name="sql" context="dbms_xmlgen$empty_tag" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23008" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$empty_tag()">
                        <complex-attribute name="sql"><![CDATA[ select 2 ]]></complex-attribute>
                        <category _I_D="f2fca4d7-3c1b-45c5-89d5-4d4b8e78af09" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c3f9766c-d40d-40e2-b2b3-eb61e06c7786" name="dbms_xmlgen$entity_decode" is-trigger-function="0" unique-function-name="dbms_xmlgen$entity_decode" is-aggregate="f" language-name="sql" context="dbms_xmlgen$entity_decode" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23009" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$entity_decode()">
                        <complex-attribute name="sql"><![CDATA[ select 1::numeric ]]></complex-attribute>
                        <category _I_D="fb39318b-d366-4fc1-819c-c18dee15ee25" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ce06d00a-0ed5-4ee8-8723-9fe7aff35c67" name="dbms_xmlgen$entity_encode" is-trigger-function="0" unique-function-name="dbms_xmlgen$entity_encode" is-aggregate="f" language-name="sql" context="dbms_xmlgen$entity_encode" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23010" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$entity_encode()">
                        <complex-attribute name="sql"><![CDATA[ select 0::numeric ]]></complex-attribute>
                        <category _I_D="54fd865d-6f5e-464d-9bf5-147b921f7166" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c022a9fc-3580-4edd-ae34-6de2e640d227" name="dbms_xmlgen$getctxobj" is-trigger-function="0" unique-function-name="dbms_xmlgen$getctxobj" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$getctxobj" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" is-returning-set="f" ret-datatype="dbms_xmlgen$tcontext" function-arguments="ctxhdl numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23026" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$getctxobj(ctxhdl numeric)">
                        <complex-attribute name="sql"><![CDATA[
begin
	if ctxHdl < 0  then
		raise exception 'XML processing error. Nagative value [%] was readed', ctxHdl using hint = '22063';
	end if;

	return aws_oracle_ext.dbms_xmlgen$context2obj(ctxHdl => trunc(ctxHdl));

end; ]]></complex-attribute>
                        <category _I_D="02497906-a904-4ee6-a343-c1211e5053c4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dbd94151-a006-436a-a801-f062485546a7" name="dbms_xmlgen$getnumrowsprocessed" is-trigger-function="0" unique-function-name="dbms_xmlgen$getnumrowsprocessed" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$getnumrowsprocessed" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" is-returning-set="f" ret-datatype="numeric" function-arguments="ctx numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23042" volatility="VOLATILE" is-window="f" function-identity-arguments="ctx numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$getnumrowsprocessed(ctx numeric)">
                        <complex-attribute name="sql"><![CDATA[
declare
	lCtx aws_oracle_ext.dbms_xmlgen$tContext;
	lnCtxHdl int := trunc(ctx);
begin
	lCtx := aws_oracle_ext.dbms_xmlgen$getctxobj(ctxHdl => lnCtxHdl);
	return coalesce(lCtx.ctxNumRowsProcessed, 0);
end; ]]></complex-attribute>
                        <category _I_D="97a52eda-0321-426f-9872-b08a6ce9a6bf" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d29531ad-b37d-4372-9c43-63a6799aaa9b" name="dbms_xmlgen$getxml" is-trigger-function="0" unique-function-name="dbms_xmlgen$getxml(ctx numeric, dtdorschema numeric)" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$getxml(ctx numeric, dtdorschema numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric" unique-suffix="(ctx numeric, dtdorschema numeric)" routine-number="23043" is-returning-set="f" ret-datatype="text" function-arguments="ctx numeric, dtdorschema numeric DEFAULT aws_oracle_ext.&quot;dbms_xmlgen$none&quot;()" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23043" volatility="VOLATILE" is-window="f" function-identity-arguments="ctx numeric, dtdorschema numeric" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_xmlgen$getxml(ctx numeric, dtdorschema numeric)">
                        <complex-attribute name="sql"><![CDATA[
declare
    lCtx aws_oracle_ext.dbms_xmlgen$tContext;
    lnCtxHdl int := trunc(ctx);
    lvReturn text;
    lrResult record;
begin
	lCtx := aws_oracle_ext.dbms_xmlgen$getctxobj(ctxHdl => lnCtxHdl);

	if lCtx is null then
	    raise exception 'Invalid context or doesn''t exists' using hint = '19019';
	else
		lrResult := aws_oracle_ext.dbms_xmlgen$qc2xml(pvSQL => lCtx.ctxQuery,
	                                                  pCr => lCtx.ctxCursor,
	                                                  pnMaxRows => (lCtx.ctxAttributes).ctxMaxRows,
	                                                  pvRowsetTag => (lCtx.ctxAttributes).ctxRowsettag,
	                                                  pvRowTag => (lCtx.ctxAttributes).ctxRowTag,
	                                                  pnSkipRows => (lCtx.ctxAttributes).ctxSkipRows
	                                                 );

	    perform aws_oracle_ext.dbms_xmlgen$setctxvalue(ctxHdl => lCtx.ctxIdx,
	                                                   ctxCursor => lCtx.ctxCursor,
	                                                   ctxQuery => lCtx.ctxQuery,
	                                                   ctxAttributes => lCtx.ctxAttributes,
	                                                   ctxNumRowsProcessed => lrResult.pnRowCount,
	                                                   forceSetValues => true
	                                                  );

	    lvReturn := xmlserialize(document lrResult.pxXML as text
                                );
	end if;

	return lvReturn;
end; ]]></complex-attribute>
                        <category _I_D="f10e09c2-1d67-46e7-9c92-34e59f54e937" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0e776459-d3ad-463d-befa-fe784f16179a" name="dbms_xmlgen$getxml" is-trigger-function="0" unique-function-name="dbms_xmlgen$getxml(sqlquery text, dtdorschema numeric)" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$getxml(sqlquery text, dtdorschema numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric" unique-suffix="(sqlquery text, dtdorschema numeric)" routine-number="23044" is-returning-set="f" ret-datatype="text" function-arguments="sqlquery text, dtdorschema numeric DEFAULT aws_oracle_ext.&quot;dbms_xmlgen$none&quot;()" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23044" volatility="VOLATILE" is-window="f" function-identity-arguments="sqlquery text, dtdorschema numeric" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_xmlgen$getxml(sqlquery text, dtdorschema numeric)">
                        <complex-attribute name="sql"><![CDATA[
begin
    return xmlserialize(document (aws_oracle_ext.dbms_xmlgen$qc2xml(pvSQL => sqlQuery,
				                                                    pCr => null,
				                                                    pvRowsetTag => aws_oracle_ext.dbms_xmlgen$default_rowsettag(),
				                                                    pvRowTag => aws_oracle_ext.dbms_xmlgen$default_rowtag()
				                                                   )).pxXML as text
                       );
end; ]]></complex-attribute>
                        <category _I_D="58541122-97c0-47e5-92f5-df876c597a96" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="81fb0e46-4fd5-4faf-89e2-5f358b04fd45" name="dbms_xmlgen$newcontext" is-trigger-function="0" unique-function-name="dbms_xmlgen$newcontext(querystring refcursor)" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$newcontext(querystring refcursor)" subcategories-loading="none" object-loading="extended" arguments-datatypes="refcursor" unique-suffix="(querystring refcursor)" routine-number="23032" is-returning-set="f" ret-datatype="numeric" function-arguments="querystring refcursor" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23032" volatility="VOLATILE" is-window="f" function-identity-arguments="querystring refcursor" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_xmlgen$newcontext(querystring refcursor)">
                        <complex-attribute name="sql"><![CDATA[
begin
	return aws_oracle_ext.dbms_xmlgen$setctxvalue(ctxHdl => null,
			                                      ctxCursor => queryString,
			                                      ctxQuery => null,
			                                      ctxAttributes => null,
			                                      ctxNumRowsProcessed => null
			                                     );
end; ]]></complex-attribute>
                        <category _I_D="2d17530a-6963-45c3-8be3-942ebd9ff7d0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5600c312-95a5-4757-bc2b-de6b71bb5917" name="dbms_xmlgen$newcontext" is-trigger-function="0" unique-function-name="dbms_xmlgen$newcontext(querystring text)" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$newcontext(querystring text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" unique-suffix="(querystring text)" routine-number="23031" is-returning-set="f" ret-datatype="numeric" function-arguments="querystring text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23031" volatility="VOLATILE" is-window="f" function-identity-arguments="querystring text" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_xmlgen$newcontext(querystring text)">
                        <complex-attribute name="sql"><![CDATA[
declare
begin
	return aws_oracle_ext.dbms_xmlgen$setctxvalue(ctxHdl => null,
			                                      ctxCursor => null,
			                                      ctxQuery => queryString,
			                                      ctxAttributes => null,
			                                      ctxNumRowsProcessed => null
			                                     );
end; ]]></complex-attribute>
                        <category _I_D="665fdce1-802a-4ae5-9481-242e69fbef87" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="440bba92-4d9a-4cf0-94d6-4f5fee1242f2" name="dbms_xmlgen$none" is-trigger-function="0" unique-function-name="dbms_xmlgen$none" is-aggregate="f" language-name="sql" context="dbms_xmlgen$none" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23011" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$none()">
                        <complex-attribute name="sql"><![CDATA[ select 0 ]]></complex-attribute>
                        <category _I_D="12526afc-ee2c-4066-8d80-5fec22f81d9f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dfaa4796-f423-4c8c-bd01-ec76161ebdba" name="dbms_xmlgen$null_attr" is-trigger-function="0" unique-function-name="dbms_xmlgen$null_attr" is-aggregate="f" language-name="sql" context="dbms_xmlgen$null_attr" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23012" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$null_attr()">
                        <complex-attribute name="sql"><![CDATA[ select 1 ]]></complex-attribute>
                        <category _I_D="7c430506-e6fe-4dd2-9118-46292d6c2ddb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9dc1aa3a-9268-4ed6-807b-b67ed8dc61bb" name="dbms_xmlgen$qc2xml" is-trigger-function="0" unique-function-name="dbms_xmlgen$qc2xml" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$qc2xml" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,refcursor,boolean,boolean,numeric,numeric,text,text,numeric,boolean,boolean,xml,integer" is-returning-set="f" ret-datatype="record" function-arguments="pvsql text, pcr refcursor, pbaddxmlroot boolean DEFAULT true, pbconvertspecialchars boolean DEFAULT NULL::boolean, pnmaxrows numeric DEFAULT NULL::numeric, pnnullhandling numeric DEFAULT NULL::numeric, pvrowsettag text DEFAULT NULL::text, pvrowtag text DEFAULT NULL::text, pnskiprows numeric DEFAULT NULL::numeric, pbusenullattributeindicator boolean DEFAULT NULL::boolean, pbuseitemtagsforcoll boolean DEFAULT NULL::boolean, OUT pxxml xml, OUT pnrowcount integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="11" function-id="23029" volatility="VOLATILE" is-window="f" function-identity-arguments="pvsql text, pcr refcursor, pbaddxmlroot boolean, pbconvertspecialchars boolean, pnmaxrows numeric, pnnullhandling numeric, pvrowsettag text, pvrowtag text, pnskiprows numeric, pbusenullattributeindicator boolean, pbuseitemtagsforcoll boolean, OUT pxxml xml, OUT pnrowcount integer" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$qc2xml(pvsql text, pcr refcursor, pbaddxmlroot boolean, pbconvertspecialchars boolean, pnmaxrows numeric, pnnullhandling numeric, pvrowsettag text, pvrowtag text, pnskiprows numeric, pbusenullattributeindicator boolean, pbuseitemtagsforcoll boolean, OUT pxxml xml, OUT pnrowcount integer)">
                        <complex-attribute name="sql"><![CDATA[
declare

  crMain refcursor;
  lxResult xml := null;
  lxXMLArr xml[];

  lvSQL text := pvSQL;
  lCr refcursor := pCr;

  lbAddXmlRoot boolean := coalesce(pbAddXmlRoot, true);
  lbConvertSpecialChars boolean := pbConvertSpecialChars;
  lnMaxRows int := trunc(pnMaxRows);
  lnNullHandling numeric := pnNullHandling;
  lvRowsetTag text := nullif(pvRowsetTag, '');
  lvRowTag text := nullif(pvRowTag, '');
  lnSkipRows int := trunc(pnSkipRows);
  lbUseNullattributeIndicator bool := pbUseNullattributeIndicator;
  lbUseItemTagsForColl bool := pbUseItemTagsForColl;

  lvQuery text;
  lvQueryROWSETTAG text :=  $query$ select xmlelement(name %1$s, xmlagg(row))
							          from unnest($1) as q(row)
       				        $query$;

  lvQueryROWTAG text := $query$ select xmlelement(name %2$s,
                                                  xmlagg(xmlelement(name %1$s, row))
				                                 )
							      from unnest($1) as q(row)
       				    $query$;

begin

   if lvRowSetTag is not null and lvRowTag is not null then

   	 lvQuery := format(lvQueryROWTAG, lvRowTag, lvRowSetTag);

   elsif lvRowSetTag is null and lvRowTag is not null or
         lvRowSetTag is not null and lvRowTag is null then

     lvQuery := format(lvQueryROWSETTAG, coalesce(lvRowSetTag, lvRowTag));

   elseif lvRowTag is null and lvRowSetTag is null then

     lxResult := xmlparse(content '<ERROR>ext.XMLSQLException: The row-set tag and the row tag are both omitted.</ERROR>');

   else

   	 lxResult := xmlparse(content '<ERROR>ext.XMLSQLException: Undeterminated error.</ERROR>');
   end if; -- if lvRowSetTag is not null and lvRowTag is not null thenn


   if lxResult is null then
     if nullif(lvSQL, '') is not null or
        nullif(lCr::text, '') is not null then

	   select array_agg(xmlrow)
	     into lxXMLArr
	     from aws_oracle_ext.dbms_xmlgen$qc2xmltab(pvSQL => lvSQL,
                                                   pCr => lCr,
                                                   pnLimit => lnMaxRows,
                                                   pnOffset => lnSkipRows
                                                  );
	 else
	   raise exception 'Null Exception.' using hint = '29532';
	 end if;

     begin
         open crMain for execute lvQuery using lxXMLArr;
         fetch crMain into lxResult;
         close crMain;
     end;

   end if; -- if lvResult is null then

   if lbAddXmlRoot then
   	lxResult := xmlroot(lxResult, version '1.0', standalone yes);
   end if;

   pxXML := lxResult;
   pnRowCount := array_length(lxXMLArr, 1);
end; ]]></complex-attribute>
                        <category _I_D="00fb2221-d9c3-4c53-a6e9-bafacc141e68" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="00aa695c-4fe5-4aa7-bfe5-938c72c72403" name="dbms_xmlgen$qc2xmltab" is-trigger-function="0" unique-function-name="dbms_xmlgen$qc2xmltab" is-aggregate="f" language-name="sql" context="dbms_xmlgen$qc2xmltab" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,refcursor,integer,integer,xml" is-returning-set="t" ret-datatype="table" function-arguments="pvsql text, pcr refcursor, pnlimit integer DEFAULT NULL::integer, pnoffset integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_DATASET" count-arguments="4" function-id="23028" volatility="STABLE" is-window="f" function-identity-arguments="pvsql text, pcr refcursor, pnlimit integer, pnoffset integer" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$qc2xmltab(pvsql text, pcr refcursor, pnlimit integer, pnoffset integer)">
                        <complex-attribute name="sql"><![CDATA[
 	 select xrs.row
	   from query_to_xml(format($q$ select * from (%1$s) q limit %2$L::int offset %3$L::int $q$,
	                            pvSQL,
	                            nullif(greatest(pnLimit, sign(pnLimit)), -1),
	                            nullif(greatest(pnOffset, 0), 0)
	                           ),
	                     false,
	                     false,
	                     ''
	                    ) as xt(xml_data),
	        xmltable('//table/row' passing xt.xml_data columns row xml path '*' ) xrs
	  where nullif(pvSQL, '') is not null
	    and nullif(pCr::text, '') is null
	 union all
	 (select xrs.row
	    from cursor_to_xml(pCr,
	                       coalesce(pnLimit,
	                                nullif(greatest(pnLimit, sign(pnLimit)), -1),
	                                2147483647)::int,
	                       false,
	                       false,
	                       ''
	                      ) as xt(xml_data),
	         xmltable('//table/row' passing xt.xml_data columns row xml path '*' ) xrs
	   where aws_oracle_ext.dbms_xmlgen$crIsOpened(pCr)
	     and nullif(pvSQL, '') is null
	     and nullif(pCr::text, '') is not null
	   offset nullif(greatest(pnOffset, 0), 0)
	 );
]]></complex-attribute>
                        <category _I_D="9074e165-c5d9-4417-9133-aa4236b58c61" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0d3788b9-38df-4ced-b716-ab0d8e8ec272" name="dbms_xmlgen$schema" is-trigger-function="0" unique-function-name="dbms_xmlgen$schema" is-aggregate="f" language-name="sql" context="dbms_xmlgen$schema" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23013" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlgen$schema()">
                        <complex-attribute name="sql"><![CDATA[ select 2 ]]></complex-attribute>
                        <category _I_D="af53ee35-41c3-4aab-a8cc-4a4912b478a6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="12f60082-c324-44f8-885f-f9568a6f1f8c" name="dbms_xmlgen$setconvertspecialchars" is-trigger-function="0" unique-function-name="dbms_xmlgen$setconvertspecialchars" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$setconvertspecialchars" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,boolean" is-returning-set="f" ret-datatype="void" function-arguments="ctx numeric, replace boolean" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23038" volatility="VOLATILE" is-window="f" function-identity-arguments="ctx numeric, replace boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$setconvertspecialchars(ctx numeric, replace boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxConvertSpecialChars constant text = 'ctxConvertSpecialChars';
	lCtx aws_oracle_ext.dbms_xmlgen$tContext;
	lnCtxHdl int := trunc(ctx);
begin
	lCtx := aws_oracle_ext.dbms_xmlgen$getctxobj(ctxHdl => lnCtxHdl);

    if not lCtx is null then
	lCtx.ctxAttributes := aws_oracle_ext.dbms_xmlgen$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
                                                                     forceParamList => array[case when replace is null then CtxConvertSpecialChars else null end],
                                                                     ctxConvertSpecialChars => replace
                                                                    );

    perform aws_oracle_ext.dbms_xmlgen$setctxvalue(ctxHdl => lCtx.ctxIdx,
                                                   ctxCursor => lCtx.ctxCursor,
                                                   ctxQuery => lCtx.ctxQuery,
                                                   ctxAttributes => lCtx.ctxAttributes,
                                                   ctxNumRowsProcessed => lCtx.ctxNumRowsProcessed,
                                                   forceSetValues => true
                                                  );
    end if;
end; ]]></complex-attribute>
                        <category _I_D="5376001b-ec4e-4b1f-97c3-37d9a65e49ff" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="cb8dc803-7f46-4b63-8819-d1fb154b8de4" name="dbms_xmlgen$setctxattrvalue" is-trigger-function="0" unique-function-name="dbms_xmlgen$setctxattrvalue" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$setctxattrvalue" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;,text[],boolean,numeric,numeric,text,text,numeric,boolean,boolean" is-returning-set="f" ret-datatype="dbms_xmlgen$tctxattributes" function-arguments="INOUT ctxattributes aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;, forceparamlist text[] DEFAULT NULL::text[], ctxconvertspecialchars boolean DEFAULT NULL::boolean, ctxmaxrows numeric DEFAULT NULL::numeric, ctxnullhandling numeric DEFAULT NULL::numeric, ctxrowsettag text DEFAULT NULL::text, ctxrowtag text DEFAULT NULL::text, ctxskiprows numeric DEFAULT NULL::numeric, ctxusenullattributeindicator boolean DEFAULT NULL::boolean, ctxuseitemtagsforcoll boolean DEFAULT NULL::boolean" schema-id="21999" function-type="RET_SCALAR" count-arguments="10" function-id="23033" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT ctxattributes aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;, forceparamlist text[], ctxconvertspecialchars boolean, ctxmaxrows numeric, ctxnullhandling numeric, ctxrowsettag text, ctxrowtag text, ctxskiprows numeric, ctxusenullattributeindicator boolean, ctxuseitemtagsforcoll boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$setctxattrvalue(INOUT ctxattributes aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;, forceparamlist text[], ctxconvertspecialchars boolean, ctxmaxrows numeric, ctxnullhandling numeric, ctxrowsettag text, ctxrowtag text, ctxskiprows numeric, ctxusenullattributeindicator boolean, ctxuseitemtagsforcoll boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
	lforceParamList text[];
begin
	if ctxMaxRows < 0  then
		raise exception 'XML processing error. Nagative value [%] was readed', ctxMaxRows using hint = '22063';
	elsif ctxSkipRows < 0 then
		raise exception 'XML processing error. Nagative value [%] was readed', ctxSkipRows using hint = '22063';
	elsif ctxNullHandling < 0 then
		raise exception 'XML processing error. Nagative value [%] was readed', ctxNullHandling using hint = '22063';
	end if;

	lforceParamList := upper(forceParamList::text)::text[];

	ctxAttributes := (case when upper('ctxConvertSpecialChars') = any(lforceParamList) then ctxConvertSpecialChars else coalesce(ctxConvertSpecialChars, ctxAttributes.ctxConvertSpecialChars) end,
	                  case when upper('ctxMaxRows') = any(lforceParamList) then ctxMaxRows else coalesce(ctxMaxRows, ctxAttributes.ctxMaxRows) end,
                      case when upper('ctxNullHandling') = any(lforceParamList) then ctxNullHandling else coalesce(ctxNullHandling, ctxAttributes.ctxNullHandling) end,
	                  case when upper('ctxRowsetTag') = any(lforceParamList) then ctxRowsetTag else coalesce(ctxRowsetTag, ctxAttributes.ctxRowsetTag) end,
	                  case when upper('ctxRowTag') = any(lforceParamList) then ctxRowTag else coalesce(ctxRowTag, ctxAttributes.ctxRowTag) end,
	                  case when upper('ctxSkipRows') = any(lforceParamList) then ctxSkipRows else coalesce(ctxSkipRows, ctxAttributes.ctxSkipRows) end,
	                  case when upper('ctxUseNullattributeIndicator') = any(lforceParamList) then ctxUseNullattributeIndicator else coalesce(ctxUseNullattributeIndicator, ctxAttributes.ctxUseNullattributeIndicator) end,
	                  case when upper('ctxUseItemTagsForColl') = any(lforceParamList) then ctxUseItemTagsForColl else coalesce(ctxUseItemTagsForColl, ctxAttributes.ctxUseItemTagsForColl) end
                     )::dbms_xmlgen$TctxAttributes;
	lforceParamList := upper(forceParamList::text)::text[];

	ctxAttributes := (case when upper('ctxConvertSpecialChars') = any(lforceParamList) then ctxConvertSpecialChars else coalesce(ctxConvertSpecialChars, ctxAttributes.ctxConvertSpecialChars) end,
	                  case when upper('ctxMaxRows') = any(lforceParamList) then ctxMaxRows else coalesce(ctxMaxRows, ctxAttributes.ctxMaxRows) end,
                      case when upper('ctxNullHandling') = any(lforceParamList) then ctxNullHandling else coalesce(ctxNullHandling, ctxAttributes.ctxNullHandling) end,
	                  case when upper('ctxRowsetTag') = any(lforceParamList) then ctxRowsetTag else coalesce(ctxRowsetTag, ctxAttributes.ctxRowsetTag) end,
	                  case when upper('ctxRowTag') = any(lforceParamList) then ctxRowTag else coalesce(ctxRowTag, ctxAttributes.ctxRowTag) end,
	                  case when upper('ctxSkipRows') = any(lforceParamList) then ctxSkipRows else coalesce(ctxSkipRows, ctxAttributes.ctxSkipRows) end,
	                  case when upper('ctxUseNullattributeIndicator') = any(lforceParamList) then ctxUseNullattributeIndicator else coalesce(ctxUseNullattributeIndicator, ctxAttributes.ctxUseNullattributeIndicator) end,
	                  case when upper('ctxUseItemTagsForColl') = any(lforceParamList) then ctxUseItemTagsForColl else coalesce(ctxUseItemTagsForColl, ctxAttributes.ctxUseItemTagsForColl) end
                     )::dbms_xmlgen$TctxAttributes;
end; ]]></complex-attribute>
                        <category _I_D="e4620f03-e46c-4fcc-b649-4da95f72aa6c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ca826379-072d-482b-9811-71d1f29260fc" name="dbms_xmlgen$setctxvalue" is-trigger-function="0" unique-function-name="dbms_xmlgen$setctxvalue" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$setctxvalue" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,refcursor,text,aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;,integer,boolean" is-returning-set="f" ret-datatype="numeric" function-arguments="ctxhdl numeric, ctxcursor refcursor, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;, ctxnumrowsprocessed integer, forcesetvalues boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="23027" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, ctxcursor refcursor, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;, ctxnumrowsprocessed integer, forcesetvalues boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$setctxvalue(ctxhdl numeric, ctxcursor refcursor, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlgen$tctxattributes&quot;, ctxnumrowsprocessed integer, forcesetvalues boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
    CONTEXT_SEQUENCE constant text := 'dbms_xmlgen$context$sequence';
    lrCtxQuery record;
    lrCtx aws_oracle_ext.dbms_xmlgen$TContext;
    lvCtx text;
    lnIdx numeric := ctxHdl;
    lvCtxIdx varchar;
    lnCurrval int := 0;
begin
	if ctxHdl is null then
		lnCurrval := coalesce(nullif(aws_oracle_ext.get_extpack_variable(variable_name => CONTEXT_SEQUENCE, missing_ok => true), ''), '-1')::integer;
        begin
            lnCurrval := lnCurrval + 1;
            perform aws_oracle_ext.set_extpack_variable(variable_name => CONTEXT_SEQUENCE, variable_value => lnCurrval::text);
            select Idx, ctxIdx, aws_oracle_ext.dbms_xmlgen$context2text(Idx, ctxCursor, ctxQuery) ctx
              into lrCtxQuery
              from aws_oracle_ext.dbms_xmlgen$ctxHdl2uidRec(lnCurrval) as (Idx numeric, ctxIdx character varying);

            lnIdx := lrCtxQuery.Idx;
            lvCtxIdx := lrCtxQuery.ctxIdx;
            lvCtx := lrCtxQuery.ctx;
        end;
	elsif ctxHdl is not null and
	      ctxCursor is not null or
          ctxQuery is not null or
          ctxAttributes is not null or
          ctxNumRowsProcessed is not null then

	   if forceSetValues then
	       lrCtx.ctxIdx := ctxHdl;
		   lrCtx.ctxCursor := ctxCursor;
		   lrCtx.ctxQuery := ctxQuery;
		   lrCtx.ctxAttributes := ctxAttributes;
		   lrCtx.ctxNumRowsProcessed := ctxNumRowsProcessed;
	   else
	   	   lrCtx := aws_oracle_ext.dbms_xmlgen$getctxobj(ctxHdl => ctxHdl);

		   if not lrCtx is null then
		   	   lrCtx.ctxCursor := coalesce(ctxCursor, lrCtx.ctxCursor);
			   lrCtx.ctxQuery := coalesce(ctxQuery, lrCtx.ctxQuery);
			   lrCtx.ctxAttributes := coalesce(ctxAttributes, lrCtx.ctxAttributes);
			   lrCtx.ctxNumRowsProcessed := coalesce(ctxNumRowsProcessed, lrCtx.ctxNumRowsProcessed);
		   end if; -- if not lrCtx is null then
	   end if; --  if forceSetValues then

	   lvCtxIdx := aws_oracle_ext.dbms_xmlgen$ctxIdx(ctxHdl);
	   lvCtx := aws_oracle_ext.dbms_xmlgen$context2text(lrCtx);
	else
		lvCtxIdx := aws_oracle_ext.dbms_xmlgen$ctxIdx(ctxHdl);
		lvCtx := null;
	end if;

    perform aws_oracle_ext.set_extpack_variable(variable_name => lvCtxIdx, variable_value => lvCtx);

    return lnIdx;
end; ]]></complex-attribute>
                        <category _I_D="90554442-2617-4855-a12a-0ee2cd6ba323" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e8dc647f-2f46-4d0d-a14a-4710fa9a4960" name="dbms_xmlgen$setmaxrows" is-trigger-function="0" unique-function-name="dbms_xmlgen$setmaxrows" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$setmaxrows" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric" is-returning-set="f" ret-datatype="void" function-arguments="ctx numeric, maxrows numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23034" volatility="VOLATILE" is-window="f" function-identity-arguments="ctx numeric, maxrows numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$setmaxrows(ctx numeric, maxrows numeric)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxMaxRows constant text = 'ctxMaxRows';
	lCtx aws_oracle_ext.dbms_xmlgen$tContext;
	lnCtxHdl int := trunc(ctx);
begin
	lCtx := aws_oracle_ext.dbms_xmlgen$getctxobj(ctxHdl => lnCtxHdl);

    if not lCtx is null then
        lCtx.ctxAttributes := aws_oracle_ext.dbms_xmlgen$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
                                                                         forceParamList => array[case when maxRows is null then CtxMaxRows else null end],
                                                                         ctxMaxRows => maxRows
                                                                        );

        perform aws_oracle_ext.dbms_xmlgen$setctxvalue(ctxHdl => lCtx.ctxIdx,
                                                       ctxCursor => lCtx.ctxCursor,
                                                       ctxQuery => lCtx.ctxQuery,
                                                       ctxAttributes => lCtx.ctxAttributes,
                                                       ctxNumRowsProcessed => lCtx.ctxNumRowsProcessed,
                                                       forceSetValues => true
                                                      );
	end if;
end; ]]></complex-attribute>
                        <category _I_D="86e0d5d6-23ad-4474-91e9-b89348280906" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7ca1e06c-643a-4982-9a38-8a38d1d68cfd" name="dbms_xmlgen$setnullhandling" is-trigger-function="0" unique-function-name="dbms_xmlgen$setnullhandling" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$setnullhandling" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric" is-returning-set="f" ret-datatype="void" function-arguments="ctx numeric, flag numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23039" volatility="VOLATILE" is-window="f" function-identity-arguments="ctx numeric, flag numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$setnullhandling(ctx numeric, flag numeric)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxNullHandling constant text = 'ctxNullHandling';
	lnCtxHdl int := trunc(ctx);
	lCtx aws_oracle_ext.dbms_xmlgen$tContext;
begin
	lCtx := aws_oracle_ext.dbms_xmlgen$getctxobj(ctxHdl => lnCtxHdl);

    if not lCtx is null then
        lCtx.ctxAttributes := aws_oracle_ext.dbms_xmlgen$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
                                                                         forceParamList => array[case when flag is null then CtxNullHandling else null end],
                                                                         ctxNullHandling => flag
                                                                        );

        perform aws_oracle_ext.dbms_xmlgen$setctxvalue(ctxHdl => lCtx.ctxIdx,
                                                       ctxCursor => lCtx.ctxCursor,
                                                       ctxQuery => lCtx.ctxQuery,
                                                       ctxAttributes => lCtx.ctxAttributes,
                                                       ctxNumRowsProcessed => lCtx.ctxNumRowsProcessed,
                                                       forceSetValues => true
                                                      );
	end if;
end; ]]></complex-attribute>
                        <category _I_D="18517800-e924-41e3-8a78-2a8cfe044b3c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8d9883a8-5735-4a8c-81b3-43f3229c424f" name="dbms_xmlgen$setrowsettag" is-trigger-function="0" unique-function-name="dbms_xmlgen$setrowsettag" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$setrowsettag" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text" is-returning-set="f" ret-datatype="void" function-arguments="ctx numeric, rowsettagname text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23035" volatility="VOLATILE" is-window="f" function-identity-arguments="ctx numeric, rowsettagname text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$setrowsettag(ctx numeric, rowsettagname text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxAttrName constant text = 'ctxRowSetTag';
	lCtx aws_oracle_ext.dbms_xmlgen$tContext;
	lnCtxHdl int := trunc(ctx);
    lbCtxExists boolean;
begin
	lCtx := aws_oracle_ext.dbms_xmlgen$getctxobj(ctxHdl => lnCtxHdl);

    if not lCtx is null then
        lCtx.ctxAttributes := aws_oracle_ext.dbms_xmlgen$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
                                                                         forceParamList => array[case when rowSetTagName is null then CtxAttrName else null end],
                                                                         ctxRowSetTag => rowSetTagName
                                                                        );

        perform aws_oracle_ext.dbms_xmlgen$setctxvalue(ctxHdl => lCtx.ctxIdx,
                                                       ctxCursor => lCtx.ctxCursor,
                                                       ctxQuery => lCtx.ctxQuery,
                                                       ctxAttributes => lCtx.ctxAttributes,
                                                       ctxNumRowsProcessed => lCtx.ctxNumRowsProcessed,
                                                       forceSetValues => true
                                                      );
	end if;
end; ]]></complex-attribute>
                        <category _I_D="6f504646-b44e-4ff5-a547-b92de55830cb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="68c231e0-1bf9-4ba6-8dbe-151a4cd5985a" name="dbms_xmlgen$setrowtag" is-trigger-function="0" unique-function-name="dbms_xmlgen$setrowtag" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$setrowtag" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text" is-returning-set="f" ret-datatype="void" function-arguments="ctx numeric, rowtagname text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23036" volatility="VOLATILE" is-window="f" function-identity-arguments="ctx numeric, rowtagname text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$setrowtag(ctx numeric, rowtagname text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxAttrName constant text = 'ctxRowTag';
	lCtx aws_oracle_ext.dbms_xmlgen$tContext;
	lnCtxHdl int := trunc(ctx);
begin
	lCtx := aws_oracle_ext.dbms_xmlgen$getctxobj(ctxHdl => lnCtxHdl);

    if not lCtx is null then
        lCtx.ctxAttributes := aws_oracle_ext.dbms_xmlgen$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
                                                                         forceParamList => array[case when rowTagName is null then CtxAttrName else null end],
                                                                         ctxRowTag => rowTagName
                                                                        );

        perform aws_oracle_ext.dbms_xmlgen$setctxvalue(ctxHdl => lCtx.ctxIdx,
                                                       ctxCursor => lCtx.ctxCursor,
                                                       ctxQuery => lCtx.ctxQuery,
                                                       ctxAttributes => lCtx.ctxAttributes,
                                                       ctxNumRowsProcessed => lCtx.ctxNumRowsProcessed,
                                                       forceSetValues => true
                                                      );
    	end if;
end; ]]></complex-attribute>
                        <category _I_D="65083561-9395-41d2-923c-1036dcfe16a3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="99de34c5-01b1-4eab-9757-ac1c18f600f5" name="dbms_xmlgen$setskiprows" is-trigger-function="0" unique-function-name="dbms_xmlgen$setskiprows" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$setskiprows" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric" is-returning-set="f" ret-datatype="void" function-arguments="ctx numeric, skiprows numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23037" volatility="VOLATILE" is-window="f" function-identity-arguments="ctx numeric, skiprows numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$setskiprows(ctx numeric, skiprows numeric)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxSkipRows constant text = 'ctxSkipRows';
	lCtx aws_oracle_ext.dbms_xmlgen$tContext;
	lnCtxHdl int := trunc(ctx);
begin
	lCtx := aws_oracle_ext.dbms_xmlgen$getctxobj(ctxHdl => lnCtxHdl);

    if not lCtx is null then
        lCtx.ctxAttributes := aws_oracle_ext.dbms_xmlgen$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
                                                                         forceParamList => array[case when skipRows is null then CtxSkipRows else null end],
                                                                         ctxSkipRows => skipRows
                                                                        );

        perform aws_oracle_ext.dbms_xmlgen$setctxvalue(ctxHdl => lCtx.ctxIdx,
                                                       ctxCursor => lCtx.ctxCursor,
                                                       ctxQuery => lCtx.ctxQuery,
                                                       ctxAttributes => lCtx.ctxAttributes,
                                                       ctxNumRowsProcessed => lCtx.ctxNumRowsProcessed,
                                                       forceSetValues => true
                                                      );
	end if;
end; ]]></complex-attribute>
                        <category _I_D="d67dfe98-76c6-4d83-9088-3fb87a052d6a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="624011e0-9f6e-4ba5-a41a-6e07241f7e3f" name="dbms_xmlgen$useitemtagsforcoll" is-trigger-function="0" unique-function-name="dbms_xmlgen$useitemtagsforcoll" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$useitemtagsforcoll" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" is-returning-set="f" ret-datatype="void" function-arguments="ctx numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23040" volatility="VOLATILE" is-window="f" function-identity-arguments="ctx numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$useitemtagsforcoll(ctx numeric)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxUseItemTagsForColl constant text = 'ctxUseItemTagsForColl';
	lnCtxHdl int := trunc(ctx);
	lCtx dbms_xmlgen$tContext;
begin
	lCtx := aws_oracle_ext.dbms_xmlgen$getctxobj(ctxHdl => lnCtxHdl);

    if not lCtx is null then
        lCtx.ctxAttributes := dbms_xmlgen$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
                                                          forceParamList => array[CtxUseItemTagsForColl],
                                                          ctxUseItemTagsForColl => true
                                                         );

        perform aws_oracle_ext.dbms_xmlgen$setctxvalue(ctxHdl => lCtx.ctxIdx,
                                                    ctxCursor => lCtx.ctxCursor,
                                                    ctxQuery => lCtx.ctxQuery,
                                                    ctxAttributes => lCtx.ctxAttributes,
                                                    ctxNumRowsProcessed => lCtx.ctxNumRowsProcessed,
                                                    forceSetValues => true
                                                   );
	end if;
end; ]]></complex-attribute>
                        <category _I_D="843f0056-b79d-4724-99e1-8345b2c86442" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="cb7a3c75-ad32-46b3-ae8b-2209e2a34169" name="dbms_xmlgen$usenullattributeindicator" is-trigger-function="0" unique-function-name="dbms_xmlgen$usenullattributeindicator" is-aggregate="f" language-name="plpgsql" context="dbms_xmlgen$usenullattributeindicator" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,boolean" is-returning-set="f" ret-datatype="void" function-arguments="ctx numeric, attrind boolean DEFAULT true" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23041" volatility="VOLATILE" is-window="f" function-identity-arguments="ctx numeric, attrind boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlgen$usenullattributeindicator(ctx numeric, attrind boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxUseNullAttributeIndicator constant text = 'ctxUseNullAttributeIndicator';
	lnCtxHdl int := trunc(ctx);
	lCtx dbms_xmlgen$tContext;
begin
	lCtx := aws_oracle_ext.dbms_xmlgen$getctxobj(ctxHdl => lnCtxHdl);

    if not lCtx is null then
        lCtx.ctxAttributes := dbms_xmlgen$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
                                                          forceParamList => array[case when attrind is null then CtxUseNullAttributeIndicator else null end],
                                                          ctxUseNullAttributeIndicator => attrind
                                                         );

        perform aws_oracle_ext.dbms_xmlgen$setctxvalue(ctxHdl => lCtx.ctxIdx,
                                                    ctxCursor => lCtx.ctxCursor,
                                                    ctxQuery => lCtx.ctxQuery,
                                                    ctxAttributes => lCtx.ctxAttributes,
                                                    ctxNumRowsProcessed => lCtx.ctxNumRowsProcessed,
                                                    forceSetValues => true
                                                   );
	end if;
end; ]]></complex-attribute>
                        <category _I_D="b73c7277-5957-4f62-b8a6-3f3c816bc2db" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6cddd263-4ae3-4718-a701-c702f966fd46" name="dbms_xmlquery$all_rows" is-trigger-function="0" unique-function-name="dbms_xmlquery$all_rows" is-aggregate="f" language-name="sql" context="dbms_xmlquery$all_rows" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22914" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$all_rows()">
                        <complex-attribute name="sql"><![CDATA[ select -1 ]]></complex-attribute>
                        <category _I_D="cc86363b-24fc-40be-9732-cc6f77389dc0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f504e581-46ff-4f71-9fd8-b32460c35528" name="dbms_xmlquery$closecontext" is-trigger-function="0" unique-function-name="dbms_xmlquery$closecontext" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$closecontext" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22944" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$closecontext(ctxhdl numeric)">
                        <complex-attribute name="sql"><![CDATA[
declare
	emtyStr constant varchar := '';
    ctxIdx text;
    ctxVal text;
begin
	ctxIdx := aws_oracle_ext.dbms_xmlquery$ctxIdx(ctxHdl);

	begin
	  ctxVal := aws_oracle_ext.get_extpack_variable(variable_name => ctxIdx, missing_ok => false);
	exception when sqlstate '42704' then
				if position(ctxIdx in sqlerrm) then
	            	ctxVal := emtyStr;
	            else
	            	raise exception using hint = sqlstate, message = sqlerrm;
	            end if;
	          when others then
	            raise exception using hint = sqlstate, message = sqlerrm;
	end;

    begin
	    if nullif(ctxVal, emtyStr) is not null then
	    	perform aws_oracle_ext.set_extpack_variable(variable_name => ctxIdx, variable_value => null::text);
	    else
	    	raise exception undefined_object;
	    end if;

	exception when undefined_object then
		raise exception 'Invalid context handle specified.' using hint = '29532';
	end;
end; ]]></complex-attribute>
                        <category _I_D="fe341da2-bb90-4079-b8a4-f97797e311c8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f01d0510-c7d0-45d0-adc4-a7052ecf18d2" name="dbms_xmlquery$context2obj" is-trigger-function="0" unique-function-name="dbms_xmlquery$context2obj(ctxhdl numeric)" is-aggregate="f" language-name="sql" context="dbms_xmlquery$context2obj(ctxhdl numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" unique-suffix="(ctxhdl numeric)" routine-number="22946" is-returning-set="f" ret-datatype="dbms_xmlquery$tcontext" function-arguments="ctxhdl numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22946" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric" overload-function-count="2" proc-language="sql" function-signature="dbms_xmlquery$context2obj(ctxhdl numeric)">
                        <complex-attribute name="sql"><![CDATA[ select dbms_xmlquery$context2obj(get_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl))) ]]></complex-attribute>
                        <category _I_D="2fe73734-7180-464d-b6c0-6769881ad1d2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="49c99bea-943d-417e-8170-544ae02be74a" name="dbms_xmlquery$context2obj" is-trigger-function="0" unique-function-name="dbms_xmlquery$context2obj(ctxvalue text)" is-aggregate="f" language-name="sql" context="dbms_xmlquery$context2obj(ctxvalue text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" unique-suffix="(ctxvalue text)" routine-number="22945" is-returning-set="f" ret-datatype="dbms_xmlquery$tcontext" function-arguments="ctxvalue text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22945" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxvalue text" overload-function-count="2" proc-language="sql" function-signature="dbms_xmlquery$context2obj(ctxvalue text)">
                        <complex-attribute name="sql"><![CDATA[ select * from json_populate_record(null::dbms_xmlquery$TContext, ctxValue::json) ]]></complex-attribute>
                        <category _I_D="771a585a-350c-4a93-bf27-a28011fa1b32" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="01f8d681-a7f3-42bf-8514-f5498b5bbc29" name="dbms_xmlquery$context2text" is-trigger-function="0" unique-function-name="dbms_xmlquery$context2text(ctxhdl numeric, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;)" is-aggregate="f" language-name="sql" context="dbms_xmlquery$context2text(ctxhdl numeric, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text,aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;" unique-suffix="(ctxhdl numeric, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;)" routine-number="22940" is-returning-set="f" ret-datatype="text" function-arguments="ctxhdl numeric, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot; DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22940" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;" overload-function-count="2" proc-language="sql" function-signature="dbms_xmlquery$context2text(ctxhdl numeric, ctxquery text, ctxattributes aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;)">
                        <complex-attribute name="sql"><![CDATA[ select dbms_xmlquery$context2text((ctxHdl,
                                         ctxQuery,
                                         coalesce(ctxAttributes, dbms_xmlquery$contextAttr2obj()
                                        )
                                       )::dbms_xmlquery$TContext)::text ]]></complex-attribute>
                        <category _I_D="5abc4f11-de90-4a75-96b0-00a3c441e632" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d95bbedc-4131-48a7-a2cb-bc0960f3ec54" name="dbms_xmlquery$context2text" is-trigger-function="0" unique-function-name="dbms_xmlquery$context2text(ctxvalue aws_oracle_ext.&quot;dbms_xmlquery$tcontext&quot;)" is-aggregate="f" language-name="sql" context="dbms_xmlquery$context2text(ctxvalue aws_oracle_ext.&quot;dbms_xmlquery$tcontext&quot;)" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;dbms_xmlquery$tcontext&quot;" unique-suffix="(ctxvalue aws_oracle_ext.&quot;dbms_xmlquery$tcontext&quot;)" routine-number="22939" is-returning-set="f" ret-datatype="text" function-arguments="ctxvalue aws_oracle_ext.&quot;dbms_xmlquery$tcontext&quot;" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22939" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxvalue aws_oracle_ext.&quot;dbms_xmlquery$tcontext&quot;" overload-function-count="2" proc-language="sql" function-signature="dbms_xmlquery$context2text(ctxvalue aws_oracle_ext.&quot;dbms_xmlquery$tcontext&quot;)">
                        <complex-attribute name="sql"><![CDATA[ select row_to_json(ctxValue)::text ]]></complex-attribute>
                        <category _I_D="ab702165-97e1-4420-8381-5b2e767314bd" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="caff214d-3bbe-4121-8c76-420ec7170d15" name="dbms_xmlquery$contextattr2obj" is-trigger-function="0" unique-function-name="dbms_xmlquery$contextattr2obj" is-aggregate="f" language-name="sql" context="dbms_xmlquery$contextattr2obj" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="dbms_xmlquery$tctxattributes" function-arguments="ctxattr text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22938" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxattr text" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$contextattr2obj(ctxattr text)">
                        <complex-attribute name="sql"><![CDATA[ select *
        from json_populate_record(null::dbms_xmlquery$TctxAttributes,
                                  coalesce(ctxAttr, dbms_xmlquery$contextAttr2text())::json
                                 ) ]]></complex-attribute>
                        <category _I_D="3103c1ae-4ac2-4a02-888b-474544479e78" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="64da7873-2c86-4a8c-b73d-ad8d0fdbf947" name="dbms_xmlquery$contextattr2text" is-trigger-function="0" unique-function-name="dbms_xmlquery$contextattr2text(ctxattrvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;)" is-aggregate="f" language-name="sql" context="dbms_xmlquery$contextattr2text(ctxattrvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;)" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;" unique-suffix="(ctxattrvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;)" routine-number="22936" is-returning-set="f" ret-datatype="text" function-arguments="ctxattrvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22936" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxattrvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;" overload-function-count="2" proc-language="sql" function-signature="dbms_xmlquery$contextattr2text(ctxattrvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;)">
                        <complex-attribute name="sql"><![CDATA[ select row_to_json(ctxAttrValue)::text ]]></complex-attribute>
                        <category _I_D="db263e97-877b-40b5-a9db-ec967a46841b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="cf95c326-dbf5-42c7-b9b2-7c08ca50009a" name="dbms_xmlquery$contextattr2text" is-trigger-function="0" unique-function-name="dbms_xmlquery$contextattr2text(ctxbindvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[], ctxdataheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxcallidattrname text, ctxdateformat text, ctxencodingtag text, ctxerrortag text, ctxmaxrows numeric, ctxmateheader text, ctxraiseexception boolean, ctxraisenorowsexception boolean, ctxrowidattrname text, ctxrowidattrvalue text, ctxrowsettag text, ctxrowtag text, ctxskiprows numeric, ctxsqltoxmlnameescaping boolean, ctxstylesheetheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxtagcase numeric, ctxxslt aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxxsltparam aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxusenullattributeindicator boolean, ctxusetypeforcollelemtag boolean)" is-aggregate="f" language-name="sql" context="dbms_xmlquery$contextattr2text(ctxbindvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[], ctxdataheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxcallidattrname text, ctxdateformat text, ctxencodingtag text, ctxerrortag text, ctxmaxrows numeric, ctxmateheader text, ctxraiseexception boolean, ctxraisenorowsexception boolean, ctxrowidattrname text, ctxrowidattrvalue text, ctxrowsettag text, ctxrowtag text, ctxskiprows numeric, ctxsqltoxmlnameescaping boolean, ctxstylesheetheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxtagcase numeric, ctxxslt aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxxsltparam aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxusenullattributeindicator boolean, ctxusetypeforcollelemtag boolean)" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[],aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;,text,text,text,text,numeric,text,boolean,boolean,text,text,text,text,numeric,boolean,aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;,numeric,aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;,aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;,boolean,boolean" unique-suffix="(ctxbindvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[], ctxdataheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxcallidattrname text, ctxdateformat text, ctxencodingtag text, ctxerrortag text, ctxmaxrows numeric, ctxmateheader text, ctxraiseexception boolean, ctxraisenorowsexception boolean, ctxrowidattrname text, ctxrowidattrvalue text, ctxrowsettag text, ctxrowtag text, ctxskiprows numeric, ctxsqltoxmlnameescaping boolean, ctxstylesheetheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxtagcase numeric, ctxxslt aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxxsltparam aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxusenullattributeindicator boolean, ctxusetypeforcollelemtag boolean)" routine-number="22937" is-returning-set="f" ret-datatype="text" function-arguments="ctxbindvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[] DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[], ctxdataheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot; DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxcallidattrname text DEFAULT NULL::text, ctxdateformat text DEFAULT NULL::text, ctxencodingtag text DEFAULT NULL::text, ctxerrortag text DEFAULT NULL::text, ctxmaxrows numeric DEFAULT NULL::numeric, ctxmateheader text DEFAULT NULL::text, ctxraiseexception boolean DEFAULT NULL::boolean, ctxraisenorowsexception boolean DEFAULT NULL::boolean, ctxrowidattrname text DEFAULT NULL::text, ctxrowidattrvalue text DEFAULT NULL::text, ctxrowsettag text DEFAULT NULL::text, ctxrowtag text DEFAULT NULL::text, ctxskiprows numeric DEFAULT NULL::numeric, ctxsqltoxmlnameescaping boolean DEFAULT NULL::boolean, ctxstylesheetheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot; DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxtagcase numeric DEFAULT NULL::numeric, ctxxslt aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot; DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxxsltparam aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot; DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxusenullattributeindicator boolean DEFAULT NULL::boolean, ctxusetypeforcollelemtag boolean DEFAULT NULL::boolean" schema-id="21999" function-type="RET_SCALAR" count-arguments="22" function-id="22937" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxbindvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[], ctxdataheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxcallidattrname text, ctxdateformat text, ctxencodingtag text, ctxerrortag text, ctxmaxrows numeric, ctxmateheader text, ctxraiseexception boolean, ctxraisenorowsexception boolean, ctxrowidattrname text, ctxrowidattrvalue text, ctxrowsettag text, ctxrowtag text, ctxskiprows numeric, ctxsqltoxmlnameescaping boolean, ctxstylesheetheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxtagcase numeric, ctxxslt aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxxsltparam aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxusenullattributeindicator boolean, ctxusetypeforcollelemtag boolean" overload-function-count="2" proc-language="sql" function-signature="dbms_xmlquery$contextattr2text(ctxbindvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[], ctxdataheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxcallidattrname text, ctxdateformat text, ctxencodingtag text, ctxerrortag text, ctxmaxrows numeric, ctxmateheader text, ctxraiseexception boolean, ctxraisenorowsexception boolean, ctxrowidattrname text, ctxrowidattrvalue text, ctxrowsettag text, ctxrowtag text, ctxskiprows numeric, ctxsqltoxmlnameescaping boolean, ctxstylesheetheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxtagcase numeric, ctxxslt aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxxsltparam aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxusenullattributeindicator boolean, ctxusetypeforcollelemtag boolean)">
                        <complex-attribute name="sql"><![CDATA[ select dbms_xmlquery$contextAttr2text((ctxBindValue,
	  			                             ctxDataHeader,
	                                         ctxCallIdAttrName,
	                                         coalesce(ctxDateFormat, dbms_xmlquery$default_date_format()),
	                                         coalesce(ctxEncodingTag, dbms_xmlquery$db_encoding()),
	                                         coalesce(ctxErrorTag, dbms_xmlquery$default_errortag()),
	                                         coalesce(ctxMaxRows, dbms_xmlquery$all_rows()),
	                                         ctxMateHeader,
	                                         ctxRaiseException,
	                                         ctxRaiseNoRowsException,
	                                         ctxRowidAttrName,
	                                         ctxRowIdAttrValue,
	                                         coalesce(ctxRowSetTag, dbms_xmlquery$default_rowsettag()),
	                                         coalesce(ctxRowTag, dbms_xmlquery$default_rowtag()),
	                                         coalesce(ctxSkipRows, 0),
	                                         ctxSQLToXMLNameescaping,
	                                         ctxStyleSheetHeader,
	                                         ctxTagCase,
	                                         ctxXSLT,
	                                         ctxXSLTParam,
	                                         ctxUseNullAttributeIndicator,
	                                         ctxUseTypeForCollElemTag
	                                        )::dbms_xmlquery$TctxAttributes)::text ]]></complex-attribute>
                        <category _I_D="288c57e1-a3a7-4acd-961d-1cf3c202e542" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5aeb8cb5-7a3d-4bf1-a753-c3237d575904" name="dbms_xmlquery$ctxhdl2uidrec" is-trigger-function="0" unique-function-name="dbms_xmlquery$ctxhdl2uidrec" is-aggregate="f" language-name="sql" context="dbms_xmlquery$ctxhdl2uidrec" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" is-returning-set="f" ret-datatype="record" function-arguments="ctxhdl numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22941" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctxhdl numeric" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$ctxhdl2uidrec(ctxhdl numeric)">
                        <complex-attribute name="sql"><![CDATA[ select ctxHdl, concat('dbms_xmlquery$context_query_', coalesce(ctxHdl::text, '')) ]]></complex-attribute>
                        <category _I_D="f52c156b-6b09-4395-b07a-f0908f39a94f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e6daba2f-2bc1-45da-8f87-c7a7eac1f87e" name="dbms_xmlquery$ctxidx" is-trigger-function="0" unique-function-name="dbms_xmlquery$ctxidx" is-aggregate="f" language-name="sql" context="dbms_xmlquery$ctxidx" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" is-returning-set="f" ret-datatype="varchar" function-arguments="ctxhdl numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22942" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctxhdl numeric" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$ctxidx(ctxhdl numeric)">
                        <complex-attribute name="sql"><![CDATA[ select ctxIdx from dbms_xmlquery$ctxHdl2uidRec(ctxHdl) as (Idx numeric, ctxIdx character varying) ]]></complex-attribute>
                        <category _I_D="95eb243b-f4f7-4ffb-8041-2bd18a29c9f2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="838010d7-7928-483c-ae66-2751e7cc77ca" name="dbms_xmlquery$db_encoding" is-trigger-function="0" unique-function-name="dbms_xmlquery$db_encoding" is-aggregate="f" language-name="sql" context="dbms_xmlquery$db_encoding" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22915" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$db_encoding()">
                        <complex-attribute name="sql"><![CDATA[ select '_' ]]></complex-attribute>
                        <category _I_D="44d4e83a-2270-4010-a5b9-dc8eb102e85f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b42e28aa-efe5-48fb-9ecb-bf0ecb4abedc" name="dbms_xmlquery$default_dataheadertag" is-trigger-function="0" unique-function-name="dbms_xmlquery$default_dataheadertag" is-aggregate="f" language-name="sql" context="dbms_xmlquery$default_dataheadertag" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22926" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$default_dataheadertag()">
                        <complex-attribute name="sql"><![CDATA[ select 'DOCUMENT' ]]></complex-attribute>
                        <category _I_D="8ed9e65c-a7f8-4ce6-b327-aef5eaa0f998" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d1a6bc5b-65f5-4e9a-92d5-08df9dfcf39b" name="dbms_xmlquery$default_date_format" is-trigger-function="0" unique-function-name="dbms_xmlquery$default_date_format" is-aggregate="f" language-name="sql" context="dbms_xmlquery$default_date_format" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22916" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$default_date_format()">
                        <complex-attribute name="sql"><![CDATA[ select 'MM/dd/yyyy HH:mm:ss' ]]></complex-attribute>
                        <category _I_D="9993f43f-d487-4b8e-a602-189c399c2bb5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ebb43fce-23e0-4894-88ee-d7754aab9cc7" name="dbms_xmlquery$default_errortag" is-trigger-function="0" unique-function-name="dbms_xmlquery$default_errortag" is-aggregate="f" language-name="sql" context="dbms_xmlquery$default_errortag" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22917" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$default_errortag()">
                        <complex-attribute name="sql"><![CDATA[ select 'ERROR' ]]></complex-attribute>
                        <category _I_D="f8b367c5-170a-412a-95e1-c6e050d888a9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="48d4abc5-7cef-4301-949f-39f2ab34e8d2" name="dbms_xmlquery$default_rowidattr" is-trigger-function="0" unique-function-name="dbms_xmlquery$default_rowidattr" is-aggregate="f" language-name="sql" context="dbms_xmlquery$default_rowidattr" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22918" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$default_rowidattr()">
                        <complex-attribute name="sql"><![CDATA[ select 'NUM' ]]></complex-attribute>
                        <category _I_D="8ae988e7-9ef1-48e3-8b72-1bf24616f67b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="67c0c8bf-6385-4448-b2e9-e049e40bf01a" name="dbms_xmlquery$default_rowsettag" is-trigger-function="0" unique-function-name="dbms_xmlquery$default_rowsettag" is-aggregate="f" language-name="sql" context="dbms_xmlquery$default_rowsettag" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22919" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$default_rowsettag()">
                        <complex-attribute name="sql"><![CDATA[ select 'ROWSET' ]]></complex-attribute>
                        <category _I_D="5d5b6a5f-e299-46e6-b198-39cbc89108d7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8f78ea4e-bcc6-47a5-b95a-ac6fc9d94ee3" name="dbms_xmlquery$default_rowtag" is-trigger-function="0" unique-function-name="dbms_xmlquery$default_rowtag" is-aggregate="f" language-name="sql" context="dbms_xmlquery$default_rowtag" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22920" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$default_rowtag()">
                        <complex-attribute name="sql"><![CDATA[ select 'ROW' ]]></complex-attribute>
                        <category _I_D="0d40554d-40a6-42d7-b41c-87a9ca1f730d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="021ee58b-a58b-4862-ab49-806a8aad736d" name="dbms_xmlquery$dtd" is-trigger-function="0" unique-function-name="dbms_xmlquery$dtd" is-aggregate="f" language-name="sql" context="dbms_xmlquery$dtd" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22921" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$dtd()">
                        <complex-attribute name="sql"><![CDATA[ select 1 ]]></complex-attribute>
                        <category _I_D="76faf264-df6f-43b5-8377-3c6bf4c4a481" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="646ec5d8-64ee-4e3b-99c4-b730ba8efacc" name="dbms_xmlquery$getnumrowsprocessed" is-trigger-function="0" unique-function-name="dbms_xmlquery$getnumrowsprocessed" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$getnumrowsprocessed" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" is-returning-set="f" ret-datatype="numeric" function-arguments="ctxhdl numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22975" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$getnumrowsprocessed(ctxhdl numeric)">
                        <complex-attribute name="sql"><![CDATA[
begin

	return 0;
    
end; ]]></complex-attribute>
                        <category _I_D="e2949153-7dd1-4901-b45a-ee65fcb4e4dc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1285f8ec-6502-4271-89a9-8125e500bd52" name="dbms_xmlquery$getversion" is-trigger-function="0" unique-function-name="dbms_xmlquery$getversion" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$getversion" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22976" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$getversion()">
                        <complex-attribute name="sql"><![CDATA[
begin
	raise notice '%', 'XSU Version                Owner         Timestamp';
    raise notice '%', '-------------------------- ------------- ----------------';
end; ]]></complex-attribute>
                        <category _I_D="ddd68a5e-ce8e-4ad9-8560-d6d0eec8046c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c4e28505-5bf5-4c6a-9724-c6f924b7bd28" name="dbms_xmlquery$getxml" is-trigger-function="0" unique-function-name="dbms_xmlquery$getxml(ctxhdl numeric, metatype numeric)" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$getxml(ctxhdl numeric, metatype numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric" unique-suffix="(ctxhdl numeric, metatype numeric)" routine-number="22973" is-returning-set="f" ret-datatype="text" function-arguments="ctxhdl numeric, metatype numeric DEFAULT aws_oracle_ext.&quot;dbms_xmlquery$none&quot;()" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22973" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, metatype numeric" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_xmlquery$getxml(ctxhdl numeric, metatype numeric)">
                        <complex-attribute name="sql"><![CDATA[
declare
    ctxObj dbms_xmlquery$tcontext;
begin
	ctxObj := dbms_xmlquery$context2obj(ctxHdl);
    return xmlserialize(document dbms_xmlquery$query2xml(pvSQL => ctxObj.ctxQuery,
                                                         pjDataHeader => (ctxObj.ctxAttributes).ctxDataHeader,
                                                         pvRowIdAttrName => (ctxObj.ctxAttributes).ctxRowIdAttrName,
                                                         pvRowsetTag => (ctxObj.ctxAttributes).ctxRowsettag,
                                                         pvRowTag => (ctxObj.ctxAttributes).ctxRowTag
                                               ) as text
                        );
end; ]]></complex-attribute>
                        <category _I_D="7c861d66-7387-47ca-9c37-b64560f3e555" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="864209b8-e7f5-4105-abf5-d862cbe7d29d" name="dbms_xmlquery$getxml" is-trigger-function="0" unique-function-name="dbms_xmlquery$getxml(sqlquery text, metatype numeric)" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$getxml(sqlquery text, metatype numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric" unique-suffix="(sqlquery text, metatype numeric)" routine-number="22974" is-returning-set="f" ret-datatype="text" function-arguments="sqlquery text, metatype numeric DEFAULT aws_oracle_ext.&quot;dbms_xmlquery$none&quot;()" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22974" volatility="VOLATILE" is-window="f" function-identity-arguments="sqlquery text, metatype numeric" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_xmlquery$getxml(sqlquery text, metatype numeric)">
                        <complex-attribute name="sql"><![CDATA[
begin
    return xmlserialize(document dbms_xmlquery$query2xml(pvSQL => sqlQuery,
                                                         pvRowIdAttrName => dbms_xmlquery$default_rowidattr(),
                                                         pvRowsetTag => dbms_xmlquery$default_rowsettag(),
                                                         pvRowTag => dbms_xmlquery$default_rowtag()
                                                        ) as text
                       );
end; ]]></complex-attribute>
                        <category _I_D="45b3482e-e58c-4808-9975-5268283550b8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6e91d6bd-d9f0-4a02-b323-fcfeb63300a0" name="dbms_xmlquery$lower_case" is-trigger-function="0" unique-function-name="dbms_xmlquery$lower_case" is-aggregate="f" language-name="sql" context="dbms_xmlquery$lower_case" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22922" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$lower_case()">
                        <complex-attribute name="sql"><![CDATA[ select 1 ]]></complex-attribute>
                        <category _I_D="e5c6f46d-cb4d-457d-8b0b-779de3ffa5d9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e36cef71-e61a-4d83-b00b-e780b5439013" name="dbms_xmlquery$newcontext" is-trigger-function="0" unique-function-name="dbms_xmlquery$newcontext" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$newcontext" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="numeric" function-arguments="sqlquery text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22943" volatility="VOLATILE" is-window="f" function-identity-arguments="sqlquery text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$newcontext(sqlquery text)">
                        <complex-attribute name="sql"><![CDATA[
declare
    ctxSequence constant text := 'dbms_xmlquery$context$sequence';
    ctxQuery record;
    lnCurrval int := 0;
begin
    lnCurrval := coalesce(nullif(aws_oracle_ext.get_extpack_variable(variable_name => ctxSequence, missing_ok => true), ''), '-1')::integer;
	begin
        lnCurrval := lnCurrval + 1;
        perform aws_oracle_ext.set_extpack_variable(variable_name => ctxSequence, variable_value => lnCurrval::text);
        select Idx, ctxIdx, aws_oracle_ext.dbms_xmlquery$context2text(Idx, sqlQuery) ctx
          into ctxQuery
          from aws_oracle_ext.dbms_xmlquery$ctxHdl2uidRec(lnCurrval) as (Idx numeric, ctxIdx character varying);

        perform aws_oracle_ext.set_extpack_variable(variable_name => ctxQuery.ctxIdx, variable_value => ctxQuery.ctx);
    end;
    return ctxQuery.Idx;
end; ]]></complex-attribute>
                        <category _I_D="14a25af9-fcee-4dac-8225-5af103cbb7c3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d90ef9db-506a-407d-b214-7d2d5bc75b08" name="dbms_xmlquery$none" is-trigger-function="0" unique-function-name="dbms_xmlquery$none" is-aggregate="f" language-name="sql" context="dbms_xmlquery$none" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22923" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$none()">
                        <complex-attribute name="sql"><![CDATA[ select 0 ]]></complex-attribute>
                        <category _I_D="02bf96e8-1d96-47ec-a870-818368ebd408" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6df08c51-cc46-4eee-a837-8bf07e607809" name="dbms_xmlquery$query2xml" is-trigger-function="0" unique-function-name="dbms_xmlquery$query2xml" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$query2xml" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,boolean,aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[],aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;,text,text,text,text,numeric,text,boolean,boolean,text,text,text,text,numeric,boolean,aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;,numeric,aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;,aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;,boolean,boolean" is-returning-set="f" ret-datatype="xml" function-arguments="pvsql text, pbaddxmlroot boolean DEFAULT true, pjbindvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[] DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[], pjdataheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot; DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, pvcallidattrname text DEFAULT NULL::text, pvdateformat text DEFAULT NULL::text, pvencodingtag text DEFAULT NULL::text, pverrortag text DEFAULT NULL::text, pnmaxrows numeric DEFAULT NULL::numeric, pvmetaheader text DEFAULT NULL::text, pbraiseexception boolean DEFAULT NULL::boolean, pbraisenorowsexception boolean DEFAULT NULL::boolean, pvrowidattrname text DEFAULT NULL::text, pvrowidattrvalue text DEFAULT NULL::text, pvrowsettag text DEFAULT NULL::text, pvrowtag text DEFAULT NULL::text, pnskiprows numeric DEFAULT NULL::numeric, pbsqltoxmlnameescaping boolean DEFAULT NULL::boolean, pnstylesheetheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot; DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, pvtagcase numeric DEFAULT NULL::numeric, pjxslt aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot; DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, pjxsltparam aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot; DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, pbusenullattributeindicator boolean DEFAULT NULL::boolean, pbusetypeforcollelemtag boolean DEFAULT NULL::boolean" schema-id="21999" function-type="RET_SCALAR" count-arguments="24" function-id="22971" volatility="VOLATILE" is-window="f" function-identity-arguments="pvsql text, pbaddxmlroot boolean, pjbindvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[], pjdataheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, pvcallidattrname text, pvdateformat text, pvencodingtag text, pverrortag text, pnmaxrows numeric, pvmetaheader text, pbraiseexception boolean, pbraisenorowsexception boolean, pvrowidattrname text, pvrowidattrvalue text, pvrowsettag text, pvrowtag text, pnskiprows numeric, pbsqltoxmlnameescaping boolean, pnstylesheetheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, pvtagcase numeric, pjxslt aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, pjxsltparam aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, pbusenullattributeindicator boolean, pbusetypeforcollelemtag boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$query2xml(pvsql text, pbaddxmlroot boolean, pjbindvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[], pjdataheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, pvcallidattrname text, pvdateformat text, pvencodingtag text, pverrortag text, pnmaxrows numeric, pvmetaheader text, pbraiseexception boolean, pbraisenorowsexception boolean, pvrowidattrname text, pvrowidattrvalue text, pvrowsettag text, pvrowtag text, pnskiprows numeric, pbsqltoxmlnameescaping boolean, pnstylesheetheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, pvtagcase numeric, pjxslt aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, pjxsltparam aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, pbusenullattributeindicator boolean, pbusetypeforcollelemtag boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
  crMain refcursor;
  lvResult xml := null;

  lvSQL text := $pvSQL$ %1$s $pvSQL$;

  lbAddXmlRoot boolean := coalesce(pbAddXmlRoot, true);
  ljBindValue aws_oracle_ext.dbms_xmlquery$TctxDictionary[] := pjBindValue;
  ljDataHeader aws_oracle_ext.dbms_xmlquery$TctxDictionary := pjDataHeader;
  lvCallIdAttrName text := pvCallIdAttrName;
  lvDateFormat text := pvDateFormat;
  lvEncodingTag text := pvEncodingTag;
  lvErrorTag text := pvErrorTag;
  lnMaxRows numeric := pnMaxRows;
  lvMetaHeader text := pvMetaHeader;
  lbRaiseException boolean := pbRaiseException;
  lbRaiseNoRowsException boolean := pbRaiseNoRowsException;
  lvRowIdAttrName text := nullif(pvRowIdAttrName, '');
  lvRowIdAttrValue text := nullif(pvRowIdAttrValue, '');
  lvRowSetTag text := nullif(pvRowSetTag,'');
  lvRowTag text := nullif(pvRowTag,'');
  lnSkipRows numeric := pnSkipRows;
  lbSQLToXMLNameEscaping text := pbSQLToXMLNameescaping;
  lnStyleSheetHeader aws_oracle_ext.dbms_xmlquery$TctxDictionary := pnStyleSheetHeader;
  lvTagCase numeric := pvTagCase;
  ljXSLT aws_oracle_ext.dbms_xmlquery$TctxDictionary := pjXSLT;
  ljXSLTParam aws_oracle_ext.dbms_xmlquery$TctxDictionary := pjXSLTParam;
  lbUseNullAttributeIndicator boolean := pbUseNullAttributeIndicator;
  lbUseTypeForCollElemTag boolean := pbUseTypeForCollElemTag;
  lvDummy text;

  lvQuery text;
  lvQueryROW text := $row_data$ select row_number() over () as num,
  					                   (select xmlagg(row) from unnest(xpath('row/*', row_data, array[array['xsi', 'http://www.w3.org/2001/XMLSchema-instance']])) as row) as row
								   from unnest(xpath('table/*',
								                     query_to_xml($query$ %1$s $query$, false, false, ''),
								                     array[array['xsi', 'http://www.w3.org/2001/XMLSchema-instance']])
								              ) as row_data
					$row_data$;
  lvQueryDATAHEADER text := $query$ select xmlelement(name "%1$s", '%2$s', (%3$s)) $query$;

  lvQueryROWSETTAG text :=  $query$ select xmlelement(name %2$s, xmlagg(row)
				                              )
							          from (%1$s) as q
       				        $query$;

  lvQueryROWTAG text := $query$ select xmlelement(name %5$s,
                                                  xmlagg(xmlelement(name %4$s, xmlattributes(%2$s as %3$s), row ))
				                                 )
							      from (%1$s) as q
       				    $query$;

begin
   if nullif(pvSQL, '') is not null then
	  lvSQL := format(lvSQL, pvSQL);
      lvQuery := format(lvQueryROW, lvSQL);
   else
	 raise exception 'Null Exception.' using hint = '29532';
   end if;

   if lvRowTag is null and lvRowSetTag is null then
   	lvResult := xmlparse(content '<ERROR>ext.XMLSQLException: The row-set tag and the row tag are both omitted.</ERROR>');

   elsif lvRowSetTag is null and lvRowTag is not null or
         lvRowSetTag is not null and lvRowTag is null then

    lvQuery := format(lvQueryROWSETTAG, lvQuery, coalesce(lvRowSetTag, lvRowTag));

   elseif lvRowSetTag is not null and lvRowTag is not null then

    lvDummy := case when lvRowIdAttrName is null then 'NULL' else 'num' end;
    lvRowIdAttrName := coalesce(lvRowIdAttrName, 'empty_row_num');
   	lvQuery := format(lvQueryROWTAG, lvQuery, lvDummy, lvRowIdAttrName, lvRowTag, lvRowSetTag);

   else

   	lvResult := xmlparse(content '<ERROR>ext.XMLSQLException: Undeterminated error.</ERROR>');
   end if; -- if lvRowTag is null and lvRowSetTag is null then


  if lvResult is null then

   if pjDataHeader is not null and nullif(pjDataHeader.var, '') is not null then
   	 lvQuery := format(lvQueryDATAHEADER, pjDataHeader.value, pjDataHeader.var, lvQuery);
   end if; -- if pjDataHeader is not null and nullif(pjDataHeader.var, '') is not null then

   open crMain for execute lvQuery;
    fetch crMain into lvResult;
   close crMain;
  end if; -- if lvResult is null then

   if lbAddXmlRoot then
   	lvResult := xmlroot(lvResult, version '1.0', standalone yes);
   end if;

   return lvResult;
end; ]]></complex-attribute>
                        <category _I_D="40bb9668-5cda-4b6c-8a42-e66c25f7944f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="29a69c92-2b56-4831-80cd-cfd922e52636" name="dbms_xmlquery$schema" is-trigger-function="0" unique-function-name="dbms_xmlquery$schema" is-aggregate="f" language-name="sql" context="dbms_xmlquery$schema" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22924" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$schema()">
                        <complex-attribute name="sql"><![CDATA[ select 2 ]]></complex-attribute>
                        <category _I_D="22ba696d-8f8c-438b-8e3b-faf00e514a7f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="61bab192-6947-4cf1-a6be-a9b8efd1fc01" name="dbms_xmlquery$setbindvalue" is-trigger-function="0" unique-function-name="dbms_xmlquery$setbindvalue" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setbindvalue" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, bindname text, bindvalue text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22948" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, bindname text, bindvalue text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setbindvalue(ctxhdl numeric, bindname text, bindvalue text)">
                        <complex-attribute name="sql"><![CDATA[
declare
    CtxAttrName constant text = 'ctxBindValue';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when bindName is null then CtxAttrName else null end],
                                                        ctxBindValue => array[(bindName, bindValue)::dbms_xmlquery$tctxDictionary]
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="49a6d53b-c681-408b-8fd2-181f7e3d5a51" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="77d85006-8e9d-4ec7-934e-ccc97b3776af" name="dbms_xmlquery$setcollidattrname" is-trigger-function="0" unique-function-name="dbms_xmlquery$setcollidattrname" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setcollidattrname" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, attrname text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22951" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, attrname text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setcollidattrname(ctxhdl numeric, attrname text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxAttrName constant text = 'ctxCollIdAttrName';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when attrName is null then CtxAttrName else null end],
                                                        ctxCollIdAttrName => attrName
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="f4ed83bf-f9da-4cdc-a323-fad8fb337cf9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="38cea77c-708a-457e-ad54-c72cc692313f" name="dbms_xmlquery$setctxattrvalue" is-trigger-function="0" unique-function-name="dbms_xmlquery$setctxattrvalue" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setctxattrvalue" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;,text[],aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[],aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;,text,text,text,text,numeric,text,boolean,boolean,text,text,text,text,numeric,boolean,aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;,numeric,aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;,aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;,boolean,boolean" is-returning-set="f" ret-datatype="dbms_xmlquery$tctxattributes" function-arguments="INOUT ctxattributes aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;, forceparamlist text[] DEFAULT NULL::text[], ctxbindvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[] DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[], ctxdataheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot; DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxcollidattrname text DEFAULT NULL::text, ctxdateformat text DEFAULT NULL::text, ctxencodingtag text DEFAULT NULL::text, ctxerrortag text DEFAULT NULL::text, ctxmaxrows numeric DEFAULT NULL::numeric, ctxmetaheader text DEFAULT NULL::text, ctxraiseexception boolean DEFAULT NULL::boolean, ctxraisenorowsexception boolean DEFAULT NULL::boolean, ctxrowidattrname text DEFAULT NULL::text, ctxrowidattrvalue text DEFAULT NULL::text, ctxrowsettag text DEFAULT NULL::text, ctxrowtag text DEFAULT NULL::text, ctxskiprows numeric DEFAULT NULL::numeric, ctxsqltoxmlnameescaping boolean DEFAULT NULL::boolean, ctxstylesheetheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot; DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxtagcase numeric DEFAULT NULL::numeric, ctxxslt aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot; DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxxsltparam aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot; DEFAULT NULL::aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxusenullattributeindicator boolean DEFAULT NULL::boolean, ctxusetypeforcollelemtag boolean DEFAULT NULL::boolean" schema-id="21999" function-type="RET_SCALAR" count-arguments="24" function-id="22947" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT ctxattributes aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;, forceparamlist text[], ctxbindvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[], ctxdataheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxcollidattrname text, ctxdateformat text, ctxencodingtag text, ctxerrortag text, ctxmaxrows numeric, ctxmetaheader text, ctxraiseexception boolean, ctxraisenorowsexception boolean, ctxrowidattrname text, ctxrowidattrvalue text, ctxrowsettag text, ctxrowtag text, ctxskiprows numeric, ctxsqltoxmlnameescaping boolean, ctxstylesheetheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxtagcase numeric, ctxxslt aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxxsltparam aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxusenullattributeindicator boolean, ctxusetypeforcollelemtag boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setctxattrvalue(INOUT ctxattributes aws_oracle_ext.&quot;dbms_xmlquery$tctxattributes&quot;, forceparamlist text[], ctxbindvalue aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;[], ctxdataheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxcollidattrname text, ctxdateformat text, ctxencodingtag text, ctxerrortag text, ctxmaxrows numeric, ctxmetaheader text, ctxraiseexception boolean, ctxraisenorowsexception boolean, ctxrowidattrname text, ctxrowidattrvalue text, ctxrowsettag text, ctxrowtag text, ctxskiprows numeric, ctxsqltoxmlnameescaping boolean, ctxstylesheetheader aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxtagcase numeric, ctxxslt aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxxsltparam aws_oracle_ext.&quot;dbms_xmlquery$tctxdictionary&quot;, ctxusenullattributeindicator boolean, ctxusetypeforcollelemtag boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
	lforceParamList text[];
begin
	lforceParamList := upper(forceParamList::text)::text[];

	ctxAttributes := (case when upper('ctxBindValue') = any(lforceParamList) then ctxBindValue else array_cat(ctxAttributes.ctxBindValue, ctxBindValue) end,
	                  case when upper('ctxDataHeader') = any(lforceParamList) then ctxDataHeader else coalesce(ctxDataHeader, ctxAttributes.ctxDataHeader) end,
                      case when upper('ctxCollIdAttrName') = any(lforceParamList) then ctxCollIdAttrName else coalesce(ctxCollIdAttrName, ctxAttributes.ctxCollIdAttrName) end,
	                  case when upper('ctxDateFormat') = any(lforceParamList) then ctxDateFormat else coalesce(ctxDateFormat, ctxAttributes.ctxDateFormat) end,
	                  case when upper('ctxEncodingTag') = any(lforceParamList) then ctxEncodingTag else coalesce(ctxEncodingTag, ctxAttributes.ctxEncodingTag) end,
	                  case when upper('ctxErrorTag') = any(lforceParamList) then ctxErrorTag else coalesce(ctxErrorTag, ctxAttributes.ctxErrorTag) end,
	                  case when upper('ctxMaxRows') = any(lforceParamList) then ctxMaxRows else coalesce(ctxMaxRows, ctxAttributes.ctxMaxRows) end,
	                  case when upper('ctxMetaHeader') = any(lforceParamList) then ctxMetaHeader else coalesce(ctxMetaHeader, ctxAttributes.ctxMetaHeader) end,
	                  case when upper('ctxRaiseException') = any(lforceParamList) then ctxRaiseException else coalesce(ctxRaiseException, ctxAttributes.ctxRaiseException) end,
	                  case when upper('ctxRaiseNoRowsException') = any(lforceParamList) then ctxRaiseNoRowsException else coalesce(ctxRaiseNoRowsException, ctxAttributes.ctxRaiseNoRowsException) end,
	                  case when upper('ctxRowIdAttrName') = any(lforceParamList) then ctxRowIdAttrName else coalesce(ctxRowIdAttrName, ctxAttributes.ctxRowIdAttrName) end,
	                  case when upper('ctxRowIdAttrValue') = any(lforceParamList) then ctxRowIdAttrValue else coalesce(ctxRowIdAttrValue, ctxAttributes.ctxRowIdAttrValue) end,
	                  case when upper('ctxRowSetTag') = any(lforceParamList) then ctxRowSetTag else coalesce(ctxRowSetTag, ctxAttributes.ctxRowSetTag) end,
	                  case when upper('ctxRowTag') = any(lforceParamList) then ctxRowTag else coalesce(ctxRowTag, ctxAttributes.ctxRowTag) end,
	                  case when upper('ctxSkipRows') = any(lforceParamList) then ctxSkipRows else coalesce(ctxSkipRows, ctxAttributes.ctxSkipRows) end,
	                  case when upper('ctxSQLToXMLNameEscaping') = any(lforceParamList) then ctxSQLToXMLNameEscaping else coalesce(ctxSQLToXMLNameEscaping, ctxAttributes.ctxSQLToXMLNameEscaping) end,
	                  case when upper('ctxStyleSheetHeader') = any(lforceParamList) then ctxStyleSheetHeader else coalesce(ctxStyleSheetHeader, ctxAttributes.ctxStyleSheetHeader) end,
	                  case when upper('ctxTagCase') = any(lforceParamList) then ctxTagCase else coalesce(ctxTagCase, ctxAttributes.ctxTagCase) end,
	                  case when upper('ctxXSLT') = any(lforceParamList) then ctxXSLT else coalesce(ctxXSLT, ctxAttributes.ctxXSLT) end,
	                  case when upper('ctxXSLTParam') = any(lforceParamList) then ctxXSLTParam else coalesce(ctxXSLTParam, ctxAttributes.ctxXSLTParam) end,
	                  case when upper('ctxUseNullAttributeIndicator') = any(lforceParamList) then ctxUseNullAttributeIndicator else coalesce(ctxUseNullAttributeIndicator, ctxAttributes.ctxUseNullAttributeIndicator) end,
	                  case when upper('ctxUseTypeForCollElemTag') = any(lforceParamList) then ctxUseTypeForCollElemTag else coalesce(ctxUseTypeForCollElemTag, ctxAttributes.ctxUseTypeForCollElemTag) end
                     )::dbms_xmlquery$TctxAttributes;
end; ]]></complex-attribute>
                        <category _I_D="952cd04f-884f-46f9-8fb6-4f98af41e249" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6ce0ba31-b79d-4cbb-83e2-80e86f24b7d8" name="dbms_xmlquery$setdataheader" is-trigger-function="0" unique-function-name="dbms_xmlquery$setdataheader" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setdataheader" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, header text DEFAULT NULL::text, tag text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22953" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, header text, tag text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setdataheader(ctxhdl numeric, header text, tag text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxDataHeader constant text = 'ctxDataHeader';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when header is null then CtxDataHeader else null end],
                                                        ctxDataHeader => ROW(header, coalesce(tag, dbms_xmlquery$default_dataheadertag()))::dbms_xmlquery$tctxdictionary
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="dce7ffbd-300b-4c6c-b531-c8871c6e99ae" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="33ce8464-2d4e-4bcc-8f86-1176b4a2732b" name="dbms_xmlquery$setdateformat" is-trigger-function="0" unique-function-name="dbms_xmlquery$setdateformat" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setdateformat" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, mask text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22952" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, mask text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setdateformat(ctxhdl numeric, mask text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxAttrName constant text = 'ctxDateFormat';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := aws_oracle_ext.dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when mask is null then CtxAttrName else null end],
                                                        ctxDateFormat => mask
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="63d82f73-dae9-4c69-a02e-204205fce757" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3c56715a-aef9-47db-8f1f-6b4154d9869e" name="dbms_xmlquery$setencodingtag" is-trigger-function="0" unique-function-name="dbms_xmlquery$setencodingtag" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setencodingtag" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, enc text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22954" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, enc text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setencodingtag(ctxhdl numeric, enc text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxEncodingTag constant text = 'ctxEncodingTag';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := aws_oracle_ext.dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when enc is null then CtxEncodingTag else null end],
                                                        ctxEncodingTag => enc
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="412aa3f0-d37e-4e78-82d7-e825852384dd" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d4490358-2130-45f0-881f-384bfb93edc8" name="dbms_xmlquery$seterrortag" is-trigger-function="0" unique-function-name="dbms_xmlquery$seterrortag" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$seterrortag" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, tag text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22955" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, tag text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$seterrortag(ctxhdl numeric, tag text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxErrorTag constant text = 'ctxErrorTag';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when tag is null then CtxErrorTag else null end],
                                                        ctxErrorTag => tag
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="afe094f1-eb9e-49c6-b689-91b9506e79b2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="12cc1393-b816-44cc-9f22-303cf0972c0f" name="dbms_xmlquery$setmaxrows" is-trigger-function="0" unique-function-name="dbms_xmlquery$setmaxrows" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setmaxrows" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, rows numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22956" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, rows numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setmaxrows(ctxhdl numeric, rows numeric)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxMaxRows constant text = 'ctxMaxRows';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when rows is null then CtxMaxRows else null end],
                                                        ctxMaxRows => rows
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="f187b21a-2c85-42a5-9347-97c39f47847e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8cac78f3-b19d-409b-86ee-33ae9705fc42" name="dbms_xmlquery$setmetaheader" is-trigger-function="0" unique-function-name="dbms_xmlquery$setmetaheader" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setmetaheader" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, header text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22957" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, header text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setmetaheader(ctxhdl numeric, header text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxMetaHeader constant text = 'ctxMetaHeader';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when header is null then CtxMetaHeader else null end],
                                                        ctxMetaHeader => header
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="90175016-4dd8-43cb-8437-e88895410625" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8f148cd4-fcce-4534-9908-bd6f34ea816f" name="dbms_xmlquery$setraiseexception" is-trigger-function="0" unique-function-name="dbms_xmlquery$setraiseexception" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setraiseexception" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,boolean" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, flag boolean DEFAULT true" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22958" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, flag boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setraiseexception(ctxhdl numeric, flag boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxRaiseException constant text = 'ctxRaiseException';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when flag is null then CtxRaiseException else null end],
                                                        ctxRaiseException => flag
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="2b1e36c4-37d9-4bd1-bdd8-1ebe17c233be" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="83e15a26-2f21-44ab-a1ec-c3f16e397788" name="dbms_xmlquery$setraisenorowsexception" is-trigger-function="0" unique-function-name="dbms_xmlquery$setraisenorowsexception" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setraisenorowsexception" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,boolean" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, flag boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22959" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, flag boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setraisenorowsexception(ctxhdl numeric, flag boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxRaiseNoRowsException constant text = 'ctxRaiseNoRowsException';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when flag is null then CtxRaiseNoRowsException else null end],
                                                        ctxRaiseNoRowsException => flag
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="13a79379-1921-418b-88ec-4149b989cfba" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9453d751-96fc-4363-8622-c5fa40caab1a" name="dbms_xmlquery$setrowidattrname" is-trigger-function="0" unique-function-name="dbms_xmlquery$setrowidattrname" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setrowidattrname" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, attrname text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22960" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, attrname text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setrowidattrname(ctxhdl numeric, attrname text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxRowidAttrName constant text = 'ctxRowidAttrName';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when attrName is null then CtxRowidAttrName else null end],
                                                        ctxRowidAttrName => attrName
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="ff21434b-2f1d-4b5e-ab82-fac9499515fa" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="00827bee-fcca-44fa-8b16-22dddfb0d07b" name="dbms_xmlquery$setrowidattrvalue" is-trigger-function="0" unique-function-name="dbms_xmlquery$setrowidattrvalue" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setrowidattrvalue" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, colname text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22961" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, colname text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setrowidattrvalue(ctxhdl numeric, colname text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxRowidAttrValue constant text = 'ctxRowidAttrValue';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when colName is null then CtxRowidAttrValue else null end],
                                                        ctxRowidAttrValue => colName
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="cff181ee-0cc4-4fd4-8ebc-e2a9304278fa" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="924e29ee-1ea0-4bca-a782-36406e5f76b0" name="dbms_xmlquery$setrowsettag" is-trigger-function="0" unique-function-name="dbms_xmlquery$setrowsettag" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setrowsettag" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, tag text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22949" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, tag text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setrowsettag(ctxhdl numeric, tag text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxAttrName constant text = 'ctxRowSetTag';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when tag is null then CtxAttrName else null end],
                                                        ctxRowSetTag => tag
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="7e623645-61ac-4778-9898-fcbb417c9436" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1288d671-de7b-430c-9500-0f118521ab97" name="dbms_xmlquery$setrowtag" is-trigger-function="0" unique-function-name="dbms_xmlquery$setrowtag" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setrowtag" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, tag text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22950" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, tag text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setrowtag(ctxhdl numeric, tag text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxAttrName constant text = 'ctxRowTag';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when tag is null then CtxAttrName else null end],
                                                        ctxRowTag => tag
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="f6305b05-569b-4dca-9950-4cf4b0be5156" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2e97e1ac-e77c-4336-9dbc-5ffa9435bb5a" name="dbms_xmlquery$setskiprows" is-trigger-function="0" unique-function-name="dbms_xmlquery$setskiprows" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setskiprows" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, rows numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22962" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, rows numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setskiprows(ctxhdl numeric, rows numeric)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxSkipRows constant text = 'ctxSkipRows';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when rows is null then CtxSkipRows else null end],
                                                        ctxSkipRows => rows
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="e512e23e-9215-4618-a23e-612b164838f2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="cb919d3d-f7f1-46d2-8657-defb3a188be5" name="dbms_xmlquery$setsqltoxmlnameescaping" is-trigger-function="0" unique-function-name="dbms_xmlquery$setsqltoxmlnameescaping" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setsqltoxmlnameescaping" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,boolean" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, flag boolean DEFAULT true" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22963" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, flag boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setsqltoxmlnameescaping(ctxhdl numeric, flag boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxSQLToXMLNameEscaping constant text = 'ctxSQLToXMLNameEscaping';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when flag is null then CtxSQLToXMLNameEscaping else null end],
                                                        ctxSQLToXMLNameEscaping => flag
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="7dca0cf2-d1a9-4b1f-bae3-880ac4cf7157" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0cc719cc-3979-45db-8c81-8803676ced64" name="dbms_xmlquery$setstylesheetheader" is-trigger-function="0" unique-function-name="dbms_xmlquery$setstylesheetheader" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setstylesheetheader" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, uri text, type text DEFAULT 'text/xsl'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22964" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, uri text, type text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setstylesheetheader(ctxhdl numeric, uri text, type text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxStyleSheetHeader constant text = 'ctxStyleSheetHeader';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when uri is null then CtxStyleSheetHeader else null end],
                                                        ctxStyleSheetHeader => ROW(uri, type)::dbms_xmlquery$tctxdictionary
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="01229269-4aed-48c0-8183-e24c03ffa01c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b9891f17-42d1-466a-a528-d98c20ace1bb" name="dbms_xmlquery$settagcase" is-trigger-function="0" unique-function-name="dbms_xmlquery$settagcase" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$settagcase" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, tcase numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22965" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, tcase numeric" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$settagcase(ctxhdl numeric, tcase numeric)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxTagCase constant text = 'ctxTagCase';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when tCase is null then CtxTagCase else null end],
                                                        ctxTagCase => tCase
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="2d76b780-3ed8-4a48-a432-139bf8bfecc2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="77704b5b-cee2-4099-b540-253c05d80ae5" name="dbms_xmlquery$setxslt" is-trigger-function="0" unique-function-name="dbms_xmlquery$setxslt(ctxhdl numeric, stylesheet text, ref text)" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setxslt(ctxhdl numeric, stylesheet text, ref text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text,text" unique-suffix="(ctxhdl numeric, stylesheet text, ref text)" routine-number="22970" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, stylesheet text, ref text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22970" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, stylesheet text, ref text" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_xmlquery$setxslt(ctxhdl numeric, stylesheet text, ref text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxXSLT constant text = 'ctxXSLT';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when stylesheet is null then CtxXSLT else null end],
                                                        ctxXSLT => ROW(stylesheet, ref)::dbms_xmlquery$tctxdictionary
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="e4abd7a5-a513-4377-a6ec-43844fcf7ae2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="438afe0b-c692-4806-a8cc-700a800401fe" name="dbms_xmlquery$setxslt" is-trigger-function="0" unique-function-name="dbms_xmlquery$setxslt(ctxhdl numeric, uri character varying, ref text)" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setxslt(ctxhdl numeric, uri character varying, ref text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,character varying,text" unique-suffix="(ctxhdl numeric, uri character varying, ref text)" routine-number="22969" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, uri character varying, ref text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22969" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, uri character varying, ref text" overload-function-count="2" proc-language="plpgsql" function-signature="dbms_xmlquery$setxslt(ctxhdl numeric, uri character varying, ref text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxXSLT constant text = 'ctxXSLT';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when uri is null then CtxXSLT else null end],
                                                        ctxXSLT => ROW(uri, ref)::dbms_xmlquery$tctxdictionary
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="ff926cb3-b6ed-4fce-aa40-5a0261e5e01d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="752c1c22-393c-463a-ac35-6639090c6e21" name="dbms_xmlquery$setxsltparam" is-trigger-function="0" unique-function-name="dbms_xmlquery$setxsltparam" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$setxsltparam" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, name text, param text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22968" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, name text, param text" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$setxsltparam(ctxhdl numeric, name text, param text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxXSLTParam constant text = 'ctxXSLTParam';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when name is null then CtxXSLTParam else null end],
                                                        ctxXSLTParam => ROW(name, param)::dbms_xmlquery$tctxdictionary
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="d01afdf6-9b02-433a-be32-62156dfb7e1f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7b316d74-2b17-4302-8fa7-c7314ec1a033" name="dbms_xmlquery$upper_case" is-trigger-function="0" unique-function-name="dbms_xmlquery$upper_case" is-aggregate="f" language-name="sql" context="dbms_xmlquery$upper_case" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22925" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="dbms_xmlquery$upper_case()">
                        <complex-attribute name="sql"><![CDATA[ select 2 ]]></complex-attribute>
                        <category _I_D="fc1e2b6f-a0cd-45be-9e5f-73fd7da1fa65" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="17fe4868-a7b5-4c40-bed7-29527ab6ffce" name="dbms_xmlquery$usenullattributeindicator" is-trigger-function="0" unique-function-name="dbms_xmlquery$usenullattributeindicator" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$usenullattributeindicator" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,boolean" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, flag boolean" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22966" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, flag boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$usenullattributeindicator(ctxhdl numeric, flag boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxUseNullAttributeIndicator constant text = 'ctxUseNullAttributeIndicator';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when flag is null then CtxUseNullAttributeIndicator else null end],
                                                        ctxUseNullAttributeIndicator => flag
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="166230d8-4974-4014-8eed-8d3f34f21d96" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="68f9e33a-b254-464a-b845-f1fab83842b3" name="dbms_xmlquery$usetypeforcollelemtag" is-trigger-function="0" unique-function-name="dbms_xmlquery$usetypeforcollelemtag" is-aggregate="f" language-name="plpgsql" context="dbms_xmlquery$usetypeforcollelemtag" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,boolean" is-returning-set="f" ret-datatype="void" function-arguments="ctxhdl numeric, flag boolean DEFAULT true" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22967" volatility="VOLATILE" is-window="f" function-identity-arguments="ctxhdl numeric, flag boolean" overload-function-count="1" proc-language="plpgsql" function-signature="dbms_xmlquery$usetypeforcollelemtag(ctxhdl numeric, flag boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
	CtxUseTypeForCollElemTag constant text = 'ctxUseTypeForCollElemTag';
	lCtx dbms_xmlquery$tContext;
begin
	lCtx := dbms_xmlquery$context2obj(ctxHdl => ctxHdl);
	lCtx.ctxAttributes := dbms_xmlquery$setCtxAttrValue(ctxAttributes => lCtx.ctxAttributes,
	                                                    forceParamList => array[case when flag is null then CtxUseTypeForCollElemTag else null end],
                                                        ctxUseTypeForCollElemTag => flag
                                                       );

    perform set_extpack_variable(variable_name => dbms_xmlquery$ctxIdx(ctxHdl), variable_value => dbms_xmlquery$context2text(ctxValue => lCtx));
end; ]]></complex-attribute>
                        <category _I_D="b207fd14-22d9-4395-90a7-2fc74fd1dd5f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7ac6af30-b464-4857-9ca0-0840eee34852" name="dbms_xslprocessor$read2clob" is-trigger-function="0" unique-function-name="dbms_xslprocessor$read2clob(flocation character varying, fname character varying)" is-aggregate="f" language-name="sql" context="dbms_xslprocessor$read2clob(flocation character varying, fname character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying" comment="This function reads content of a file into a character large object (CLOB)." unique-suffix="(flocation character varying, fname character varying)" routine-number="23528" is-returning-set="f" ret-datatype="text" function-arguments="flocation character varying, fname character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23528" volatility="VOLATILE" is-window="f" function-identity-arguments="flocation character varying, fname character varying" overload-function-count="4" proc-language="sql" function-signature="dbms_xslprocessor$read2clob(flocation character varying, fname character varying)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.get_text_file_from_s3(directory_name => flocation::TEXT, /* DIRECTORY name */
                                            file_name      => fname::TEXT, /* File name */
                                            error_on_empty => true);
]]></complex-attribute>
                        <category _I_D="2da0532e-510d-4bcf-985c-af788c8a46f9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4c8ba396-e06b-4006-a3ef-dee0131c7dc8" name="dbms_xslprocessor$read2clob" is-trigger-function="0" unique-function-name="dbms_xslprocessor$read2clob(flocation character varying, fname text)" is-aggregate="f" language-name="sql" context="dbms_xslprocessor$read2clob(flocation character varying, fname text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,text" comment="This function reads content of a file into a character large object (CLOB)." unique-suffix="(flocation character varying, fname text)" routine-number="23526" is-returning-set="f" ret-datatype="text" function-arguments="flocation character varying, fname text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23526" volatility="VOLATILE" is-window="f" function-identity-arguments="flocation character varying, fname text" overload-function-count="4" proc-language="sql" function-signature="dbms_xslprocessor$read2clob(flocation character varying, fname text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.get_text_file_from_s3(directory_name => flocation::TEXT, /* DIRECTORY name */
                                            file_name      => fname, /* File name */
                                            error_on_empty => true);
]]></complex-attribute>
                        <category _I_D="eb703392-5b45-440b-bdd5-04d52b929e60" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d7281aeb-8e8d-4706-89b4-72d252636ca3" name="dbms_xslprocessor$read2clob" is-trigger-function="0" unique-function-name="dbms_xslprocessor$read2clob(flocation text, fname character varying)" is-aggregate="f" language-name="sql" context="dbms_xslprocessor$read2clob(flocation text, fname character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,character varying" comment="This function reads content of a file into a character large object (CLOB)." unique-suffix="(flocation text, fname character varying)" routine-number="23527" is-returning-set="f" ret-datatype="text" function-arguments="flocation text, fname character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23527" volatility="VOLATILE" is-window="f" function-identity-arguments="flocation text, fname character varying" overload-function-count="4" proc-language="sql" function-signature="dbms_xslprocessor$read2clob(flocation text, fname character varying)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.get_text_file_from_s3(directory_name => flocation, /* DIRECTORY name */
                                            file_name      => fname::TEXT, /* File name */
                                            error_on_empty => true);
]]></complex-attribute>
                        <category _I_D="fd98175f-ea85-478e-af53-1a6303d205af" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0a91e556-3ec1-4a63-ac12-d41ef2187a77" name="dbms_xslprocessor$read2clob" is-trigger-function="0" unique-function-name="dbms_xslprocessor$read2clob(flocation text, fname text)" is-aggregate="f" language-name="sql" context="dbms_xslprocessor$read2clob(flocation text, fname text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" comment="This function reads content of a file into a character large object (CLOB)." unique-suffix="(flocation text, fname text)" routine-number="23525" is-returning-set="f" ret-datatype="text" function-arguments="flocation text, fname text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23525" volatility="VOLATILE" is-window="f" function-identity-arguments="flocation text, fname text" overload-function-count="4" proc-language="sql" function-signature="dbms_xslprocessor$read2clob(flocation text, fname text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.get_text_file_from_s3(directory_name => flocation, /* DIRECTORY name */
                                            file_name      => fname, /* File name */
                                            error_on_empty => true);
]]></complex-attribute>
                        <category _I_D="dddf8732-1364-4487-af6b-befd2166b6b2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e7ca776b-33f8-4a1f-a6b7-1b3a475ff99b" name="dbtimezone" is-trigger-function="0" unique-function-name="dbtimezone" is-aggregate="f" language-name="plpgsql" context="dbtimezone" subcategories-loading="none" object-loading="extended" comment="Returns the value of the database time zone." is-returning-set="f" ret-datatype="varchar" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22515" volatility="STABLE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="dbtimezone()">
                        <complex-attribute name="sql"><![CDATA[
begin  
	
  return aws_oracle_ext.get_extpack_variable(variable_name => 'TIME_ZONE', missing_ok => false); 
 
  exception 
     when internal_error then 
	   return coalesce(CURRENT_SETTING('TIMEZONE', TRUE), 'UTC');   
end;       
]]></complex-attribute>
                        <category _I_D="f96ba4da-54b8-4fe2-9155-2fb688f86e8b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e4d8481b-846f-440f-9794-882a1686ec42" name="delete" is-trigger-function="0" unique-function-name="delete(parray anyarray)" is-aggregate="f" language-name="plpgsql" context="delete(parray anyarray)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray" unique-suffix="(parray anyarray)" routine-number="22382" is-returning-set="f" ret-datatype="anyarray" function-arguments="parray anyarray" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22382" volatility="VOLATILE" is-window="f" function-identity-arguments="parray anyarray" overload-function-count="3" proc-language="plpgsql" function-signature="delete(parray anyarray)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

/* DELETE removes all elements from a collection */
    RETURN '{}';

END;
]]></complex-attribute>
                        <category _I_D="a49c29c7-3233-4f21-b4d3-69c7c6cc50fa" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e42b8575-cb30-4b6e-a595-72bfdb3a69bd" name="delete" is-trigger-function="0" unique-function-name="delete(parray anyarray, m integer, n integer)" is-aggregate="f" language-name="plpgsql" context="delete(parray anyarray, m integer, n integer)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,integer,integer" unique-suffix="(parray anyarray, m integer, n integer)" routine-number="22380" is-returning-set="f" ret-datatype="anyarray" function-arguments="parray anyarray, m integer, n integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22380" volatility="VOLATILE" is-window="f" function-identity-arguments="parray anyarray, m integer, n integer" overload-function-count="3" proc-language="plpgsql" function-signature="delete(parray anyarray, m integer, n integer)">
                        <complex-attribute name="sql"><![CDATA[  
DECLARE
    ind INTEGER;
    vArray parray%type;
BEGIN
/* DELETE(m,n) removes all elements in the range m..n from collection */

    IF (m > n) OR (n IS NULL) OR (m iS NULL) THEN

        vArray := parray;

    ELSE

        ind := ARRAY_LENGTH(parray, 1);
        vArray := parray[1:m - 1];

        FOR i IN 1..n - m + 1 LOOP

            vArray := ARRAY_APPEND(vArray, NULL);

        END LOOP;

        vArray := vArray || parray[n + 1:ind];

    END IF;

    RETURN vArray;

END;
]]></complex-attribute>
                        <category _I_D="8b56c6d2-e495-499a-b168-504ca1803f16" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="32d64744-ae14-46ae-987a-2b58fa4eaad6" name="delete" is-trigger-function="0" unique-function-name="delete(parray anyarray, n integer)" is-aggregate="f" language-name="plpgsql" context="delete(parray anyarray, n integer)" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,integer" unique-suffix="(parray anyarray, n integer)" routine-number="22381" is-returning-set="f" ret-datatype="anyarray" function-arguments="parray anyarray, n integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22381" volatility="VOLATILE" is-window="f" function-identity-arguments="parray anyarray, n integer" overload-function-count="3" proc-language="plpgsql" function-signature="delete(parray anyarray, n integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    ind INTEGER;
BEGIN

/* DELETE(n) removes the nth element from collection */
    ind := ARRAY_LENGTH(parray, 1);

    RETURN
    CASE
        WHEN (n > ind) OR (n < 1) OR (n IS NULL) THEN
            parray
        ELSE
            ARRAY_APPEND(parray[1:n - 1], NULL)||parray[n + 1:ind]
    END;

END;
]]></complex-attribute>
                        <category _I_D="84d85fcd-c446-469a-8927-eaece0924fee" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a63cf9ba-46cb-4925-b845-f6241398f4b7" name="dump" is-trigger-function="0" unique-function-name="dump" is-aggregate="f" language-name="plpgsql" context="dump" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyelement,integer,integer,integer" comment="Returns a text value that includes the datatype code,the length in bytes, and the internal representation of the expression." is-returning-set="f" ret-datatype="text" function-arguments="p_expr anyelement, p_fmt integer DEFAULT NULL::integer, p_pos integer DEFAULT NULL::integer, p_len integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22516" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_expr anyelement, p_fmt integer, p_pos integer, p_len integer" overload-function-count="1" proc-language="plpgsql" function-signature="dump(p_expr anyelement, p_fmt integer, p_pos integer, p_len integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  result text;
  proname name;
  expr_hex bytea;
BEGIN
IF p_expr IS NULL THEN RETURN 'NULL'; END IF;

EXECUTE 'SELECT p.proname
           FROM pg_catalog.pg_proc p
      LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
          WHERE pg_catalog.pg_function_is_visible(p.oid)
            AND n.nspname = ''pg_catalog''
            AND p.proname LIKE ''%send''
            AND pg_catalog.pg_get_function_arguments(p.oid) = $1'
  INTO proname
 USING pg_typeof(p_expr)::text;

EXECUTE 'SELECT ' || proname || '($1)'
   INTO expr_hex
  USING p_expr;

SELECT ARRAY_TO_STRING(ARRAY_AGG(CONCAT(CASE
                                          WHEN p_fmt IN (8,1008) --OCT
                                          THEN aws_oracle_ext.to_oct(i)::text
                                          WHEN p_fmt IN (16,1016) --HEX
                                          THEN CASE
                                                 WHEN SUBSTRING(v,1,1) = '0' THEN SUBSTRING(v,2)
                                                 ELSE v
                                               END
                                          WHEN p_fmt IN (10,1010) --DEC
                                          THEN i::text
                                          WHEN p_fmt IN (17,1017) OR p_fmt < 0 --ASCII/HEX
                                          THEN CASE
                                                 WHEN i BETWEEN 1 AND 31 THEN '^' || CHR(i+64)
                                                 WHEN i BETWEEN 32 AND 126 THEN CHR(i)
                                                 ELSE v
                                               END
                                          ELSE i::text --DEC
                                        END
                                       ,',')
                                 )
                      ,'')
  FROM (SELECT v, i, row_number() OVER (ORDER BY rn DESC) AS rn
          FROM (SELECT v, aws_oracle_ext.hex_to_int(v) AS i, row_number() OVER () AS rn
                  FROM REGEXP_SPLIT_TO_TABLE(LTRIM(expr_hex::text, '\x')
                                            ,E'(?=(..)+$)') AS v) t
       ) t
 WHERE rn BETWEEN COALESCE(p_pos,1) AND COALESCE(p_pos,1) + COALESCE(p_len,rn) - 1
  INTO result;

SELECT 'Typ=' || pg_typeof(p_expr)::oid ||
       ' Len=' || pg_column_size(p_expr) ||
       CASE
         WHEN p_fmt > 1000
         THEN ' CharacterSet=' || (SELECT character_set_name FROM information_schema.character_sets)
         ELSE ''
       END
       || ': ' || RTRIM(result,',')
  INTO result;

RETURN result;
END
]]></complex-attribute>
                        <category _I_D="ea8aa55c-aa60-489f-bd7c-f985744b55d7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ef931d29-bcee-4dc3-be93-364103265b43" name="exists" is-trigger-function="0" unique-function-name="exists" is-aggregate="f" language-name="sql" context="exists" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,integer" is-returning-set="f" ret-datatype="bool" function-arguments="pcollection anyarray, n integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23239" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pcollection anyarray, n integer" overload-function-count="1" proc-language="sql" function-signature="exists(pcollection anyarray, n integer)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT EXISTS 
    (
        SELECT
        FROM UNNEST(pcollection) WITH ORDINALITY AS t(v,o)
        WHERE o = n
    );
]]></complex-attribute>
                        <category _I_D="cb993cd8-ed52-4240-9c7a-fb563f8fa61e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d687b0db-4d0b-4405-ae75-f6e53c37f7b6" name="extend" is-trigger-function="0" unique-function-name="extend" is-aggregate="f" language-name="plpgsql" context="extend" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,double precision,double precision" is-returning-set="f" ret-datatype="anyarray" function-arguments="parray anyarray, n double precision DEFAULT 1, ii double precision DEFAULT NULL::double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22383" volatility="VOLATILE" is-window="f" function-identity-arguments="parray anyarray, n double precision, ii double precision" overload-function-count="1" proc-language="plpgsql" function-signature="extend(parray anyarray, n double precision, ii double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    FOR idx IN 1..n::NUMERIC(10) LOOP

      parray := ARRAY_APPEND(parray, parray[ii::NUMERIC(10)]);

    END LOOP;

    RETURN parray;

END;
]]></complex-attribute>
                        <category _I_D="fc5a7b2d-a875-4340-9101-e3bb807e5ed0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4ba8152f-18af-415d-a584-f739ddd88188" name="first_weekday" is-trigger-function="0" unique-function-name="first_weekday" is-aggregate="f" language-name="sql" context="first_weekday" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="Get the first day of week" is-returning-set="f" ret-datatype="int4" function-arguments="territory text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22505" volatility="IMMUTABLE" is-window="f" function-identity-arguments="territory text" overload-function-count="1" proc-language="sql" function-signature="first_weekday(territory text)">
                        <complex-attribute name="sql"><![CDATA[ 
SELECT
CASE
WHEN territory IN ('AMERICA', 'BAHRAIN', 'BRAZIL', 'CANADA', 'CHINA', 'HONG KONG',
                   'INDIA', 'ISRAEL', 'JAPAN', 'KOREA', 'KUWAIT', 'MALAYSIA',
                   'PORTUGAL', 'SINGAPORE', 'SOUTH AFRICA', 'TAIWAN', 'THAILAND',
                   'UNITED ARAB EMIRATES', 'VIETNAM')
THEN 1 --Sunday is the first day of week
WHEN territory IN ('DJIBOUTI', 'EGYPT', 'IRAQ', 'JORDAN', 'LEBANON', 'LIBYA', 'MAURITANIA', 'MOROCCO', 'OMAN',
                   'QATAR', 'SAUDI ARABIA', 'SOMALIA', 'SUDAN', 'SYRIA', 'TUNISIA', 'YEMEN')
THEN 2 --Saturday is the first day of week
WHEN territory = 'BANGLADESH'
THEN 3 --Friday is the first day of week
ELSE 0 --Monday is the first day of week
END;
]]></complex-attribute>
                        <category _I_D="17a28660-5ead-4bdf-9b1c-36487e5cbcd4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bb7806d6-4ee6-4cba-895c-398e09c4dadb" name="format_identifier_case" is-trigger-function="0" unique-function-name="format_identifier_case" is-aggregate="f" language-name="sql" context="format_identifier_case" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="text" function-arguments="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22991" volatility="IMMUTABLE" is-window="f" function-identity-arguments="text" overload-function-count="1" proc-language="sql" function-signature="format_identifier_case(text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT
        CASE
            WHEN $1 LIKE '"%"' THEN
                SUBSTRING($1, 2, LENGTH($1) - 2)
            ELSE
                UPPER($1)
            END;
]]></complex-attribute>
                        <category _I_D="5f58251d-bfbc-4747-b044-c3d3d1d8117a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d458c34a-5f42-49fe-bfee-f38773ec4a24" name="from_tz" is-trigger-function="0" unique-function-name="from_tz" is-aggregate="f" language-name="sql" context="from_tz" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone,character varying" is-returning-set="f" ret-datatype="timestamptz" function-arguments="timestamp_value timestamp without time zone, time_zone_value character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22384" volatility="IMMUTABLE" is-window="f" function-identity-arguments="timestamp_value timestamp without time zone, time_zone_value character varying" overload-function-count="1" proc-language="sql" function-signature="from_tz(timestamp_value timestamp without time zone, time_zone_value character varying)">
                        <complex-attribute name="sql"><![CDATA[


    SELECT
        CASE

            WHEN LENGTH($2) = 0 THEN

                NULL::TIMESTAMP WITH TIME ZONE

            ELSE

                MAKE_TIMESTAMPTZ
                (
                    EXTRACT(YEAR FROM $1)::INTEGER,
                    EXTRACT(MONTH FROM $1)::INTEGER,
                    EXTRACT(DAY FROM $1)::INTEGER,
                    EXTRACT(HOUR FROM $1)::INTEGER,
                    EXTRACT(MIN FROM $1)::INTEGER,
                    EXTRACT(SEC FROM $1),
                    CONCAT
                    (
                        CASE WHEN $2 !~* '[\-\+]' THEN '+' ELSE '' END,
                        REPLACE($2, ' ', '')
                    )
                )

        END;


]]></complex-attribute>
                        <category _I_D="76cd5936-e5f8-4a51-ab0e-7e8fd47de98b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b13ea8c4-0866-457a-b26a-a08c5e15fe7a" name="get_application_context" is-trigger-function="0" unique-function-name="get_application_context" is-aggregate="f" language-name="plpgsql" context="get_application_context" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying,character varying" is-returning-set="f" ret-datatype="varchar" function-arguments="a_context_namespace character varying, a_context_attribute character varying, a_username character varying DEFAULT NULL::character varying, a_client_id character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22996" volatility="VOLATILE" is-window="f" function-identity-arguments="a_context_namespace character varying, a_context_attribute character varying, a_username character varying, a_client_id character varying" overload-function-count="1" proc-language="plpgsql" function-signature="get_application_context(a_context_namespace character varying, a_context_attribute character varying, a_username character varying, a_client_id character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  l_context_type text;
  l_key text;
  l_interval text;
  l_signature text;
  l_value character varying;
 
begin
  perform aws_oracle_ext.init_context_struct();
  l_key := aws_oracle_ext.get_context_param('key');
  l_context_type := aws_oracle_ext.get_context_type(a_context_namespace);

 
  case upper(l_context_type) 
  	when 'ACCESSED LOCALLY' then 
  		begin
			select cl.attribute_value, cl.signature 
			  into strict l_value, l_signature
			from context_local cl
			where cl.context_namespace = $1
			  and cl.attribute_name = $2
		  	  and (cl.user_name = $3 or cl.user_name is null)
		  	  and (cl.cliend_id = $4 or coalesce(cl.cliend_id, '') = '')
		    limit 1;	  		
	  	end;
  	when 'ACCESSED GLOBALLY' then	  
  		begin		
			delete from aws_oracle_context.context_global 
			where backend_start <= now()::timestamp - (coalesce(aws_oracle_ext.get_context_param('auto_clean_interval'), '1 day'))::interval;
		 	
			select w.attribute_value, w.signature 
			into strict l_value, l_signature 
			from (
				select 
					cg.attribute_value, 
					cg.signature,
					row_number() over (order by cg.context_namespace, cg.attribute_name, cg.cliend_id) as row
				from aws_oracle_context.context_global cg 
				where cg.context_namespace = $1
				  and cg.attribute_name = $2
				  and (cg.user_name = $3 or cg.user_name is null)
				  and (cg.cliend_id = $4 or coalesce(cg.cliend_id, '') = '')
				) w  
		    where row = 1;
	  	end;  
  	else 
		-- INITIALIZED EXTERNALLY, INITIALIZED GLOBALLY  	
  		raise exception 'unsupported context type: %', l_context_type;
  end case;
 
  if l_signature <> crypt(l_value || ':' || l_key, l_signature) then  
	raise exception  'The signature for %.% is broken', $1, $2;
  end if;	  	
  
  return l_value;
  exception 
 	when no_data_found then return null; 
end;
]]></complex-attribute>
                        <category _I_D="c8362d1a-d004-4485-8ac1-51f7716f7641" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="01b261e5-e825-418c-8ef6-dde8ed3ce38c" name="get_application_name" is-trigger-function="0" unique-function-name="get_application_name" is-aggregate="f" language-name="plpgsql" context="get_application_name" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23132" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="get_application_name()">
                        <complex-attribute name="sql"><![CDATA[
declare 
  l_res jsonb;
begin
  execute 'show application_name' into strict l_res;
  return l_res;
 
  exception when others then 
	return jsonb_build_object('action'::text, 'init'::text);
end;
]]></complex-attribute>
                        <category _I_D="08d2b39c-3f2b-4431-a48c-2ce4edd245a8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4a2e3036-24a6-4e04-a65d-398be0809a9e" name="get_base_type_by_dtype" is-trigger-function="0" unique-function-name="get_base_type_by_dtype" is-aggregate="f" language-name="sql" context="get_base_type_by_dtype" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="The function returns base data type capable to store the value of the given data type" is-returning-set="f" ret-datatype="text" function-arguments="p_data_type text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22340" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_data_type text" overload-function-count="1" proc-language="sql" function-signature="get_base_type_by_dtype(p_data_type text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT CASE p_data_type
          -- character data types
          WHEN 'TEXT' THEN 'TEXT'
          WHEN 'CHARACTER' THEN 'TEXT'
          WHEN 'CHARACTER VARYING' THEN 'TEXT'
          -- numeric data types
          WHEN 'BIGINT' THEN 'NUMERIC'
          WHEN 'INTEGER' THEN 'NUMERIC'
          WHEN 'NUMERIC' THEN 'NUMERIC'
          WHEN 'SMALLINT' THEN 'NUMERIC'
          WHEN 'REAL' THEN 'DOUBLE PRECISION'
          WHEN 'DOUBLE PRECISION' THEN 'DOUBLE PRECISION'
          -- date/time data types
          WHEN 'DATE' THEN 'TIMESTAMP WITHOUT TIME ZONE'
          WHEN 'TIME WITHOUT TIME ZONE' THEN 'TIMESTAMP WITHOUT TIME ZONE'
          ELSE p_data_type
       END
]]></complex-attribute>
                        <category _I_D="289651e8-552e-4635-90ec-41b2c129eb2d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a3b13884-7faf-40c6-ace3-ca6d747730c6" name="get_charset_name" is-trigger-function="0" unique-function-name="get_charset_name" is-aggregate="f" language-name="sql" context="get_charset_name" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" comment="&amp;#x000a;  Returns PostgreSQL character set name&amp;#x000a;&amp;#x000a;  Parameters:&amp;#x000a;    ora_charset_name -- Oracle character set name&amp;#x000a;&amp;#x000a;  Returns:&amp;#x000a;    PostgreSQL character set name&amp;#x000a;" is-returning-set="f" ret-datatype="varchar" function-arguments="ora_charset_name character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22385" volatility="STABLE" is-window="f" function-identity-arguments="ora_charset_name character varying" overload-function-count="1" proc-language="sql" function-signature="get_charset_name(ora_charset_name character varying)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT COALESCE
    (
        (
            SELECT m.postgresql_charset
            FROM aws_oracle_ext.charset_mapping m
            WHERE STRPOS(LOWER(ora_charset_name), LOWER(m.oracle_charset)) > 0
            LIMIT 1
        ),
        'UNICODE'
    );

]]></complex-attribute>
                        <category _I_D="5018d792-f004-4edf-91bb-aad06576d672" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a2e7239a-c8cc-4782-9588-345e4ee236a9" name="get_cmd_type_by_sql_func_code" is-trigger-function="0" unique-function-name="get_cmd_type_by_sql_func_code" is-aggregate="f" language-name="plpgsql" context="get_cmd_type_by_sql_func_code" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer" comment="This function returns SQL command type (DDL, DML, DCL, TCL, SCL, SCS) by SQL function code." is-returning-set="f" ret-datatype="text" function-arguments="p_sql_func_code integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22338" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_sql_func_code integer" overload-function-count="1" proc-language="plpgsql" function-signature="get_cmd_type_by_sql_func_code(p_sql_func_code integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_cmd_type TEXT;
    v_cmd_types TEXT[] = ARRAY['DDL', -- Data Definition Language (DDL)
                               'DML', -- Data Manipulation Language (DML)
                               'DCL', -- Data Control Language (DCL)
                               'TCL', -- Transaction Control Language (TCL)
                               'SCL', -- Session Control Language (SCL)
                               'SCS']; -- System Control Statement (SCS)
BEGIN
    /* See list of possible function codes here:
       https://docstore.mik.ua/orelly/oracle/bipack/ch02_03.htm
    */
    v_cmd_type := CASE p_sql_func_code
                     WHEN 1 -- CREATE [TEMP ]TABLE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 2 -- SET ROLE
                     THEN v_cmd_types[5] -- SCL
                     WHEN 3 -- INSERT[ INTO]
                     THEN v_cmd_types[2] -- DML
                     WHEN 4 -- SELECT
                     THEN v_cmd_types[2] -- DML
                     WHEN 5 -- UPDATE
                     THEN v_cmd_types[2] -- DML
                     WHEN 6 -- DROP ROLE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 7 -- DROP VIEW
                     THEN v_cmd_types[1] -- DDL
                     WHEN 8 -- DROP TABLE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 9 -- DELETE[ FROM]
                     THEN v_cmd_types[2] -- DML
                     WHEN 10 -- CREATE [TEMP ]VIEW
                     THEN v_cmd_types[1] -- DDL
                     WHEN 11 -- DROP USER|SCHEMA
                     THEN v_cmd_types[1] -- DDL
                     WHEN 12 -- CREATE ROLE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 13 -- CREATE [TEMP ]SEQUENCE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 14 -- ALTER SEQUENCE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 16 -- DROP SEQUENCE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 18 -- CREATE CLUSTER
                     THEN v_cmd_types[1] -- DDL
                     WHEN 19 -- CREATE USER|SCHEMA
                     THEN v_cmd_types[1] -- DDL
                     WHEN 20 -- CREATE INDEX
                     THEN v_cmd_types[1] -- DDL
                     WHEN 21 -- DROP INDEX
                     THEN v_cmd_types[1] -- DDL
                     WHEN 22 -- DROP CLUSTER
                     THEN v_cmd_types[1] -- DDL
                     WHEN 24 -- CREATE[ OR REPLACE] PROCEDURE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 25 -- ALTER PROCEDURE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 26 -- ALTER TABLE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 27 -- EXPLAIN[ PLAN]
                     THEN v_cmd_types[2] -- DML
                     WHEN 28 -- GRANT
                     THEN v_cmd_types[3] -- DCL
                     WHEN 29 -- REVOKE
                     THEN v_cmd_types[3] -- DCL
                     WHEN 30 -- CREATE[ OR REPLACE] SYNONYM
                     THEN v_cmd_types[1] -- DDL
                     WHEN 31 -- DROP SYNONYM
                     THEN v_cmd_types[1] -- DDL
                     WHEN 32 -- ALTER SYSTEM
                     THEN v_cmd_types[6] -- SCS
                     WHEN 33 -- SET TRANSACTION
                     THEN v_cmd_types[4] -- TCL
                     WHEN 34 -- PL/SQL EXECUTE
                     THEN v_cmd_types[2] -- DML
                     WHEN 35 -- LOCK[ TABLE]
                     THEN v_cmd_types[2] -- DML
                     WHEN 37 -- RENAME
                     THEN v_cmd_types[1] -- DDL
                     WHEN 38 -- COMMENT
                     THEN v_cmd_types[1] -- DDL
                     WHEN 39 -- AUDIT
                     THEN v_cmd_types[1] -- DDL
                     WHEN 40 -- NOAUDIT
                     THEN v_cmd_types[1] -- DDL
                     WHEN 41 -- ALTER INDEX
                     THEN v_cmd_types[1] -- DDL
                     WHEN 44 -- CREATE DATABASE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 45 -- ALTER DATABASE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 46 -- CREATE[ OR REPLACE] ROLLBACK SEGMENT
                     THEN v_cmd_types[1] -- DDL
                     WHEN 47 -- ALTER ROLLBACK SEGMENT
                     THEN v_cmd_types[1] -- DDL
                     WHEN 48 -- DROP ROLLBACK SEGMENT
                     THEN v_cmd_types[1] -- DDL
                     WHEN 49 -- CREATE[ TEMPORARY] TABLESPACE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 50 -- ALTER TABLESPACE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 51 -- DROP TABLESPACE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 52 -- ALTER SESSION
                     THEN v_cmd_types[5] -- SCL
                     WHEN 53 -- ALTER USER|SCHEMA
                     THEN v_cmd_types[1] -- DDL
                     WHEN 54 -- COMMIT[ WORK]
                     THEN v_cmd_types[4] -- TCL
                     WHEN 55 -- ROLLBACK[ WORK]
                     THEN v_cmd_types[4] -- TCL
                     WHEN 56 -- SAVEPOINT
                     THEN v_cmd_types[4] -- TCL
                     WHEN 57 -- CREATE CONTROL FILE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 59 -- CREATE TRIGGER
                     THEN v_cmd_types[1] -- DDL
                     WHEN 60 -- ALTER TRIGGER
                     THEN v_cmd_types[1] -- DDL
                     WHEN 61 -- DROP TRIGGER
                     THEN v_cmd_types[1] -- DDL
                     WHEN 62 -- ANALYZE TABLE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 63 -- ANALYZE INDEX
                     THEN v_cmd_types[1] -- DDL
                     WHEN 64 -- ANALYZE CLUSTER
                     THEN v_cmd_types[1] -- DDL
                     WHEN 65 -- CREATE PROFILE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 66 -- DROP PROFILE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 67 -- ALTER PROFILE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 68 -- DROP PROCEDURE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 70 -- ALTER RESOURCE COST
                     THEN v_cmd_types[1] -- DDL
                     WHEN 71 -- CREATE SNAPSHOT LOG
                     THEN v_cmd_types[1] -- DDL
                     WHEN 72 -- ALTER SNAPSHOT LOG
                     THEN v_cmd_types[1] -- DDL
                     WHEN 73 -- DROP SNAPSHOT LOG
                     THEN v_cmd_types[1] -- DDL
                     WHEN 74 -- CREATE SNAPSHOT
                     THEN v_cmd_types[1] -- DDL
                     WHEN 75 -- ALTER SNAPSHOT
                     THEN v_cmd_types[1] -- DDL
                     WHEN 76 -- DROP SNAPSHOT
                     THEN v_cmd_types[1] -- DDL
                     WHEN 77 -- CREATE[ OR REPLACE] TYPE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 78 -- DROP TYPE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 79 -- ALTER ROLE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 80 -- ALTER TYPE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 81 -- CREATE[ OR REPLACE] TYPE BODY
                     THEN v_cmd_types[1] -- DDL
                     WHEN 82 -- ALTER TYPE BODY
                     THEN v_cmd_types[1] -- DDL
                     WHEN 83 -- DROP TYPE BODY
                     THEN v_cmd_types[1] -- DDL
                     WHEN 84 -- DROP LIBRARY
                     THEN v_cmd_types[1] -- DDL
                     WHEN 85 -- TRUNCATE TABLE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 86 -- TRUNCATE CLUSTER
                     THEN v_cmd_types[1] -- DDL
                     WHEN 87 -- CREATE BITMAPFILE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 88 -- ALTER VIEW
                     THEN v_cmd_types[1] -- DDL
                     WHEN 89 -- DROP BITMAPFILE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 90 -- SET CONSTRAINT[S]
                     THEN v_cmd_types[4] -- TCL
                     WHEN 91 -- CREATE[ OR REPLACE] FUNCTION
                     THEN v_cmd_types[1] -- DDL
                     WHEN 92 -- ALTER FUNCTION
                     THEN v_cmd_types[1] -- DDL
                     WHEN 93 -- DROP FUNCTION
                     THEN v_cmd_types[1] -- DDL
                     WHEN 94 -- CREATE[ OR REPLACE] PACKAGE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 95 -- ALTER PACKAGE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 96 -- DROP PACKAGE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 97 -- CREATE[ OR REPLACE] PACKAGE BODY
                     THEN v_cmd_types[1] -- DDL
                     WHEN 98 -- ALTER PACKAGE BODY
                     THEN v_cmd_types[1] -- DDL
                     WHEN 99 -- DROP PACKAGE BODY
                     THEN v_cmd_types[1] -- DDL
                     WHEN 157 -- CREATE[ OR REPLACE] DIRECTORY
                     THEN v_cmd_types[1] -- DDL
                     WHEN 158 -- DROP DIRECTORY
                     THEN v_cmd_types[1] -- DDL
                     WHEN 159 -- CREATE[ OR REPLACE] LIBRARY
                     THEN v_cmd_types[1] -- DDL
                     WHEN 170 -- CALL METHOD
                     THEN v_cmd_types[2] -- DML
                     WHEN 189 -- MERGE
                     THEN v_cmd_types[2] -- DML
                     WHEN 197 -- PURGE RECYCLEBIN
                     THEN v_cmd_types[1] -- DDL
                     WHEN 198 -- PURGE DBA_RECYCLEBIN
                     THEN v_cmd_types[1] -- DDL
                     WHEN 199 -- PURGE TABLESPACE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 200 -- PURGE TABLE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 201 -- PURGE INDEX
                     THEN v_cmd_types[1] -- DDL
                     WHEN 202 -- FLASHBACK (UNDROP)
                     THEN v_cmd_types[1] -- DDL
                     WHEN 203 -- DROP DATABASE
                     THEN v_cmd_types[1] -- DDL
                     WHEN 243 -- CREATE[ OR REPLACE] ATTRIBUTE DIMENSION
                     THEN v_cmd_types[1] -- DDL
                     WHEN 244 -- ALTER ATTRIBUTE DIMENSION
                     THEN v_cmd_types[1] -- DDL
                     WHEN 245 -- DROP ATTRIBUTE DIMENSION
                     THEN v_cmd_types[1] -- DDL
                     WHEN 246 -- CREATE[ OR REPLACE] HIERARCHY
                     THEN v_cmd_types[1] -- DDL
                     WHEN 247 -- ALTER HIERARCHY
                     THEN v_cmd_types[1] -- DDL
                     WHEN 248 -- DROP HIERARCHY
                     THEN v_cmd_types[1] -- DDL
                     WHEN 249 -- CREATE[ OR REPLACE] ANALYTIC VIEW
                     THEN v_cmd_types[1] -- DDL
                     WHEN 250 -- ALTER ANALYTIC VIEW
                     THEN v_cmd_types[1] -- DDL
                     WHEN 251 -- DROP ANALYTIC VIEW
                     THEN v_cmd_types[1] -- DDL
                  END;

    RETURN v_cmd_type;
END;
]]></complex-attribute>
                        <category _I_D="460a1b08-9b1c-486c-8b1e-7fdfd8161d8b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b010bfd2-649e-4549-891c-908b75d28e34" name="get_context_param" is-trigger-function="0" unique-function-name="get_context_param" is-aggregate="f" language-name="plpgsql" context="get_context_param" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="varchar" function-arguments="a_param_name character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22995" volatility="VOLATILE" is-window="f" function-identity-arguments="a_param_name character varying" overload-function-count="1" proc-language="plpgsql" function-signature="get_context_param(a_param_name character varying)">
                        <complex-attribute name="sql"><![CDATA[
begin
	/*Params:
	 * 'key' - secret key for the crypt calls
	 * 'auto_clean_interval' - an interval for context_global auto cleaning*/	
  return (select param_value 
 			from aws_oracle_context.params 
 			where param_name = a_param_name);  
end;	
]]></complex-attribute>
                        <category _I_D="e05453c0-c653-40c4-80ec-31e2657143ec" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bdad41fd-2ffe-4538-b920-479d114241af" name="get_context_type" is-trigger-function="0" unique-function-name="get_context_type" is-aggregate="f" language-name="sql" context="get_context_type" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="varchar" function-arguments="a_context_namespace character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22994" volatility="IMMUTABLE" is-window="f" function-identity-arguments="a_context_namespace character varying" overload-function-count="1" proc-language="sql" function-signature="get_context_type(a_context_namespace character varying)">
                        <complex-attribute name="sql"><![CDATA[
  select upper(context_type) 
 			from aws_oracle_context.context 
 			where context_namespace = $1;  
]]></complex-attribute>
                        <category _I_D="ffb855a5-c460-4a0f-8d9e-c3d66cd32351" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6ad1cf1b-7b59-4714-b0ec-3a835c2302f7" name="get_extpack_variable" is-trigger-function="0" unique-function-name="get_extpack_variable" is-aggregate="f" language-name="plpgsql" context="get_extpack_variable" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,boolean" is-returning-set="f" ret-datatype="text" function-arguments="variable_name text, missing_ok boolean DEFAULT true" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22051" volatility="VOLATILE" is-window="f" function-identity-arguments="variable_name text, missing_ok boolean" overload-function-count="1" proc-language="plpgsql" function-signature="get_extpack_variable(variable_name text, missing_ok boolean)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    RETURN aws_oracle_ext.get_package_variable
    (
        variable_name => get_extpack_variable.variable_name
    );
   
EXCEPTION 
    WHEN OTHERS THEN

        IF missing_ok THEN
        
            RETURN NULL;

        ELSE

            RAISE;

        END IF;

END;
]]></complex-attribute>
                        <category _I_D="edd5c493-9abd-4110-bf10-087c41921220" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e2443468-9a3f-4f34-bdff-028a35deee58" name="get_id_by_name" is-trigger-function="0" unique-function-name="get_id_by_name" is-aggregate="f" language-name="plpgsql" context="get_id_by_name" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="int8" function-arguments="object_name text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22283" volatility="VOLATILE" is-window="f" function-identity-arguments="object_name text" overload-function-count="1" proc-language="plpgsql" function-signature="get_id_by_name(object_name text)">
                        <complex-attribute name="sql"><![CDATA[
declare res bigint;
begin
  execute concat('select x''', substring(encode(digest($1, 'sha1'), 'hex'), 1, 16), '''::bigint') into res;
  return res;  
end;
]]></complex-attribute>
                        <category _I_D="ec383e2b-4599-4277-bbd9-966f065a39bf" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="17424bae-3413-4c5e-880f-e0ae265fc352" name="get_jobs" is-trigger-function="0" unique-function-name="get_jobs" is-aggregate="f" language-name="plpgsql" context="get_jobs" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone,integer,bigint,character varying,character varying" is-returning-set="t" ret-datatype="table" function-arguments="p_next_date_before timestamp without time zone DEFAULT CURRENT_TIMESTAMP, p_limit integer DEFAULT 1" schema-id="21999" function-type="RET_DATASET" count-arguments="2" function-id="22386" volatility="VOLATILE" is-window="f" function-identity-arguments="p_next_date_before timestamp without time zone, p_limit integer" overload-function-count="1" proc-language="plpgsql" function-signature="get_jobs(p_next_date_before timestamp without time zone, p_limit integer)">
                        <complex-attribute name="sql"><![CDATA[
  declare
    l_this_date timestamp with time zone := clock_timestamp();
  begin
    return query 
      update aws_oracle_ext.jobs j
         set this_date = l_this_date
        from (
          select jj.job
            from aws_oracle_ext.jobs jj
           where jj.this_date is null
             and broken <> 'Y'
             and jj.next_date <= p_next_date_before
             and pg_try_advisory_xact_lock( jj.job )
           limit p_limit
             for update
        ) jj
       where j.job = jj.job
      returning j.job, j.what, j.search_path;
  end;
]]></complex-attribute>
                        <category _I_D="904c92f7-5436-43c0-a934-44a13bdad89a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2aa81ce2-8442-4e0e-abed-cdb0bc8597ba" name="get_ora_sqlcode" is-trigger-function="0" unique-function-name="get_ora_sqlcode" is-aggregate="f" language-name="plpgsql" context="get_ora_sqlcode" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" comment="&amp;#x000a;  Returns an appropriate Oracle error code for Oracle built-in exception.&amp;#x000a;&amp;#x000a;  Parameters:&amp;#x000a;    ora_exception -- name of Oracle built-in exception&amp;#x000a;" is-returning-set="f" ret-datatype="int4" function-arguments="ora_exception character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22387" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ora_exception character varying" overload-function-count="1" proc-language="plpgsql" function-signature="get_ora_sqlcode(ora_exception character varying)">
                        <complex-attribute name="sql"><![CDATA[
  declare
    l_ora_code aws_oracle_ext.mapped_error_codes.ora_code%type;
  begin
    select ora_code into strict l_ora_code
      from aws_oracle_ext.mapped_error_codes c
     where c.ora_exception = upper( get_ora_sqlcode.ora_exception )
       and ora_code is not null;

    return l_ora_code;
  exception
    when no_data_found then
      raise exception no_data_found 
      using message = format( 'No error code is found for the Oracle built-in exception (%s)', ora_exception )
          , detail =  concat_ws
              ( 'There is no mapping found for the Oracle error code in the current version of Extension Pack: ', ora_exception )
          , hint = 'Check the documentation on error code mappings, please.';
  end;
]]></complex-attribute>
                        <category _I_D="3c752145-fc14-4a0b-9673-6f99c8075827" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="70c62592-1707-4a38-bce3-05d4fe417e30" name="get_ora_sqlcode_by_pg" is-trigger-function="0" unique-function-name="get_ora_sqlcode_by_pg" is-aggregate="f" language-name="plpgsql" context="get_ora_sqlcode_by_pg" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="int4" function-arguments="pg_code character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23144" volatility="VOLATILE" is-window="f" function-identity-arguments="pg_code character varying" overload-function-count="1" proc-language="plpgsql" function-signature="get_ora_sqlcode_by_pg(pg_code character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare
    l_ora_code aws_oracle_ext.mapped_error_codes.ora_code%type;
  begin
    select ora_code into strict l_ora_code
      from aws_oracle_ext.mapped_error_codes c
     where c.pg_code = upper( get_ora_sqlcode_by_pg.pg_code )
       and ora_code is not null;

    return l_ora_code;
  exception
    when no_data_found then
      raise exception no_data_found 
      using message = format( 'No error code mapping is found for the PostgreSQL error code (%s)', pg_code )
          , detail =  concat_ws
              ('', 'There is no mapping found for the PostgreSQL error code in the current version of Extension Pack: ', pg_code )
          , hint = 'Check the documentation on error code mappings, please.'    ;
          
    when too_many_rows then
      raise exception too_many_rows 
      using message = format( 'More than one error code mapping is found for the PostgreSQL error code (%s)', pg_code )
          , detail =  concat_ws
              ('', 'More than one row found for the PostgreSQL error code in the current version of Extension Pack: ', pg_code )
          , hint = 'Check the documentation on error code mappings, please.'    ;
  end;
]]></complex-attribute>
                        <category _I_D="60c6e571-1068-459e-83d9-6dcf738f8020" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="36522d5e-6c6c-4229-9acc-77bb50dce38b" name="get_package_variable" is-trigger-function="0" unique-function-name="get_package_variable" is-aggregate="f" language-name="plpgsql" context="get_package_variable" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="schema_name text DEFAULT 'AWS_ORACLE_EXT'::text, package_name text DEFAULT 'AWS_ORACLE_ENV'::text, variable_name text DEFAULT ''::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22022" volatility="VOLATILE" is-window="f" function-identity-arguments="schema_name text, package_name text, variable_name text" overload-function-count="1" proc-language="plpgsql" function-signature="get_package_variable(schema_name text, package_name text, variable_name text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vschema_name TEXT := schema_name;
    vpackage_name TEXT := package_name;
    name_is_quoted BOOLEAN DEFAULT FALSE;
BEGIN
    
    IF COALESCE(schema_name, 'AWS_ORACLE_EXT') <> 'AWS_ORACLE_EXT' AND

        COALESCE(package_name, 'AWS_ORACLE_ENV') <> 'AWS_ORACLE_ENV' THEN

        vschema_name := aws_oracle_ext.check_identifier_case(schema_name);
        vpackage_name := aws_oracle_ext.check_identifier_case(package_name);

        IF RIGHT(vpackage_name, 1) = '"' THEN

            name_is_quoted := TRUE;

        END IF;
    
        IF aws_oracle_ext.check_identifier_case(variable_name) <> 'init$$' THEN
        
            EXECUTE CONCAT
            (
                'SELECT ',
                schema_name,
                '.',
                CASE WHEN NOT name_is_quoted THEN package_name ELSE SUBSTR(package_name, 1, LENGTH(package_name) - 1) END,
                '$init',
                CASE WHEN name_is_quoted THEN '"' ELSE '' END,
                '()'
            );
    
        END IF;

    END IF;
    
    RETURN NULLIF
    (
        aws_oracle_ext.get_package_variable_v8
        (
            sn => vschema_name,
            pn => vpackage_name,
            vn => aws_oracle_ext.check_identifier_case(variable_name)
        ),
        ''
    );

END;
]]></complex-attribute>
                        <category _I_D="8de15c7c-9dd6-40d0-ad3a-62e8a2858fb8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d738210a-cfe9-4d6d-9a6a-029ad5f66efe" name="get_package_variable_object" is-trigger-function="0" unique-function-name="get_package_variable_object" is-aggregate="f" language-name="plpgsql" context="get_package_variable_object" subcategories-loading="none" object-loading="extended" arguments-datatypes="name,name,name" is-returning-set="f" ret-datatype="text" function-arguments="schema_name name, package_name name, object_name name" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22388" volatility="VOLATILE" is-window="f" function-identity-arguments="schema_name name, package_name name, object_name name" overload-function-count="1" proc-language="plpgsql" function-signature="get_package_variable_object(schema_name name, package_name name, object_name name)">
                        <complex-attribute name="sql"><![CDATA[
  begin
    execute 'select ' || schema_name || '.' || package_name || '$Init()';

    return aws_oracle_ext.get_package_variable
        ( schema_name := schema_name
        , package_name := package_name
        , variable_name := object_name || '$OBJ' );
  end;
]]></complex-attribute>
                        <category _I_D="803a260e-4de0-44e4-90dd-484921e20392" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c4c1a428-9564-439a-8293-b78db9757b72" name="get_package_variable_object_field" is-trigger-function="0" unique-function-name="get_package_variable_object_field" is-aggregate="f" language-name="plpgsql" context="get_package_variable_object_field" subcategories-loading="none" object-loading="extended" arguments-datatypes="name,name,name,text" is-returning-set="f" ret-datatype="text" function-arguments="schema_name name, package_name name, variable_name name, field_name text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22389" volatility="VOLATILE" is-window="f" function-identity-arguments="schema_name name, package_name name, variable_name name, field_name text" overload-function-count="1" proc-language="plpgsql" function-signature="get_package_variable_object_field(schema_name name, package_name name, variable_name name, field_name text)">
                        <complex-attribute name="sql"><![CDATA[
  begin
    execute 'select ' || schema_name || '.' || package_name || '$Init()';

    return aws_oracle_ext.get_package_variable
      ( schema_name, package_name, variable_name || '.' || field_name );
  end;
]]></complex-attribute>
                        <category _I_D="e6ffdf7b-75bc-4977-958d-c880d4b64e7b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="db239054-80c8-49e0-b8cb-b8e02f51a81d" name="get_pg_sqlstate" is-trigger-function="0" unique-function-name="get_pg_sqlstate" is-aggregate="f" language-name="plpgsql" context="get_pg_sqlstate" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer" comment="&amp;#x000a;  Returns a mapped PostgreSQL error code for Oracle error code, if a mapping exists.&amp;#x000a;&amp;#x000a;  Parameters:&amp;#x000a;    ora_code -- Oracle integer error code like those SQLCODE returns&amp;#x000a;" is-returning-set="f" ret-datatype="varchar" function-arguments="ora_code integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22390" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ora_code integer" overload-function-count="1" proc-language="plpgsql" function-signature="get_pg_sqlstate(ora_code integer)">
                        <complex-attribute name="sql"><![CDATA[
  declare
    l_pg_code aws_oracle_ext.mapped_error_codes.pg_code%type;
  begin
    select pg_code into strict l_pg_code
      from aws_oracle_ext.mapped_error_codes c
     where c.ora_code = get_pg_sqlstate.ora_code
       and pg_code is not null;

    return l_pg_code;
  exception
    when no_data_found then
      raise exception no_data_found 
      using message = format( 'No error code mapping is found for the Oracle error code (%s)', ora_code )
          , detail =  concat_ws
              ( 'There is no mapping found for the Oracle error code in the current version of Extension Pack: ', ora_code )
          , hint = 'Check the documentation on error code mappings, please.'    ;
  end;
]]></complex-attribute>
                        <category _I_D="6ab53b0c-b7ba-4f61-84cc-9636bb449d32" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8f8e754a-9895-4cf8-97fe-808fd3e29458" name="get_sequence_value" is-trigger-function="0" unique-function-name="get_sequence_value" is-aggregate="f" language-name="plpgsql" context="get_sequence_value" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying" comment="Returns the sequence current value" is-returning-set="f" ret-datatype="int8" function-arguments="aschemaname character varying, asequencename character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22155" volatility="VOLATILE" is-window="f" function-identity-arguments="aschemaname character varying, asequencename character varying" overload-function-count="1" proc-language="plpgsql" function-signature="get_sequence_value(aschemaname character varying, asequencename character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare
  lVal bigint;
begin
  EXECUTE 'SELECT last_value from '||quote_ident(aSchemaName)||'.'||quote_ident(aSequenceName) into lVal;
  return lVal;    
  exception when others then
    return null;
end;
]]></complex-attribute>
                        <category _I_D="fc014974-537f-4643-8505-7d1a8b79d02d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d9f9bce4-1f34-46f8-84c7-1c088bab57f4" name="get_service_setting" is-trigger-function="0" unique-function-name="get_service_setting" is-aggregate="f" language-name="sql" context="get_service_setting" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying" is-returning-set="f" ret-datatype="varchar" function-arguments="p_service character varying, p_setting character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22391" volatility="VOLATILE" is-window="f" function-identity-arguments="p_service character varying, p_setting character varying" overload-function-count="1" proc-language="sql" function-signature="get_service_setting(p_service character varying, p_setting character varying)">
                        <complex-attribute name="sql"><![CDATA[
  select value from aws_oracle_ext.service_settings where service = p_service and setting = p_setting;
]]></complex-attribute>
                        <category _I_D="1d6ca64b-ac90-42dc-8f9f-10a8a549d45d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f21d63eb-499d-48cf-9fdd-38ea0ba2d09e" name="get_text_file_from_s3" is-trigger-function="0" unique-function-name="get_text_file_from_s3" is-aggregate="f" language-name="plpgsql" context="get_text_file_from_s3" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,boolean" comment="This function This function downloads a text file from an AWS S3 bucket and reads (returns) its contents." is-returning-set="f" ret-datatype="text" function-arguments="directory_name text, file_name text, error_on_empty boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23524" volatility="VOLATILE" is-window="f" function-identity-arguments="directory_name text, file_name text, error_on_empty boolean" overload-function-count="1" proc-language="plpgsql" function-signature="get_text_file_from_s3(directory_name text, file_name text, error_on_empty boolean)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_file_data TEXT;
    v_bucket_name TEXT;
    v_bucket_path TEXT;
    v_aws_region VARCHAR(50);
    v_err_message TEXT;
BEGIN
    SELECT s3_bucket_name,
           s3_bucket_path,
           aws_region
      INTO STRICT
           v_bucket_name,
           v_bucket_path,
           v_aws_region
      FROM aws_oracle_ext.sys_dba_directories drs
     WHERE drs.directory_name = get_text_file_from_s3.directory_name;

    -- Temp table for importing the text file data into
    CREATE TEMP TABLE aws_s3_file_data$c75b9c8510b3ab (
        file_data TEXT
    )
    ON COMMIT DROP;

    BEGIN
        -- Downloading the file from the S3 bucket and reading its contents into a column of a given table
        PERFORM aws_s3.table_import_from_s3(table_name  => 'aws_s3_file_data$c75b9c8510b3ab',
                                            column_list => 'file_data',
                                            options     => '',
                                            bucket      => v_bucket_name,
                                            file_path   => concat_ws('/', v_bucket_path, file_name),
                                            region      => v_aws_region);
    EXCEPTION
        WHEN OTHERS THEN
            GET STACKED DIAGNOSTICS
                v_err_message = MESSAGE_TEXT;

            -- Throw an exception if the file is empty and `error_on_empty` parameter is set to true
            IF (v_err_message ~* '0 rows were copied successfully')
            THEN
                IF (error_on_empty)
                THEN
                    -- The file exists but is empty (0 bytes)
                    RAISE USING MESSAGE := 'The file is empty (0 bytes).',
                                DETAIL := 'The file exists but is empty (0 bytes)';
                END IF;
            ELSE
                RAISE;
            END IF;
    END;

    SELECT file_data
      INTO v_file_data
      FROM aws_s3_file_data$c75b9c8510b3ab;

    RETURN coalesce(v_file_data, '');
EXCEPTION
    WHEN no_data_found THEN
        -- ORA-29280: invalid directory object
        RAISE USING MESSAGE := 'Invalid directory object.',
                    DETAIL := 'The directory object passed in does not exist in the database. Check that the name is correct and create a directory object if necessary.',
                    HINT := '-29280';
    WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS
            v_err_message = MESSAGE_TEXT;

        IF (v_err_message ~* 'HTTP 404. No response body.')
        THEN
            -- ORA-29283: invalid file operation
            RAISE USING MESSAGE := 'Invalid file operation.',
                        DETAIL := 'The AWS S3 file path or file name is incorrect.',
                        HINT := '-29283';
        ELSIF (v_err_message ~* 'invalid byte sequence for encoding "UTF8"')
        THEN
            -- Invalid text file or unsupported encoding (not UTF-8)
            RAISE USING MESSAGE := 'Invalid text file.',
                        DETAIL := 'The specified file is not a text file or contains data encoded in an unsupported encoding.',
                        HINT := 'Make sure the file is a valid UTF-8 text file. If not, convert it to UTF-8 and try again.';
        ELSIF (v_err_message ~* 'credentials stored with the database')
        THEN
            -- IAM role containing the s3Import feature error
            RAISE USING MESSAGE := 'The IAM role containing the s3Import feature is not associated with the DB instance.',
                        DETAIL := 'The credentials stored with the database instance can''t be accessed.',
                        HINT := 'Make sure that the desired Amazon Resource Name (ARN) is associated with the feature-name: s3Import.';
        ELSE
            RAISE;
        END IF;
END;
]]></complex-attribute>
                        <category _I_D="524f9bc2-faf8-4ca0-ace0-a33a5a372ec5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ffb90335-da7e-4125-9a94-8b4066268cf3" name="get_user_oid_by_name" is-trigger-function="0" unique-function-name="get_user_oid_by_name" is-aggregate="f" language-name="sql" context="get_user_oid_by_name" subcategories-loading="none" object-loading="extended" arguments-datatypes="name" comment="This function returns OID for the specified database user name." is-returning-set="f" ret-datatype="int8" function-arguments="p_user_name name" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22339" volatility="VOLATILE" is-window="f" function-identity-arguments="p_user_name name" overload-function-count="1" proc-language="sql" function-signature="get_user_oid_by_name(p_user_name name)">
                        <complex-attribute name="sql"><![CDATA[
SELECT oid::BIGINT
  FROM pg_catalog.pg_roles
 WHERE rolname = p_user_name
]]></complex-attribute>
                        <category _I_D="44a78837-f161-4396-b0dc-54a9034515f2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2234e19c-94f2-4c1a-bbe9-d03c126b09ac" name="get_version" is-trigger-function="0" unique-function-name="get_version" is-aggregate="f" language-name="sql" context="get_version" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="varchar" function-arguments="pcomponentname character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22392" volatility="VOLATILE" is-window="f" function-identity-arguments="pcomponentname character varying" overload-function-count="1" proc-language="sql" function-signature="get_version(pcomponentname character varying)">
                        <complex-attribute name="sql"><![CDATA[
	SELECT componentversion 
	  FROM aws_oracle_ext.versions
	 WHERE extpackcomponentname = pComponentName;
]]></complex-attribute>
                        <category _I_D="5bafefca-e7b9-41cf-a0ab-a3e92a43de3a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e69bca5d-2bcd-43a1-9441-8d511e2bf4dc" name="getpathparts" is-trigger-function="0" unique-function-name="getpathparts" is-aggregate="f" language-name="plpgsql" context="getpathparts" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="_text" function-arguments="ppath text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23155" volatility="VOLATILE" is-window="f" function-identity-arguments="ppath text" overload-function-count="1" proc-language="plpgsql" function-signature="getpathparts(ppath text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    
    IF ppath !~ '[^\[\]]+\[.+\]' THEN

        RETURN NULL;

    END IF;

    RETURN REGEXP_SPLIT_TO_ARRAY
    (
        REPLACE
        (
            REPLACE
            (
                ppath,
                '[',
                '.'
            ),
            ']',
            ''
        ),
        '\.'
    );
END;
]]></complex-attribute>
                        <category _I_D="dd70ae17-6fcc-4f92-9cc5-b75090312a4f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="aed41376-255d-405c-b580-52332193ffb7" name="greatest" is-trigger-function="0" unique-function-name="greatest" is-aggregate="f" language-name="sql" context="greatest" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray" is-returning-set="f" ret-datatype="anyelement" function-arguments="VARIADIC anyarray" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23145" volatility="VOLATILE" is-window="f" function-identity-arguments="VARIADIC anyarray" overload-function-count="1" proc-language="sql" function-signature="greatest(VARIADIC anyarray)">
                        <complex-attribute name="sql"><![CDATA[
  SELECT unnest($1)
  ORDER BY 1 DESC NULLS FIRST
  LIMIT 1;
]]></complex-attribute>
                        <category _I_D="9976fb84-80b8-4b74-85e3-9c2e0a7a7f04" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0f432966-b7d3-4595-9d2b-b5027900d62e" name="has_column_privilege" is-trigger-function="0" unique-function-name="has_column_privilege" is-aggregate="f" language-name="sql" context="has_column_privilege" subcategories-loading="none" object-loading="extended" arguments-datatypes="name,name,name" is-returning-set="f" ret-datatype="bool" function-arguments="schema_name name, table_name name, column_name name" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22156" volatility="VOLATILE" is-window="f" function-identity-arguments="schema_name name, table_name name, column_name name" overload-function-count="1" proc-language="sql" function-signature="has_column_privilege(schema_name name, table_name name, column_name name)">
                        <complex-attribute name="sql"><![CDATA[
    select 
        has_column_privilege
            (
                quote_ident($1) || '.' || quote_ident($2), 
                quote_ident($3), 
                'SELECT,INSERT,UPDATE,REFERENCES'
            );
]]></complex-attribute>
                        <category _I_D="bbb4dee4-e8a9-4c8c-a349-52ebee8b0482" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5370dc9c-1d7f-4ad9-9a9c-f2504d28e858" name="hex_to_int" is-trigger-function="0" unique-function-name="hex_to_int" is-aggregate="f" language-name="plpgsql" context="hex_to_int" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="Convert hex string to integer." is-returning-set="f" ret-datatype="int4" function-arguments="hexval text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22514" volatility="IMMUTABLE" is-window="f" function-identity-arguments="hexval text" overload-function-count="1" proc-language="plpgsql" function-signature="hex_to_int(hexval text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  result  int;
BEGIN
  EXECUTE 'SELECT x' || quote_literal(hexval) || '::int' INTO result;
  --EXECUTE 'SELECT x''' || hexval || '''::int' INTO result;
  RETURN result;
END; 
]]></complex-attribute>
                        <category _I_D="f748bd4e-9630-49d4-b9d9-e3a96fdd9bb6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1d1373e4-b7eb-4b50-8c5f-905628024872" name="htf$address" is-trigger-function="0" unique-function-name="htf$address" is-aggregate="f" language-name="sql" context="htf$address" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cvalue text, cnowrap text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22530" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cvalue text, cnowrap text, cclear text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$address(cvalue text, cnowrap text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('',
                     '<address',
                     aws_oracle_ext.htf$ifnotnull(cclear, concat_ws('', 'clear="', cclear, '"')),
                     aws_oracle_ext.htf$ifnotnull(cnowrap,' nowrap="nowrap"'),
                     aws_oracle_ext.htf$ifnotnull(cattributes,concat_ws('', ' ', cattributes)),
                     '>',
                     cvalue,
                     '</address>');

]]></complex-attribute>
                        <category _I_D="031969a7-da08-438f-a065-55865eb78ca8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="da8a8a47-6d20-4c19-b03c-79c3fd921cce" name="htf$anchor" is-trigger-function="0" unique-function-name="htf$anchor" is-aggregate="f" language-name="sql" context="htf$anchor" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="curl text, ctext text, cname text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22532" volatility="IMMUTABLE" is-window="f" function-identity-arguments="curl text, ctext text, cname text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$anchor(curl text, ctext text, cname text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('', 
        '<A HREF="',
        curl,
        '"',
        CASE
            WHEN cname IS NOT NULL THEN
                CONCAT_WS('', ' NAME="', cname, '"')
            ELSE
                ''
        END,
        CASE
            WHEN cattributes IS NOT NULL THEN
                CONCAT_WS('', ' ', cattributes)
            ELSE
                ''
        END,
        '>',
        ctext,
        '</A>'
    );

]]></complex-attribute>
                        <category _I_D="6aa280e3-5868-4d79-9c25-0c5629e8d57e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7ec0c6b6-8a44-4735-8d97-ea15c6d779f4" name="htf$anchor2" is-trigger-function="0" unique-function-name="htf$anchor2" is-aggregate="f" language-name="sql" context="htf$anchor2" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="curl text, ctext text, cname text DEFAULT NULL::text, ctarget text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22531" volatility="IMMUTABLE" is-window="f" function-identity-arguments="curl text, ctext text, cname text, ctarget text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$anchor2(curl text, ctext text, cname text, ctarget text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('', 
        '<A HREF="',
        curl,
        '"',
        CASE
            WHEN cname IS NOT NULL THEN
                CONCAT_WS('', ' NAME="', cname, '"')
            ELSE
                ''
        END,
        CASE
            WHEN ctarget IS NOT NULL THEN
                CONCAT_WS('', ' TARGET="', ctarget, '"')
            ELSE
                ''
        END,
        CASE
            WHEN cattributes IS NOT NULL THEN
                CONCAT_WS('', ' ', cattributes)
            ELSE
                ''
        END,
        '>',
        ctext,
        '</A>'
    );

]]></complex-attribute>
                        <category _I_D="93620724-b0b2-4123-8b36-0142e91faed2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="054eb809-40d7-4999-8869-91665bb623ed" name="htf$appletclose" is-trigger-function="0" unique-function-name="htf$appletclose" is-aggregate="f" language-name="sql" context="htf$appletclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22533" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$appletclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</applet>';

]]></complex-attribute>
                        <category _I_D="33ed68f1-8ea4-4f06-baa1-dd0fdffa83cb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1d33ee19-cff2-44ef-8102-2ab1c3997895" name="htf$appletopen" is-trigger-function="0" unique-function-name="htf$appletopen" is-aggregate="f" language-name="sql" context="htf$appletopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,numeric,text" is-returning-set="f" ret-datatype="text" function-arguments="ccode text, cwidth numeric, cheight numeric, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22534" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ccode text, cwidth numeric, cheight numeric, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$appletopen(ccode text, cwidth numeric, cheight numeric, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('',
                     '<applet code=',
                     ccode,
                     ' width=',cwidth,
                     ' height=',cheight,
                     aws_oracle_ext.htf$ifnotnull(cattributes,concat_ws('',' ', cattributes)),
                     '>');

]]></complex-attribute>
                        <category _I_D="7756891a-0402-4d36-a6d7-6be06bfc4667" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="88f74e00-5811-43c5-8ad5-6d49ef1172f9" name="htf$area" is-trigger-function="0" unique-function-name="htf$area" is-aggregate="f" language-name="sql" context="htf$area" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="ccoords text, cshape text DEFAULT NULL::text, chref text DEFAULT NULL::text, cnohref text DEFAULT NULL::text, ctarget text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22535" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ccoords text, cshape text, chref text, cnohref text, ctarget text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$area(ccoords text, cshape text, chref text, cnohref text, ctarget text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

      SELECT CONCAT_WS('',
                       '<area',
                       aws_oracle_ext.htf$ifnotnull(cshape,' shape="'||cshape||'"'),
                       ' coords="',
                       ccoords,'"',
                       aws_oracle_ext.htf$ifnotnull(chref, concat_ws('', ' href="', chref, '"')),
                       aws_oracle_ext.htf$ifnotnull(cnohref, concat_ws('', ' nohref="nohref"')),
                       aws_oracle_ext.htf$ifnotnull(ctarget, concat_ws('', ' target="', ctarget, '"')),
                       aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                       ' />');

]]></complex-attribute>
                        <category _I_D="40fa16da-8ec0-43cd-990e-876d2e4888d4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d17be420-a21b-4e9a-846e-aac798f185ad" name="htf$base" is-trigger-function="0" unique-function-name="htf$base" is-aggregate="f" language-name="sql" context="htf$base" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctarget text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22537" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctarget text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$base(ctarget text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<base',
                     aws_oracle_ext.htf$ifnotnull(ctarget, concat_ws('', ' target="', ctarget, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     ' href="',
                     case when aws_oracle_ext.owa_util$get_cgi_env('REQUEST_PROTOCOL') is null then 'http'
                          else lower('REQUEST_PROTOCOL')
                      end,
                     '://',
                     aws_oracle_ext.owa_util$get_cgi_env('SERVER_NAME'),
                     ':',
                     aws_oracle_ext.owa_util$get_cgi_env('SERVER_PORT'),
                     aws_oracle_ext.owa_util$get_cgi_env('SCRIPT_NAME'),
                     aws_oracle_ext.owa_util$get_cgi_env('PATH_INFO'),
                     '" />');

]]></complex-attribute>
                        <category _I_D="c017a9c0-7352-471b-bedd-c75ec1ff985d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5f80e43f-57f8-4c5a-b48e-9d8549a98f05" name="htf$basefont" is-trigger-function="0" unique-function-name="htf$basefont" is-aggregate="f" language-name="sql" context="htf$basefont" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text" is-returning-set="f" ret-datatype="text" function-arguments="nsize numeric, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22536" volatility="IMMUTABLE" is-window="f" function-identity-arguments="nsize numeric, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$basefont(nsize numeric, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('' ,
                     '<basefont size="', 
                     nsize ,
                     '"',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     ' />');

]]></complex-attribute>
                        <category _I_D="86598ffb-1c42-4cf9-9ccd-3ac17f704165" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4270630a-0ebc-43db-a3b2-351c6bbc46b3" name="htf$bgsound" is-trigger-function="0" unique-function-name="htf$bgsound" is-aggregate="f" language-name="sql" context="htf$bgsound" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="csrc text, cloop text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22538" volatility="IMMUTABLE" is-window="f" function-identity-arguments="csrc text, cloop text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$bgsound(csrc text, cloop text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('',
                     '<bgsound src="',
                     csrc,
                     '"',
                     aws_oracle_ext.htf$IFNOTNULL(cloop, concat_ws('', ' loop="', cloop, '"')),
                     aws_oracle_ext.htf$IFNOTNULL(cattributes, concat_ws('',' ', cattributes)),
                     '>');

]]></complex-attribute>
                        <category _I_D="f862f49f-4787-43ce-89a8-763abb2742b8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="68e24016-6edb-4c82-ad3c-2915bd425102" name="htf$big" is-trigger-function="0" unique-function-name="htf$big" is-aggregate="f" language-name="sql" context="htf$big" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22539" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$big(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<big',
                     aws_oracle_ext.htf$IFNOTNULL(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</big>');

]]></complex-attribute>
                        <category _I_D="d91efeac-22f8-4019-b77c-6cfe9354a934" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="727897d3-c04d-4d3a-95f2-a73d66523af6" name="htf$blockquoteclose" is-trigger-function="0" unique-function-name="htf$blockquoteclose" is-aggregate="f" language-name="sql" context="htf$blockquoteclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22540" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$blockquoteclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</blockquote>';

]]></complex-attribute>
                        <category _I_D="04bea6d4-772e-407f-8369-2ecbcfd4b7a7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="71815406-3532-4a29-8024-2ef28046a10a" name="htf$blockquoteopen" is-trigger-function="0" unique-function-name="htf$blockquoteopen" is-aggregate="f" language-name="sql" context="htf$blockquoteopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cnowrap text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22541" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cnowrap text, cclear text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$blockquoteopen(cnowrap text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<blockquote',
                     aws_oracle_ext.htf$ifnotnull(cclear, concat_ws('', ' clear="', cclear, '"')),
                     aws_oracle_ext.htf$ifnotnull(cnowrap, concat_ws('', ' nowrap="nowrap"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>');

]]></complex-attribute>
                        <category _I_D="ba47d4be-e18e-4e23-8015-67466686b3cb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="609eb8e8-0347-4aeb-bceb-9c87d491b378" name="htf$bold" is-trigger-function="0" unique-function-name="htf$bold" is-aggregate="f" language-name="sql" context="htf$bold" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22542" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$bold(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<b',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</b>');

]]></complex-attribute>
                        <category _I_D="bfe9e9ac-c2be-4181-a860-63de14c894a6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="63e8d4f0-5f18-47db-9a9a-e9fcefeabe05" name="htf$br" is-trigger-function="0" unique-function-name="htf$br" is-aggregate="f" language-name="sql" context="htf$br" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22543" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cclear text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$br(cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<br',
                     aws_oracle_ext.htf$ifnotnull(cclear, concat_ws('', ' clear="', cclear, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>');

]]></complex-attribute>
                        <category _I_D="c9716704-e53c-4c72-9c87-b9fa79bd1ad9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6f7212b1-1dc2-4096-8f05-3c108931659e" name="htf$center" is-trigger-function="0" unique-function-name="htf$center" is-aggregate="f" language-name="sql" context="htf$center" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22546" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text" overload-function-count="1" proc-language="sql" function-signature="htf$center(ctext text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<center>',
                     ctext,
                     '</center>');

]]></complex-attribute>
                        <category _I_D="0034e60b-2943-4a45-8cf0-df93224dbc2c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c9ab24b9-318d-4c97-ab2d-76d1a42cc0bb" name="htf$centerclose" is-trigger-function="0" unique-function-name="htf$centerclose" is-aggregate="f" language-name="sql" context="htf$centerclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22544" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$centerclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</center>';

]]></complex-attribute>
                        <category _I_D="69e4559f-6f6d-421f-854c-fb6133836ce6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="cab04f27-9521-4b58-9ffa-2849884d43c3" name="htf$centeropen" is-trigger-function="0" unique-function-name="htf$centeropen" is-aggregate="f" language-name="sql" context="htf$centeropen" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22545" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$centeropen()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '<center>';

]]></complex-attribute>
                        <category _I_D="3188594b-060a-470a-b24a-0b8601d14bf1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="db4c43af-2a12-4bc7-9e81-74b3200b82d8" name="htf$cite" is-trigger-function="0" unique-function-name="htf$cite" is-aggregate="f" language-name="sql" context="htf$cite" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22547" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$cite(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<cite',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</cite>');

]]></complex-attribute>
                        <category _I_D="93853e87-7083-4634-b941-324a279a16fb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="fb2f1c64-8c90-4292-a900-5a2f3c67ab51" name="htf$code" is-trigger-function="0" unique-function-name="htf$code" is-aggregate="f" language-name="sql" context="htf$code" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22548" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$code(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('',
                     '<code',
                     aws_oracle_ext.htf$IFNOTNULL(cattributes, concat_ws('', ' ', cattributes)),
                     '>', 
                     ctext, 
                     '</code>');

]]></complex-attribute>
                        <category _I_D="85c845e4-2958-481e-bbc8-e300308c179a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5720c8cf-4c72-4e02-98f3-0271fc002545" name="htf$comment" is-trigger-function="0" unique-function-name="htf$comment" is-aggregate="f" language-name="sql" context="htf$comment" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22549" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text" overload-function-count="1" proc-language="sql" function-signature="htf$comment(ctext text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('',
                     '<!-- ',
                     ctext,
                     ' --');

]]></complex-attribute>
                        <category _I_D="c1c38312-5e43-40d1-b4aa-0446a40b040d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="52a0b906-a582-4631-a2f7-0fb6589792b3" name="htf$dfn" is-trigger-function="0" unique-function-name="htf$dfn" is-aggregate="f" language-name="sql" context="htf$dfn" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22550" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$dfn(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('',
                     '<dfn',
                     aws_oracle_ext.htf$IFNOTNULL(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</dfn>');

]]></complex-attribute>
                        <category _I_D="3fef530d-3838-4994-93b5-9ff700d272d6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f7c96726-9842-4712-bed9-8f43a77be429" name="htf$dirlistclose" is-trigger-function="0" unique-function-name="htf$dirlistclose" is-aggregate="f" language-name="sql" context="htf$dirlistclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22551" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$dirlistclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</dir>';

]]></complex-attribute>
                        <category _I_D="5b4fbb33-93ec-44a3-8cf3-4f137eafbc59" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5cc565bd-cfe9-4e01-91ec-f8dc88f51358" name="htf$dirlistopen" is-trigger-function="0" unique-function-name="htf$dirlistopen" is-aggregate="f" language-name="sql" context="htf$dirlistopen" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22552" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$dirlistopen()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '<dir>';

]]></complex-attribute>
                        <category _I_D="b1a96c62-0cd9-4d1f-aeaf-122f040eea99" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bc825ece-938b-46fd-b9e1-6abb06baa900" name="htf$div" is-trigger-function="0" unique-function-name="htf$div" is-aggregate="f" language-name="sql" context="htf$div" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="calign text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22553" volatility="IMMUTABLE" is-window="f" function-identity-arguments="calign text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$div(calign text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('',
                     '<div',
                  aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="', calign, '"')),
                  aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                  '>');

]]></complex-attribute>
                        <category _I_D="01fbeee4-d0f5-4a79-8a88-1a887cd7f367" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="fbecd52b-866c-4aae-9cba-483cfbaa7248" name="htf$dlistclose" is-trigger-function="0" unique-function-name="htf$dlistclose" is-aggregate="f" language-name="sql" context="htf$dlistclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22554" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$dlistclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</dl>';

]]></complex-attribute>
                        <category _I_D="b252139f-cf0a-4afc-8857-1d019d9c0f53" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="101e3070-e5b9-4379-ab7a-03f5ef7162c3" name="htf$dlistdef" is-trigger-function="0" unique-function-name="htf$dlistdef" is-aggregate="f" language-name="sql" context="htf$dlistdef" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22555" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cclear text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$dlistdef(ctext text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('', '<dd',
                  aws_oracle_ext.htf$ifnotnull(cclear, concat_ws('', ' clear="'||cclear||'"')),
                  aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                  '>',ctext);

]]></complex-attribute>
                        <category _I_D="6d845717-aa87-4aa2-a2c9-31df39915070" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="924f919f-93bd-47ac-8e12-4231957042a2" name="htf$dlistopen" is-trigger-function="0" unique-function-name="htf$dlistopen" is-aggregate="f" language-name="sql" context="htf$dlistopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22556" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cclear text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$dlistopen(cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('',
                     '<dl',
                     aws_oracle_ext.htf$ifnotnull(cclear, concat_ws('', ' clear="', cclear,'"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('',' ', cattributes)),
                     '>');

]]></complex-attribute>
                        <category _I_D="03fa02c5-1b23-4318-93c0-470ba10505c8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b87e1e66-9432-4d34-9226-83eaa811b6fd" name="htf$dlistterm" is-trigger-function="0" unique-function-name="htf$dlistterm" is-aggregate="f" language-name="sql" context="htf$dlistterm" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22557" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cclear text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$dlistterm(ctext text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('',
                     '<dt',
                     aws_oracle_ext.htf$IFNOTNULL(cclear, concat_ws('', ' clear="', cclear, '"')),
                     aws_oracle_ext.htf$IFNOTNULL(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext);

]]></complex-attribute>
                        <category _I_D="381ab6ad-a663-4106-ab71-6c5b86b8eec7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4ee860e4-2193-43a6-a389-e8fa6611516b" name="htf$em" is-trigger-function="0" unique-function-name="htf$em" is-aggregate="f" language-name="sql" context="htf$em" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22558" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$em(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('',
                     '<em',
                     aws_oracle_ext.htf$ifnotnull(cattributes,concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</em>');

]]></complex-attribute>
                        <category _I_D="dca03b48-6fe3-4d7e-867c-9babd8e15ebf" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="520f8cf0-f882-45cb-bd6f-50c744eadc65" name="htf$emphasis" is-trigger-function="0" unique-function-name="htf$emphasis" is-aggregate="f" language-name="sql" context="htf$emphasis" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22559" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$emphasis(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT aws_oracle_ext.htf$em(ctext,cattributes);

]]></complex-attribute>
                        <category _I_D="8e91bb69-55b5-451e-a865-496147192946" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f54220bb-91ec-428e-84a8-3c4a2843104e" name="htf$escape_sc" is-trigger-function="0" unique-function-name="htf$escape_sc" is-aggregate="f" language-name="sql" context="htf$escape_sc" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22560" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text" overload-function-count="1" proc-language="sql" function-signature="htf$escape_sc(ctext text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT replace(
             replace(
             replace(
             replace(ctext, '&', concat_ws('', '&', 'amp;')),
                            '"', concat_ws('', '&', 'quot;')),
                            '<', concat_ws('', '&', 'lt;')),
                            '>', concat_ws('', '&', 'gt;'));

]]></complex-attribute>
                        <category _I_D="2e3d4de3-2a69-48c0-b66c-c0f5b3b94f88" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d314d20e-4fce-4753-926e-6d3cd0969697" name="htf$escape_url" is-trigger-function="0" unique-function-name="htf$escape_url" is-aggregate="f" language-name="sql" context="htf$escape_url" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="text" function-arguments="p_url text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22561" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_url text" overload-function-count="1" proc-language="sql" function-signature="htf$escape_url(p_url text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT replace(aws_oracle_ext.htf$escape_sc(p_url), '%', '%25');

]]></complex-attribute>
                        <category _I_D="5f022264-c940-4534-a41c-28ad18da3bae" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="81f1e177-a147-474a-bf17-6b3ead931d7f" name="htf$fontclose" is-trigger-function="0" unique-function-name="htf$fontclose" is-aggregate="f" language-name="sql" context="htf$fontclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22562" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$fontclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</font>';

]]></complex-attribute>
                        <category _I_D="317c24a2-f803-49b4-a404-fac24743bbaf" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="22225c11-2a24-4124-8d2d-6b3c2f976bdf" name="htf$fontopen" is-trigger-function="0" unique-function-name="htf$fontopen" is-aggregate="f" language-name="sql" context="htf$fontopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="ccolor text DEFAULT NULL::text, cface text DEFAULT NULL::text, csize text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22563" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ccolor text, cface text, csize text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$fontopen(ccolor text, cface text, csize text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('',
                     '<font',
                     aws_oracle_ext.htf$ifnotnull(ccolor, concat_ws('', ' color="', ccolor, '"')),
                     aws_oracle_ext.htf$ifnotnull(cface, concat_ws('', ' face="', cface, '"')),
                     aws_oracle_ext.htf$ifnotnull(csize, concat_ws('', ' size="', csize, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>');

]]></complex-attribute>
                        <category _I_D="65dc4bdd-0952-4ccc-ba9e-63414cc98176" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c193b2df-59b3-4f7f-92b9-8c4b2026f09b" name="htf$format_cell" is-trigger-function="0" unique-function-name="htf$format_cell" is-aggregate="f" language-name="plpgsql" context="htf$format_cell" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="columnvalue text, format_numbers text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22564" volatility="VOLATILE" is-window="f" function-identity-arguments="columnvalue text, format_numbers text" overload-function-count="1" proc-language="plpgsql" function-signature="htf$format_cell(columnvalue text, format_numbers text)">
                        <complex-attribute name="sql"><![CDATA[
begin

   if format_numers is null then
      return aws_oracle_ext.htf$tableData(columnValue);
   end if;

   return aws_oracle_ext.htf$tableData(coalesce(ltrim(aws_oracle_ext.to_char(aws_oracle_ext.to_number(columnValue),
                                                                    format_numbers)),
                                                '(null)'),
                                       'right');
end;
]]></complex-attribute>
                        <category _I_D="7632c6c8-32fb-4efe-8229-99a3d95f8609" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2bd48274-69c2-402e-979e-0a809d53c491" name="htf$formcheckbox" is-trigger-function="0" unique-function-name="htf$formcheckbox" is-aggregate="f" language-name="sql" context="htf$formcheckbox" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text, cvalue text DEFAULT 'on'::text, cchecked text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22565" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, cvalue text, cchecked text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formcheckbox(cname text, cvalue text, cchecked text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<input type="checkbox" name="',
                     cname,
                     '"',
                     aws_oracle_ext.htf$ifnotnull(cvalue, concat_ws('', ' value="', cvalue, '"')),
                     aws_oracle_ext.htf$ifnotnull(cchecked, ' checked="checked"'),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     ' />');

]]></complex-attribute>
                        <category _I_D="9d6b0b8f-b977-4764-8db6-a144a473d707" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5f55dffc-754c-46ef-92af-f1066298f363" name="htf$formclose" is-trigger-function="0" unique-function-name="htf$formclose" is-aggregate="f" language-name="sql" context="htf$formclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22566" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$formclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</form>';

]]></complex-attribute>
                        <category _I_D="8d632c5e-b7be-4893-91d1-2259cb707978" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="571a99f7-db3d-4a95-8a38-f29e1f315190" name="htf$formfile" is-trigger-function="0" unique-function-name="htf$formfile" is-aggregate="f" language-name="sql" context="htf$formfile" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text, caccept text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22567" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, caccept text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formfile(cname text, caccept text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<input type="file"',
                     aws_oracle_ext.htf$ifnotnull(cname, concat_ws('', ' name="', cname, '"')),
                     aws_oracle_ext.htf$ifnotnull(caccept, concat_ws('', ' accept="', caccept, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     ' />');

]]></complex-attribute>
                        <category _I_D="78f48286-8f86-4eb2-bec3-6b7a990dc864" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e4941855-198c-4773-932e-b8882ba93bc7" name="htf$formhidden" is-trigger-function="0" unique-function-name="htf$formhidden" is-aggregate="f" language-name="sql" context="htf$formhidden" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text, cvalue text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22568" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, cvalue text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formhidden(cname text, cvalue text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<input type="hidden" name="',
                     cname,
                     '"',
                     ' value="',
                     cvalue,
                     '"',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     ' />');

]]></complex-attribute>
                        <category _I_D="933f733b-b53a-4e48-853e-27d93ce7d68f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a5740b58-591e-495c-bbd3-3e3ccd615e8d" name="htf$formimage" is-trigger-function="0" unique-function-name="htf$formimage" is-aggregate="f" language-name="sql" context="htf$formimage" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text, csrc text, calign text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22569" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, csrc text, calign text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formimage(cname text, csrc text, calign text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<input type="image" name="',
                     cname,
                     '"',
                     ' src="',
                     csrc,
                     '"',
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="', calign, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     ' />');

]]></complex-attribute>
                        <category _I_D="29b0c6a9-0fb2-454f-8ba0-9a5fdfbce3d4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="84505eec-eb43-4265-ba69-31ce75040202" name="htf$formopen" is-trigger-function="0" unique-function-name="htf$formopen" is-aggregate="f" language-name="sql" context="htf$formopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="curl text, cmethod text DEFAULT 'POST'::text, ctarget text DEFAULT NULL::text, cenctype text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22570" volatility="IMMUTABLE" is-window="f" function-identity-arguments="curl text, cmethod text, ctarget text, cenctype text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formopen(curl text, cmethod text, ctarget text, cenctype text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT CONCAT_WS('',
        '<FORM ACTION="',
        curl,
        '" METHOD="',
        cmethod,
        '"',
        CASE
            WHEN ctarget IS NOT NULL THEN
                CONCAT_WS('', ' TARGET="', ctarget, '"')
            ELSE
                ''
        END,
        CASE
            WHEN cenctype IS NOT NULL THEN
                CONCAT_WS('', ' ENCTYPE="', cenctype, '"')
            ELSE
                ''
        END,
        CASE
            WHEN cattributes IS NOT NULL THEN
                CONCAT_WS('', ' ', cattributes)
            ELSE
                ''
        END,
        '>'
    );

]]></complex-attribute>
                        <category _I_D="3ffec6a2-4dc1-4f13-afac-430a8d77f103" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="165f1184-ded9-4b7c-bb6c-6a51058c99bb" name="htf$formpassword" is-trigger-function="0" unique-function-name="htf$formpassword" is-aggregate="f" language-name="sql" context="htf$formpassword" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text, csize text, cmaxlength text DEFAULT NULL::text, cvalue text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22571" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, csize text, cmaxlength text, cvalue text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formpassword(cname text, csize text, cmaxlength text, cvalue text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('', 
        '<INPUT TYPE="password" NAME="',
        cname,
        '" SIZE="',
        csize,
        CASE
            WHEN cmaxlength IS NOT NULL THEN
                CONCAT_WS('', '" MAXLENGTH="', cmaxlength, '"')
            ELSE
                ''
        END,
        CASE
            WHEN cvalue IS NOT NULL THEN
                CONCAT_WS('', ' VALUE="', cvalue, '"')
            ELSE
                ''
        END,
        CASE
            WHEN cattributes IS NOT NULL THEN
                CONCAT_WS('', ' ', cattributes)
            ELSE
                ''
        END,
        '>'
    );

]]></complex-attribute>
                        <category _I_D="77ed18ff-a8ed-4b4b-b3c8-9793976e1958" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0d3e8856-5006-452d-9199-b6b866e73cf3" name="htf$formradio" is-trigger-function="0" unique-function-name="htf$formradio" is-aggregate="f" language-name="sql" context="htf$formradio" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text, cvalue text, cchecked text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22572" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, cvalue text, cchecked text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formradio(cname text, cvalue text, cchecked text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<input type="radio" name="',
                      cname,
                     'value="',
                     cvalue,
                     aws_oracle_ext.htf$ifnotnull(cchecked,' checked="checked"'),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     ' />');

]]></complex-attribute>
                        <category _I_D="a312dd80-a5c1-49c1-ab64-66a0fe05c8c4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="608b8ed1-a19a-424c-97e8-6fc42e0d42b3" name="htf$formreset" is-trigger-function="0" unique-function-name="htf$formreset" is-aggregate="f" language-name="sql" context="htf$formreset" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="cvalue text DEFAULT 'Reset'::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22573" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cvalue text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formreset(cvalue text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('', 
                     '<input type="reset" value="',
                     cvalue,
                     '"',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     ' />');

]]></complex-attribute>
                        <category _I_D="055f9df0-5f7e-46ba-8928-d999d3370ca8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6988071a-67dc-48da-b75f-427471143563" name="htf$formselectclose" is-trigger-function="0" unique-function-name="htf$formselectclose" is-aggregate="f" language-name="sql" context="htf$formselectclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22574" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$formselectclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</select>';

]]></complex-attribute>
                        <category _I_D="6248eac3-2fb2-4841-981a-8bfeb8fa89f8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="408ba7fa-282f-4404-abcc-839c963c498e" name="htf$formselectopen" is-trigger-function="0" unique-function-name="htf$formselectopen" is-aggregate="f" language-name="sql" context="htf$formselectopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,numeric,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text, cprompt text DEFAULT NULL::text, nsize numeric DEFAULT NULL::numeric, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22575" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, cprompt text, nsize numeric, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formselectopen(cname text, cprompt text, nsize numeric, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     cprompt,
                     '<select name="',
                     cname,
                     aws_oracle_ext.htf$ifnotnull(aws_oracle_ext.to_char(nsize), concat_ws('', ' size="', nsize, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     ' />');

]]></complex-attribute>
                        <category _I_D="e58fcc48-7439-4b06-aaf2-481b8d0cae43" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="edfe277d-579a-4e16-bfaa-d59a2572dcaa" name="htf$formselectoption" is-trigger-function="0" unique-function-name="htf$formselectoption" is-aggregate="f" language-name="sql" context="htf$formselectoption" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cvalue text, cselected text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22576" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cvalue text, cselected text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formselectoption(cvalue text, cselected text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<option',
                     aws_oracle_ext.htf$ifnotnull(cselected, concat_ws('', ' selected="selected"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '</option>');

]]></complex-attribute>
                        <category _I_D="dba22616-f49d-412f-93f3-00fd9bf958f8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2f322960-e51d-4c82-9d23-789423ce464b" name="htf$formsubmit" is-trigger-function="0" unique-function-name="htf$formsubmit" is-aggregate="f" language-name="sql" context="htf$formsubmit" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text DEFAULT NULL::text, cvalue text DEFAULT 'Submit'::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22577" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, cvalue text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formsubmit(cname text, cvalue text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<input type="submit"',
                      aws_oracle_ext.htf$ifnotnull(cname, concat_ws('', ' name="', cname, '"')),
                      aws_oracle_ext.htf$ifnotnull(cvalue, concat_ws('', ' value="', cvalue, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     ' />');

]]></complex-attribute>
                        <category _I_D="20df093f-a89e-461f-a503-d081c85b845d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="aad0721b-2dac-4cd2-ac17-331db1360c7f" name="htf$formtext" is-trigger-function="0" unique-function-name="htf$formtext" is-aggregate="f" language-name="sql" context="htf$formtext" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text, csize text DEFAULT NULL::text, cmaxlength text DEFAULT NULL::text, cvalue text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22583" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, csize text, cmaxlength text, cvalue text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formtext(cname text, csize text, cmaxlength text, cvalue text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<input type="text" name="',
                     cname,
                     '"',
                     aws_oracle_ext.htf$ifnotnull(csize, concat_ws('', ' size="', csize, '"')),
                     aws_oracle_ext.htf$ifnotnull(cmaxlength, concat_ws('', ' maxlength="', cmaxlength, '"')),
                     aws_oracle_ext.htf$ifnotnull(cvalue, concat_ws('', ' value="', cvalue, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '/>');

]]></complex-attribute>
                        <category _I_D="656f814d-d2c3-4896-b92f-84ccf9788c2d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bc54af02-310b-4a66-be1a-d08188d222af" name="htf$formtextarea" is-trigger-function="0" unique-function-name="htf$formtextarea" is-aggregate="f" language-name="sql" context="htf$formtextarea" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,numeric,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text, nrows numeric, ncolumns numeric, calign text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22582" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, nrows numeric, ncolumns numeric, calign text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formtextarea(cname text, nrows numeric, ncolumns numeric, calign text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<textarea name="',
                     cname,
                     '"',
                     ' rows="',
                     aws_oracle_ext.to_char(nrows),
                     '"',
                     ' cols="',
                     aws_oracle_ext.to_char(ncolumns),
                     '"',
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="', calign, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '></textarea>');

]]></complex-attribute>
                        <category _I_D="6f956cf0-0d0e-4d8d-8360-3d6e90a36a2c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6e1b6588-7dad-4232-9e14-307b82777e37" name="htf$formtextarea2" is-trigger-function="0" unique-function-name="htf$formtextarea2" is-aggregate="f" language-name="sql" context="htf$formtextarea2" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,numeric,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text, nrows numeric, ncolumns numeric, calign text DEFAULT NULL::text, cwrap text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22578" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, nrows numeric, ncolumns numeric, calign text, cwrap text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formtextarea2(cname text, nrows numeric, ncolumns numeric, calign text, cwrap text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<textarea name="',
                     cname,
                     '"',
                     ' rows="',
                     aws_oracle_ext.to_char(nrows),
                     '"',
                     ' cols="',
                     aws_oracle_ext.to_char(ncolumns),
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="', calign, '"')),
                     aws_oracle_ext.htf$ifnotnull(cwrap, concat_ws('', ' wrap="', cwrap, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '></textarea>');

]]></complex-attribute>
                        <category _I_D="2fe33b72-8e6d-4b7d-af97-ef152557f020" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="90381900-839e-4a1f-9bd0-a731f7877708" name="htf$formtextareaclose" is-trigger-function="0" unique-function-name="htf$formtextareaclose" is-aggregate="f" language-name="sql" context="htf$formtextareaclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22579" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$formtextareaclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</textarea>';

]]></complex-attribute>
                        <category _I_D="65af68c9-619c-46e5-818c-fb6bb431ae5d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a0944d00-20b9-4062-8afe-6cd76ca5dfc2" name="htf$formtextareaopen" is-trigger-function="0" unique-function-name="htf$formtextareaopen" is-aggregate="f" language-name="sql" context="htf$formtextareaopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,numeric,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text, nrows numeric, ncolumns numeric, calign text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22581" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, nrows numeric, ncolumns numeric, calign text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formtextareaopen(cname text, nrows numeric, ncolumns numeric, calign text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<textarea name="',
                     cname,
                     '"',
                     ' rows="',
                     aws_oracle_ext.to_char(nrows),
                     '"',
                     ' cols="',
                     aws_oracle_ext.to_char(ncolumns),
                     '"',
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="', calign, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>');

]]></complex-attribute>
                        <category _I_D="9cd1faea-34fc-4bc5-8c3d-0915ba1f15a1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2558b087-6d01-4228-a294-38edde8de985" name="htf$formtextareaopen2" is-trigger-function="0" unique-function-name="htf$formtextareaopen2" is-aggregate="f" language-name="sql" context="htf$formtextareaopen2" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,numeric,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text, nrows numeric, ncolumns numeric, calign text DEFAULT NULL::text, cwrap text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22580" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, nrows numeric, ncolumns numeric, calign text, cwrap text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$formtextareaopen2(cname text, nrows numeric, ncolumns numeric, calign text, cwrap text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<textarea name="',
                     cname,
                     '"',
                     ' rows="',
                     aws_oracle_ext.to_char(nrows),
                     '"',
                     ' cols="',
                     aws_oracle_ext.to_char(ncolumns),
                     '"',
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="', calign, '"')),
                     aws_oracle_ext.htf$ifnotnull(cwrap, concat_ws('', ' wrap="', cwrap, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>');

]]></complex-attribute>
                        <category _I_D="4a4a7913-f226-45c2-9634-b0eab6aa9261" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="609d7e24-0739-4015-8ba4-c69c4a0a7b13" name="htf$frame" is-trigger-function="0" unique-function-name="htf$frame" is-aggregate="f" language-name="sql" context="htf$frame" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="csrc text, cname text DEFAULT NULL::text, cmarginwidth text DEFAULT NULL::text, cmarginheight text DEFAULT NULL::text, cscrolling text DEFAULT NULL::text, cnoresize text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="7" function-id="22586" volatility="IMMUTABLE" is-window="f" function-identity-arguments="csrc text, cname text, cmarginwidth text, cmarginheight text, cscrolling text, cnoresize text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$frame(csrc text, cname text, cmarginwidth text, cmarginheight text, cscrolling text, cnoresize text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<frame src="',
                     csrc,
                     '"',
                     aws_oracle_ext.htf$ifnotnull(cname, concat_ws('', ' name="', cname, '"')),
                     aws_oracle_ext.htf$ifnotnull(cmarginwidth, concat_ws('', ' marginwidth="', cmarginwidth, '"')),
                     aws_oracle_ext.htf$ifnotnull(cmarginheight, concat_ws('', ' marginheight="', cmarginheight, '"')),
                     aws_oracle_ext.htf$ifnotnull(cscrolling, concat_ws('', ' scrolling="', cscrolling, '"')),
                     aws_oracle_ext.htf$ifnotnull(cnoresize, concat_ws('', ' noresize="noresize"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '/>');

]]></complex-attribute>
                        <category _I_D="c3e395ad-7511-42bc-a97d-0955b80448ce" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e51cbc45-3632-4924-b754-d8a996e202bc" name="htf$framesetclose" is-trigger-function="0" unique-function-name="htf$framesetclose" is-aggregate="f" language-name="sql" context="htf$framesetclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22584" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$framesetclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</frameset>';

]]></complex-attribute>
                        <category _I_D="a848ce1a-e94e-42a0-a9d9-6317f84c3f3d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5b60d37d-ff7e-4447-bbbc-779bc8e1b8f7" name="htf$framesetopen" is-trigger-function="0" unique-function-name="htf$framesetopen" is-aggregate="f" language-name="sql" context="htf$framesetopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="crows text DEFAULT NULL::text, ccols text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22585" volatility="IMMUTABLE" is-window="f" function-identity-arguments="crows text, ccols text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$framesetopen(crows text, ccols text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<frameset',
                     aws_oracle_ext.htf$ifnotnull(crows, concat_ws('', ' rows="', crows, '"')),
                     aws_oracle_ext.htf$ifnotnull(ccols, concat_ws('', ' cols="', ccols, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>');

]]></complex-attribute>
                        <category _I_D="6b896b21-fb4c-4a39-9e5c-a5b3dd269588" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d7ac57c1-3e17-47dd-a8ee-167a26b83973" name="htf$header" is-trigger-function="0" unique-function-name="htf$header" is-aggregate="f" language-name="sql" context="htf$header" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="nsize numeric, cheader text, calign text DEFAULT NULL::text, cnowrap text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22587" volatility="IMMUTABLE" is-window="f" function-identity-arguments="nsize numeric, cheader text, calign text, cnowrap text, cclear text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$header(nsize numeric, cheader text, calign text, cnowrap text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<',
                     'h',
                     aws_oracle_ext.to_char(least(abs(nsize),6)),
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="', calign, '"')),
                     aws_oracle_ext.htf$ifnotnull(cclear, concat_ws('', ' clear="', cclear, '"')),
                     aws_oracle_ext.htf$ifnotnull(cnowrap, concat_ws('', ' nowrap="nowrap"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     cheader,
                     '</',
                     'h',
                     aws_oracle_ext.to_char(least(abs(nsize),6)),
                     '>');

]]></complex-attribute>
                        <category _I_D="e214f472-6770-4154-a22b-425606a47107" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7c09aa49-7858-4178-b4b0-c8ca9f3b4787" name="htf$hr" is-trigger-function="0" unique-function-name="htf$hr" is-aggregate="f" language-name="sql" context="htf$hr" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cclear text DEFAULT NULL::text, csrc text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22588" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cclear text, csrc text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$hr(cclear text, csrc text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<hr',
                     aws_oracle_ext.htf$ifnotnull(cclear, concat_ws('', ' clear="', cclear, '"')),
                     aws_oracle_ext.htf$ifnotnull(csrc, concat_ws('', ' src="', csrc, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '/>');

]]></complex-attribute>
                        <category _I_D="8d96a28a-2fed-46c4-a289-acc5d183d518" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="50bbf372-c906-4e99-805e-fb3af7f1b4f7" name="htf$htitle" is-trigger-function="0" unique-function-name="htf$htitle" is-aggregate="f" language-name="sql" context="htf$htitle" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctitle text, nsize numeric DEFAULT 1, calign text DEFAULT NULL::text, cnowrap text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22590" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctitle text, nsize numeric, calign text, cnowrap text, cclear text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$htitle(ctitle text, nsize numeric, calign text, cnowrap text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     aws_oracle_ext.htf$title(ctitle),
                     aws_oracle_ext.htf$header(nsize,ctitle,calign,cnowrap,cclear,cattributes));

]]></complex-attribute>
                        <category _I_D="ed3d38ac-2cef-4c36-a09c-d30e25569aa5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="deb97753-8c71-4204-a47f-952c41262325" name="htf$ifnotnull" is-trigger-function="0" unique-function-name="htf$ifnotnull" is-aggregate="f" language-name="sql" context="htf$ifnotnull" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="str1 text, str2 text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22529" volatility="IMMUTABLE" is-window="f" function-identity-arguments="str1 text, str2 text" overload-function-count="1" proc-language="sql" function-signature="htf$ifnotnull(str1 text, str2 text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT case when str1 is null then null
		            else str2
		       end;
]]></complex-attribute>
                        <category _I_D="38740d49-07c3-4bae-ae14-0fc75697f0c1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f8977824-c123-49bc-8dbc-038e655ab1aa" name="htf$img" is-trigger-function="0" unique-function-name="htf$img" is-aggregate="f" language-name="sql" context="htf$img" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="curl text, calign text DEFAULT NULL::text, calt text DEFAULT NULL::text, cismap text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22592" volatility="IMMUTABLE" is-window="f" function-identity-arguments="curl text, calign text, calt text, cismap text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$img(curl text, calign text, calt text, cismap text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<img src="',
                     curl,
                     '"',
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="',calign,'"')),
                     aws_oracle_ext.htf$ifnotnull(calt, concat_ws('', ' alt="',calt,'"')),
                     aws_oracle_ext.htf$ifnotnull(cismap, concat_ws('', ' ismap="ismap"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ',cattributes)),
                     ' />');

]]></complex-attribute>
                        <category _I_D="69fe0d3e-dfa4-4d9e-8a3c-03eb3d515b01" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4619c225-6a51-4f9c-9459-f28afac0d87e" name="htf$img2" is-trigger-function="0" unique-function-name="htf$img2" is-aggregate="f" language-name="sql" context="htf$img2" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="curl text, calign text DEFAULT NULL::text, calt text DEFAULT NULL::text, cismap text DEFAULT NULL::text, cusemap text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22591" volatility="IMMUTABLE" is-window="f" function-identity-arguments="curl text, calign text, calt text, cismap text, cusemap text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$img2(curl text, calign text, calt text, cismap text, cusemap text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<img src="',
                     curl,
                     '"',
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="',calign,'"')),
                     aws_oracle_ext.htf$ifnotnull(calt, concat_ws('', ' alt="',calt,'"')),
                     aws_oracle_ext.htf$ifnotnull(cismap, concat_ws('', ' ismap="ismap"')),
                     aws_oracle_ext.htf$ifnotnull(cusemap, concat_ws('', ' usemap="',cusemap,'"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ',cattributes)),
                     ' />');
   
]]></complex-attribute>
                        <category _I_D="1e8bb3c2-d5cb-4253-bec0-2a60e7b63dc9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4157e9fd-8f05-47f2-b5f1-c9fe2696e1b4" name="htf$isindex" is-trigger-function="0" unique-function-name="htf$isindex" is-aggregate="f" language-name="sql" context="htf$isindex" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="cprompt text DEFAULT NULL::text, curl text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22593" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cprompt text, curl text" overload-function-count="1" proc-language="sql" function-signature="htf$isindex(cprompt text, curl text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<isindex',
                     aws_oracle_ext.htf$IFNOTNULL(cprompt, concat_ws('', ' prompt="',cprompt,'"')),
                     aws_oracle_ext.htf$IFNOTNULL(curl, concat_ws('', ' href="',curl,'"')),
                     '>');
]]></complex-attribute>
                        <category _I_D="9c7073fb-fd4e-47c0-a55d-0dc4f5622e97" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1d5655c0-a766-4206-8215-89cd6f7f67e8" name="htf$italic" is-trigger-function="0" unique-function-name="htf$italic" is-aggregate="f" language-name="sql" context="htf$italic" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22594" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$italic(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<i',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ',cattributes)),
                     '>',
                     ctext,
                     '</i>');

]]></complex-attribute>
                        <category _I_D="7a039933-32ba-477b-b10c-aa539c8ceb24" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3d8918ae-c000-4128-a859-dafca7e500e2" name="htf$kbd" is-trigger-function="0" unique-function-name="htf$kbd" is-aggregate="f" language-name="sql" context="htf$kbd" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22595" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$kbd(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<kbd',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ',cattributes)),
                     '>',
                     ctext,
                     '</kbd>');

]]></complex-attribute>
                        <category _I_D="659e26ad-27da-4f32-9fb5-704ef0d37ed8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6079c1bf-58b2-43f4-9c15-60b43304a72a" name="htf$keyboard" is-trigger-function="0" unique-function-name="htf$keyboard" is-aggregate="f" language-name="sql" context="htf$keyboard" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22596" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$keyboard(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT aws_oracle_ext.htf$kbd(ctext,cattributes);

]]></complex-attribute>
                        <category _I_D="2f712506-1dee-4061-a0d7-2bad6107a5a0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4d606390-faa5-4d2c-9f0c-d6513c42e7f3" name="htf$line" is-trigger-function="0" unique-function-name="htf$line" is-aggregate="f" language-name="sql" context="htf$line" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cclear text DEFAULT NULL::text, csrc text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22597" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cclear text, csrc text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$line(cclear text, csrc text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT aws_oracle_ext.htf$hr(cclear, csrc, cattributes);

]]></complex-attribute>
                        <category _I_D="eb531f47-6126-4dfe-af00-d45052e807d8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="da9c54dc-7d9a-418e-90d7-a75ebaa2b0d6" name="htf$linkrel" is-trigger-function="0" unique-function-name="htf$linkrel" is-aggregate="f" language-name="sql" context="htf$linkrel" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="crel text, curl text, ctitle text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22598" volatility="IMMUTABLE" is-window="f" function-identity-arguments="crel text, curl text, ctitle text" overload-function-count="1" proc-language="sql" function-signature="htf$linkrel(crel text, curl text, ctitle text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<link rel="',
                     crel,
                     '"',
                     ' href="',
                     curl,
                     '"',
                     aws_oracle_ext.htf$ifnotnull(ctitle, concat_ws('', ' title="',ctitle,'"')),
                     '>');

]]></complex-attribute>
                        <category _I_D="52f9f311-a934-4a93-92bf-831a11eff3e3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bbb0a39a-b8b6-4522-a7a6-586b127011e9" name="htf$linkrev" is-trigger-function="0" unique-function-name="htf$linkrev" is-aggregate="f" language-name="sql" context="htf$linkrev" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="crev text, curl text, ctitle text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22599" volatility="IMMUTABLE" is-window="f" function-identity-arguments="crev text, curl text, ctitle text" overload-function-count="1" proc-language="sql" function-signature="htf$linkrev(crev text, curl text, ctitle text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<link rev="',
                     crev,
                     '"',
                     ' href="',
                     curl,
                     '"',
                     aws_oracle_ext.htf$ifnotnull(ctitle, concat_ws('', ' title="',ctitle,'"')),
                     '>');

]]></complex-attribute>
                        <category _I_D="606b0157-d82b-41f6-99ac-53805c0215a8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="39f08efd-301b-49ca-be9d-563e5e2d9bf6" name="htf$listheader" is-trigger-function="0" unique-function-name="htf$listheader" is-aggregate="f" language-name="sql" context="htf$listheader" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22600" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$listheader(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<lh',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ',cattributes)),
                     '>',
                     ctext,
                     '</lh>');

]]></complex-attribute>
                        <category _I_D="d30bf4cf-1e0e-4f68-8e8f-30845338bfb0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="64184bd2-d1c8-48c0-8507-2ce6cab3adc2" name="htf$listingclose" is-trigger-function="0" unique-function-name="htf$listingclose" is-aggregate="f" language-name="sql" context="htf$listingclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22601" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$listingclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</listing>';

]]></complex-attribute>
                        <category _I_D="774a4a99-b132-44e1-bd2e-1cd2aa9c4a8e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e03ca8a1-bd0e-47e9-8348-888120c3d63b" name="htf$listingopen" is-trigger-function="0" unique-function-name="htf$listingopen" is-aggregate="f" language-name="sql" context="htf$listingopen" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22602" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$listingopen()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '<listing>';

]]></complex-attribute>
                        <category _I_D="4b96bfa8-e4c2-41c3-b507-120352700d35" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dbedac8a-5937-4f74-9b83-41832ba8f846" name="htf$listitem" is-trigger-function="0" unique-function-name="htf$listitem" is-aggregate="f" language-name="sql" context="htf$listitem" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cdingbat text DEFAULT NULL::text, csrc text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22603" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cclear text, cdingbat text, csrc text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$listitem(ctext text, cclear text, cdingbat text, csrc text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<li'||
                     aws_oracle_ext.htf$ifnotnull(cclear, concat_ws('', ' clear="',cclear,'"')),
                     aws_oracle_ext.htf$ifnotnull(cdingbat, concat_ws('', ' dingbat="',cdingbat,'"')),
                     aws_oracle_ext.htf$ifnotnull(csrc, concat_ws('', ' src="',csrc,'"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ',cattributes)),
                     '>',
                     ctext);

]]></complex-attribute>
                        <category _I_D="2e76df67-e956-46a2-abae-5b5308ba1355" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="64b19ee5-50c4-4460-9bce-b79c93dbbde9" name="htf$mailto" is-trigger-function="0" unique-function-name="htf$mailto" is-aggregate="f" language-name="sql" context="htf$mailto" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="caddress text, ctext text, cname text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22604" volatility="IMMUTABLE" is-window="f" function-identity-arguments="caddress text, ctext text, cname text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$mailto(caddress text, ctext text, cname text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT aws_oracle_ext.htf$anchor(concat_ws('', 'mailto:', caddress),
                                     ctext,
                                     cname,
                                     cattributes);

]]></complex-attribute>
                        <category _I_D="88389a87-8765-4e90-ad92-70535f981467" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="557bbfd6-91fb-40d3-9da1-2b3e4d175482" name="htf$mapclose" is-trigger-function="0" unique-function-name="htf$mapclose" is-aggregate="f" language-name="sql" context="htf$mapclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22605" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$mapclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</map>';

]]></complex-attribute>
                        <category _I_D="8d09ff3a-64f3-449c-9e12-0f77f4e81dbb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a84e2370-5948-4a1f-94ff-d8b8658239c3" name="htf$mapopen" is-trigger-function="0" unique-function-name="htf$mapopen" is-aggregate="f" language-name="sql" context="htf$mapopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22606" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$mapopen(cname text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('', 
                     '<map name="',
                     cname,
                     '"',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ',cattributes)),
                     '>');

]]></complex-attribute>
                        <category _I_D="f3cff702-c53c-4f85-a61f-4524c89c62be" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="34be0964-2bf3-4c7f-8757-06ec480dd4a1" name="htf$menulistclose" is-trigger-function="0" unique-function-name="htf$menulistclose" is-aggregate="f" language-name="sql" context="htf$menulistclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22607" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$menulistclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</menu>';

]]></complex-attribute>
                        <category _I_D="18d053f5-2bc0-4574-ab5b-c66c5f292e96" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c1671596-be30-4b71-81a7-eafd9f9a1e4a" name="htf$menulistopen" is-trigger-function="0" unique-function-name="htf$menulistopen" is-aggregate="f" language-name="sql" context="htf$menulistopen" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22608" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$menulistopen()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '<menu>';

]]></complex-attribute>
                        <category _I_D="cc80f1f4-8a09-4648-93d7-3c88d7b8363f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c8c33374-c70c-491b-bce2-be00cb397ee7" name="htf$meta" is-trigger-function="0" unique-function-name="htf$meta" is-aggregate="f" language-name="sql" context="htf$meta" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="chttp_equiv text, cname text, ccontent text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22609" volatility="IMMUTABLE" is-window="f" function-identity-arguments="chttp_equiv text, cname text, ccontent text" overload-function-count="1" proc-language="sql" function-signature="htf$meta(chttp_equiv text, cname text, ccontent text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('', 
                     '<meta http-equiv="',
                     chttp_equiv,
                     '" name="',
                     cname,
                     '" content="',
                     ccontent,
                     '">')

]]></complex-attribute>
                        <category _I_D="3c434fe0-1a6a-4a92-994b-356734e9a710" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="adf80fa6-6574-40d1-bac1-7c04df8cef6f" name="htf$nextid" is-trigger-function="0" unique-function-name="htf$nextid" is-aggregate="f" language-name="sql" context="htf$nextid" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="text" function-arguments="cidentifier text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22610" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cidentifier text" overload-function-count="1" proc-language="sql" function-signature="htf$nextid(cidentifier text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<nextid n="',
                     cidentifier,
                     '>');

]]></complex-attribute>
                        <category _I_D="e3a914f1-7f54-4016-aabc-5222c4daab98" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ee19e6e9-181a-4d9a-baf2-784a0644ec6d" name="htf$nl" is-trigger-function="0" unique-function-name="htf$nl" is-aggregate="f" language-name="sql" context="htf$nl" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22611" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cclear text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$nl(cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

  SELECT aws_oracle_ext.htf$br(cclear, cattributes);

]]></complex-attribute>
                        <category _I_D="691768cc-f8a0-41ad-b1fa-8eb4be8a169b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1d58069d-3507-46b4-8733-dca08c32fb46" name="htf$nobr" is-trigger-function="0" unique-function-name="htf$nobr" is-aggregate="f" language-name="sql" context="htf$nobr" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22612" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text" overload-function-count="1" proc-language="sql" function-signature="htf$nobr(ctext text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<nobr>',
                     ctext,
                     '</nobr>');

]]></complex-attribute>
                        <category _I_D="648be90f-9add-43c7-b4e1-4f07648f6cbb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8132b4c2-ae72-4c79-aa0d-8b2a3fe153ad" name="htf$noframesclose" is-trigger-function="0" unique-function-name="htf$noframesclose" is-aggregate="f" language-name="sql" context="htf$noframesclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22613" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$noframesclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</noframes>';

]]></complex-attribute>
                        <category _I_D="f6c8f4cc-ebb9-4ec9-a730-0733876e1887" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="99e01b74-3994-4b62-a373-17e4d08727ea" name="htf$noframesopen" is-trigger-function="0" unique-function-name="htf$noframesopen" is-aggregate="f" language-name="sql" context="htf$noframesopen" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22614" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$noframesopen()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '<noframes>';

]]></complex-attribute>
                        <category _I_D="649bf115-ca2a-4138-9bc3-8e3da2c1eb95" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5c5e796d-5b4a-4043-8562-e891b3443e21" name="htf$olistclose" is-trigger-function="0" unique-function-name="htf$olistclose" is-aggregate="f" language-name="sql" context="htf$olistclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22615" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$olistclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</ol>';

]]></complex-attribute>
                        <category _I_D="13666cb6-3a69-44d2-9b66-24bd283850d3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e376f04e-1271-4715-b987-3b10e68e484e" name="htf$olistopen" is-trigger-function="0" unique-function-name="htf$olistopen" is-aggregate="f" language-name="sql" context="htf$olistopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cclear text DEFAULT NULL::text, cwrap text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22616" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cclear text, cwrap text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$olistopen(cclear text, cwrap text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<ol',
                     aws_oracle_ext.htf$ifnotnull(cclear, concat_ws('', ' clear="', cclear, '"')),
                     aws_oracle_ext.htf$ifnotnull(cwrap, concat_ws('', ' wrap="', cwrap, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>');
                     
]]></complex-attribute>
                        <category _I_D="2270d268-fef3-420b-9a29-8878d5d9dc0c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f6bd33e3-dec1-4d5c-b4fe-9a550c0321c7" name="htf$para" is-trigger-function="0" unique-function-name="htf$para" is-aggregate="f" language-name="sql" context="htf$para" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22619" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$para()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '<p>';

]]></complex-attribute>
                        <category _I_D="fe906534-9b35-4273-9bff-9d993db69dee" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ed803150-90d0-4c1c-bc69-2f8d37fd6074" name="htf$paragraph" is-trigger-function="0" unique-function-name="htf$paragraph" is-aggregate="f" language-name="sql" context="htf$paragraph" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="calign text DEFAULT NULL::text, cnowrap text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22617" volatility="IMMUTABLE" is-window="f" function-identity-arguments="calign text, cnowrap text, cclear text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$paragraph(calign text, cnowrap text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<p',
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' calign="', calign, '"')),
                     aws_oracle_ext.htf$ifnotnull(cclear, concat_ws('', ' clear="', cclear, '"')),
                     aws_oracle_ext.htf$ifnotnull(cnowrap, concat_ws('', ' nowrap="', cnowrap, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>');

]]></complex-attribute>
                        <category _I_D="ae47320f-ecc2-4606-abfe-ecf4257de2d8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="112cd810-0e32-43e9-b529-3ad2f107d831" name="htf$param" is-trigger-function="0" unique-function-name="htf$param" is-aggregate="f" language-name="sql" context="htf$param" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="cname text, cvalue text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22618" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cname text, cvalue text" overload-function-count="1" proc-language="sql" function-signature="htf$param(cname text, cvalue text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('', 
                     '<param name=',
                     cname,
                     ' value= "',
                     cvalue,
                     '" >');

]]></complex-attribute>
                        <category _I_D="4fba7ae9-9144-4058-b398-83628633a6d1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e0677466-1b89-4fe6-aca0-ae8fb57d80fe" name="htf$plaintext" is-trigger-function="0" unique-function-name="htf$plaintext" is-aggregate="f" language-name="sql" context="htf$plaintext" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22620" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$plaintext(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<plaintext',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</plaintext>');

]]></complex-attribute>
                        <category _I_D="eb1a38f3-8640-4fda-923f-5eae0b1ab5d9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2b1172cb-2e94-40bc-9031-70b2a2497932" name="htf$preclose" is-trigger-function="0" unique-function-name="htf$preclose" is-aggregate="f" language-name="sql" context="htf$preclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22621" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$preclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</pre>';

]]></complex-attribute>
                        <category _I_D="04fe088d-3947-41a8-bb0b-7a2c66b1f8e6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5f1a19eb-f704-4144-9bc4-e241daee2c8c" name="htf$preopen" is-trigger-function="0" unique-function-name="htf$preopen" is-aggregate="f" language-name="sql" context="htf$preopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cclear text DEFAULT NULL::text, cwidth text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22622" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cclear text, cwidth text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$preopen(cclear text, cwidth text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('', 
                     '<pre',
                     aws_oracle_ext.htf$ifnotnull(cclear, concat_ws('', ' clear="', cclear, '"')),
                     aws_oracle_ext.htf$ifnotnull(cwidth, concat_ws('', ' width="', cwidth, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),  
                     '>');

]]></complex-attribute>
                        <category _I_D="1a1e78da-51be-46db-9f6d-a5ca9e961228" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3856dfd7-c0e0-4077-a259-ad419a0a4745" name="htf$s" is-trigger-function="0" unique-function-name="htf$s" is-aggregate="f" language-name="sql" context="htf$s" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22626" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$s(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<s',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</s>');

]]></complex-attribute>
                        <category _I_D="868792fa-585c-405a-99aa-4d560d20c0ac" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="35473a32-b278-46d5-aed4-10d47c3723fe" name="htf$sample" is-trigger-function="0" unique-function-name="htf$sample" is-aggregate="f" language-name="sql" context="htf$sample" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22623" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$sample(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<samp',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</samp>');

]]></complex-attribute>
                        <category _I_D="8816d7a4-843d-4a4b-96b6-e8ce9470e312" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="70c0b972-8852-4137-b315-54e96b53b5cd" name="htf$script" is-trigger-function="0" unique-function-name="htf$script" is-aggregate="f" language-name="sql" context="htf$script" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="cscript text, clanguage text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22624" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cscript text, clanguage text" overload-function-count="1" proc-language="sql" function-signature="htf$script(cscript text, clanguage text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<script'||
                     aws_oracle_ext.htf$ifnotnull(clanguage, concat_ws('', ' language="', clanguage, '"')),
                     '>',
                     cscript,
                     '</script>');

]]></complex-attribute>
                        <category _I_D="c770150a-eb5d-420d-ab7a-0419967ea72a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5aac4a7e-063d-46a3-b78e-092e90d48997" name="htf$small" is-trigger-function="0" unique-function-name="htf$small" is-aggregate="f" language-name="sql" context="htf$small" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22625" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$small(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('',
        '<SMALL',
        CASE
            WHEN cattributes IS NOT NULL THEN
                CONCAT_WS('', ' ', cattributes)
            ELSE
                ''
        END,
        '>',
        ctext,
        '</SMALL>'
    );

]]></complex-attribute>
                        <category _I_D="6acd1bec-8a0f-4aec-8760-8953bf7b9f75" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f66c3769-bddd-4b52-bf62-7aef5d4a086a" name="htf$strike" is-trigger-function="0" unique-function-name="htf$strike" is-aggregate="f" language-name="sql" context="htf$strike" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22627" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$strike(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<strike',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</strike>');

]]></complex-attribute>
                        <category _I_D="784c32a5-dbcf-44f3-b436-16aa1d8468a3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bcc8e8fd-712b-4c69-9943-d50317e13450" name="htf$strong" is-trigger-function="0" unique-function-name="htf$strong" is-aggregate="f" language-name="sql" context="htf$strong" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22628" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$strong(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<strong',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</strong>');

]]></complex-attribute>
                        <category _I_D="9e26c916-b0ba-4e3e-a812-3dd13ae83055" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c02281eb-514e-4d9e-8aca-7a39f4c78428" name="htf$style" is-trigger-function="0" unique-function-name="htf$style" is-aggregate="f" language-name="sql" context="htf$style" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="text" function-arguments="cstyle text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22629" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cstyle text" overload-function-count="1" proc-language="sql" function-signature="htf$style(cstyle text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<style>',
                     cstyle,
                     '</style>');

]]></complex-attribute>
                        <category _I_D="bf4ea544-0353-46b3-9368-c0bfcb7672ee" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="893eb2d9-57b2-4b02-809c-f0fe52aa6d84" name="htf$sub" is-trigger-function="0" unique-function-name="htf$sub" is-aggregate="f" language-name="sql" context="htf$sub" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, calign text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22630" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, calign text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$sub(ctext text, calign text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<sub',
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="', calign, '"')),  
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</sub>');

]]></complex-attribute>
                        <category _I_D="68bd577c-e63c-4709-a7b2-e6953565c397" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3333d776-c426-42bd-8c0e-d7111d09f30f" name="htf$sup" is-trigger-function="0" unique-function-name="htf$sup" is-aggregate="f" language-name="sql" context="htf$sup" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, calign text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22631" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, calign text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$sup(ctext text, calign text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<sup',
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="', calign, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</sup>');

]]></complex-attribute>
                        <category _I_D="baac73b7-a541-423d-98b0-f02ec7d26a7b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="abfb20b8-6dcc-4f30-883f-6b39e73fc973" name="htf$tablecaption" is-trigger-function="0" unique-function-name="htf$tablecaption" is-aggregate="f" language-name="sql" context="htf$tablecaption" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="ccaption text, calign text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22632" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ccaption text, calign text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$tablecaption(ccaption text, calign text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<caption',
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="', calign, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ccaption,
                     '</caption>');

]]></complex-attribute>
                        <category _I_D="76e37174-3d86-4524-9a60-65789c64ddb9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="681327d3-7f88-48bf-ba44-311a341b3dcb" name="htf$tableclose" is-trigger-function="0" unique-function-name="htf$tableclose" is-aggregate="f" language-name="sql" context="htf$tableclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22633" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$tableclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</table>';

]]></complex-attribute>
                        <category _I_D="c89dc5b8-b8dd-4cda-ad9d-48543160bc3b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a0532e33-6802-4cac-98d4-accfafb113f0" name="htf$tabledata" is-trigger-function="0" unique-function-name="htf$tabledata" is-aggregate="f" language-name="sql" context="htf$tabledata" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cvalue text DEFAULT NULL::text, calign text DEFAULT NULL::text, cdp text DEFAULT NULL::text, cnowrap text DEFAULT NULL::text, crowspan text DEFAULT NULL::text, ccolspan text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="7" function-id="22634" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cvalue text, calign text, cdp text, cnowrap text, crowspan text, ccolspan text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$tabledata(cvalue text, calign text, cdp text, cnowrap text, crowspan text, ccolspan text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<td',
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="', calign, '"')),
                     aws_oracle_ext.htf$ifnotnull(cdp, concat_ws('', ' dp="', cdp, '"')),
                     aws_oracle_ext.htf$ifnotnull(crowspan, concat_ws('', ' rowspan="', crowspan, '"')),
                     aws_oracle_ext.htf$ifnotnull(ccolspan, concat_ws('', ' colspan="', ccolspan, '"')),
                     aws_oracle_ext.htf$ifnotnull(cnowrap, concat_ws('', ' nowrap="nowrap"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     cvalue,
                     '</td>');

]]></complex-attribute>
                        <category _I_D="17e374d6-73e3-41e2-8bc0-d820022e4b74" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="56378a8f-0c35-447f-8a94-5da81c9e5628" name="htf$tableheader" is-trigger-function="0" unique-function-name="htf$tableheader" is-aggregate="f" language-name="sql" context="htf$tableheader" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cvalue text DEFAULT NULL::text, calign text DEFAULT NULL::text, cdp text DEFAULT NULL::text, cnowrap text DEFAULT NULL::text, crowspan text DEFAULT NULL::text, ccolspan text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="7" function-id="22635" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cvalue text, calign text, cdp text, cnowrap text, crowspan text, ccolspan text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$tableheader(cvalue text, calign text, cdp text, cnowrap text, crowspan text, ccolspan text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<th',
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="', calign, '"')),
                     aws_oracle_ext.htf$ifnotnull(cdp, concat_ws('', ' dp="', cdp, '"')),
                     aws_oracle_ext.htf$ifnotnull(crowspan, concat_ws('', ' rowspan="', crowspan, '"')),
                     aws_oracle_ext.htf$ifnotnull(ccolspan, concat_ws('', ' colspan="', ccolspan, '"')),
                     aws_oracle_ext.htf$ifnotnull(cnowrap, concat_ws('', ' nowrap="nowrap"')),               
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     cvalue,
                     '</th>');

]]></complex-attribute>
                        <category _I_D="99c029a7-d467-4a1e-8095-3db98ed450d9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a00a14aa-f6eb-46d7-807b-66420c3bfdd3" name="htf$tableopen" is-trigger-function="0" unique-function-name="htf$tableopen" is-aggregate="f" language-name="sql" context="htf$tableopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cborder text DEFAULT NULL::text, calign text DEFAULT NULL::text, cnowrap text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22636" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cborder text, calign text, cnowrap text, cclear text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$tableopen(cborder text, calign text, cnowrap text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<table ',
                     aws_oracle_ext.htf$ifnotnull(cborder, concat_ws('', ' ', cborder)), 
                     aws_oracle_ext.htf$ifnotnull(cnowrap, concat_ws('', ' nowrap="nowrap"')),
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="', calign, '"')),
                     aws_oracle_ext.htf$ifnotnull(cclear, concat_ws('', ' clearn="', cclear, '"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>');

]]></complex-attribute>
                        <category _I_D="d6d71184-78ae-4562-ac3e-15d22d8b744e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="399a9270-2166-4505-9925-386fc7bb3061" name="htf$tablerowclose" is-trigger-function="0" unique-function-name="htf$tablerowclose" is-aggregate="f" language-name="sql" context="htf$tablerowclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22637" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$tablerowclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</tr>';

]]></complex-attribute>
                        <category _I_D="b04fa5b1-1fdb-4266-99c0-a53dba6a2101" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="69bf3dc1-a08a-4b38-a921-beee9b2d7c3b" name="htf$tablerowopen" is-trigger-function="0" unique-function-name="htf$tablerowopen" is-aggregate="f" language-name="sql" context="htf$tablerowopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="calign text DEFAULT NULL::text, cvalign text DEFAULT NULL::text, cdp text DEFAULT NULL::text, cnowrap text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22638" volatility="IMMUTABLE" is-window="f" function-identity-arguments="calign text, cvalign text, cdp text, cnowrap text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$tablerowopen(calign text, cvalign text, cdp text, cnowrap text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<tr',
                     aws_oracle_ext.htf$ifnotnull(calign, concat_ws('', ' align="', calign, '"')),
                     aws_oracle_ext.htf$ifnotnull(cvalign, concat_ws('', ' valign="', cvalign, '"')),
                     aws_oracle_ext.htf$ifnotnull(cdp, concat_ws('', ' dp="', cdp, '"')),
                     aws_oracle_ext.htf$ifnotnull(cnowrap, concat_ws('', ' nowrap="nowrap"')),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>');
 
]]></complex-attribute>
                        <category _I_D="7dd9f687-d9f0-451a-8a7a-2aba06ebda97" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b64ef84f-28b4-448d-b9a2-3c7b44d6abda" name="htf$teletype" is-trigger-function="0" unique-function-name="htf$teletype" is-aggregate="f" language-name="sql" context="htf$teletype" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22639" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$teletype(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<tt',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</tt>');

]]></complex-attribute>
                        <category _I_D="37fd2674-bad6-452e-bff6-4c29005b9648" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2562aa60-5c66-4124-b993-f302d7d88094" name="htf$title" is-trigger-function="0" unique-function-name="htf$title" is-aggregate="f" language-name="sql" context="htf$title" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="text" function-arguments="ctitle text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22589" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctitle text" overload-function-count="1" proc-language="sql" function-signature="htf$title(ctitle text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT_WS('',
                     '<TITLE>',
                     ctitle,
                     '</TITLE>'
                    );

]]></complex-attribute>
                        <category _I_D="0759e1f4-3f13-4c14-a799-b1bff475aab3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c3ad62ab-5666-420e-9ede-e4cf750cda21" name="htf$ulistclose" is-trigger-function="0" unique-function-name="htf$ulistclose" is-aggregate="f" language-name="sql" context="htf$ulistclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22640" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$ulistclose()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '</ul>';

]]></complex-attribute>
                        <category _I_D="3967bd62-86b3-4ef5-bdb6-0132de8f259d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="55f877fb-6e2f-43d0-9975-1de7ee1d8d71" name="htf$ulistopen" is-trigger-function="0" unique-function-name="htf$ulistopen" is-aggregate="f" language-name="sql" context="htf$ulistopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="text" function-arguments="cclear text DEFAULT NULL::text, cwrap text DEFAULT NULL::text, cdingbat text DEFAULT NULL::text, csrc text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22641" volatility="IMMUTABLE" is-window="f" function-identity-arguments="cclear text, cwrap text, cdingbat text, csrc text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$ulistopen(cclear text, cwrap text, cdingbat text, csrc text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<ul',
                     aws_oracle_ext.htf$ifnotnull(cclear, concat_ws('', ' clear="', cclear, '"')),
                     aws_oracle_ext.htf$ifnotnull(cwrap, concat_ws('', ' wrap="', cwrap, '"')),
                     aws_oracle_ext.htf$ifnotnull(cdingbat, concat_ws('', ' dingbat="', cdingbat, '"')),
                     aws_oracle_ext.htf$ifnotnull(csrc, concat_ws('', ' csrc="', csrc)),
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>');

]]></complex-attribute>
                        <category _I_D="59f29f6a-4073-49c4-b753-0d9b69b9837c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ba7a33d9-afdc-41cb-8d44-02409797b5ae" name="htf$underline" is-trigger-function="0" unique-function-name="htf$underline" is-aggregate="f" language-name="sql" context="htf$underline" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22642" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$underline(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<u',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</u>');

]]></complex-attribute>
                        <category _I_D="85b9f2d4-65c8-4f86-ade8-ac7fe5b21ed9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7987cc84-0e8f-41e5-bfcf-d15a58a217ae" name="htf$variable" is-trigger-function="0" unique-function-name="htf$variable" is-aggregate="f" language-name="sql" context="htf$variable" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22643" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="sql" function-signature="htf$variable(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT concat_ws('',
                     '<var',
                     aws_oracle_ext.htf$ifnotnull(cattributes, concat_ws('', ' ', cattributes)),
                     '>',
                     ctext,
                     '</var>');

]]></complex-attribute>
                        <category _I_D="c6ebc260-698d-4ab0-afa4-d09d494eddf9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bf2520ec-12e8-44f6-9a46-40b44e9fcae6" name="htf$wbr" is-trigger-function="0" unique-function-name="htf$wbr" is-aggregate="f" language-name="sql" context="htf$wbr" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22644" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htf$wbr()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT '<wbr>';

]]></complex-attribute>
                        <category _I_D="3e2868ca-feac-4562-b542-e0ae29f161b4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2557e1de-04fe-441b-9d31-97107f6b0aa1" name="htp$address" is-trigger-function="0" unique-function-name="htp$address" is-aggregate="f" language-name="plpgsql" context="htp$address" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cvalue text, cnowrap text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22645" volatility="VOLATILE" is-window="f" function-identity-arguments="cvalue text, cnowrap text, cclear text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$address(cvalue text, cnowrap text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

  PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$address(cvalue, cnowrap, cclear, cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="b111c1b2-4fde-41d5-b696-cde82afdcf6a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9600d1d4-68c2-4902-89a0-4d73e725d60a" name="htp$anchor" is-trigger-function="0" unique-function-name="htp$anchor" is-aggregate="f" language-name="plpgsql" context="htp$anchor" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="curl text, ctext text, cname text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22647" volatility="VOLATILE" is-window="f" function-identity-arguments="curl text, ctext text, cname text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$anchor(curl text, ctext text, cname text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$anchor(curl,ctext,cname,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="5a36e7e5-67e6-4ad1-84dd-2411dd48ffcd" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1c99a3eb-5e42-4bf8-9f5c-9b4125d973bf" name="htp$anchor2" is-trigger-function="0" unique-function-name="htp$anchor2" is-aggregate="f" language-name="plpgsql" context="htp$anchor2" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="curl text, ctext text, cname text DEFAULT NULL::text, ctarget text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22646" volatility="VOLATILE" is-window="f" function-identity-arguments="curl text, ctext text, cname text, ctarget text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$anchor2(curl text, ctext text, cname text, ctarget text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$anchor2(curl,ctext,cname,ctarget,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="9add01f2-f0f6-4246-99c1-bb362155dac1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="48ef71e3-c6d0-4238-b1f6-0fbe565b440c" name="htp$appletclose" is-trigger-function="0" unique-function-name="htp$appletclose" is-aggregate="f" language-name="plpgsql" context="htp$appletclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22648" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$appletclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$appletClose());
    
END;
]]></complex-attribute>
                        <category _I_D="397e8a28-6a81-4b85-9046-382830a6890e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b331199a-3807-4ba4-95a5-0b89bd3b65d0" name="htp$appletopen" is-trigger-function="0" unique-function-name="htp$appletopen" is-aggregate="f" language-name="plpgsql" context="htp$appletopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,numeric,text" is-returning-set="f" ret-datatype="void" function-arguments="ccode text, cwidth numeric, cheight numeric, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22649" volatility="VOLATILE" is-window="f" function-identity-arguments="ccode text, cwidth numeric, cheight numeric, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$appletopen(ccode text, cwidth numeric, cheight numeric, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$appletOpen());
    
END;
]]></complex-attribute>
                        <category _I_D="24065dcc-c9e1-4e50-9c47-19904048b679" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0fea83ee-9b6a-40de-bbd5-dfd109ce4012" name="htp$area" is-trigger-function="0" unique-function-name="htp$area" is-aggregate="f" language-name="plpgsql" context="htp$area" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="ccoords text, cshape text DEFAULT NULL::text, chref text DEFAULT NULL::text, cnohref text DEFAULT NULL::text, ctarget text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22650" volatility="VOLATILE" is-window="f" function-identity-arguments="ccoords text, cshape text, chref text, cnohref text, ctarget text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$area(ccoords text, cshape text, chref text, cnohref text, ctarget text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$area(ccoords,cshape,chref,cnohref,ctarget,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="6636935a-6160-4321-9d4d-aba2ff141c84" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="11d7825a-290d-4adc-972e-c1b437471864" name="htp$base" is-trigger-function="0" unique-function-name="htp$base" is-aggregate="f" language-name="plpgsql" context="htp$base" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctarget text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22652" volatility="VOLATILE" is-window="f" function-identity-arguments="ctarget text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$base(ctarget text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$base(ctarget,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="64d0fc54-108a-4fa9-9b31-8b663977dc65" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="01808ba0-6b7c-471f-9693-dd2c20a62020" name="htp$basefont" is-trigger-function="0" unique-function-name="htp$basefont" is-aggregate="f" language-name="plpgsql" context="htp$basefont" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" is-returning-set="f" ret-datatype="void" function-arguments="nsize numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22651" volatility="VOLATILE" is-window="f" function-identity-arguments="nsize numeric" overload-function-count="1" proc-language="plpgsql" function-signature="htp$basefont(nsize numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$basefont(nsize));
    
END;
]]></complex-attribute>
                        <category _I_D="33c5fe24-9382-43fd-8968-b45791d1085d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="eacf0374-ee39-4831-a818-b4015987f9c0" name="htp$bgsound" is-trigger-function="0" unique-function-name="htp$bgsound" is-aggregate="f" language-name="plpgsql" context="htp$bgsound" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="csrc text, cloop text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22653" volatility="VOLATILE" is-window="f" function-identity-arguments="csrc text, cloop text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$bgsound(csrc text, cloop text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$bgsound(csrc,cloop,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="66ba8bbd-ae85-4e2f-888e-91f2474f6e3e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8a50d4ad-ba6a-415f-b680-81e11bf069a5" name="htp$big" is-trigger-function="0" unique-function-name="htp$big" is-aggregate="f" language-name="plpgsql" context="htp$big" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22654" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$big(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$big(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="32c18511-0ed6-49f4-ac7f-67f9a2da7703" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bbc63104-599e-42b9-837e-b9451aed729b" name="htp$blockquoteclose" is-trigger-function="0" unique-function-name="htp$blockquoteclose" is-aggregate="f" language-name="plpgsql" context="htp$blockquoteclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22655" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$blockquoteclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$blockquoteClose());
    
END;
]]></complex-attribute>
                        <category _I_D="8b4deeda-ed06-471b-9bd8-376b77524081" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="017c4e4a-a00c-480f-b201-54d39d56138c" name="htp$blockquoteopen" is-trigger-function="0" unique-function-name="htp$blockquoteopen" is-aggregate="f" language-name="plpgsql" context="htp$blockquoteopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cnowrap text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22656" volatility="VOLATILE" is-window="f" function-identity-arguments="cnowrap text, cclear text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$blockquoteopen(cnowrap text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$blockquoteOpen(cnowrap,cclear,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="21701216-a8ad-4f80-a482-bc3bdb10493c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6d98ff17-f97c-4d29-87ed-e5441783274f" name="htp$bodyclose" is-trigger-function="0" unique-function-name="htp$bodyclose" is-aggregate="f" language-name="plpgsql" context="htp$bodyclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22657" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$bodyclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$bodyClose());
    
END;
]]></complex-attribute>
                        <category _I_D="664c1dcd-69f1-44fa-8b35-785c3b4b317b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="10f0b5d9-05e0-4bdb-874e-90c236b62820" name="htp$bodyopen" is-trigger-function="0" unique-function-name="htp$bodyopen" is-aggregate="f" language-name="plpgsql" context="htp$bodyopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="cbackground text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22658" volatility="VOLATILE" is-window="f" function-identity-arguments="cbackground text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$bodyopen(cbackground text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$bodyOpen(cbackground,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="2dca9bd3-0099-4401-9e34-1f4c0b924c0c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f57ea99f-8ea5-43d8-821a-6d4a565a2b7a" name="htp$bold" is-trigger-function="0" unique-function-name="htp$bold" is-aggregate="f" language-name="plpgsql" context="htp$bold" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22659" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$bold(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$bold(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="58ed8ceb-033f-48ec-854f-7b00021753b0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f8f3df41-6b5e-4b00-b966-e05956927ecb" name="htp$br" is-trigger-function="0" unique-function-name="htp$br" is-aggregate="f" language-name="plpgsql" context="htp$br" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22660" volatility="VOLATILE" is-window="f" function-identity-arguments="cclear text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$br(cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$nl(cclear,cattributes);
    
END;
]]></complex-attribute>
                        <category _I_D="4798b4d4-4b80-4da1-a5f4-a544f2b94081" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d89368f5-9e10-4f6a-a408-1c5c22ceaef6" name="htp$center" is-trigger-function="0" unique-function-name="htp$center" is-aggregate="f" language-name="plpgsql" context="htp$center" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22663" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$center(ctext text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$center(ctext));
    
END;
]]></complex-attribute>
                        <category _I_D="ca44a49b-4a71-4641-8645-e1c54163ce16" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bbf7bb4a-0244-4537-b4fb-b3866d74c090" name="htp$centerclose" is-trigger-function="0" unique-function-name="htp$centerclose" is-aggregate="f" language-name="plpgsql" context="htp$centerclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22661" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$centerclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$centerClose());
    
END;
]]></complex-attribute>
                        <category _I_D="9eea3474-42fa-4f08-90b3-9e85ed72a34c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="74d0815d-bb78-4095-8e12-84bf80547af1" name="htp$centeropen" is-trigger-function="0" unique-function-name="htp$centeropen" is-aggregate="f" language-name="plpgsql" context="htp$centeropen" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22662" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$centeropen()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$centerOpen());
    
END;
]]></complex-attribute>
                        <category _I_D="6018ce1f-d0ae-4f93-a17a-32656569b1b5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="40dba5fe-a24d-4af4-ade5-6774a789c239" name="htp$cite" is-trigger-function="0" unique-function-name="htp$cite" is-aggregate="f" language-name="plpgsql" context="htp$cite" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22664" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$cite(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$cite(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="96269ee0-63d6-48ce-9cd3-46a509e6bbd1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c912d09c-19b5-49c8-b175-63cb693ae79b" name="htp$code" is-trigger-function="0" unique-function-name="htp$code" is-aggregate="f" language-name="plpgsql" context="htp$code" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22665" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$code(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$code(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="92758a51-63d9-4a94-aea2-7fd6a4299826" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="04f2ee49-ca4f-4d95-b1ad-eb8c851d6fb7" name="htp$comment" is-trigger-function="0" unique-function-name="htp$comment" is-aggregate="f" language-name="plpgsql" context="htp$comment" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22666" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$comment(ctext text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$comment(ctext));
    
END;
]]></complex-attribute>
                        <category _I_D="63d7c8f3-0ab7-4cd4-99c6-5b6a079f93b5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="029d3b6a-9dfb-44d4-a934-f88296d17a65" name="htp$dfn" is-trigger-function="0" unique-function-name="htp$dfn" is-aggregate="f" language-name="plpgsql" context="htp$dfn" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22667" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$dfn(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$dfn(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="3cea72ce-a26e-4efd-95c7-e459004631e4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6c05ca91-fce6-4970-81e5-3d6373b51f8d" name="htp$dirlistclose" is-trigger-function="0" unique-function-name="htp$dirlistclose" is-aggregate="f" language-name="plpgsql" context="htp$dirlistclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22668" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$dirlistclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$dirlistClose());
    
END;
]]></complex-attribute>
                        <category _I_D="9a6c20c7-78bd-4407-9407-9e0fdc83c110" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3bf4c716-709f-4a85-9f3a-a46bc7e4155e" name="htp$dirlistopen" is-trigger-function="0" unique-function-name="htp$dirlistopen" is-aggregate="f" language-name="plpgsql" context="htp$dirlistopen" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22669" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$dirlistopen()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.dirlistOpen());
    
END;
]]></complex-attribute>
                        <category _I_D="fb4a7b0b-8fd2-420e-86b9-83c010774655" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="145ef43d-1915-4362-8b2f-e1a6a1f6f770" name="htp$div" is-trigger-function="0" unique-function-name="htp$div" is-aggregate="f" language-name="plpgsql" context="htp$div" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="calign text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22670" volatility="VOLATILE" is-window="f" function-identity-arguments="calign text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$div(calign text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.div(calign,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="c9d1f88f-9f7f-43dc-acca-9dded4e3ddb0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0dde6605-eb10-41ba-a7a4-5b60fed86ab5" name="htp$dlistclose" is-trigger-function="0" unique-function-name="htp$dlistclose" is-aggregate="f" language-name="plpgsql" context="htp$dlistclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22671" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$dlistclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.dlistClose());
    
END;
]]></complex-attribute>
                        <category _I_D="0cfc7074-9567-4000-85d2-b332b99c7a8e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6fa5a29e-44d3-4059-93af-9c2b63dcf051" name="htp$dlistdef" is-trigger-function="0" unique-function-name="htp$dlistdef" is-aggregate="f" language-name="plpgsql" context="htp$dlistdef" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22672" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cclear text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$dlistdef(ctext text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.dlistDef(ctext,cclear,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="acce1086-b1c7-42ee-ac6c-3a022f878704" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1d5bfc23-dd02-47f7-a39a-87862a3c2751" name="htp$dlistopen" is-trigger-function="0" unique-function-name="htp$dlistopen" is-aggregate="f" language-name="plpgsql" context="htp$dlistopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22673" volatility="VOLATILE" is-window="f" function-identity-arguments="cclear text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$dlistopen(cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.dlistOpen(cclear,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="2cec16bf-ca8b-4787-af92-e70b9e631bba" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ce001aa9-0e2b-4099-9ae5-f0758196ae01" name="htp$dlistterm" is-trigger-function="0" unique-function-name="htp$dlistterm" is-aggregate="f" language-name="plpgsql" context="htp$dlistterm" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22674" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cclear text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$dlistterm(ctext text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.dlistTerm(ctext,cclear,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="b943852b-0947-42f5-b133-14277544159f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1d7d8f7d-6488-4b70-915d-bc9fa7112751" name="htp$em" is-trigger-function="0" unique-function-name="htp$em" is-aggregate="f" language-name="plpgsql" context="htp$em" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22676" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$em(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.em(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="97ff3402-3552-4b3b-b9dd-a916b3d7a565" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f1b203e7-ca58-4900-b67f-898d7b8119be" name="htp$emphasis" is-trigger-function="0" unique-function-name="htp$emphasis" is-aggregate="f" language-name="plpgsql" context="htp$emphasis" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22675" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$emphasis(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$emphasis(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="f238a153-40a5-4725-be82-f1e50f51a9d2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ee528d68-92df-411e-9eb7-54ac1c4f63fe" name="htp$escape_sc" is-trigger-function="0" unique-function-name="htp$escape_sc" is-aggregate="f" language-name="plpgsql" context="htp$escape_sc" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22763" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$escape_sc(ctext text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

  PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$escape_sc(ctext));
    
END;
]]></complex-attribute>
                        <category _I_D="bf29b7e5-b1ca-46d3-bc11-e292c1103fab" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e0b84ce9-36b8-4314-ad74-eb2fbb049ea5" name="htp$fontclose" is-trigger-function="0" unique-function-name="htp$fontclose" is-aggregate="f" language-name="plpgsql" context="htp$fontclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22677" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$fontclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$fontClose);
    
END;
]]></complex-attribute>
                        <category _I_D="a699871e-a8a8-433e-84ad-7c2819630cfc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="113d2fc8-66d1-4401-bb3c-c9775e04e46d" name="htp$fontopen" is-trigger-function="0" unique-function-name="htp$fontopen" is-aggregate="f" language-name="plpgsql" context="htp$fontopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="ccolor text DEFAULT NULL::text, cface text DEFAULT NULL::text, csize text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22678" volatility="VOLATILE" is-window="f" function-identity-arguments="ccolor text, cface text, csize text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$fontopen(ccolor text, cface text, csize text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$fontOpen(ccolor,cface,csize,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="3d0673f4-58f4-42b5-aec5-67ce1edab4c7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="746dde1a-55aa-4642-9a29-be665eef4524" name="htp$formcheckbox" is-trigger-function="0" unique-function-name="htp$formcheckbox" is-aggregate="f" language-name="plpgsql" context="htp$formcheckbox" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text, cvalue text DEFAULT 'on'::text, cchecked text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22679" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, cvalue text, cchecked text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formcheckbox(cname text, cvalue text, cchecked text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formCheckbox(cname,cvalue,cchecked,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="79c1dbd0-e27f-49ce-9f1e-00eeb82cc41c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4f219c9a-8acb-40aa-ab63-9e7d62e5c255" name="htp$formclose" is-trigger-function="0" unique-function-name="htp$formclose" is-aggregate="f" language-name="plpgsql" context="htp$formclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22680" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formClose());
    
END;
]]></complex-attribute>
                        <category _I_D="53b76e37-1c7e-415e-8795-abdf620c53b3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ac26779d-7a90-45c6-883a-20416c20a70d" name="htp$formfile" is-trigger-function="0" unique-function-name="htp$formfile" is-aggregate="f" language-name="plpgsql" context="htp$formfile" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text, caccept text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22681" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, caccept text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formfile(cname text, caccept text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formFile(cname,caccept,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="90b73b85-db7f-40e1-a1c7-ab54f0b0ff02" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="425be89d-05bb-4550-8bc4-83ec7daa4f50" name="htp$formhidden" is-trigger-function="0" unique-function-name="htp$formhidden" is-aggregate="f" language-name="plpgsql" context="htp$formhidden" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text, cvalue text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22682" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, cvalue text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formhidden(cname text, cvalue text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formHidden(cname,cvalue,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="d6cefdd3-94ce-436b-b445-02868ec03f6c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3aa924ea-567b-4809-ab40-95fb1edd31fd" name="htp$formimage" is-trigger-function="0" unique-function-name="htp$formimage" is-aggregate="f" language-name="plpgsql" context="htp$formimage" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text, csrc text, calign text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22683" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, csrc text, calign text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formimage(cname text, csrc text, calign text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formImage(cname,csrc,calign,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="c9a74f71-8f6c-498a-b116-bbdcb8cf77cd" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e8811c8c-6bf7-4abf-a7dd-0732d9cc0bdd" name="htp$formopen" is-trigger-function="0" unique-function-name="htp$formopen" is-aggregate="f" language-name="plpgsql" context="htp$formopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="curl text, cmethod text DEFAULT 'post'::text, ctarget text DEFAULT NULL::text, cenctype text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22684" volatility="VOLATILE" is-window="f" function-identity-arguments="curl text, cmethod text, ctarget text, cenctype text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formopen(curl text, cmethod text, ctarget text, cenctype text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formOpen(curl,cmethod,ctarget,cenctype,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="d08fd06e-eb3e-421e-ac6c-3583a6615b0b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="cc1ab410-dded-4ba9-9a45-6eb42e486206" name="htp$formpassword" is-trigger-function="0" unique-function-name="htp$formpassword" is-aggregate="f" language-name="plpgsql" context="htp$formpassword" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text, csize text DEFAULT NULL::text, cmaxlength text DEFAULT NULL::text, cvalue text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22685" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, csize text, cmaxlength text, cvalue text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formpassword(cname text, csize text, cmaxlength text, cvalue text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formPassword(cname,csize,cmaxlength,cvalue,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="9fed203c-d7fb-49cd-9f28-923561d4c204" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bbf802c7-ab76-41bd-9969-62e8288b042c" name="htp$formradio" is-trigger-function="0" unique-function-name="htp$formradio" is-aggregate="f" language-name="plpgsql" context="htp$formradio" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text, cvalue text, cchecked text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22686" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, cvalue text, cchecked text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formradio(cname text, cvalue text, cchecked text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formRadio(cname,cvalue,cchecked,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="c8daca7a-627f-4e89-98a5-7fa59d46330a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b8d7ca3c-dfa5-4b15-9c2f-52833d7510f1" name="htp$formreset" is-trigger-function="0" unique-function-name="htp$formreset" is-aggregate="f" language-name="plpgsql" context="htp$formreset" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="cvalue text DEFAULT 'Reset'::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22687" volatility="VOLATILE" is-window="f" function-identity-arguments="cvalue text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formreset(cvalue text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formReset(cvalue,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="879a9284-12f9-40fe-8b1c-04d291edb03d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="269a70fc-8c20-47ba-8c55-5238dc960c8d" name="htp$formselectclose" is-trigger-function="0" unique-function-name="htp$formselectclose" is-aggregate="f" language-name="plpgsql" context="htp$formselectclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22688" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formselectclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formSelectClose());
    
END;
]]></complex-attribute>
                        <category _I_D="458a4337-1806-4dbb-bd57-9c7124313d25" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="42cc60e3-2234-4b50-ad84-9a6d46e24ef9" name="htp$formselectopen" is-trigger-function="0" unique-function-name="htp$formselectopen" is-aggregate="f" language-name="plpgsql" context="htp$formselectopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,numeric,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text, cprompt text DEFAULT NULL::text, nsize numeric DEFAULT NULL::numeric, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22689" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, cprompt text, nsize numeric, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formselectopen(cname text, cprompt text, nsize numeric, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.formSelectOpen(cname,cprompt,nsize,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="703ae53b-6c30-4d62-a68e-01ab15ac97f5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5310f80b-cc28-475f-b487-f350bb514339" name="htp$formselectoption" is-trigger-function="0" unique-function-name="htp$formselectoption" is-aggregate="f" language-name="plpgsql" context="htp$formselectoption" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cvalue text, cselected text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22690" volatility="VOLATILE" is-window="f" function-identity-arguments="cvalue text, cselected text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formselectoption(cvalue text, cselected text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formSelectOption(cvalue,cselected,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="f67e247f-ae41-4d41-b9c7-aacc782b211d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e32615c6-5d0c-4127-ac3e-47ed55b92e68" name="htp$formsubmit" is-trigger-function="0" unique-function-name="htp$formsubmit" is-aggregate="f" language-name="plpgsql" context="htp$formsubmit" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text DEFAULT NULL::text, cvalue text DEFAULT 'Submit'::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22691" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, cvalue text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formsubmit(cname text, cvalue text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formSubmit(cname,cvalue,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="6bc9870a-255e-45f8-b310-f1d208f861c8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="fd38b271-d8fd-4f42-ae33-df99a3842c89" name="htp$formtext" is-trigger-function="0" unique-function-name="htp$formtext" is-aggregate="f" language-name="plpgsql" context="htp$formtext" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text, csize text DEFAULT NULL::text, cmaxlength text DEFAULT NULL::text, cvalue text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22697" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, csize text, cmaxlength text, cvalue text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formtext(cname text, csize text, cmaxlength text, cvalue text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formText(cname,csize,cmaxlength,cvalue,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="55b57b68-c91e-4e01-b396-716246a75816" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8bc350c7-699e-4485-8d49-5452039ce573" name="htp$formtextarea" is-trigger-function="0" unique-function-name="htp$formtextarea" is-aggregate="f" language-name="plpgsql" context="htp$formtextarea" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,numeric,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text, nrows numeric, ncolumns numeric, calign text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22696" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, nrows numeric, ncolumns numeric, calign text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formtextarea(cname text, nrows numeric, ncolumns numeric, calign text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formTextarea(cname,nrows,ncolumns,calign,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="431f5f25-1282-446a-ba7e-1e90f96a419e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3079c170-0c53-4ed7-9ea4-8e3c4876e513" name="htp$formtextarea2" is-trigger-function="0" unique-function-name="htp$formtextarea2" is-aggregate="f" language-name="plpgsql" context="htp$formtextarea2" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,numeric,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text, nrows numeric, ncolumns numeric, calign text DEFAULT NULL::text, cwrap text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22692" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, nrows numeric, ncolumns numeric, calign text, cwrap text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formtextarea2(cname text, nrows numeric, ncolumns numeric, calign text, cwrap text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formTextarea2(cname,nrows,ncolumns,calign,cwrap,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="7b7a8b4b-a7c4-4beb-a308-9e011d9be2a3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9ba3e2a9-856a-4824-ba6d-2d1f3b46e795" name="htp$formtextareaclose" is-trigger-function="0" unique-function-name="htp$formtextareaclose" is-aggregate="f" language-name="plpgsql" context="htp$formtextareaclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22693" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formtextareaclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formTextareaClose);
    
END;
]]></complex-attribute>
                        <category _I_D="0ad2a7ab-6a16-483d-8f23-666f576ea35b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="367bbf31-b2fc-4b09-83c4-41a7b9272106" name="htp$formtextareaopen" is-trigger-function="0" unique-function-name="htp$formtextareaopen" is-aggregate="f" language-name="plpgsql" context="htp$formtextareaopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,numeric,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text, nrows numeric, ncolumns numeric, calign text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22695" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, nrows numeric, ncolumns numeric, calign text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formtextareaopen(cname text, nrows numeric, ncolumns numeric, calign text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formTextareaOpen(cname,nrows,ncolumns,calign,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="922b5dd8-5772-475b-a41b-1bd40c8e0feb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8611c164-e66e-4887-a82c-c8539b59468a" name="htp$formtextareaopen2" is-trigger-function="0" unique-function-name="htp$formtextareaopen2" is-aggregate="f" language-name="plpgsql" context="htp$formtextareaopen2" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,numeric,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text, nrows numeric, ncolumns numeric, calign text DEFAULT NULL::text, cwrap text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22694" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, nrows numeric, ncolumns numeric, calign text, cwrap text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$formtextareaopen2(cname text, nrows numeric, ncolumns numeric, calign text, cwrap text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$formTextareaOpen2(cname,nrows,ncolumns,calign,cwrap,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="3e968e6b-841b-4ba0-b2a3-4ad61c44df6d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b5002637-1cbb-45f5-85a7-406faa6dbf69" name="htp$frame" is-trigger-function="0" unique-function-name="htp$frame" is-aggregate="f" language-name="plpgsql" context="htp$frame" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="csrc text, cname text DEFAULT NULL::text, cmarginwidth text DEFAULT NULL::text, cmarginheight text DEFAULT NULL::text, cscrolling text DEFAULT NULL::text, cnoresize text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="7" function-id="22700" volatility="VOLATILE" is-window="f" function-identity-arguments="csrc text, cname text, cmarginwidth text, cmarginheight text, cscrolling text, cnoresize text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$frame(csrc text, cname text, cmarginwidth text, cmarginheight text, cscrolling text, cnoresize text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$frame( csrc, cname, cmarginwidth, cmarginheight, cscrolling, cnoresize, cattributes ));
    
END;
]]></complex-attribute>
                        <category _I_D="8e1f56a9-b22f-4a1d-a91f-8f7430a4f2bf" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="95a9dbf0-2611-4aa8-9c84-2a38c4f0d7ce" name="htp$framesetclose" is-trigger-function="0" unique-function-name="htp$framesetclose" is-aggregate="f" language-name="plpgsql" context="htp$framesetclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22698" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$framesetclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$framesetClose);
    
END;
]]></complex-attribute>
                        <category _I_D="48947e57-58d0-49a7-8142-cba393fdfbda" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5e826055-b412-4650-b79b-cfe29eddad89" name="htp$framesetopen" is-trigger-function="0" unique-function-name="htp$framesetopen" is-aggregate="f" language-name="plpgsql" context="htp$framesetopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="crows text DEFAULT NULL::text, ccols text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22699" volatility="VOLATILE" is-window="f" function-identity-arguments="crows text, ccols text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$framesetopen(crows text, ccols text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$framesetOpen( crows, ccols, cattributes ));
    
END;
]]></complex-attribute>
                        <category _I_D="27b620d9-52b2-4a0c-8a9f-67faefc1998b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6a96a29d-e8f9-4a04-a721-ad761c84d82f" name="htp$get_page" is-trigger-function="0" unique-function-name="htp$get_page" is-aggregate="f" language-name="plpgsql" context="htp$get_page" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="t" ret-datatype="table" function-arguments="ppagepart text" schema-id="21999" function-type="RET_DATASET" count-arguments="1" function-id="22778" volatility="VOLATILE" is-window="f" function-identity-arguments="ppagepart text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$get_page(ppagepart text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vPagePart TEXT;
    vHeaderPosition BIGINT;
    rec RECORD;
    headerExists BOOLEAN DEFAULT FALSE;
BEGIN

    IF COALESCE(pPagePart, NULL) NOT IN ('headers', 'body') THEN

        vPagePart := 'body';

    ELSE

        vPagePart := pPagePart;

    END IF;

    FOR rec IN
    (
        SELECT id,
            column_value
        FROM aws_htbuf_arr
        ORDER BY id
    ) LOOP

        IF rec.column_value = E'\n\n' THEN

            vHeaderPosition := rec.id;
            headerExists := TRUE;
            EXIT;

        END IF;

        IF rec.column_value ~ '^\n$' THEN

            IF vHeaderPosition IS NOT NULL THEN

                vHeaderPosition := rec.id;
                headerExists := TRUE;
                EXIT;

            ELSE

                vHeaderPosition := rec.id;

            END IF;

        END IF;

        IF rec.column_value ~ '\n$' AND rec.column_value !~ '^\n$' THEN

            vHeaderPosition := rec.id;

        END IF;

        IF rec.column_value !~ '\n$' AND vHeaderPosition IS NOT NULL THEN

            vHeaderPosition := NULL;

        END IF;


    END LOOP;

    IF NOT headerExists THEN

        vHeaderPosition := NULL;

    END IF;

    IF vPagePart = 'headers' THEN

        RETURN QUERY
        SELECT aha.column_value
        FROM aws_htbuf_arr aha
        WHERE aha.id < vHeaderPosition
        ORDER BY id;

    ELSE

        RETURN QUERY
        SELECT aha.column_value
        FROM aws_htbuf_arr aha
        WHERE aha.id > COALESCE(vHeaderPosition, 0)
        ORDER BY id;

    END IF;

    RETURN;

END;    
]]></complex-attribute>
                        <category _I_D="5b34b44e-c93c-4f30-8c3f-2c5d73e8e8d1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5ba2cfae-d763-4320-b5f7-761d7fd0c5ba" name="htp$headclose" is-trigger-function="0" unique-function-name="htp$headclose" is-aggregate="f" language-name="plpgsql" context="htp$headclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22701" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$headclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$headClose());
    
END;
]]></complex-attribute>
                        <category _I_D="06e8b238-c5a8-4915-8f57-ab176cd59fd8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e5c1aacc-7b64-49b8-b772-5ff81cc2d6cc" name="htp$header" is-trigger-function="0" unique-function-name="htp$header" is-aggregate="f" language-name="plpgsql" context="htp$header" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="nsize numeric, cheader text, calign text DEFAULT NULL::text, cnowrap text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22702" volatility="VOLATILE" is-window="f" function-identity-arguments="nsize numeric, cheader text, calign text, cnowrap text, cclear text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$header(nsize numeric, cheader text, calign text, cnowrap text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$header(nsize,cheader,calign,cnowrap,cclear,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="c6d16781-725a-4b7d-a506-a8cd319bcefb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c1a15629-7286-4513-ab93-4912d56e7a39" name="htp$headopen" is-trigger-function="0" unique-function-name="htp$headopen" is-aggregate="f" language-name="plpgsql" context="htp$headopen" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22703" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$headopen()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$headOpen());
    
END;
]]></complex-attribute>
                        <category _I_D="73f05410-52c0-4db1-b803-e859ed606402" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1b0d3d2a-0d7a-4983-b5fe-8af3146c1094" name="htp$hr" is-trigger-function="0" unique-function-name="htp$hr" is-aggregate="f" language-name="plpgsql" context="htp$hr" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cclear text DEFAULT NULL::text, csrc text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22704" volatility="VOLATILE" is-window="f" function-identity-arguments="cclear text, csrc text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$hr(cclear text, csrc text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$hr(cclear, csrc, cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="315f3f13-5f9d-432a-af99-2518e6d75112" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f36fa796-b986-4e69-b212-1e869565421a" name="htp$htitle" is-trigger-function="0" unique-function-name="htp$htitle" is-aggregate="f" language-name="plpgsql" context="htp$htitle" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctitle text, nsize numeric DEFAULT 1, calign text DEFAULT NULL::text, cnowrap text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22705" volatility="VOLATILE" is-window="f" function-identity-arguments="ctitle text, nsize numeric, calign text, cnowrap text, cclear text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$htitle(ctitle text, nsize numeric, calign text, cnowrap text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$htitle(ctitle,nsize,calign,cnowrap,cclear,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="8eef6674-ea9a-43b6-9fcb-3d84fd928521" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="11d1fb34-dce8-4298-81e9-772ffdfd160c" name="htp$htmlclose" is-trigger-function="0" unique-function-name="htp$htmlclose" is-aggregate="f" language-name="plpgsql" context="htp$htmlclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22706" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$htmlclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$htmlClose());
    
END;
]]></complex-attribute>
                        <category _I_D="714fcdfa-eb30-4955-8843-8540e11c242e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="31022cbe-a4db-457c-8b2b-a1ce603e6959" name="htp$htmlopen" is-trigger-function="0" unique-function-name="htp$htmlopen" is-aggregate="f" language-name="plpgsql" context="htp$htmlopen" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22707" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$htmlopen()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$htmlOpen);
    
END;
]]></complex-attribute>
                        <category _I_D="431dd93d-cd47-484a-878a-947c7f7ff28c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9bd727c2-8d6b-41dd-8dc6-db273afcb0e2" name="htp$img" is-trigger-function="0" unique-function-name="htp$img" is-aggregate="f" language-name="plpgsql" context="htp$img" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="curl text, calign text DEFAULT NULL::text, calt text DEFAULT NULL::text, cismap text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22709" volatility="VOLATILE" is-window="f" function-identity-arguments="curl text, calign text, calt text, cismap text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$img(curl text, calign text, calt text, cismap text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$img(curl,calign,calt,cismap,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="cea32897-4b09-4070-8583-d5024e602648" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a8b419c3-6950-427d-98e3-b4c6c113bccf" name="htp$img2" is-trigger-function="0" unique-function-name="htp$img2" is-aggregate="f" language-name="plpgsql" context="htp$img2" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="curl text, calign text DEFAULT NULL::text, calt text DEFAULT NULL::text, cismap text DEFAULT NULL::text, cusemap text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22708" volatility="VOLATILE" is-window="f" function-identity-arguments="curl text, calign text, calt text, cismap text, cusemap text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$img2(curl text, calign text, calt text, cismap text, cusemap text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$img2(curl,calign,calt,cismap,cusemap,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="d7ae66e1-159c-4829-93c2-cfbec459aa5c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7eddd317-7b23-43ad-aa0a-1f30901462d8" name="htp$init" is-trigger-function="0" unique-function-name="htp$init" is-aggregate="f" language-name="sql" context="htp$init" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22520" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="htp$init()">
                        <complex-attribute name="sql"><![CDATA[

    CREATE TEMPORARY TABLE IF NOT EXISTS aws_cgi_env
    (
        id BIGINT NOT NULL GENERATED ALWAYS AS IDENTITY,
        cgi_var_name TEXT NULL,
        cgi_var_val TEXT NULL,
        CONSTRAINT ht_headers_pk PRIMARY KEY (id)
    );

    CREATE TEMPORARY TABLE IF NOT EXISTS aws_htbuf_arr
    (
        id BIGINT NOT NULL GENERATED ALWAYS AS IDENTITY,
        column_value TEXT NULL,
        CONSTRAINT htbuf_arr_pk PRIMARY KEY (id)
    );

    TRUNCATE TABLE aws_htbuf_arr;

    CREATE TEMPORARY TABLE IF NOT EXISTS aws_cgi_cookie
    (
        cookie_name TEXT NOT NULL,
        cookie_val_id BIGINT NOT null GENERATED ALWAYS AS IDENTITY,
        cookie_val TEXT NULL,
        CONSTRAINT aws_cgi_cookies_pk PRIMARY KEY (cookie_name)
    );

    TRUNCATE TABLE aws_cgi_cookie;

]]></complex-attribute>
                        <category _I_D="07f20a12-ca5d-4982-aa76-9e21b18a5959" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e6379269-2053-49fa-9f8d-6c6121c6686a" name="htp$isindex" is-trigger-function="0" unique-function-name="htp$isindex" is-aggregate="f" language-name="plpgsql" context="htp$isindex" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="cprompt text DEFAULT NULL::text, curl text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22710" volatility="VOLATILE" is-window="f" function-identity-arguments="cprompt text, curl text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$isindex(cprompt text, curl text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$isindex(cprompt, curl));
    
END;
]]></complex-attribute>
                        <category _I_D="754a64bc-4770-4ddb-acbd-f8277ad4b30d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="89e803ce-adf9-4e29-be12-06886c66ae8d" name="htp$italic" is-trigger-function="0" unique-function-name="htp$italic" is-aggregate="f" language-name="plpgsql" context="htp$italic" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22711" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$italic(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$italic(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="87615355-643a-4d3c-bc3c-be852d0b3714" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f49296ee-65ab-404e-8e34-bd7139fec561" name="htp$kbd" is-trigger-function="0" unique-function-name="htp$kbd" is-aggregate="f" language-name="plpgsql" context="htp$kbd" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22712" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$kbd(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$kbd(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="cb4a2c91-4464-41f2-80cc-ea9f24cdab8a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="79f7067e-b8ae-4abe-897f-27a868d7e411" name="htp$keyboard" is-trigger-function="0" unique-function-name="htp$keyboard" is-aggregate="f" language-name="plpgsql" context="htp$keyboard" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22713" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$keyboard(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$keyboard(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="2f8820b5-2644-4fd4-b4d5-f379386667c9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="006f8742-d0e8-4a15-9ea7-9014faeb0932" name="htp$line" is-trigger-function="0" unique-function-name="htp$line" is-aggregate="f" language-name="plpgsql" context="htp$line" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cclear text DEFAULT NULL::text, csrc text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22714" volatility="VOLATILE" is-window="f" function-identity-arguments="cclear text, csrc text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$line(cclear text, csrc text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$hr(cclear, csrc, cattributes);
    
END;
]]></complex-attribute>
                        <category _I_D="25f117dc-2322-4ff0-89a9-12d35e452fa9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5d747c58-07a2-4a05-8a2b-a3882f2d5be7" name="htp$linkrel" is-trigger-function="0" unique-function-name="htp$linkrel" is-aggregate="f" language-name="plpgsql" context="htp$linkrel" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="crel text, curl text, ctitle text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22715" volatility="VOLATILE" is-window="f" function-identity-arguments="crel text, curl text, ctitle text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$linkrel(crel text, curl text, ctitle text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$linkRel(crel, curl, ctitle));
    
END;
]]></complex-attribute>
                        <category _I_D="17cc8f2e-f08d-4c78-8ddf-f049bff96c8e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="85e3d599-6709-41d5-86a4-45334150e7e2" name="htp$linkrev" is-trigger-function="0" unique-function-name="htp$linkrev" is-aggregate="f" language-name="plpgsql" context="htp$linkrev" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="crev text, curl text, ctitle text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22716" volatility="VOLATILE" is-window="f" function-identity-arguments="crev text, curl text, ctitle text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$linkrev(crev text, curl text, ctitle text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$linkRev(crev, curl, ctitle));
    
END;
]]></complex-attribute>
                        <category _I_D="eef625f5-9f16-4a00-bf81-3e4ef3f7f93d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4c7bd174-60c9-4b0c-86bb-498192d693fd" name="htp$listheader" is-trigger-function="0" unique-function-name="htp$listheader" is-aggregate="f" language-name="plpgsql" context="htp$listheader" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22717" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$listheader(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$listHeader(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="2d33de6a-17c6-4350-a219-a35c8c09375c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8d2de019-a4e2-4719-ba13-3dbcf932c681" name="htp$listingclose" is-trigger-function="0" unique-function-name="htp$listingclose" is-aggregate="f" language-name="plpgsql" context="htp$listingclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22718" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$listingclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$listingClose());
    
END;
]]></complex-attribute>
                        <category _I_D="9d0cb449-7460-4cfe-9269-104a26f77a76" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d3ebac2f-d55f-45ef-a8d5-441385c7b517" name="htp$listingopen" is-trigger-function="0" unique-function-name="htp$listingopen" is-aggregate="f" language-name="plpgsql" context="htp$listingopen" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22719" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$listingopen()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$listingOpen());
    
END;
]]></complex-attribute>
                        <category _I_D="26ecad97-1594-4866-a677-fb268cfee980" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6789fca4-f04c-42cd-ac44-0408937f96a2" name="htp$listitem" is-trigger-function="0" unique-function-name="htp$listitem" is-aggregate="f" language-name="plpgsql" context="htp$listitem" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cdingbat text DEFAULT NULL::text, csrc text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22720" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cclear text, cdingbat text, csrc text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$listitem(ctext text, cclear text, cdingbat text, csrc text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$listItem(ctext,cclear,cdingbat,csrc,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="2957a68c-8f55-4310-b3e6-599d4e4afc54" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="18e49c16-54d5-4a8c-af04-66935189a8ef" name="htp$mailto" is-trigger-function="0" unique-function-name="htp$mailto" is-aggregate="f" language-name="plpgsql" context="htp$mailto" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="caddress text, ctext text, cname text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22721" volatility="VOLATILE" is-window="f" function-identity-arguments="caddress text, ctext text, cname text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$mailto(caddress text, ctext text, cname text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$mailto(caddress,ctext,cname,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="a0ec8e72-a475-4dee-80a9-0db24d5088d3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b5d95035-04ab-4215-a9c0-9b55050405c6" name="htp$mapclose" is-trigger-function="0" unique-function-name="htp$mapclose" is-aggregate="f" language-name="plpgsql" context="htp$mapclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22722" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$mapclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$mapClose());
    
END;
]]></complex-attribute>
                        <category _I_D="72d32b34-bc0b-46af-b922-c09a323fdbcf" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="70645715-7a34-4b8e-9c50-612dde7989aa" name="htp$mapopen" is-trigger-function="0" unique-function-name="htp$mapopen" is-aggregate="f" language-name="plpgsql" context="htp$mapopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22723" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$mapopen(cname text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$mapOpen(cname,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="47657585-e2d9-4606-b14f-c7b1ccddbe1e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b8017c9d-d7fd-4c8b-8c0c-c07ded85ba93" name="htp$menulistclose" is-trigger-function="0" unique-function-name="htp$menulistclose" is-aggregate="f" language-name="plpgsql" context="htp$menulistclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22724" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$menulistclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$menulistClose());
    
END;
]]></complex-attribute>
                        <category _I_D="06a96689-eb6d-4f3a-ac38-98caa5c5b04d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3bc33a4d-5db3-4232-8d7c-77f7b0886cbe" name="htp$menulistopen" is-trigger-function="0" unique-function-name="htp$menulistopen" is-aggregate="f" language-name="plpgsql" context="htp$menulistopen" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22725" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$menulistopen()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$menulistOpen());
    
END;
]]></complex-attribute>
                        <category _I_D="bc24165a-67bc-4e4c-b9ff-73e1a2be6f10" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="82d50828-77fd-4437-a46b-3e3440af1395" name="htp$meta" is-trigger-function="0" unique-function-name="htp$meta" is-aggregate="f" language-name="plpgsql" context="htp$meta" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="chttp_equiv text, cname text, ccontent text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22726" volatility="VOLATILE" is-window="f" function-identity-arguments="chttp_equiv text, cname text, ccontent text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$meta(chttp_equiv text, cname text, ccontent text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$meta(chttp_equiv, cname, ccontent));
    
END;
]]></complex-attribute>
                        <category _I_D="eea997e8-6f3a-431f-a499-85ad00879e46" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6eef1171-7225-416f-b156-a86a5108f7bf" name="htp$nextid" is-trigger-function="0" unique-function-name="htp$nextid" is-aggregate="f" language-name="plpgsql" context="htp$nextid" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="void" function-arguments="cidentifier text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22727" volatility="VOLATILE" is-window="f" function-identity-arguments="cidentifier text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$nextid(cidentifier text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$nextid(cidentifier));
    
END;
]]></complex-attribute>
                        <category _I_D="e9fa90fc-8400-4573-98a0-39ffdc969dd5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d0c6f6c7-e08b-4f91-b358-9b042c37ecd1" name="htp$nl" is-trigger-function="0" unique-function-name="htp$nl" is-aggregate="f" language-name="plpgsql" context="htp$nl" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22728" volatility="VOLATILE" is-window="f" function-identity-arguments="cclear text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$nl(cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$nl(cclear,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="5b8bd3fd-6a7e-4919-b510-1f6205ef3e2c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9e13fa9b-3e84-4078-bb9f-c33b67992e5f" name="htp$nobr" is-trigger-function="0" unique-function-name="htp$nobr" is-aggregate="f" language-name="plpgsql" context="htp$nobr" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22729" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$nobr(ctext text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$nobr(ctext));
    
END;
]]></complex-attribute>
                        <category _I_D="2b0fc545-fac6-49b1-9891-d831bf2c5e19" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="14e789cb-8ff3-4d0f-b891-7c5f96e2668c" name="htp$noframesclose" is-trigger-function="0" unique-function-name="htp$noframesclose" is-aggregate="f" language-name="plpgsql" context="htp$noframesclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22730" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$noframesclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$noframesClose());
    
END;
]]></complex-attribute>
                        <category _I_D="dc7d096e-850e-4080-b262-b750faaba543" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="61b3d970-516c-4d8f-9e07-e858e8c1e87c" name="htp$noframesopen" is-trigger-function="0" unique-function-name="htp$noframesopen" is-aggregate="f" language-name="plpgsql" context="htp$noframesopen" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22731" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$noframesopen()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$noframesOpen());
    
END;
]]></complex-attribute>
                        <category _I_D="90a4460a-a7ca-492c-b1f6-ecff76afd080" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1f5cf229-5388-4b95-815a-235c133c8ddd" name="htp$olistclose" is-trigger-function="0" unique-function-name="htp$olistclose" is-aggregate="f" language-name="plpgsql" context="htp$olistclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22732" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$olistclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$olistClose());
    
END;
]]></complex-attribute>
                        <category _I_D="269e6434-1841-462e-9539-3aa9edde557e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="747ac52a-d85a-4814-8566-a9f89568320b" name="htp$olistopen" is-trigger-function="0" unique-function-name="htp$olistopen" is-aggregate="f" language-name="plpgsql" context="htp$olistopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cclear text DEFAULT NULL::text, cwrap text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22733" volatility="VOLATILE" is-window="f" function-identity-arguments="cclear text, cwrap text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$olistopen(cclear text, cwrap text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$olistOpen(cclear,cwrap,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="cbb7d0ab-4296-4e43-afd6-c3a7df8c9324" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7f2732cc-4def-4497-9f65-c94d1230c9fd" name="htp$p" is-trigger-function="0" unique-function-name="htp$p(cbuf text)" is-aggregate="f" language-name="plpgsql" context="htp$p(cbuf text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" unique-suffix="(cbuf text)" routine-number="22773" is-returning-set="f" ret-datatype="void" function-arguments="cbuf text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22773" volatility="VOLATILE" is-window="f" function-identity-arguments="cbuf text" overload-function-count="3" proc-language="plpgsql" function-signature="htp$p(cbuf text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    INSERT INTO aws_htbuf_arr(column_value)
    SELECT CONCAT(
        cbuf,
        E'\n'
    );
    
END;
]]></complex-attribute>
                        <category _I_D="49353b22-e2bc-4650-b367-cb2755fe62f3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ba0da325-ef55-4a61-81eb-fa02fcd4489c" name="htp$p" is-trigger-function="0" unique-function-name="htp$p(dbuf timestamp without time zone)" is-aggregate="f" language-name="plpgsql" context="htp$p(dbuf timestamp without time zone)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone" unique-suffix="(dbuf timestamp without time zone)" routine-number="22774" is-returning-set="f" ret-datatype="void" function-arguments="dbuf timestamp without time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22774" volatility="VOLATILE" is-window="f" function-identity-arguments="dbuf timestamp without time zone" overload-function-count="3" proc-language="plpgsql" function-signature="htp$p(dbuf timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    INSERT INTO aws_htbuf_arr(column_value)
    SELECT CONCAT(
        aws_oracle_ext.to_char(dbuf),
        E'\n'
    );
    
END;
]]></complex-attribute>
                        <category _I_D="151465f0-2dfb-41bd-b739-93ad1f397378" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="919f74c6-7d8f-44bb-ac0b-ccb1fab3ad91" name="htp$p" is-trigger-function="0" unique-function-name="htp$p(nbuf double precision)" is-aggregate="f" language-name="plpgsql" context="htp$p(nbuf double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision" unique-suffix="(nbuf double precision)" routine-number="22764" is-returning-set="f" ret-datatype="void" function-arguments="nbuf double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22764" volatility="VOLATILE" is-window="f" function-identity-arguments="nbuf double precision" overload-function-count="3" proc-language="plpgsql" function-signature="htp$p(nbuf double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    INSERT INTO aws_htbuf_arr(column_value)
    SELECT CONCAT(
        aws_oracle_ext.to_char(nbuf),
        E'\n'
    );
    
END;
]]></complex-attribute>
                        <category _I_D="1b12e96e-bf1e-4e39-9da0-73feb5e06e68" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="817660d9-a95b-48c6-bd7d-e1e3a264eb10" name="htp$para" is-trigger-function="0" unique-function-name="htp$para" is-aggregate="f" language-name="plpgsql" context="htp$para" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22736" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$para()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

  PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$para());
    
END;
]]></complex-attribute>
                        <category _I_D="643d2c59-c220-4196-963b-07e4a11ad507" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8c8cb59e-f157-4718-9b05-d3ca3431b308" name="htp$paragraph" is-trigger-function="0" unique-function-name="htp$paragraph" is-aggregate="f" language-name="plpgsql" context="htp$paragraph" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="calign text DEFAULT NULL::text, cnowrap text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22734" volatility="VOLATILE" is-window="f" function-identity-arguments="calign text, cnowrap text, cclear text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$paragraph(calign text, cnowrap text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$paragraph(calign,cnowrap,cclear,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="f6848f50-53ba-4977-b555-2fe13f03a009" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="316bde3d-1bb5-4456-8896-52a41608a8b9" name="htp$param" is-trigger-function="0" unique-function-name="htp$param" is-aggregate="f" language-name="plpgsql" context="htp$param" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="cname text, cvalue text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22735" volatility="VOLATILE" is-window="f" function-identity-arguments="cname text, cvalue text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$param(cname text, cvalue text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$param(cname,cvalue));
    
END;
]]></complex-attribute>
                        <category _I_D="beb0a780-1091-4d3b-911a-045c29f7dae3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="07034878-c1dc-48b6-8d8d-73b7610127d8" name="htp$plaintext" is-trigger-function="0" unique-function-name="htp$plaintext" is-aggregate="f" language-name="plpgsql" context="htp$plaintext" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22737" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$plaintext(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$plaintext(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="be58c76b-8f3c-4bb2-a24c-7f89330d2207" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5d239156-701a-4c04-bfc2-1e468304f54b" name="htp$preclose" is-trigger-function="0" unique-function-name="htp$preclose" is-aggregate="f" language-name="plpgsql" context="htp$preclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22738" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$preclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$$preClose());
    
END;
]]></complex-attribute>
                        <category _I_D="60bc5659-5b0b-408f-ae57-f535dde3c3f2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="fd6c339d-6963-4166-9d3a-472c249252f8" name="htp$preopen" is-trigger-function="0" unique-function-name="htp$preopen" is-aggregate="f" language-name="plpgsql" context="htp$preopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cclear text DEFAULT NULL::text, cwidth text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22739" volatility="VOLATILE" is-window="f" function-identity-arguments="cclear text, cwidth text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$preopen(cclear text, cwidth text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$preOpen(cclear,cwidth,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="90c15c1d-af0d-4e3b-a0cf-bd096df0af17" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="60614685-efaa-48a3-ba31-adeaa590dcb2" name="htp$print" is-trigger-function="0" unique-function-name="htp$print(cbuf text)" is-aggregate="f" language-name="plpgsql" context="htp$print(cbuf text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" unique-suffix="(cbuf text)" routine-number="22767" is-returning-set="f" ret-datatype="void" function-arguments="cbuf text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22767" volatility="VOLATILE" is-window="f" function-identity-arguments="cbuf text" overload-function-count="3" proc-language="plpgsql" function-signature="htp$print(cbuf text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    INSERT INTO aws_htbuf_arr(column_value)
    SELECT CONCAT(
        cbuf,
        E'\n'
    );
    
END;
]]></complex-attribute>
                        <category _I_D="2bdd7cf1-8172-4675-8331-46d15e384e64" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1d619887-95e4-48a4-a085-1db3080a794f" name="htp$print" is-trigger-function="0" unique-function-name="htp$print(dbuf timestamp without time zone)" is-aggregate="f" language-name="plpgsql" context="htp$print(dbuf timestamp without time zone)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone" unique-suffix="(dbuf timestamp without time zone)" routine-number="22768" is-returning-set="f" ret-datatype="void" function-arguments="dbuf timestamp without time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22768" volatility="VOLATILE" is-window="f" function-identity-arguments="dbuf timestamp without time zone" overload-function-count="3" proc-language="plpgsql" function-signature="htp$print(dbuf timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    INSERT INTO aws_htbuf_arr(column_value)
    SELECT CONCAT(
        aws_oracle_ext.to_char(dbuf),
        E'\n'
    );
    
END;
]]></complex-attribute>
                        <category _I_D="d7b15507-f082-4889-b639-c52336c10888" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="be25e696-c502-478f-99a3-1d81c8010cd8" name="htp$print" is-trigger-function="0" unique-function-name="htp$print(nbuf double precision)" is-aggregate="f" language-name="plpgsql" context="htp$print(nbuf double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision" unique-suffix="(nbuf double precision)" routine-number="22765" is-returning-set="f" ret-datatype="void" function-arguments="nbuf double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22765" volatility="VOLATILE" is-window="f" function-identity-arguments="nbuf double precision" overload-function-count="3" proc-language="plpgsql" function-signature="htp$print(nbuf double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    INSERT INTO aws_htbuf_arr(column_value)
    SELECT CONCAT(
        aws_oracle_ext.to_char(nbuf),
        E'\n'
    );
    
END;
]]></complex-attribute>
                        <category _I_D="ef593adf-894b-49c7-a286-aa45dbe9a66a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e1577239-93ca-49df-84f9-a496e61e8cbd" name="htp$prints" is-trigger-function="0" unique-function-name="htp$prints" is-aggregate="f" language-name="plpgsql" context="htp$prints" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22766" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$prints(ctext text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$escape_sc(ctext));
    
END;
]]></complex-attribute>
                        <category _I_D="62f3d5c0-a8e8-43b6-ad76-0ec73f00a435" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f25e49de-19f0-4881-99cf-9c671da927c4" name="htp$prn" is-trigger-function="0" unique-function-name="htp$prn(cbuf text)" is-aggregate="f" language-name="plpgsql" context="htp$prn(cbuf text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" unique-suffix="(cbuf text)" routine-number="22770" is-returning-set="f" ret-datatype="void" function-arguments="cbuf text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22770" volatility="VOLATILE" is-window="f" function-identity-arguments="cbuf text" overload-function-count="3" proc-language="plpgsql" function-signature="htp$prn(cbuf text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    INSERT INTO aws_htbuf_arr(column_value)
    SELECT CONCAT(
        cbuf
    );
    
END;
]]></complex-attribute>
                        <category _I_D="be5c2428-e8e9-44c1-9e38-bdf824c88dd1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="35c7a11a-81cc-4f60-83a9-e1eca8e185ca" name="htp$prn" is-trigger-function="0" unique-function-name="htp$prn(dbuf timestamp without time zone)" is-aggregate="f" language-name="plpgsql" context="htp$prn(dbuf timestamp without time zone)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone" unique-suffix="(dbuf timestamp without time zone)" routine-number="22771" is-returning-set="f" ret-datatype="void" function-arguments="dbuf timestamp without time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22771" volatility="VOLATILE" is-window="f" function-identity-arguments="dbuf timestamp without time zone" overload-function-count="3" proc-language="plpgsql" function-signature="htp$prn(dbuf timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    INSERT INTO aws_htbuf_arr(column_value)
    SELECT CONCAT(
        aws_oracle_ext.to_char(dbuf)
    );
    
END;
]]></complex-attribute>
                        <category _I_D="93e5d32d-e6b9-42a8-acdd-3ce64084c165" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3621df9d-6bc4-4c36-a927-d9471d28ca66" name="htp$prn" is-trigger-function="0" unique-function-name="htp$prn(nbuf double precision)" is-aggregate="f" language-name="plpgsql" context="htp$prn(nbuf double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision" unique-suffix="(nbuf double precision)" routine-number="22769" is-returning-set="f" ret-datatype="void" function-arguments="nbuf double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22769" volatility="VOLATILE" is-window="f" function-identity-arguments="nbuf double precision" overload-function-count="3" proc-language="plpgsql" function-signature="htp$prn(nbuf double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    INSERT INTO aws_htbuf_arr(column_value)
    SELECT CONCAT(
        aws_oracle_ext.to_char(nbuf)
    );
    
END;
]]></complex-attribute>
                        <category _I_D="b74489d7-4738-47fd-a780-4e4b3915323a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2b3f1e51-7207-45cd-b6a2-17f07b082239" name="htp$ps" is-trigger-function="0" unique-function-name="htp$ps" is-aggregate="f" language-name="plpgsql" context="htp$ps" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22772" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$ps(ctext text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$escape_sc(ctext));
    
END;
]]></complex-attribute>
                        <category _I_D="4e8c1cca-3e64-41d6-ade9-b0d9e40f8e2a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a24e22a0-a925-4e23-82a4-91f00887a4b8" name="htp$putraw" is-trigger-function="0" unique-function-name="htp$putraw" is-aggregate="f" language-name="plpgsql" context="htp$putraw" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea,integer" is-returning-set="f" ret-datatype="void" function-arguments="bbuf bytea, buflen integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22775" volatility="VOLATILE" is-window="f" function-identity-arguments="bbuf bytea, buflen integer" overload-function-count="1" proc-language="plpgsql" function-signature="htp$putraw(bbuf bytea, buflen integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    NULL;
    
END;
]]></complex-attribute>
                        <category _I_D="303bc2af-f7f3-455b-bb98-ddb6111dd859" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="75b22d44-1bd2-46d1-bac1-05e5d7146895" name="htp$s" is-trigger-function="0" unique-function-name="htp$s" is-aggregate="f" language-name="plpgsql" context="htp$s" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22743" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$s(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$s(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="a4ccfa05-9d75-4fdd-995e-73f89d4e8247" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bce33f17-1f43-434c-9396-4d8596ea38ff" name="htp$sample" is-trigger-function="0" unique-function-name="htp$sample" is-aggregate="f" language-name="plpgsql" context="htp$sample" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22740" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$sample(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$sample(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="b01d0b96-ae7e-428a-959d-45f0448346c9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c04dab83-5143-4696-9f2a-d594bc6cb636" name="htp$script" is-trigger-function="0" unique-function-name="htp$script" is-aggregate="f" language-name="plpgsql" context="htp$script" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="cscript text, clanguage text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22741" volatility="VOLATILE" is-window="f" function-identity-arguments="cscript text, clanguage text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$script(cscript text, clanguage text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$script(cscript, clanguage));
    
END;
]]></complex-attribute>
                        <category _I_D="225f190a-c084-4c35-9262-e507deee432f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d1936d12-bf1a-4c41-b301-492f7ee82a25" name="htp$small" is-trigger-function="0" unique-function-name="htp$small" is-aggregate="f" language-name="plpgsql" context="htp$small" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22742" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$small(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$small(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="65de747e-9003-476d-9ea3-e45095a59f75" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b559e0af-c0a1-458f-b530-65804ec005a1" name="htp$strike" is-trigger-function="0" unique-function-name="htp$strike" is-aggregate="f" language-name="plpgsql" context="htp$strike" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22744" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$strike(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$strike(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="edb05a5f-8aa3-4ec0-857d-8ade9cfac8f5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7335ba85-aae8-415a-b908-43d7ddb1e2c7" name="htp$strong" is-trigger-function="0" unique-function-name="htp$strong" is-aggregate="f" language-name="plpgsql" context="htp$strong" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22745" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$strong(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$strong(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="283db0f1-1b76-45ac-948a-d3aee33a694f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d6b01d75-95b7-4bf0-b238-9f6f64a9ef3c" name="htp$style" is-trigger-function="0" unique-function-name="htp$style" is-aggregate="f" language-name="plpgsql" context="htp$style" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="void" function-arguments="cstyle text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22746" volatility="VOLATILE" is-window="f" function-identity-arguments="cstyle text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$style(cstyle text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$style(cstyle));
    
END;
]]></complex-attribute>
                        <category _I_D="80d1e24b-88fa-4ab0-87b7-d2b57ab5e3ff" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="68a7482c-e0b1-459f-a348-2d3055fb8b20" name="htp$sub" is-trigger-function="0" unique-function-name="htp$sub" is-aggregate="f" language-name="plpgsql" context="htp$sub" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, calign text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22747" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, calign text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$sub(ctext text, calign text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$sub(ctext,calign,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="2ebac50f-49fa-4667-b08d-d9ba8d6f804e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="27eef817-7c1f-4f27-8fd8-69e624a4526e" name="htp$sup" is-trigger-function="0" unique-function-name="htp$sup" is-aggregate="f" language-name="plpgsql" context="htp$sup" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, calign text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22748" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, calign text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$sup(ctext text, calign text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$sup(ctext,calign,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="313367a6-3b7d-49d1-af20-68a66e2611d3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8fd789fc-41c0-4457-b03f-7b5e1248efdf" name="htp$tablecaption" is-trigger-function="0" unique-function-name="htp$tablecaption" is-aggregate="f" language-name="plpgsql" context="htp$tablecaption" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="ccaption text, calign text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22749" volatility="VOLATILE" is-window="f" function-identity-arguments="ccaption text, calign text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$tablecaption(ccaption text, calign text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$tableCaption(ccaption,calign,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="f24d73db-204e-46cd-84f6-4fdb4abe653a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="64991f63-ebd6-49fa-a7bb-10f809567cd9" name="htp$tableclose" is-trigger-function="0" unique-function-name="htp$tableclose" is-aggregate="f" language-name="plpgsql" context="htp$tableclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22750" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$tableclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$tableClose());
    
END;
]]></complex-attribute>
                        <category _I_D="3a0c03ac-6191-4f7f-a3bf-c25734be74cc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c7fbfa88-0d38-4d9a-8d65-a7bbc387dcca" name="htp$tabledata" is-trigger-function="0" unique-function-name="htp$tabledata" is-aggregate="f" language-name="plpgsql" context="htp$tabledata" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cvalue text DEFAULT NULL::text, calign text DEFAULT NULL::text, cdp text DEFAULT NULL::text, cnowrap text DEFAULT NULL::text, crowspan text DEFAULT NULL::text, ccolspan text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="7" function-id="22751" volatility="VOLATILE" is-window="f" function-identity-arguments="cvalue text, calign text, cdp text, cnowrap text, crowspan text, ccolspan text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$tabledata(cvalue text, calign text, cdp text, cnowrap text, crowspan text, ccolspan text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$tableData(cvalue,calign,cdp,cnowrap,crowspan,ccolspan,cattributes));

END;
]]></complex-attribute>
                        <category _I_D="c060f39c-4c96-42d9-bec5-c90664387b91" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5e0ab29c-59ec-4f3d-b74c-4c25e79528d5" name="htp$tableheader" is-trigger-function="0" unique-function-name="htp$tableheader" is-aggregate="f" language-name="plpgsql" context="htp$tableheader" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cvalue text DEFAULT NULL::text, calign text DEFAULT NULL::text, cdp text DEFAULT NULL::text, cnowrap text DEFAULT NULL::text, crowspan text DEFAULT NULL::text, ccolspan text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="7" function-id="22752" volatility="VOLATILE" is-window="f" function-identity-arguments="cvalue text, calign text, cdp text, cnowrap text, crowspan text, ccolspan text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$tableheader(cvalue text, calign text, cdp text, cnowrap text, crowspan text, ccolspan text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$tableHeader(cvalue,calign,cdp,cnowrap,crowspan,ccolspan,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="1baa1246-5892-4b32-ae8d-1f6a367cc28b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4a93a8bb-3a0d-47a6-b37f-0a09c5712ff5" name="htp$tableopen" is-trigger-function="0" unique-function-name="htp$tableopen" is-aggregate="f" language-name="plpgsql" context="htp$tableopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cborder text DEFAULT NULL::text, calign text DEFAULT NULL::text, cnowrap text DEFAULT NULL::text, cclear text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22753" volatility="VOLATILE" is-window="f" function-identity-arguments="cborder text, calign text, cnowrap text, cclear text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$tableopen(cborder text, calign text, cnowrap text, cclear text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$tableOpen(cborder,calign,cnowrap,cclear,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="fd7407b4-136c-40bf-907b-718241ec0eb8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4a84673c-1e87-4c18-8408-78095b318b11" name="htp$tablerowclose" is-trigger-function="0" unique-function-name="htp$tablerowclose" is-aggregate="f" language-name="plpgsql" context="htp$tablerowclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22754" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$tablerowclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$tableClose());
    
END;
]]></complex-attribute>
                        <category _I_D="425c37ff-204b-43f8-8723-924e687d595a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="234120a0-1121-45de-b43e-b5398c6bb103" name="htp$tablerowopen" is-trigger-function="0" unique-function-name="htp$tablerowopen" is-aggregate="f" language-name="plpgsql" context="htp$tablerowopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="calign text DEFAULT NULL::text, cvalign text DEFAULT NULL::text, cdp text DEFAULT NULL::text, cnowrap text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22755" volatility="VOLATILE" is-window="f" function-identity-arguments="calign text, cvalign text, cdp text, cnowrap text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$tablerowopen(calign text, cvalign text, cdp text, cnowrap text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$tableRowOpen(calign,cvalign,cdp,cnowrap,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="78d6a107-2fdd-448a-bf95-80cf3aac5bbb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6a26708b-525f-4c05-9a61-c54ce539fb0a" name="htp$teletype" is-trigger-function="0" unique-function-name="htp$teletype" is-aggregate="f" language-name="plpgsql" context="htp$teletype" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22756" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$teletype(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$teletype(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="f689c290-4555-4ed6-bded-17c9b5669d26" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="92e7e0a3-15ca-4e26-96a8-5a32acaa4423" name="htp$title" is-trigger-function="0" unique-function-name="htp$title" is-aggregate="f" language-name="plpgsql" context="htp$title" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="void" function-arguments="ctitle text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22757" volatility="VOLATILE" is-window="f" function-identity-arguments="ctitle text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$title(ctitle text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$title(ctitle));
    
END;
]]></complex-attribute>
                        <category _I_D="d048ed40-31a9-4023-b78e-9c5987758879" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e4e5a2f0-bf74-493a-8f22-10df1ea5c53f" name="htp$ulistclose" is-trigger-function="0" unique-function-name="htp$ulistclose" is-aggregate="f" language-name="plpgsql" context="htp$ulistclose" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22758" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$ulistclose()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$ulistClose());
    
END;
]]></complex-attribute>
                        <category _I_D="eac3f99e-adc1-4adb-aad3-155f0609a442" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="412cebf4-e864-4a09-a227-3c8f03b8ae8f" name="htp$ulistopen" is-trigger-function="0" unique-function-name="htp$ulistopen" is-aggregate="f" language-name="plpgsql" context="htp$ulistopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="cclear text DEFAULT NULL::text, cwrap text DEFAULT NULL::text, cdingbat text DEFAULT NULL::text, csrc text DEFAULT NULL::text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22759" volatility="VOLATILE" is-window="f" function-identity-arguments="cclear text, cwrap text, cdingbat text, csrc text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$ulistopen(cclear text, cwrap text, cdingbat text, csrc text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$ulistOpen(cclear,cwrap,cdingbat,csrc,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="6b6d9880-4cef-4650-9ce5-a6f573762b6d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ee0b1d79-fdf1-4324-83ad-e7f3c57a36f0" name="htp$underline" is-trigger-function="0" unique-function-name="htp$underline" is-aggregate="f" language-name="plpgsql" context="htp$underline" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22760" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$underline(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$underline(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="c25c4bcc-7a61-488c-af9b-9d66f3ed4b5b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e4b039fc-c1af-4327-b2d0-eb7181833e57" name="htp$variable" is-trigger-function="0" unique-function-name="htp$variable" is-aggregate="f" language-name="plpgsql" context="htp$variable" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="ctext text, cattributes text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22761" volatility="VOLATILE" is-window="f" function-identity-arguments="ctext text, cattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="htp$variable(ctext text, cattributes text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$variable(ctext,cattributes));
    
END;
]]></complex-attribute>
                        <category _I_D="d1c46707-d062-469c-a427-6f6e036354cf" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="270e3b4d-3cad-456f-9656-0814891bfabe" name="htp$wbr" is-trigger-function="0" unique-function-name="htp$wbr" is-aggregate="f" language-name="plpgsql" context="htp$wbr" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22762" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="htp$wbr()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$p(aws_oracle_ext.htf$wbr());
    
END;
]]></complex-attribute>
                        <category _I_D="0e2ee3b3-90d8-4d45-a836-85b58b808a05" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a1b35912-0f13-4eee-ad7e-0104d5e0ed27" name="immutable_concat" is-trigger-function="0" unique-function-name="immutable_concat" is-aggregate="f" language-name="sql" context="immutable_concat" subcategories-loading="none" object-loading="extended" arguments-datatypes="text[]" is-returning-set="f" ret-datatype="text" function-arguments="VARIADIC param_args text[]" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23142" volatility="IMMUTABLE" is-window="f" function-identity-arguments="VARIADIC param_args text[]" overload-function-count="1" proc-language="sql" function-signature="immutable_concat(VARIADIC param_args text[])">
                        <complex-attribute name="sql"><![CDATA[
SELECT ARRAY_TO_STRING($1, '');
]]></complex-attribute>
                        <category _I_D="379dc8fc-3463-4485-9d9d-9c442a4100d1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="802938aa-19b4-4118-ac15-a0cb21fd7c4e" name="immutable_concat_ws" is-trigger-function="0" unique-function-name="immutable_concat_ws" is-aggregate="f" language-name="sql" context="immutable_concat_ws" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text[]" is-returning-set="f" ret-datatype="text" function-arguments="text, VARIADIC param_args text[]" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23143" volatility="IMMUTABLE" is-window="f" function-identity-arguments="text, VARIADIC param_args text[]" overload-function-count="1" proc-language="sql" function-signature="immutable_concat_ws(text, VARIADIC param_args text[])">
                        <complex-attribute name="sql"><![CDATA[
SELECT array_to_string($2,$1);
]]></complex-attribute>
                        <category _I_D="9601b02e-69a5-4589-8cb4-4a713710566b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a9aaeccf-e212-40f9-84d6-edfbd1e51ab6" name="increment_rowcount" is-trigger-function="0" unique-function-name="increment_rowcount" is-aggregate="f" language-name="plpgsql" context="increment_rowcount" subcategories-loading="none" object-loading="extended" arguments-datatypes="bigint,boolean" comment="&amp;#x000a;  Increments the variable emulating the ROWCOUNT cursor attribute's behaviour in Oracle. &amp;#x000a;  Must be called whenever an explicit cursor's fetch occured, if the migrated object's &amp;#x000a;  code contains the ROWCOUNT cursor attribute.&amp;#x000a;&amp;#x000a;  Parameters:&amp;#x000a;    rc       -- variable emulating the ROWCOUNT attribute for the explicit cursor&amp;#x000a;    is_found -- value of the emulated FOUND curcor attribute, should be always set &amp;#x000a;                to FOUND when calling the function&amp;#x000a;&amp;#x000a;  Returns:&amp;#x000a;    Conditionally increased value of the rc parameter&amp;#x000a;" is-returning-set="f" ret-datatype="int8" function-arguments="INOUT rc bigint, is_found boolean" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22393" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT rc bigint, is_found boolean" overload-function-count="1" proc-language="plpgsql" function-signature="increment_rowcount(INOUT rc bigint, is_found boolean)">
                        <complex-attribute name="sql"><![CDATA[
begin
  rc := rc + case when is_found then 1 else 0 end;
end;
]]></complex-attribute>
                        <category _I_D="c76b22c0-a5b7-4251-8fc4-f3c8c00da962" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9abaf6ba-1309-4ba6-b035-38d8e926e68a" name="init_context_struct" is-trigger-function="0" unique-function-name="init_context_struct" is-aggregate="f" language-name="sql" context="init_context_struct" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22993" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="init_context_struct()">
                        <complex-attribute name="sql"><![CDATA[
   	create temporary table if not exists context_local(
	  context_namespace text not null,
	  attribute_name text not null,  
	  attribute_value text,
	  user_name text,
	  cliend_id text,
	  signature text,
	  backend_start timestamp not null default now(),				  
	  pid int default pg_backend_pid(),
  	  constraint un_context_local unique (context_namespace, attribute_name)
	) on commit preserve rows;


	create unlogged table if not exists aws_oracle_context.context_global(
	  context_namespace text not null references aws_oracle_context.context on delete cascade,
	  attribute_name text not null,  
	  attribute_value text,
	  user_name text,
	  cliend_id text,
	  signature text,
	  backend_start timestamp not null default now(),				  
	  pid int default pg_backend_pid()
  	  ,constraint un_context_global unique (context_namespace, attribute_name, cliend_id)
	);
]]></complex-attribute>
                        <category _I_D="61169fc4-cc83-4739-aacd-c9e2ba6e4e1e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8bb6b4b7-d5de-4c59-89eb-6c9e3800c80d" name="instr" is-trigger-function="0" unique-function-name="instr" is-aggregate="f" language-name="sql" context="instr" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,numeric,numeric" comment="This function searches a string for a substring using characters and returns the position in the string that is the first character of a specified occurrence of the substring." is-returning-set="f" ret-datatype="numeric" function-arguments="p_str text, p_substr text, p_pos numeric DEFAULT 1, p_occurrence numeric DEFAULT 1" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22394" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_str text, p_substr text, p_pos numeric, p_occurrence numeric" overload-function-count="1" proc-language="sql" function-signature="instr(p_str text, p_substr text, p_pos numeric, p_occurrence numeric)">
                        <complex-attribute name="sql"><![CDATA[


    SELECT
        CASE

            WHEN LENGTH($1) = 0 OR LENGTH($2) = 0 THEN NULL::NUMERIC

            WHEN TRUNC($4) = 0 THEN 1/TRUNC($4)

            WHEN $4 < 0 THEN SQRT($4)

            ELSE

                (

                    WITH RECURSIVE t(str, shift, pos, tail, o, n) AS 
                    (
                        SELECT CASE WHEN TRUNC($3) < 0 THEN REVERSE($1) ELSE $1 END AS str,
                            0 AS shift,
                            CASE WHEN TRUNC($3) < 0 THEN -1 * TRUNC($3)::INT ELSE TRUNC($3)::INT END AS pos,
                            CASE WHEN TRUNC($3) < 0 THEN REVERSE($1) ELSE $1 END AS tail,
                            0 AS o,
                            CASE WHEN TRUNC($3) < 0 THEN REVERSE($2) ELSE $2 END AS n
                        UNION ALL
                        SELECT str,
                            shift + pos AS shift,
                            STRPOS(SUBSTR(str, shift + pos), n) AS pos,
                            SUBSTR(str, shift + pos) AS tail,
                            o + 1 AS o,
                            n
                        FROM t
                        WHERE pos <> 0
                    )
                    ,r AS
                    (
                        SELECT t.str,
                            t.shift,
                            t.pos,
                            t.tail,
                            t.o,
                            CASE
                                WHEN TRUNC($3) > 0 THEN
                                    t.pos + t.shift - 1
                                ELSE
                                    LENGTH(t.str) - t.pos - t.shift + 2
                            END cc
                        FROM t
                        WHERE t.o = TRUNC($4)
                        AND t.pos <> 0
                    )
                    SELECT COALESCE
                    (
                        (
                            SELECT r.cc
                            FROM r
                        ),
                        0
                    )::NUMERiC
                )

        END;

]]></complex-attribute>
                        <category _I_D="3b70bf1a-15f3-4e96-8cba-956060dfa646" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b50324b8-fca3-490e-9aac-3736bda44416" name="instrb" is-trigger-function="0" unique-function-name="instrb" is-aggregate="f" language-name="sql" context="instrb" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" comment="Returns the byte position of a specified string in the input string." is-returning-set="f" ret-datatype="int4" function-arguments="text, text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22395" volatility="VOLATILE" is-window="f" function-identity-arguments="text, text" overload-function-count="1" proc-language="sql" function-signature="instrb(text, text)">
                        <complex-attribute name="sql"><![CDATA[
  SELECT POSITION($2::bytea IN $1::bytea);
]]></complex-attribute>
                        <category _I_D="c1c64961-46c6-448e-806b-7f2a1c92f7b1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="34f5fa68-639e-4876-8e79-77f98c32d70a" name="is_package_initialized" is-trigger-function="0" unique-function-name="is_package_initialized" is-aggregate="f" language-name="plpgsql" context="is_package_initialized" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" comment="&amp;#x000a; Checks a flag for the migrated package that it has already been initialized in the current session, &amp;#x000a; to prevent a re-execution for the initialization function.&amp;#x000a; &amp;#x000a; Parameters:&amp;#x000a;  schema_name -- migrated schema&amp;#x000a;  package_name -- migrated package&amp;#x000a;" is-returning-set="f" ret-datatype="bool" function-arguments="schema_name text, package_name text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22396" volatility="VOLATILE" is-window="f" function-identity-arguments="schema_name text, package_name text" overload-function-count="1" proc-language="plpgsql" function-signature="is_package_initialized(schema_name text, package_name text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    RETURN aws_oracle_ext.get_package_variable
    (
        schema_name => is_package_initialized.schema_name,
        package_name => is_package_initialized.package_name,
        variable_name => 'Init$$'
    )::BOOLEAN;

EXCEPTION
    WHEN OTHERS THEN

        RETURN FALSE;

END;
]]></complex-attribute>
                        <category _I_D="41e864f6-0bf6-449b-af9e-e2f9b6285d3c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c81bf7e0-2747-4bcc-9ae4-087b3d53a737" name="isopen" is-trigger-function="0" unique-function-name="isopen" is-aggregate="f" language-name="plpgsql" context="isopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="bool" function-arguments="p_cursor_name character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22977" volatility="VOLATILE" is-window="f" function-identity-arguments="p_cursor_name character varying" overload-function-count="1" proc-language="plpgsql" function-signature="isopen(p_cursor_name character varying)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
  RETURN EXISTS(SELECT 1 FROM pg_cursors WHERE name = lower(p_cursor_name));
END;
]]></complex-attribute>
                        <category _I_D="4b1aac30-67c8-4cf1-85ba-db37ffadd725" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8b9cc1a3-0d9a-4b3a-afa0-073d40d8c26f" name="json_set_by_path" is-trigger-function="0" unique-function-name="json_set_by_path" is-aggregate="f" language-name="plpgsql" context="json_set_by_path" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb,text,anyelement" is-returning-set="f" ret-datatype="jsonb" function-arguments="src jsonb, ppath text, pvalue anyelement" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="23151" volatility="IMMUTABLE" is-window="f" function-identity-arguments="src jsonb, ppath text, pvalue anyelement" overload-function-count="1" proc-language="plpgsql" function-signature="json_set_by_path(src jsonb, ppath text, pvalue anyelement)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    pathParts TEXT[];
    valuetype TEXT;
    vres JSONB;
    vpart TEXT;
    vdatatype TEXT;
    vproxy JSONB;
    vleaf JSONB;
BEGIN

    SELECT JSONB_TYPEOF
    (
        JSONB_BUILD_OBJECT
        (
            'tst',
            pvalue
        ) -> 'tst'
    )
    INTO valuetype;

    pathParts := REGEXP_SPLIT_TO_ARRAY
    (
        REPLACE
        (
            REPLACE
            (
                ppath,
                '[',
                '.'
            ),
            ']',
            ''
        ),
        '\.'
    );



    SELECT
        CASE
            WHEN pt.typtype = 'b' THEN
                'base'
            ELSE
                'udt'
        END
    INTO vdatatype
    FROM pg_type pt
    WHERE pt.oid = PG_TYPEOF(pvalue); 

    IF NOT FOUND THEN

        vdatatype := 'udt';

    END IF;

    -- simple case
    IF CARDINALITY(pathParts) = 2 THEN

        IF vdatatype = 'base' THEN

            vres := JSONB_BUILD_OBJECT
            (
                'column_value',
                TO_JSONB(pvalue)
            );

        ELSE

            SELECT TO_JSONB(z)
            INTO vres
            FROM JSONB_POPULATE_RECORD
            (
                pvalue,
                TO_JSONB(pvalue)
            ) z;

        END IF;

        RETURN vres;

    END IF;

    IF vdatatype = 'base' THEN

        IF valuetype = 'null' THEN

            vproxy := 'null'::JSONB;
        
        ELSE
        
            vproxy := TO_JSONB(pvalue);

        END IF;

    ELSE

        SELECT TO_JSONB(z)
        INTO vproxy
        FROM JSONB_POPULATE_RECORD
        (
            pvalue,
            TO_JSONB(pvalue)
        ) z;

    END IF;
        
    FOR i IN REVERSE CARDINALITY(pathParts)..3 LOOP

        vleaf := src #> pathParts[3:i-1];
        vres := JSONB_SET
        (
            CASE
                WHEN vleaf IS NOT NULL AND JSONB_TYPEOF(vleaf) = 'object' THEN
                    vleaf
                ELSE
                    '{}'::JSONB
                END,
            ARRAY[pathParts[i]],
            CASE
                WHEN i = CARDINALITY(pathParts) THEN
                    vproxy
                ELSE
                    vres
            END
        );

    END LOOP;

    RETURN src || vres;

END;
]]></complex-attribute>
                        <category _I_D="143abc4e-4266-4389-abd6-0b5f2ff2ae1d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f095ee65-febc-4745-adbf-4edc00b96e53" name="last_day" is-trigger-function="0" unique-function-name="last_day(pdate date)" is-aggregate="f" language-name="sql" context="last_day(pdate date)" subcategories-loading="none" object-loading="extended" arguments-datatypes="date" unique-suffix="(pdate date)" routine-number="22397" is-returning-set="f" ret-datatype="date" function-arguments="pdate date" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22397" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pdate date" overload-function-count="3" proc-language="sql" function-signature="last_day(pdate date)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT (
        DATE_TRUNC('month', pDate) +'1month'::INTERVAL - '1 day'::INTERVAL
    )::DATE;

]]></complex-attribute>
                        <category _I_D="62584e3f-08eb-4aca-b044-08f5baf84dc3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="32307c72-52a3-4c19-b8c6-90d319c97045" name="last_day" is-trigger-function="0" unique-function-name="last_day(pdate timestamp with time zone)" is-aggregate="f" language-name="sql" context="last_day(pdate timestamp with time zone)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp with time zone" unique-suffix="(pdate timestamp with time zone)" routine-number="22399" is-returning-set="f" ret-datatype="timestamptz" function-arguments="pdate timestamp with time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22399" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pdate timestamp with time zone" overload-function-count="3" proc-language="sql" function-signature="last_day(pdate timestamp with time zone)">
                        <complex-attribute name="sql"><![CDATA[
  
    SELECT MAKE_TIMESTAMPTZ
    (
        EXTRACT('YEAR' FROM pDate)::INT,
        EXTRACT('MONTH' FROM pDate)::INT,
        EXTRACT('DAY' FROM (DATE_TRUNC('MONTH', pDate) +'1MONTH'::INTERVAL -'1 DAY'::INTERVAL))::INT,
        EXTRACT('HOUR' FROM PDATE)::INT,
        EXTRACT('MIN' FROM PDATE)::INT,
        EXTRACT('SEC' FROM PDATE)
    );

]]></complex-attribute>
                        <category _I_D="435cef87-da18-423e-90e3-ae885b537af6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="692aa582-44e5-4718-ab3a-b0b730916774" name="last_day" is-trigger-function="0" unique-function-name="last_day(pdate timestamp without time zone)" is-aggregate="f" language-name="sql" context="last_day(pdate timestamp without time zone)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone" unique-suffix="(pdate timestamp without time zone)" routine-number="22398" is-returning-set="f" ret-datatype="timestamp" function-arguments="pdate timestamp without time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22398" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pdate timestamp without time zone" overload-function-count="3" proc-language="sql" function-signature="last_day(pdate timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT MAKE_TIMESTAMP
    (
        EXTRACT('YEAR' FROM pDate)::INT,
        EXTRACT('MONTH' FROM pDate)::INT,
        EXTRACT('DAY' FROM (DATE_TRUNC('MONTH', pDate) + '1MONTH'::INTERVAL - '1 DAY'::INTERVAL))::INT,
        EXTRACT('HOUR' FROM pDate)::INT,
        EXTRACT('MIN' FROM pDate)::INT,
        EXTRACT('SEC' FROM pDate)
    );

]]></complex-attribute>
                        <category _I_D="339ca708-44cb-4372-9077-18040f91dcad" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8c8d6849-7985-4adf-bed7-caad00d336d1" name="least" is-trigger-function="0" unique-function-name="least" is-aggregate="f" language-name="sql" context="least" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray" is-returning-set="f" ret-datatype="anyelement" function-arguments="VARIADIC anyarray" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23146" volatility="VOLATILE" is-window="f" function-identity-arguments="VARIADIC anyarray" overload-function-count="1" proc-language="sql" function-signature="least(VARIADIC anyarray)">
                        <complex-attribute name="sql"><![CDATA[
  SELECT unnest($1)
  ORDER BY 1 ASC NULLS FIRST
  LIMIT 1;
]]></complex-attribute>
                        <category _I_D="fefb8c2a-6ba6-4885-b91e-b7b46de85868" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b6d7e60c-7e63-46b2-9419-7c58c0f2ed87" name="limit" is-trigger-function="0" unique-function-name="limit" is-aggregate="f" language-name="sql" context="limit" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyelement" comment="Implements Oracle Collection method limit" is-returning-set="f" ret-datatype="int4" function-arguments="parray anyelement" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22401" volatility="STABLE" is-window="f" function-identity-arguments="parray anyelement" overload-function-count="1" proc-language="sql" function-signature="limit(parray anyelement)">
                        <complex-attribute name="sql"><![CDATA[
    /*the function is depricated. collection_%METHOD_NAME% has to be used instead*/
    SELECT
    COALESCE
    (
        SUBSTRING(SUBSTRING(pg_get_constraintdef(pc.oid) FROM '<=\s*\d+') FROM '\d+')::INTEGER,
        SUBSTRING(SUBSTRING(pg_get_constraintdef(pc.oid) FROM '<\s*\d+') FROM '\d+')::INTEGER - 1
    )
    FROM pg_constraint pc
    JOIN pg_type pt ON pt.oid = pc.contypid
    WHERE pt.typname = SUBSTRING(PG_TYPEOF(parray)::TEXT FROM POSITION('.' IN PG_TYPEOF(parray)::TEXT) + 1)
    AND pt.typcategory = 'A'
    AND pt.typtype = 'd'
    AND pc.conname LIKE '%_lim';

]]></complex-attribute>
                        <category _I_D="1c951574-0c22-4fba-abc9-9f939c6702fd" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="67da23ae-acd7-4ec6-85a6-0de350bc6f3a" name="lnnvl" is-trigger-function="0" unique-function-name="lnnvl" is-aggregate="f" language-name="sql" context="lnnvl" subcategories-loading="none" object-loading="extended" arguments-datatypes="boolean" comment="Evaluates if a value is false or unknown" is-returning-set="f" ret-datatype="bool" function-arguments="boolean" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22498" volatility="IMMUTABLE" is-window="f" function-identity-arguments="boolean" overload-function-count="1" proc-language="sql" function-signature="lnnvl(boolean)">
                        <complex-attribute name="sql"><![CDATA[
SELECT NOT COALESCE($1, FALSE::BOOL)
/*
CASE $1
  WHEN FALSE THEN TRUE::BOOL
  WHEN TRUE THEN FALSE::BOOL
  ELSE TRUE::BOOL --NULL
END
*/
]]></complex-attribute>
                        <category _I_D="95518c2a-cd34-4493-8bb1-4598cc85e908" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1ccc29c5-75a1-4429-8212-d2394da01207" name="localtimestamp" is-trigger-function="0" unique-function-name="localtimestamp" is-aggregate="f" language-name="sql" context="localtimestamp" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer" is-returning-set="f" ret-datatype="timestamp" function-arguments="p_precision integer DEFAULT 6" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22402" volatility="STABLE" is-window="f" function-identity-arguments="p_precision integer" overload-function-count="1" proc-language="sql" function-signature="localtimestamp(p_precision integer)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT 
    CASE
    
        WHEN p_precision = 0 THEN LOCALTIMESTAMP(0)
        WHEN p_precision = 1 THEN LOCALTIMESTAMP(1)
        WHEN p_precision = 2 THEN LOCALTIMESTAMP(3)
        WHEN p_precision = 4 THEN LOCALTIMESTAMP(4)
        WHEN p_precision = 5 THEN LOCALTIMESTAMP(5)

        ELSE LOCALTIMESTAMP

    END;
    
]]></complex-attribute>
                        <category _I_D="ee3b675d-53d4-49bc-b975-51e9de71da60" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2d07585a-d094-4e7f-ae46-65f39592db4c" name="months_between" is-trigger-function="0" unique-function-name="months_between" is-aggregate="f" language-name="sql" context="months_between" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone,timestamp without time zone" is-returning-set="f" ret-datatype="numeric" function-arguments="enddate1 timestamp without time zone, startdate2 timestamp without time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22403" volatility="IMMUTABLE" is-window="f" function-identity-arguments="enddate1 timestamp without time zone, startdate2 timestamp without time zone" overload-function-count="1" proc-language="sql" function-signature="months_between(enddate1 timestamp without time zone, startdate2 timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[

SELECT
    CASE
        WHEN DATE_TRUNC('DAY', $1) = DATE_TRUNC('DAY', $2) THEN
        
            0::NUMERIC

        WHEN EXTRACT(DAY FROM $1) = EXTRACT(DAY FROM $2) THEN

            ROUND
            (
                EXTRACT(YEARS FROM AGE($1, $2)) * 12 +
                EXTRACT(MONTHS FROM AGE($1, $2))  +
                EXTRACT(DAYS FROM AGE($1, $2)) /31 +
                EXTRACT(HOURS FROM AGE($1, $2)) /31 /24 +
                EXTRACT(SECONDS FROM AGE($1, $2)) /86400 /31
            )::NUMERIC

        WHEN DATE_TRUNC('DAY', aws_oracle_ext.last_day($1)) = DATE_TRUNC('DAY', $1) AND
            DATE_TRUNC('DAY', aws_oracle_ext.last_day($2)) = DATE_TRUNC('DAY', $2) THEN

            FLOOR
            (
                EXTRACT(YEARS FROM AGE($1, $2)) * 12 +
                EXTRACT(MONTHS FROM AGE($1, $2))  +
                EXTRACT(DAYS FROM AGE($1, $2)) /31 +
                EXTRACT(HOURS FROM AGE($1, $2)) /31 /24 +
                EXTRACT(SECONDS FROM AGE($1, $2)) /86400 /31
            )::NUMERIC

        ELSE

            (
                EXTRACT(YEARS FROM AGE($1, $2)) * 12 +
                EXTRACT(MONTHS FROM AGE($1, $2))  +
                EXTRACT(DAYS FROM AGE($1, $2)) /31 +
                EXTRACT(HOURS FROM AGE($1, $2)) /31 /24 +
                EXTRACT(SECONDS FROM AGE($1, $2)) /86400 /31
            )::NUMERIC

    END;

]]></complex-attribute>
                        <category _I_D="ee6e6a47-b9f3-4d29-8f85-799d8c301868" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1ad13cda-9491-4692-a616-15845f8af037" name="multiset_operator" is-trigger-function="0" unique-function-name="multiset_operator" is-aggregate="f" language-name="plpgsql" context="multiset_operator" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,anyelement,text,text,boolean" comment="Emulates MULTISET OPERATORS for Nested tables. Please, note collection members order (differs from Oracle)" is-returning-set="f" ret-datatype="text" function-arguments="poperator text, pfirsttable text, psecondtable text, pcollectiontype anyelement, pmode text DEFAULT 'ALL'::text, pstoreto text DEFAULT NULL::text, pisglobal boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="7" function-id="22404" volatility="VOLATILE" is-window="f" function-identity-arguments="poperator text, pfirsttable text, psecondtable text, pcollectiontype anyelement, pmode text, pstoreto text, pisglobal boolean" overload-function-count="1" proc-language="plpgsql" function-signature="multiset_operator(poperator text, pfirsttable text, psecondtable text, pcollectiontype anyelement, pmode text, pstoreto text, pisglobal boolean)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vSQL VARCHAR;
	vResultTable TEXT;
	vType VARCHAR;
    vFirstStorageTable VARCHAR;
    vSecondStorageTable VARCHAR;
    vResultStorageTable VARCHAR;

BEGIN

	vType := PG_TYPEOF(pCollectionType)::text;
	
    IF pIsGlobal THEN

        PERFORM aws_oracle_ext.array$copy
        (
            p_source_param_name => pFirstTable::JSONB ->> 'Array Name',
            p_source_procedure_name => pFirstTable::JSONB ->> 'Procedure Name',
            p_dest_param_name => 'ml1$'||(pFirstTable::JSONB ->> 'Array Name'),
            p_dest_procedure_name => pFirstTable::JSONB ->> 'Procedure Name'
        );

        PERFORM aws_oracle_ext.array$copy
        (
            p_source_param_name => pSecondTable::JSONB ->> 'Array Name',
            p_source_procedure_name => pSecondTable::JSONB ->> 'Procedure Name',
            p_dest_param_name => 'ml2$'||(pSecondTable::JSONB ->> 'Array Name'),
            p_dest_procedure_name => pSecondTable::JSONB ->> 'Procedure Name'
        );

        PERFORM aws_oracle_ext.array$create_storage_table
        (
            p_array_name => 'ml1$'||(pFirstTable::JSONB ->> 'Array Name'),
            p_procedure_name => pFirstTable::JSONB ->> 'Procedure Name',
            p_cast_type_name => vType
        );

        PERFORM aws_oracle_ext.array$create_storage_table
        (
            p_array_name => 'ml2$'||(pSecondTable::JSONB ->> 'Array Name'),
            p_procedure_name => pSecondTable::JSONB ->> 'Procedure Name',
            p_cast_type_name => vType
        );

        vFirstStorageTable := aws_oracle_ext.array$get_storage_table_name
        (
            --pFirstTable::JSONB ->> 'Array Name',
            p_array_path_without_indexes => 'ml1$'||(pFirstTable::JSONB ->> 'Array Name'),
            p_procedure_name => pFirstTable::JSONB ->> 'Procedure Name'
        );

        vSecondStorageTable := aws_oracle_ext.array$get_storage_table_name
        (
            --pSecondTable::JSONB ->> 'Array Name',
            p_array_path_without_indexes => 'ml2$'||(pSecondTable::JSONB ->> 'Array Name'),
            p_procedure_name => pSecondTable::JSONB ->> 'Procedure Name'
        );

        vResultStorageTable := aws_oracle_ext.array$get_storage_table_name
        (
            pStoreTo::JSONB ->> 'Array Name',
            pStoreTo::JSONB ->> 'Procedure Name'
        );

        IF vFirstStorageTable IS NULL OR
            vSecondStorageTable IS NULL OR
            vResultStorageTable IS NULL THEN

            RAISE USING MESSAGE := 'STG';

        END IF;

        vSql := CONCAT
        (
            'TRUNCATE TABLE ',
            vResultStorageTable
        );

        EXECUTE vSql;

        vSql := CONCAT
        (
            'ALTER SEQUENCE aws_oracle_ext$sq_',
            vResultStorageTable,
            ' RESTART WITH 1'
        );

        EXECUTE vSql;


        vSQL := CONCAT
        (
            'INSERT INTO ',
            vResultStorageTable,
            '(record_body)',
            CHR(10),
            'SELECT ROW_TO_JSON(mltst) FROM ('
            'SELECT f.* FROM ',
            vFirstStorageTable,
            ' CROSS JOIN LATERAL JSONB_POPULATE_RECORD(NULL::',
            vType,
            ', record_body) f',
            CHR(10),
            pOperator,
            ' ',
            pMode,
            CHR(10),
            'SELECT s.* FROM ',
            vSecondStorageTable,
            ' CROSS JOIN LATERAL JSONB_POPULATE_RECORD(NULL::',
            vType,
            ', record_body) s',
            CHR(10),
            ') mltst'
        );

        EXECUTE vSQL;

        PERFORM aws_oracle_ext.array$drop
        (
            p_array_name => 'ml1$'||(pFirstTable::JSONB ->> 'Array Name'),
            p_procedure_name => pFirstTable::JSONB ->> 'Procedure Name'
        );

        PERFORM aws_oracle_ext.array$drop
        (
            p_array_name => 'ml2$'||(pSecondTable::JSONB ->> 'Array Name'),
            p_procedure_name => pSecondTable::JSONB ->> 'Procedure Name'
        );

    ELSE
	
        vSQL := CONCAT(
            'SELECT ARRAY(',
            CHR(10),
            'SELECT UNNEST(CAST($1 '|| 'AS '||vType||'))',
            CHR(10),
            pOperator,
            ' ',
            pMode,
            CHR(10),
            'SELECT UNNEST(CAST ($2 AS '||vType||'))',
            CHR(10),
            ')::TExt'
        );

        EXECUTE vSQL USING pFirstTable, pSecondTable INTO vResultTable;

    END IF;

    RETURN vResultTable;
END;
]]></complex-attribute>
                        <category _I_D="2df0c6a3-0575-41a9-b1db-63864897721a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5e77726c-a15c-4d1c-880f-82f0eeda63ce" name="nanvl" is-trigger-function="0" unique-function-name="nanvl(double precision, character varying)" is-aggregate="f" language-name="sql" context="nanvl(double precision, character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,character varying" comment="Returns a substitute value when a value is not a number (NaN)" unique-suffix="(double precision, character varying)" routine-number="22500" is-returning-set="f" ret-datatype="float8" function-arguments="double precision, character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22500" volatility="IMMUTABLE" is-window="f" function-identity-arguments="double precision, character varying" overload-function-count="6" proc-language="sql" function-signature="nanvl(double precision, character varying)">
                        <complex-attribute name="sql"><![CDATA[ SELECT CASE WHEN $1 = 'NaN' THEN $2::FLOAT8 ELSE $1 END; ]]></complex-attribute>
                        <category _I_D="6b9ac3f4-c66b-41d5-8e36-2b4ead7d335e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="afec2479-5470-4f2a-bf09-0d596dc9fa10" name="nanvl" is-trigger-function="0" unique-function-name="nanvl(double precision, double precision)" is-aggregate="f" language-name="sql" context="nanvl(double precision, double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,double precision" comment="Returns a substitute value when a value is not a number (NaN)" unique-suffix="(double precision, double precision)" routine-number="22503" is-returning-set="f" ret-datatype="float8" function-arguments="double precision, double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22503" volatility="IMMUTABLE" is-window="f" function-identity-arguments="double precision, double precision" overload-function-count="6" proc-language="sql" function-signature="nanvl(double precision, double precision)">
                        <complex-attribute name="sql"><![CDATA[ SELECT CASE WHEN $1 = 'NaN' THEN $2 ELSE $1 END; ]]></complex-attribute>
                        <category _I_D="3829dbf9-8249-4f51-ba05-975f0c5ce4a7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3ccfcdcc-ea69-4a97-aa1f-7a4b62a683ce" name="nanvl" is-trigger-function="0" unique-function-name="nanvl(numeric, character varying)" is-aggregate="f" language-name="sql" context="nanvl(numeric, character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,character varying" comment="Returns a substitute value when a value is not a number (NaN)" unique-suffix="(numeric, character varying)" routine-number="22499" is-returning-set="f" ret-datatype="numeric" function-arguments="numeric, character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22499" volatility="IMMUTABLE" is-window="f" function-identity-arguments="numeric, character varying" overload-function-count="6" proc-language="sql" function-signature="nanvl(numeric, character varying)">
                        <complex-attribute name="sql"><![CDATA[ SELECT CASE WHEN $1 = 'NaN' THEN $2::NUMERIC ELSE $1 END; ]]></complex-attribute>
                        <category _I_D="44df141e-73b4-4500-9922-d5642231b10d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d20d74ad-fd2b-431e-8eae-d186cb45610e" name="nanvl" is-trigger-function="0" unique-function-name="nanvl(numeric, numeric)" is-aggregate="f" language-name="sql" context="nanvl(numeric, numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric" comment="Returns a substitute value when a value is not a number (NaN)" unique-suffix="(numeric, numeric)" routine-number="22502" is-returning-set="f" ret-datatype="numeric" function-arguments="numeric, numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22502" volatility="IMMUTABLE" is-window="f" function-identity-arguments="numeric, numeric" overload-function-count="6" proc-language="sql" function-signature="nanvl(numeric, numeric)">
                        <complex-attribute name="sql"><![CDATA[ SELECT CASE WHEN $1 = 'NaN' THEN $2 ELSE $1 END; ]]></complex-attribute>
                        <category _I_D="96dc72bc-0e29-4317-ada7-07548a22edbc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5222094d-fcfc-4e1a-8d62-4666bffb9e81" name="nanvl" is-trigger-function="0" unique-function-name="nanvl(real, character varying)" is-aggregate="f" language-name="sql" context="nanvl(real, character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="real,character varying" comment="Returns a substitute value when a value is not a number (NaN)" unique-suffix="(real, character varying)" routine-number="22501" is-returning-set="f" ret-datatype="float4" function-arguments="real, character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22501" volatility="IMMUTABLE" is-window="f" function-identity-arguments="real, character varying" overload-function-count="6" proc-language="sql" function-signature="nanvl(real, character varying)">
                        <complex-attribute name="sql"><![CDATA[ SELECT CASE WHEN $1 = 'NaN' THEN $2::FLOAT4 ELSE $1 END; ]]></complex-attribute>
                        <category _I_D="c17411ce-ffde-4930-9f00-ac58576731b3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0f93a84b-2471-4f9a-9454-cace3391e8b8" name="nanvl" is-trigger-function="0" unique-function-name="nanvl(real, real)" is-aggregate="f" language-name="sql" context="nanvl(real, real)" subcategories-loading="none" object-loading="extended" arguments-datatypes="real,real" comment="Returns a substitute value when a value is not a number (NaN)" unique-suffix="(real, real)" routine-number="22504" is-returning-set="f" ret-datatype="float4" function-arguments="real, real" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22504" volatility="IMMUTABLE" is-window="f" function-identity-arguments="real, real" overload-function-count="6" proc-language="sql" function-signature="nanvl(real, real)">
                        <complex-attribute name="sql"><![CDATA[ SELECT CASE WHEN $1 = 'NaN' THEN $2 ELSE $1 END; ]]></complex-attribute>
                        <category _I_D="0a8b5cc3-3573-44b6-a567-d038820d551d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f6973fdb-d446-4e2a-b0d3-81f707dee6a7" name="nested_table$add_fields_to_array" is-trigger-function="0" unique-function-name="nested_table$add_fields_to_array" is-aggregate="f" language-name="plpgsql" context="nested_table$add_fields_to_array" subcategories-loading="none" object-loading="extended" arguments-datatypes="bigint,text" is-returning-set="f" ret-datatype="void" function-arguments="p_array_id bigint, p_fields text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22025" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_array_id bigint, p_fields text" overload-function-count="1" proc-language="plpgsql" function-signature="nested_table$add_fields_to_array(p_array_id bigint, p_fields text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
END;
]]></complex-attribute>
                        <category _I_D="7a27246e-555b-4271-9e66-0de25c5fa94f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5137ea5e-f36e-41e3-8184-92d738ab589b" name="nested_table$first" is-trigger-function="0" unique-function-name="nested_table$first" is-aggregate="f" language-name="sql" context="nested_table$first" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,anyelement" is-returning-set="f" ret-datatype="anyelement" function-arguments="p_array_path character varying, p_procedure_name character varying, p_def anyelement DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22030" volatility="VOLATILE" is-window="f" function-identity-arguments="p_array_path character varying, p_procedure_name character varying, p_def anyelement" overload-function-count="1" proc-language="sql" function-signature="nested_table$first(p_array_path character varying, p_procedure_name character varying, p_def anyelement)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT aws_oracle_ext.collection_first
    (
        p_routine_name => p_procedure_name,
        p_collection_path => p_array_path,
        p_tp => p_def
    );

]]></complex-attribute>
                        <category _I_D="b7e84812-2331-4330-af26-a8ac9ce12770" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="fec64202-7453-4497-866f-04c1afb92954" name="nested_table$get_value" is-trigger-function="0" unique-function-name="nested_table$get_value" is-aggregate="f" language-name="plpgsql" context="nested_table$get_value" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,anyelement" is-returning-set="f" ret-datatype="anyelement" function-arguments="p_array_value_path character varying, p_procedure_name character varying, p_value_datatype anyelement DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22031" volatility="VOLATILE" is-window="f" function-identity-arguments="p_array_value_path character varying, p_procedure_name character varying, p_value_datatype anyelement" overload-function-count="1" proc-language="plpgsql" function-signature="nested_table$get_value(p_array_value_path character varying, p_procedure_name character varying, p_value_datatype anyelement)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vret JSONB;
BEGIN

    vret := aws_oracle_ext.collection_element_get
	(
		p_routine_name => p_procedure_name,
        p_collection_path => p_array_value_path
	);

    IF vret IS NULL THEN

        RAISE NO_DATA_FOUND;

    END IF;

    RETURN JSONB_POPULATE_RECORD
    (
        p_value_datatype,
        vret
    );

END;
]]></complex-attribute>
                        <category _I_D="9dda88b5-0694-485f-8950-4eaf6941f385" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a89310ff-eafc-4269-9065-241337745ec7" name="nested_table$last" is-trigger-function="0" unique-function-name="nested_table$last" is-aggregate="f" language-name="sql" context="nested_table$last" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,anyelement" is-returning-set="f" ret-datatype="anyelement" function-arguments="p_array_path character varying, p_procedure_name character varying, p_def anyelement DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22032" volatility="VOLATILE" is-window="f" function-identity-arguments="p_array_path character varying, p_procedure_name character varying, p_def anyelement" overload-function-count="1" proc-language="sql" function-signature="nested_table$last(p_array_path character varying, p_procedure_name character varying, p_def anyelement)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT aws_oracle_ext.collection_last
    (
        p_routine_name => p_procedure_name,
        p_collection_path => p_array_path,
        p_tp => p_def
    );

]]></complex-attribute>
                        <category _I_D="1c52cbc7-9702-4efd-bfd1-bcf14288cd04" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7f0cea84-fcfa-4ebb-b5e9-43436e0d6a6e" name="nested_table$next" is-trigger-function="0" unique-function-name="nested_table$next" is-aggregate="f" language-name="sql" context="nested_table$next" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying,anyelement" is-returning-set="f" ret-datatype="anyelement" function-arguments="p_array_path character varying, p_array_key character varying, p_procedure_name character varying, p_def anyelement DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22033" volatility="VOLATILE" is-window="f" function-identity-arguments="p_array_path character varying, p_array_key character varying, p_procedure_name character varying, p_def anyelement" overload-function-count="1" proc-language="sql" function-signature="nested_table$next(p_array_path character varying, p_array_key character varying, p_procedure_name character varying, p_def anyelement)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT aws_oracle_ext.collection_next
	(
		p_routine_name => p_procedure_name,
        p_collection_path => p_array_path,
        p_idx => p_array_key,
        p_tp => p_def
	);

]]></complex-attribute>
                        <category _I_D="7f00b60e-b217-4d4a-98b0-43d94fe98a65" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9ba1eee2-2152-496d-b251-24428ef50a14" name="nested_table$prior" is-trigger-function="0" unique-function-name="nested_table$prior" is-aggregate="f" language-name="sql" context="nested_table$prior" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying,anyelement" is-returning-set="f" ret-datatype="anyelement" function-arguments="p_array_path character varying, p_array_key character varying, p_procedure_name character varying, p_def anyelement DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22034" volatility="VOLATILE" is-window="f" function-identity-arguments="p_array_path character varying, p_array_key character varying, p_procedure_name character varying, p_def anyelement" overload-function-count="1" proc-language="sql" function-signature="nested_table$prior(p_array_path character varying, p_array_key character varying, p_procedure_name character varying, p_def anyelement)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT aws_oracle_ext.collection_prior
	(
		p_routine_name => p_procedure_name,
        p_collection_path => p_array_path,
        p_idx => p_array_key,
        p_tp => p_def
	);

]]></complex-attribute>
                        <category _I_D="71f0f49c-9bfb-4697-b027-9c4e983fcd4d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4f526cc3-f976-4ed3-84d1-ac49a69a957f" name="nested_table$set_value" is-trigger-function="0" unique-function-name="nested_table$set_value" is-aggregate="f" language-name="sql" context="nested_table$set_value" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,anyelement" is-returning-set="f" ret-datatype="void" function-arguments="p_array_path character varying, p_procedure_name character varying, p_value anyelement" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22035" volatility="VOLATILE" is-window="f" function-identity-arguments="p_array_path character varying, p_procedure_name character varying, p_value anyelement" overload-function-count="1" proc-language="sql" function-signature="nested_table$set_value(p_array_path character varying, p_procedure_name character varying, p_value anyelement)">
                        <complex-attribute name="sql"><![CDATA[

    SELECT aws_oracle_ext.collection_element_set
    (
        p_routine_name => p_procedure_name,
        p_collection_path => p_array_path,
        p_val => p_value
    );

]]></complex-attribute>
                        <category _I_D="546f24df-294d-4526-bb31-33cd0d22e0a9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="23c1e098-0d98-47b4-8a66-128a992f6415" name="next" is-trigger-function="0" unique-function-name="next" is-aggregate="f" language-name="sql" context="next" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,integer" is-returning-set="f" ret-datatype="int4" function-arguments="pcollection anyarray, n integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22405" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pcollection anyarray, n integer" overload-function-count="1" proc-language="sql" function-signature="next(pcollection anyarray, n integer)">
                        <complex-attribute name="sql"><![CDATA[  
    /*the function is depricated. collection_%METHOD_NAME% has to be used instead*/
    SELECT
        CASE
            WHEN COALESCE(ARRAY_LENGTH(pcollection, 1), 0) = 0 THEN
                NULL
            WHEN n >= ARRAY_LENGTH(pcollection, 1) THEN
                NULL
            WHEN n < 1 THEN
                1::INT
            ELSE 
                n + 1
        END;

]]></complex-attribute>
                        <category _I_D="070de016-bd26-4aed-aac6-0b4c185d7510" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c39ad8d0-0c93-4dee-be23-774afbabf53d" name="next_day" is-trigger-function="0" unique-function-name="next_day" is-aggregate="f" language-name="sql" context="next_day" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone,text" is-returning-set="f" ret-datatype="timestamp" function-arguments="ddate timestamp without time zone, cchar text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22463" volatility="IMMUTABLE" is-window="f" function-identity-arguments="ddate timestamp without time zone, cchar text" overload-function-count="1" proc-language="sql" function-signature="next_day(ddate timestamp without time zone, cchar text)">
                        <complex-attribute name="sql"><![CDATA[

    WITH calc AS
    (
        SELECT t.v,
            TO_CHAR(t,'DY') AS wd
        FROM GENERATE_SERIES
        (
            ddate::TIMESTAMP(0),
            ddate::TIMESTAMP(0) + '7 days'::INTERVAL,
            '1 day'
        ) AS t(v)
    )
    SELECT v
    FROM calc
    WHERE calc.wd = SUBSTR(UPPER(cchar), 1, 3)
    AND v > ddate::TIMESTAMP(0)
    LIMIT 1;

]]></complex-attribute>
                        <category _I_D="91ecb7dc-6b78-4b10-bbf8-b7435479e038" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="34a0771a-2486-46f6-83ff-fe645ead99fa" name="nls_parameters_init" is-trigger-function="0" unique-function-name="nls_parameters_init" is-aggregate="f" language-name="plpgsql" context="nls_parameters_init" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,boolean" comment="This function sets some NLS session parameters on the first TO_CHAR\TO_DATE\TO_NUMBER call" is-returning-set="f" ret-datatype="void" function-arguments="pterritory text DEFAULT NULL::text, precalc boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22273" volatility="VOLATILE" is-window="f" function-identity-arguments="pterritory text, precalc boolean" overload-function-count="1" proc-language="plpgsql" function-signature="nls_parameters_init(pterritory text, precalc boolean)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vNlsTerritory TEXT;
    vctype TEXT;
    rec RECORD;
    vrecalc BOOLEAN DEFAULT FALSE;
BEGIN
    
    IF precalc THEN

        vrecalc := TRUE;

    ELSE

        vrecalc := CASE WHEN COALESCE(UPPER(aws_oracle_ext.get_extpack_variable(variable_name => 'RECALCNLS', missing_ok => TRUE)), 'TRUE') <> 'TRUE' THEN FALSE ELSE TRUE END;

    END IF;
    
    IF vrecalc THEN

        IF pterritory IS NULL THEN

            SELECT SPLIT_PART(pd.datctype::TEXT, '.', 1)
            INTO vctype
            FROM pg_database pd
            WHERE pd.datname = CURRENT_DATABASE();

            SELECT ap.nls_territory
            INTO vNlsTerritory
            FROM aws_oracle_ext.nls_parameters ap
            WHERE ap.pg_territory_ux = vctype
            ORDER BY 1
            LIMIT 1;

            IF NOT FOUND THEN

                vNlsTerritory := 'AMERICA';

            END IF;
        ELSE

            SELECT ap.nls_territory
            INTO vNlsTerritory
            FROM aws_oracle_ext.nls_parameters ap
            WHERE ap.nls_territory = pterritory;

            IF NOT FOUND THEN

                vNlsTerritory := 'AMERICA';

            END IF;

        END IF;
        
        FOR rec IN
        (
            SELECT anp.nls_territory,
                anp.params_dictionary ->> 'NLS_CURRENCY' AS NLS_CURRENCY,
                anp.params_dictionary ->> 'NLS_ISO_CURRENCY' AS NLS_ISO_CURRENCY,
                anp.params_dictionary ->> 'NLS_DATE_FORMAT' AS NLS_DATE_FORMAT,
                anp.params_dictionary ->> 'NLS_DUAL_CURRENCY' AS NLS_DUAL_CURRENCY,
                anp.params_dictionary ->> 'NLS_NUMERIC_CHARACTERS' AS NLS_NUMERIC_CHARACTERS,
                anp.params_dictionary ->> 'NLS_CALENDAR' AS nls_calendar,
                anp.params_dictionary ->> 'NLS_CHARACTERSET' AS nls_characterset,
                anp.params_dictionary ->> 'NLS_COMP' AS nls_comp,
                anp.params_dictionary ->> 'NLS_DATE_LANGUAGE' AS nls_date_language,
                anp.params_dictionary ->> 'NLS_LANGUAGE' AS nls_language,
                anp.params_dictionary ->> 'NLS_LENGTH_SEMANTICS' AS nls_length_semantics,
                anp.params_dictionary ->> 'NLS_NCHAR_CHARACTERSET' AS nls_nchar_characterset,
                anp.params_dictionary ->> 'NLS_NCHAR_CONV_EXCP' AS nls_nchar_conv_excp,
                anp.params_dictionary ->> 'NLS_SORT' AS nls_sort,
                anp.params_dictionary ->> 'NLS_TERRITORY' AS nls_territory,
                anp.params_dictionary ->> 'NLS_TIMESTAMP_FORMAT' AS nls_timestamp_format,
                anp.params_dictionary ->> 'NLS_TIMESTAMP_TZ_FORMAT' AS nls_timestamp_tz_format,
                anp.params_dictionary ->> 'NLS_TIME_FORMAT' AS nls_time_format,
                anp.params_dictionary ->> 'NLS_TIME_TZ_FORMAT' AS nls_time_tz_format

            FROM aws_oracle_ext.nls_parameters anp
            WHERE anp.nls_territory = vNlsTerritory
        )
        LOOP

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_TERRITORY',
                variable_value => rec.nls_territory::TEXT
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_CURRENCY',
                variable_value => rec.nls_currency::TEXT
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_ISO_CURRENCY',
                variable_value => rec.nls_iso_currency::TEXT
            );
            
            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_DATE_FORMAT',
                variable_value => rec.nls_date_format::TEXT
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_DUAL_CURRENCY',
                variable_value => rec.nls_dual_currency::TEXT
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_NUMERIC_CHARACTERS',
                variable_value => rec.nls_numeric_characters::TEXT
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_CALENDAR',
                variable_value => rec.nls_calendar
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_CHARACTERSET',
                variable_value => rec.nls_characterset
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_COMP',
                variable_value => rec.nls_comp
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_DATE_LANGUAGE',
                variable_value => rec.nls_date_language
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_LANGUAGE',
                variable_value => rec.nls_language
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_LENGTH_SEMANTICS',
                variable_value => rec.nls_length_semantics
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_NCHAR_CHARACTERSET',
                variable_value => rec.nls_nchar_characterset
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_NCHAR_CONV_EXCP',
                variable_value => rec.nls_nchar_conv_excp
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_SORT',
                variable_value => rec.nls_sort
            );
            
            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_TERRITORY',
                variable_value => rec.nls_territory
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_TIMESTAMP_FORMAT',
                variable_value => rec.nls_timestamp_format
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_TIMESTAMP_TZ_FORMAT',
                variable_value => rec.nls_timestamp_tz_format
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_TIME_FORMAT',
                variable_value => rec.nls_timestamp_tz_format
            );

            PERFORM aws_oracle_ext.set_package_variable
            (
                variable_name => 'NLS_TIME_TZ_FORMAT',
                variable_value => rec.nls_timestamp_tz_format
            );

        END LOOP;

    PERFORM aws_oracle_ext.set_package_variable
    (
        variable_name => 'RECALCNLS',
        variable_value => FALSE::TEXT
    );

    END IF;

END;

]]></complex-attribute>
                        <category _I_D="b7da43be-bc9a-4439-ba05-216bf913b3f0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c1414dc7-d60f-4d9b-a5ad-133ec07e15ef" name="number_limit_correct" is-trigger-function="0" unique-function-name="number_limit_correct" is-aggregate="f" language-name="plpgsql" context="number_limit_correct" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" comment="Check if value is in range for Oracle Number" is-returning-set="f" ret-datatype="numeric" function-arguments="pval numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22406" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pval numeric" overload-function-count="1" proc-language="plpgsql" function-signature="number_limit_correct(pval numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    IF pVal < -1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    OR pVal > 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    THEN

        RAISE USING MESSAGE := 'ORA-01426: numeric overflow', HINT := '-01426';

    END IF;

    RETURN pVal;
    
END;
]]></complex-attribute>
                        <category _I_D="20b5058a-619c-4a74-ae2b-a3c70290db82" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dc8bd729-2fb7-4c7e-9799-78d3e16e40a2" name="owa$init_cgi_env" is-trigger-function="0" unique-function-name="owa$init_cgi_env" is-aggregate="f" language-name="plpgsql" context="owa$init_cgi_env" subcategories-loading="none" object-loading="extended" arguments-datatypes="json" is-returning-set="f" ret-datatype="void" function-arguments="pparams json" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22521" volatility="VOLATILE" is-window="f" function-identity-arguments="pparams json" overload-function-count="1" proc-language="plpgsql" function-signature="owa$init_cgi_env(pparams json)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    CREATE TEMPORARY TABLE IF NOT EXISTS aws_cgi_env
    (
        id BIGINT NOT NULL GENERATED ALWAYS AS IDENTITY,
        cgi_var_name TEXT NULL,
        cgi_var_val TEXT NULL,
        CONSTRAINT ht_headers_pk PRIMARY KEY (id)
    );

    TRUNCATE TABLE aws_cgi_env;

    INSERT INTO aws_cgi_env(cgi_var_name, cgi_var_val)
    SELECT * FROM JSON_EACH_TEXT(pParams);

    INSERT INTO aws_cgi_env(cgi_var_name, cgi_var_val)
    VALUES ('REMOTE_USER', CURRENT_SCHEMA());


END;
]]></complex-attribute>
                        <category _I_D="20d69307-b728-4fd2-aa92-046ebd84d02f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9662765c-1f81-4f93-8599-f9fee67a33d5" name="owa_cookie$get" is-trigger-function="0" unique-function-name="owa_cookie$get" is-aggregate="f" language-name="plpgsql" context="owa_cookie$get" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="json" function-arguments="name text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22527" volatility="VOLATILE" is-window="f" function-identity-arguments="name text" overload-function-count="1" proc-language="plpgsql" function-signature="owa_cookie$get(name text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    http_cookie TEXT;
    vResult JSON;
BEGIN

    http_cookie := aws_oracle_ext.owa_util$get_cgi_env('HTTP_COOKIE');

    TRUNCATE TABLE aws_cgi_cookie;

    IF LENGTH(COALESCE(TRIM(http_cookie),'')) <> 0 THEN

        INSERT INTO aws_cgi_cookie(cookie_name, cookie_val)
        SELECT
            SUBSTR
            (
                LTRIM(v),
                1,
                STRPOS
                (
                    LTRIM(v),
                    '='
                ) - 1
            ),
            SUBSTR
            (
                LTRIM(v),
                STRPOS(LTRIM(v), '=') + 1
            )
        FROM REGEXP_SPLIT_TO_TABLE(SUBSTR(http_cookie, 1, LENGTH(http_cookie) - 1), ';') v;

    END IF;

    SELECT JSON_BUILD_OBJECT
    (
        'name', cookie_name
        ,
        'vals', vals
        ,
        'num_vals', num_vals
    )
    INTO vResult
    FROM
    (
        SELECT cookie_name,
            COUNT(cookie_val_id) AS num_vals,
        ARRAY_AGG(cookie_val) AS vals
        FROM aws_cgi_cookie 
        WHERE cookie_name = name
        GROUP BY cookie_name
    ) z;

    IF vResult IS NULL THEN

        vResult := JSON_BUILD_OBJECT
        (
            'name', name
            ,
            'num_vals', 0
        );

    END IF;


    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="ab173273-a5b9-4caf-935c-7502ce47523d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0129197e-d485-4c28-823f-9060a8f8101f" name="owa_cookie$send" is-trigger-function="0" unique-function-name="owa_cookie$send" is-aggregate="f" language-name="plpgsql" context="owa_cookie$send" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,timestamp without time zone,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="name text, value text, expires timestamp without time zone DEFAULT NULL::timestamp without time zone, path text DEFAULT NULL::text, domain text DEFAULT NULL::text, secure text DEFAULT NULL::text, httponly text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="7" function-id="22528" volatility="VOLATILE" is-window="f" function-identity-arguments="name text, value text, expires timestamp without time zone, path text, domain text, secure text, httponly text" overload-function-count="1" proc-language="plpgsql" function-signature="owa_cookie$send(name text, value text, expires timestamp without time zone, path text, domain text, secure text, httponly text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$print
    (
        CONCAT
        (
            'Set-Cookie: ',
            name,
            '=',
            value,
            ';',
            CASE
                WHEN expires IS NOT NULL THEN
                    CONCAT(' expires=', aws_oracle_ext.to_char(expires, 'DD-Mon-YYYY HH24:MI:SS', 'NLS_DATE_LANGUAGE=en_US'), ';')
                ELSE
                    ''
            END,
            CASE
                WHEN path IS NOT NULL THEN
                    CONCAT(' path=', path, ';')
                ELSE
                    ''
            END,
            CASE
                WHEN domain IS NOT NULL THEN
                    CONCAT(' domain=', domain, ';')
                ELSE
                    ''
            END,
            CASE
                WHEN secure IS NOT NULL THEN
                    ' secure;'
                ELSE
                    ''
            END,
            CASE
                WHEN httponly IS NOT NULL THEN
                    ' HttpOnly'
                ELSE
                    ''
            END
        )
    );

END;
]]></complex-attribute>
                        <category _I_D="8a0d2a3f-20f4-4b25-b5ab-4fbbf50b41bd" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4bbf3ee5-0e6d-41e1-ad94-e71a0ddd1b0f" name="owa_util$get_cgi_env" is-trigger-function="0" unique-function-name="owa_util$get_cgi_env" is-aggregate="f" language-name="plpgsql" context="owa_util$get_cgi_env" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="text" function-arguments="param_name text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22524" volatility="VOLATILE" is-window="f" function-identity-arguments="param_name text" overload-function-count="1" proc-language="plpgsql" function-signature="owa_util$get_cgi_env(param_name text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vResult TEXT;
BEGIN

    SELECT cgi_var_val
    INTO vResult
    FROM aws_cgi_env
    WHERE UPPER(cgi_var_name) = UPPER(param_name)
    ORDER BY id
    LIMIT 1;

    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="14378192-89f9-4a5c-b351-4e937af1ea52" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="230cb3db-cdaa-45fe-aab4-06ee8f41161e" name="owa_util$get_owa_service_path" is-trigger-function="0" unique-function-name="owa_util$get_owa_service_path" is-aggregate="f" language-name="plpgsql" context="owa_util$get_owa_service_path" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22525" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="owa_util$get_owa_service_path()">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    script_name TEXT;
BEGIN

    script_name := aws_oracle_ext.owa_util$get_cgi_env('SCRIPT_NAME');

    script_name := CONCAT
    (
        script_name,
        CASE
            WHEN SUBSTR(script_name,-1) = '/' then
                ''
            ELSE
                '/'
        END
    );
    
    RETURN script_name;

END;
]]></complex-attribute>
                        <category _I_D="1e0375e9-51fd-4a05-816d-6c5ffacbe0b2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="73f6e4b5-05c9-4674-92f5-ad7709cb05d7" name="owa_util$http_header_close" is-trigger-function="0" unique-function-name="owa_util$http_header_close" is-aggregate="f" language-name="plpgsql" context="owa_util$http_header_close" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22777" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="owa_util$http_header_close()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$prn(E'\n');
    
END;
]]></complex-attribute>
                        <category _I_D="bae877df-f727-483c-9965-507bf995488f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b390acbb-3825-42c8-9502-ec8da2d21533" name="owa_util$mime_header" is-trigger-function="0" unique-function-name="owa_util$mime_header" is-aggregate="f" language-name="plpgsql" context="owa_util$mime_header" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,boolean,text" is-returning-set="f" ret-datatype="void" function-arguments="ccontent_type text DEFAULT 'text/html'::text, bclose_header boolean DEFAULT true, ccharset text DEFAULT 'MaGiC_KeY'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22776" volatility="VOLATILE" is-window="f" function-identity-arguments="ccontent_type text, bclose_header boolean, ccharset text" overload-function-count="1" proc-language="plpgsql" function-signature="owa_util$mime_header(ccontent_type text, bclose_header boolean, ccharset text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    charset VARCHAR(40);
BEGIN

    IF ccharset = 'MaGiC_KeY' THEN

        IF UPPER(ccontent_type) LIKE 'TEXT%' THEN

            charset := aws_oracle_ext.owa_util$get_cgi_env('REQUEST_IANA_CHARSET');
            
            IF charset IS NULL THEN
               
                PERFORM aws_oracle_ext.htp$prn
                (
                    CONCAT
                    (
                        'Content-type: ',
                        ccontent_type,
                        E'\n'
                    )
                );

            ELSE

                PERFORM aws_oracle_ext.htp$prn
                (
                    CONCAT
                    (
                        'Content-type: ',
                        ccontent_type,
                        '; charset=',
                        charset,
                        E'\n'
                    )
                );

            END IF;

         ELSE

            PERFORM aws_oracle_ext.htp$prn
            (
                CONCAT
                (
                    'Content-type: ',
                    ccontent_type,
                    E'\n'
                )
            );

        END IF;

    ELSE
         
         IF charset IS NULL THEN

            PERFORM aws_oracle_ext.htp$prn
            (
                CONCAT
                (
                    'Content-type: ',
                    ccontent_type,
                    E'\n'
                )
            );

         ELSE
            
            PERFORM aws_oracle_ext.htp$prn
            (
                CONCAT
                (
                    'Content-type: ',
                    ccontent_type,
                    '; charset=',
                    charset,
                    E'\n'
                )
            );

         END IF;

    END IF;

    IF bclose_header THEN

        PERFORM aws_oracle_ext.owa_util$http_header_close();

    END IF;

END;
]]></complex-attribute>
                        <category _I_D="6cb4a2c9-223e-49ea-aff9-7e26fd700b89" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="54d921fe-d94c-48ed-9960-29e74f9f42b8" name="owa_util$print_cgi_env" is-trigger-function="0" unique-function-name="owa_util$print_cgi_env" is-aggregate="f" language-name="plpgsql" context="owa_util$print_cgi_env" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22523" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="owa_util$print_cgi_env()">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    rec RECORD;
BEGIN

    FOR rec IN
    (
        SELECT cgi_var_name,
            cgi_var_val
        FROM aws_cgi_env
        ORDER BY id
    ) LOOP
        
        PERFORM aws_oracle_ext.htp$print
        (
            CONCAT
            (
                rec.cgi_var_name,
                ' = ',
                rec.cgi_var_val,
                aws_oracle_ext.htf$nl()
            )
        );

    END LOOP;
    
END;
]]></complex-attribute>
                        <category _I_D="3a370f29-0a96-4c5f-8822-7ac66fde196b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e029470f-662f-4bbb-b283-53cf0cf6af09" name="owa_util$redirect_url" is-trigger-function="0" unique-function-name="owa_util$redirect_url" is-aggregate="f" language-name="plpgsql" context="owa_util$redirect_url" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,boolean" is-returning-set="f" ret-datatype="void" function-arguments="curl text, bclose_header boolean DEFAULT true" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22526" volatility="VOLATILE" is-window="f" function-identity-arguments="curl text, bclose_header boolean" overload-function-count="1" proc-language="plpgsql" function-signature="owa_util$redirect_url(curl text, bclose_header boolean)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.owa_util$status_line
    (
        nstatus      => 302,
        bclose_header => FALSE
    );
    
    PERFORM aws_oracle_ext.htp$prn
    (
        CONCAT
        (
            'Location: ',
            curl,
            E'\n'
        )
    );

    IF bclose_header THEN

        PERFORM aws_oracle_ext.owa_util$http_header_close();

    END IF;

END;
]]></complex-attribute>
                        <category _I_D="cbae58c8-f9a9-4ddb-a380-18455de97b7e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="46c76e5c-5a1c-405a-983e-0855ac0fa9c5" name="owa_util$status_line" is-trigger-function="0" unique-function-name="owa_util$status_line" is-aggregate="f" language-name="plpgsql" context="owa_util$status_line" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text,boolean" is-returning-set="f" ret-datatype="void" function-arguments="nstatus numeric, creason text DEFAULT NULL::text, bclose_header boolean DEFAULT true" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22522" volatility="VOLATILE" is-window="f" function-identity-arguments="nstatus numeric, creason text, bclose_header boolean" overload-function-count="1" proc-language="plpgsql" function-signature="owa_util$status_line(nstatus numeric, creason text, bclose_header boolean)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.htp$prn
    (
        CONCAT
        (
            'Status: ',
            nstatus,
            ' ',
            creason,
            E'\n'
        )
    );

    IF (bclose_header) THEN
        
        PERFORM aws_oracle_ext.owa_util$http_header_close();

    END IF;
    
END;
]]></complex-attribute>
                        <category _I_D="d87a6ce2-3f03-4d0b-b031-96b6dbd04b78" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="20a3f653-ef25-43ef-a64d-1d69bca650bd" name="owa_wrapper" is-trigger-function="0" unique-function-name="owa_wrapper" is-aggregate="f" language-name="plpgsql" context="owa_wrapper" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,json" is-returning-set="f" ret-datatype="void" function-arguments="proutinepath text, pparams json" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22779" volatility="VOLATILE" is-window="f" function-identity-arguments="proutinepath text, pparams json" overload-function-count="1" proc-language="plpgsql" function-signature="owa_wrapper(proutinepath text, pparams json)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vSchema TEXT;
    vRoutineName TEXT;
    vRarray TEXT[];
    vStatusCode SMALLINT DEFAULT 404;
    vStatusDescription TEXT;
    vRoutineExists SMALLINT DEFAULT 0;
    rec RECORD;
    vParamsPassed TEXT[];
    vParamsExpected TEXT[];
    vSQL TEXT;
    vDefaults JSONB;
    vArgs TEXT;
BEGIN

    vRarray := REGEXP_SPLIT_TO_ARRAY(pRoutinePath, '\.');

    IF ARRAY_LENGTH(vRarray, 1) = 1 THEN

        vSchema := CURRENT_SCHEMA();
        vRoutineName := vRarray[1];

    ELSE

        vSchema := vRarray[1];

        vRoutineName := ARRAY_TO_STRING(ARRAY_REMOVE(vRarray, vSchema), '');

    END IF;

    IF vSchema IS NOT NULL THEN

        SELECT COUNT(*)
        INTO vRoutineExists
        FROM pg_proc p
        JOIN pg_namespace n ON p.pronamespace = n.oid
        WHERE n.nspname = TRIM(LOWER(vSchema))
        AND p.proname = TRIM(LOWER(vRoutineName));

    END IF;

    IF vRoutineExists = 1 THEN

        SELECT COALESCE(
            ARRAY_AGG(V),
            ARRAY[]::TEXT[]
        )
        INTO vParamsPassed
        FROM JSON_OBJECT_KEYS(pParams) AS v;

        <<procsearch>>
        FOR rec IN
        (
            SElECT p.oid,
                p.proname,
                p.proargnames,
                p.pronargdefaults,
                p.proargtypes
            FROM pg_proc p
            JOIN pg_namespace n ON p.pronamespace = n.oid
            WHERE n.nspname = TRIM(LOWER(vSchema))
            AND p.proname = TRIM(LOWER(vRoutineName))
        )
        LOOP

            CASE
                
                WHEN rec.proargnames IS NULL AND vParamsPassed = ARRAY[]::TEXT[] THEN

                    vArgs := '';

                WHEN rec.pronargdefaults > 0 AND vParamsPassed <@ rec.proargnames AND rec.proargnames IS NOT NULL THEN

                    FOR i IN 1..ARRAY_LENGTH(rec.proargnames, 1) LOOP

                        IF NOT pParams::JSONB ? rec.proargnames[i]
                            AND PG_GET_FUNCTION_ARG_DEFAULT(rec.oid, i) IS NULL THEN

                            RAISE SQLSTATE '42883';

                        END IF;

                        vArgs := CONCAT(
                            vArgs,
                            rec.proargnames[i],
                            ' => ',
                            CASE
                                WHEN pParams::JSONB ? rec.proargnames[i] THEN
                                    CONCAT(
                                        CASE WHEN rec.proargtypes[i - 1] <> 701 AND LENGTH(COALESCE(pParams->rec.proargnames[i]->>0, '')) <> 0 THEN E'\'' ELSE '' END,
                                        CASE WHEN LENGTH(COALESCE(pParams->rec.proargnames[i]->>0, '')) = 0 THEN 'NULL' ELSE pParams->rec.proargnames[i]->>0 END,
                                        CASE WHEN rec.proargtypes[i - 1] <> 701 AND LENGTH(COALESCE(pParams->rec.proargnames[i]->>0, '')) <> 0 THEN E'\'' ELSE '' END,
                                        '::',
                                        CASE WHEN rec.proargtypes[i - 1] = 701 THEN 'DOUBLE PRECISION' ELSE 'TEXT' END      
                                    )
                                ELSE
                                    PG_GET_FUNCTION_ARG_DEFAULT(rec.oid, i)
                            END,
                            CASE WHEN i = ARRAY_LENGTH(rec.proargnames, 1) THEN '' ELSE ',' END
                        );

                    END LOOP;

                WHEN rec.pronargdefaults = 0 AND 
                    (JSONB_ARRAY_LENGTH(TO_JSONB(vParamsPassed)) = ARRAY_LENGTH(rec.proargnames, 1)) AND
                    TO_JSONB(vParamsPassed) ?& rec.proargnames THEN

                    FOR i IN 1..ARRAY_LENGTH(rec.proargnames, 1) LOOP

                        vArgs := CONCAT(
                            vArgs,
                            rec.proargnames[i],
                            ' => ',
                            CASE WHEN rec.proargtypes[i - 1] <> 701 THEN E'\'' ELSE '' END,
                            pParams->rec.proargnames[i]->>0,
                            CASE WHEN rec.proargtypes[i - 1] <> 701 THEN E'\'' ELSE '' END,
                            '::',
                            CASE WHEN rec.proargtypes[i - 1] = 701 THEN 'DOUBLE PRECISION' ELSE 'TEXT' END,
                            CASE WHEN i = ARRAY_LENGTH(rec.proargnames, 1) THEN '' ELSE ',' END
                        );

                    END LOOP;

                ELSE

                    CONTINUE procsearch;

            END CASE;

        END LOOP procsearch;

        IF vArgs IS NOT NULL THEN

            vSQL := CONCAT(
                'SELECT ',
                TRIM(LOWER(vSchema)),
                '.',
                TRIM(LOWER(vRoutineName)),
                '(',
                vArgs,
                ')'
            );

        END IF;

        IF vSQL IS NULL THEN

            RAISE SQLSTATE '42883';

        ELSE

            EXECUTE vSQL;

        END IF;

    ELSE
        
        RAISE SQLSTATE '42883';

    END IF;

EXCEPTION
    
    WHEN SQLSTATE '42883' THEN
        
        PERFORM aws_oracle_ext.owa_util$status_line(404);
        
END;
]]></complex-attribute>
                        <category _I_D="7b04c55c-6fc1-43c7-b515-1067dda16fbf" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="12906211-d4ed-44f4-adc9-94bfb6b6236e" name="prior" is-trigger-function="0" unique-function-name="prior" is-aggregate="f" language-name="sql" context="prior" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,integer" is-returning-set="f" ret-datatype="int4" function-arguments="pcollection anyarray, n integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22407" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pcollection anyarray, n integer" overload-function-count="1" proc-language="sql" function-signature="prior(pcollection anyarray, n integer)">
                        <complex-attribute name="sql"><![CDATA[  
    /*the function is depricated. collection_%METHOD_NAME% has to be used instead*/
    SELECT
        CASE
            WHEN n < 2 OR COALESCE(ARRAY_LENGTH(pcollection, 1), 0) = 0 THEN
                NULL
            WHEN n > ARRAY_LENGTH(pcollection, 1) THEN
                ARRAY_LENGTH(pcollection, 1)
            ELSE
                n - 1
        END;

]]></complex-attribute>
                        <category _I_D="9b3d345e-02cd-4c55-aca4-788ed050aab3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="05de7db0-b023-4821-b56e-19d811f55d7e" name="ratio_to_report" is-trigger-function="0" unique-function-name="ratio_to_report(double precision, double precision)" is-aggregate="f" language-name="sql" context="ratio_to_report(double precision, double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,double precision" comment="This function displays the ratio of the specified value to the sum of (double precision) values in the set. It doesn't support the order or windowing clauses. Omitting a partitioning clause from the OVER clause means the whole result set is treated as a single partition." unique-suffix="(double precision, double precision)" routine-number="23400" is-returning-set="f" ret-datatype="float8" function-arguments="double precision, double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23400" volatility="IMMUTABLE" is-window="f" function-identity-arguments="double precision, double precision" overload-function-count="3" proc-language="sql" function-signature="ratio_to_report(double precision, double precision)">
                        <complex-attribute name="sql"><![CDATA[
SELECT $1 / nullif($2, 0);
]]></complex-attribute>
                        <category _I_D="b515761c-fc20-48a0-a054-4a3777456b08" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="21c71ff9-6739-4d45-b5ce-8dc8b8f4dd9e" name="ratio_to_report" is-trigger-function="0" unique-function-name="ratio_to_report(numeric, numeric)" is-aggregate="f" language-name="sql" context="ratio_to_report(numeric, numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric" comment="This function displays the ratio of the specified value to the sum of (numeric) values in the set. It doesn't support the order or windowing clauses. Omitting a partitioning clause from the OVER clause means the whole result set is treated as a single partition." unique-suffix="(numeric, numeric)" routine-number="23398" is-returning-set="f" ret-datatype="numeric" function-arguments="numeric, numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23398" volatility="IMMUTABLE" is-window="f" function-identity-arguments="numeric, numeric" overload-function-count="3" proc-language="sql" function-signature="ratio_to_report(numeric, numeric)">
                        <complex-attribute name="sql"><![CDATA[
SELECT $1 / nullif($2, 0);
]]></complex-attribute>
                        <category _I_D="b923e119-77e0-4a91-8b33-64489b99b1a0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e1b488d2-76fb-4677-9fef-e15022786ec9" name="ratio_to_report" is-trigger-function="0" unique-function-name="ratio_to_report(real, real)" is-aggregate="f" language-name="sql" context="ratio_to_report(real, real)" subcategories-loading="none" object-loading="extended" arguments-datatypes="real,real" comment="This function displays the ratio of the specified value to the sum of (real) values in the set. It doesn't support the order or windowing clauses. Omitting a partitioning clause from the OVER clause means the whole result set is treated as a single partition." unique-suffix="(real, real)" routine-number="23399" is-returning-set="f" ret-datatype="float4" function-arguments="real, real" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23399" volatility="IMMUTABLE" is-window="f" function-identity-arguments="real, real" overload-function-count="3" proc-language="sql" function-signature="ratio_to_report(real, real)">
                        <complex-attribute name="sql"><![CDATA[
SELECT $1 / nullif($2, 0);
]]></complex-attribute>
                        <category _I_D="ddb6cd3d-9fa2-4f5f-88e2-43f01eaf4a50" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="87d78c00-4152-4776-b694-ea5043c396e5" name="record_to_json" is-trigger-function="0" unique-function-name="record_to_json" is-aggregate="f" language-name="sql" context="record_to_json" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyelement" is-returning-set="f" ret-datatype="json" function-arguments="anyelement" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23229" volatility="IMMUTABLE" is-window="f" function-identity-arguments="anyelement" overload-function-count="1" proc-language="sql" function-signature="record_to_json(anyelement)">
                        <complex-attribute name="sql"><![CDATA[
SELECT ROW_TO_JSON(z.*)
        FROM JSON_POPULATE_RECORD
        (
            $1,
            TO_JSON($1)
        ) z;
]]></complex-attribute>
                        <category _I_D="e626ec2d-348f-43a7-9922-b1e3e41daada" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="93133b17-cac2-4c7d-a3c0-c3e0e7c829c0" name="record_to_jsonb" is-trigger-function="0" unique-function-name="record_to_jsonb" is-aggregate="f" language-name="sql" context="record_to_jsonb" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyelement" is-returning-set="f" ret-datatype="jsonb" function-arguments="anyelement" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23154" volatility="IMMUTABLE" is-window="f" function-identity-arguments="anyelement" overload-function-count="1" proc-language="sql" function-signature="record_to_jsonb(anyelement)">
                        <complex-attribute name="sql"><![CDATA[
SELECT TO_JSONB(z)
        FROM JSONB_POPULATE_RECORD
        (
            $1,
            TO_JSONB($1)
        ) z;
]]></complex-attribute>
                        <category _I_D="c34ee698-003b-4548-807e-8596a3f4d9be" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="eb716191-b7c1-44f2-9af8-e0c1e71acc8d" name="regexp_count" is-trigger-function="0" unique-function-name="regexp_count" is-aggregate="f" language-name="plpgsql" context="regexp_count" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,numeric,text" comment="Returns a count of the number of times that a regular expression pattern is matched in a string. If the pattern expression is not found and no argument is null, the result is 0." is-returning-set="f" ret-datatype="int4" function-arguments="p_src_string text, p_regexp_pat text, p_position numeric DEFAULT 1, p_match_param text DEFAULT 'c'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22408" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_src_string text, p_regexp_pat text, p_position numeric, p_match_param text" overload-function-count="1" proc-language="plpgsql" function-signature="regexp_count(p_src_string text, p_regexp_pat text, p_position numeric, p_match_param text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_res_count INTEGER;
    v_position INTEGER;
    v_match_param TEXT;
    v_src_string TEXT;
BEGIN
    -- Extracting INT value of position
    v_position := floor(p_position);

    -- Removing spaces from match_param
    v_match_param := trim(p_match_param);

    -- Preparing source string for further work
    v_src_string := substr(p_src_string, v_position);

    -- Block of input parameters validation checks
    IF (coalesce(p_src_string, '') = '' OR
        coalesce(p_regexp_pat, '') = '' OR
        p_position IS NULL)
    THEN
        RETURN NULL;
    ELSIF (v_position <= 0) THEN
        /* The value of the argument for parameter in position "3" (start position)
           should be greater than or equal to 1 */
        RAISE USING MESSAGE := format('Argument ''%s'' is out of range.', v_position),
                    DETAIL := 'The value of the argument should be greater than or equal to 1.',
                    HINT := '-1428';
    ELSIF (coalesce(v_match_param, '') = '') THEN
        v_match_param := 'c';
    ELSIF (v_match_param !~ 'i|c|n|m|x') THEN
        /* The value of the argument for parameter in position "4" (match parameter)
           must be one of the following: "i", "c", "n", "m", "x" */
        RAISE USING MESSAGE := 'Illegal argument for function.',
                    DETAIL := 'The value of the argument must be one of the following: "i", "c", "n", "m", "x".',
                    HINT := '-1760';
    END IF;

    -- Translate regexp flags (match parameter) between matching engines
    v_match_param := concat('g', v_match_param);
    v_match_param := regexp_replace(v_match_param, 'm|x', '', 'g');
    v_match_param := CASE
                        WHEN v_match_param !~ 'n' THEN v_match_param || 'p'
                        ELSE regexp_replace(v_match_param, 'n', '', 'g')
                     END;

    -- Find the count of matches which correspond to the supplied regexp mask
    SELECT COUNT(regexpval)::INTEGER
      INTO v_res_count
      FROM (SELECT ROW_NUMBER() OVER (ORDER BY 1) AS rownum,
                   regexpval
              FROM (SELECT unnest(regexp_matches(v_src_string,
                                                 p_regexp_pat,
                                                 v_match_param)) AS regexpval
                   ) AS regexpvals
             WHERE char_length(regexpval) > 0
           ) AS rankexpvals;

    RETURN v_res_count;
END;
]]></complex-attribute>
                        <category _I_D="f91ad4a2-ac4f-4b24-b169-c3719a75475b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="70b34c47-4b28-42c7-bad2-3e6fd15d97c0" name="regexp_instr" is-trigger-function="0" unique-function-name="regexp_instr" is-aggregate="f" language-name="plpgsql" context="regexp_instr" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,numeric,numeric,numeric,text" comment="This function returns the starting or ending position of the matched substring, depending on the value of the return_option argument." is-returning-set="f" ret-datatype="int4" function-arguments="p_src_string text, p_regexp_pat text, p_position numeric DEFAULT 1, p_occurrence numeric DEFAULT 1, p_retopt numeric DEFAULT 0, p_match_param text DEFAULT 'c'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22409" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_src_string text, p_regexp_pat text, p_position numeric, p_occurrence numeric, p_retopt numeric, p_match_param text" overload-function-count="1" proc-language="plpgsql" function-signature="regexp_instr(p_src_string text, p_regexp_pat text, p_position numeric, p_occurrence numeric, p_retopt numeric, p_match_param text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_retopt INTEGER;
    v_position INTEGER;
    v_occurrence INTEGER;
    v_match_param TEXT;
    v_src_string TEXT;
    v_instr_pos INTEGER;
    v_srcstr_len INTEGER;
    v_resposition INTEGER;
    v_regexpres_row RECORD;
    v_match_count INTEGER := 0;
BEGIN
    -- Extracting INT value of position
    v_position := floor(p_position);

    -- Preparing source string for further work
    v_src_string := substr(p_src_string, v_position);

    -- Extracting INT value of occurrence
    v_occurrence := floor(p_occurrence);

    -- Extracting INT value of return option
    v_retopt := floor(p_retopt);

    -- Removing spaces from match_param
    v_match_param := trim(p_match_param);

    v_srcstr_len := char_length(v_src_string);

    -- Block of input parameters validation checks
    IF (coalesce(p_src_string, '') = '' OR
        coalesce(p_regexp_pat, '') = '' OR
        p_position IS NULL OR
        p_occurrence IS NULL OR
        p_retopt IS NULL)
    THEN
        RETURN NULL;
    ELSIF (v_position <= 0) THEN
        /* The value of the argument for parameter in position "3" (start position)
           should be greater than or equal to 1 */
        RAISE USING MESSAGE := format('Argument ''%s'' is out of range.', v_position),
                    DETAIL := 'The value of the argument should be greater than or equal to 1.',
                    HINT := '-1428';
    ELSIF (v_occurrence <= 0) THEN
        /* The value of the argument for parameter in position "4" (occurrence of match)
           should be greater than or equal to 1 */
        RAISE USING MESSAGE := format('Argument ''%s'' is out of range.', v_position),
                    DETAIL := 'The value of the argument should be greater than or equal to 1.',
                    HINT := '-1428';
    ELSIF (v_retopt < 0) THEN
        /* The value of the argument for parameter in position "5" (return option)
           should be either 0 or 1 */
        RAISE USING MESSAGE := format('Argument ''%s'' is out of range.', v_retopt),
                    DETAIL := 'The value of the argument should be either 0 or 1.',
                    HINT := '-1428';
    ELSIF (coalesce(v_match_param, '') = '') THEN
        v_match_param := 'c';
    ELSIF (v_match_param !~ 'i|c|n|m|x') THEN
        /* The value of the argument for parameter in position "6" (match parameter)
           must be one of the following: "i", "c", "n", "m", "x" */
        RAISE USING MESSAGE := 'Illegal argument for function.',
                    DETAIL := 'The value of the argument must be one of the following: "i", "c", "n", "m", "x".',
                    HINT := '-1760';
    END IF;

    -- Translate regexp flags (match parameter) between matching engines
    v_match_param := concat('g', v_match_param);
    v_match_param := regexp_replace(v_match_param, 'm|x', '', 'g');
    v_match_param := CASE
                        WHEN v_match_param !~ 'n' THEN v_match_param || 'p'
                        ELSE regexp_replace(v_match_param, 'n', '', 'g')
                     END;

    -- Find the position of the particular occurrence of the regexp match
    FOR v_regexpres_row IN
    (SELECT rownum,
            regexpval,
            char_length(regexpval) AS value_len
       FROM (SELECT ROW_NUMBER() OVER (ORDER BY 1) AS rownum,
                    regexpval
               FROM (SELECT unnest(regexp_matches(v_src_string,
                                                  p_regexp_pat,
                                                  v_match_param)) AS regexpval
                    ) AS regexpvals
              WHERE char_length(regexpval) > 0
            ) AS rankexpvals
      ORDER BY rownum ASC)
    LOOP
        v_src_string := substr(v_src_string, strpos(v_src_string, v_regexpres_row.regexpval) + v_regexpres_row.value_len);
        v_resposition := v_srcstr_len - char_length(v_src_string) - v_regexpres_row.value_len + 1;

        IF (v_position > 1) THEN
            v_resposition := v_resposition + v_position - 1;
        END IF;

        IF (v_retopt > 0) THEN
            v_resposition := v_resposition + v_regexpres_row.value_len;
        END IF;

        v_match_count := v_regexpres_row.rownum;
        EXIT WHEN v_match_count = v_occurrence;
    END LOOP;

    v_instr_pos := CASE
                      WHEN v_match_count != v_occurrence THEN 0
                      ELSE v_resposition
                   END;

    RETURN v_instr_pos;
END;
]]></complex-attribute>
                        <category _I_D="3bb5ee3b-68be-4692-b8ed-18d4311d334c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d26dd673-7043-4202-ba2c-d784d7c23141" name="regexp_like" is-trigger-function="0" unique-function-name="regexp_like" is-aggregate="f" language-name="plpgsql" context="regexp_like" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" comment="This function returns a boolean value indicating if the regular expression pattern is found in a string." is-returning-set="f" ret-datatype="bool" function-arguments="p_src_string text, p_regexp_pat text, p_match_param text DEFAULT 'c'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22410" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_src_string text, p_regexp_pat text, p_match_param text" overload-function-count="1" proc-language="plpgsql" function-signature="regexp_like(p_src_string text, p_regexp_pat text, p_match_param text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_match_param TEXT;
BEGIN

    -- Removing spaces from match_param
    v_match_param := trim(p_match_param);

    -- Block of input parameters validation checks
    IF (coalesce(p_src_string, '') = '' OR
        coalesce(p_regexp_pat, '') = '')
    THEN
        RETURN NULL;
    ELSIF (coalesce(v_match_param, '') = '') THEN
        v_match_param := 'c';
    ELSIF (v_match_param !~ 'i|c|n|m|x') THEN
        /* The value of the argument for parameter in position "3" (match parameter)
           must be one of the following: "i", "c", "n", "m", "x" */
        RAISE USING MESSAGE := 'Illegal argument for function.',
                    DETAIL := 'The value of the argument must be one of the following: "i", "c", "n", "m", "x".',
                    HINT := '-1760';
    END IF;

    -- Translate regexp flags (match parameter) between matching engines
    v_match_param := concat('g', v_match_param);
    v_match_param := regexp_replace(v_match_param, 'm|x', '', 'g');
    v_match_param := CASE
                        WHEN v_match_param !~ 'n' THEN v_match_param || 'p'
                        ELSE regexp_replace(v_match_param, 'n', '', 'g')
                     END;

    -- Finding if there is a match regarding supplied regexp mask
    RETURN EXISTS(SELECT regexp_matches(p_src_string, p_regexp_pat, v_match_param));

END;
]]></complex-attribute>
                        <category _I_D="69bc091e-c307-4a48-949a-7295354481fe" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5aecb0c7-9788-4cc4-880f-ce0bbb08ae68" name="regexp_replace" is-trigger-function="0" unique-function-name="regexp_replace" is-aggregate="f" language-name="plpgsql" context="regexp_replace" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,numeric,numeric,text" comment="This function returns a modified version of the source string where occurrences of the regular expression pattern found in the source string are replaced with the specified replacement string" is-returning-set="f" ret-datatype="text" function-arguments="p_src_string text, p_regexp_pat text, p_replace_string text DEFAULT ''::text, p_position numeric DEFAULT 1, p_occurrence numeric DEFAULT 0, p_match_param text DEFAULT 'c'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22411" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_src_string text, p_regexp_pat text, p_replace_string text, p_position numeric, p_occurrence numeric, p_match_param text" overload-function-count="1" proc-language="plpgsql" function-signature="regexp_replace(p_src_string text, p_regexp_pat text, p_replace_string text, p_position numeric, p_occurrence numeric, p_match_param text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_res_string TEXT;
    v_regexp_val TEXT;
    v_res_position INTEGER;
    v_regexpres_row RECORD;
    v_position INTEGER;
    v_occurrence INTEGER;
    v_match_param TEXT;
    v_src_string TEXT;
    v_srcstr_len INTEGER;
    v_match_count INTEGER := 0;
BEGIN
    -- Extracting INT value of position
    v_position := floor(p_position);

    -- Extracting INT value of occurrence
    v_occurrence := floor(p_occurrence);

    -- Removing spaces from match_param
    v_match_param := trim(p_match_param);

    -- Preparing source string for further work
    v_src_string := substr(p_src_string, v_position);

    v_srcstr_len := char_length(v_src_string);

    /* Possible combinations of the input parameters
       (processing some of them) */
    IF (char_length(v_src_string) != 0 AND
        char_length(coalesce(p_regexp_pat, '')) = 0)
    THEN
        RETURN p_src_string;
    END IF;

    -- Block of input parameters validation checks
    IF (coalesce(p_src_string, '') = '' OR
        coalesce(p_regexp_pat, '') = '' OR
        p_position IS NULL OR
        p_occurrence IS NULL)
    THEN
        RETURN v_res_string;
    ELSIF (v_position <= 0) THEN
        /* The value of the argument for parameter in position "4" (start position)
           should be greater than or equal to 1 */
        RAISE USING MESSAGE := format('Argument ''%s'' is out of range.', v_position),
                    DETAIL := 'The value of the argument should be greater than or equal to 1.',
                    HINT := '-1428';
    ELSIF (v_occurrence < 0) THEN
        /* The value of the argument for parameter in position "5" (occurrence of match)
           should be greater than or equal to 1 */
        RAISE USING MESSAGE := format('Argument ''%s'' is out of range.', v_position),
                    DETAIL := 'The value of the argument should be greater than or equal to 0.',
                    HINT := '-1428';
    ELSIF (coalesce(v_match_param, '') = '') THEN
        v_match_param := 'c';
    ELSIF (v_match_param !~ 'i|c|n|m|x') THEN
        /* The value of the argument for parameter in position "6" (match parameter)
           must be one of the following: "i", "c", "n", "m", "x" */
        RAISE USING MESSAGE := 'Illegal argument for function.',
                    DETAIL := 'The value of the argument must be one of the following: "i", "c", "n", "m", "x".',
                    HINT := '-1760';
    END IF;

    -- Translate regexp flags (match parameter) between matching engines
    v_match_param := concat('g', v_match_param);
    v_match_param := regexp_replace(v_match_param, 'm|x', '', 'g');
    v_match_param := CASE
                        WHEN v_match_param !~ 'n' THEN v_match_param || 'p'
                        ELSE regexp_replace(v_match_param, 'n', '', 'g')
                     END;

    -- Replace all occurrences of match if particular one isn't specified
    IF (v_occurrence = 0) THEN
        v_res_string := regexp_replace(v_src_string,
                                       p_regexp_pat,
                                       coalesce(p_replace_string, ''),
                                       v_match_param);

        v_res_string := concat(substr(p_src_string, 1, v_position - 1), v_res_string);
    -- Replace the particular occurrence of the regexp match (specified as `p_occurrence` param)
    ELSE
        FOR v_regexpres_row IN
        (SELECT rownum,
                regexpval,
                char_length(regexpval) AS value_len
           FROM (SELECT ROW_NUMBER() OVER (ORDER BY 1) AS rownum,
                        regexpval
                   FROM (SELECT unnest(regexp_matches(v_src_string,
                                                      p_regexp_pat,
                                                      v_match_param)) AS regexpval
                        ) AS regexpvals
                  WHERE char_length(regexpval) > 0
                ) AS rankexpvals
          ORDER BY rownum ASC)
        LOOP
            v_regexp_val := v_regexpres_row.regexpval;
            v_src_string := substr(v_src_string, strpos(v_src_string, v_regexp_val) + v_regexpres_row.value_len);
            v_res_position := v_srcstr_len - char_length(v_src_string) - v_regexpres_row.value_len + 1;

            IF (p_position > 1) THEN
                v_res_position := v_res_position + p_position - 1;
            END IF;

            v_match_count := v_regexpres_row.rownum;
            EXIT WHEN v_match_count = v_occurrence;
        END LOOP;

        IF (v_match_count = v_occurrence) THEN
            v_res_string := concat(substr(p_src_string, 0, v_res_position),
                                   p_replace_string,
                                   substr(p_src_string, v_res_position + char_length(v_regexp_val)));
        END IF;
    END IF;

    v_res_string := coalesce(v_res_string, p_src_string);

    RETURN nullif(v_res_string, '');
END;
]]></complex-attribute>
                        <category _I_D="8cc026c7-a256-4d8d-b453-f202e38b5a2b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c54cde57-b9ce-4971-bf2f-6c2b125a8dfb" name="regexp_substr" is-trigger-function="0" unique-function-name="regexp_substr" is-aggregate="f" language-name="plpgsql" context="regexp_substr" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,numeric,numeric,text" comment="This function returns one occurrence of a substring of a string that matches the regular expression pattern. If the pattern expression is not found, the result is the null value." is-returning-set="f" ret-datatype="text" function-arguments="p_src_string text, p_regexp_pat text, p_position numeric DEFAULT 1, p_occurrence numeric DEFAULT 1, p_match_param text DEFAULT 'c'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22413" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_src_string text, p_regexp_pat text, p_position numeric, p_occurrence numeric, p_match_param text" overload-function-count="1" proc-language="plpgsql" function-signature="regexp_substr(p_src_string text, p_regexp_pat text, p_position numeric, p_occurrence numeric, p_match_param text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_res_string TEXT;
    v_regexp_val TEXT;
    v_position INTEGER;
    v_occurrence INTEGER;
    v_match_param TEXT;
    v_src_string TEXT;
    v_regexpres_row RECORD;
    v_match_count INTEGER := 0;
BEGIN
    -- Extracting INT value of position
    v_position := floor(p_position);

    -- Extracting INT value of occurrence
    v_occurrence := floor(p_occurrence);

    -- Removing spaces from match_param
    v_match_param := trim(p_match_param);

    -- Preparing source string for further work
    v_src_string := substr(p_src_string, v_position);

    -- Block of input parameters validation checks
    IF (coalesce(p_src_string, '') = '' OR
        coalesce(p_regexp_pat, '') = '' OR
        p_position IS NULL OR
        p_occurrence IS NULL)
    THEN
        RETURN v_res_string;
    ELSIF (v_position <= 0) THEN
        /* The value of the argument for parameter in position "3" (start position)
           should be greater than or equal to 1 */
        RAISE USING MESSAGE := format('Argument ''%s'' is out of range.', v_position),
                    DETAIL := 'The value of the argument should be greater than or equal to 1.',
                    HINT := '-1428';
    ELSIF (v_occurrence < 0) THEN
        /* The value of the argument for parameter in position "4" (occurrence of match)
           should be greater than or equal to 1 */
        RAISE USING MESSAGE := format('Argument ''%s'' is out of range.', v_position),
                    DETAIL := 'The value of the argument should be greater than or equal to 1.',
                    HINT := '-1428';
    ELSIF (coalesce(v_match_param, '') = '') THEN
        v_match_param := 'c';
    ELSIF (v_match_param !~ 'i|c|n|m|x') THEN
        /* The value of the argument for parameter in position "5" (match parameter)
           must be one of the following: "i", "c", "n", "m", "x" */
        RAISE USING MESSAGE := 'Illegal argument for function.',
                    DETAIL := 'The value of the argument must be one of the following: "i", "c", "n", "m", "x".',
                    HINT := '-1760';
    END IF;

    -- Translate regexp flags (match parameter) between matching engines
    v_match_param := concat('g', v_match_param);
    v_match_param := regexp_replace(v_match_param, 'm|x', '', 'g');
    v_match_param := CASE
                        WHEN v_match_param !~ 'n' THEN v_match_param || 'p'
                        ELSE regexp_replace(v_match_param, 'n', '', 'g')
                     END;

    -- Find the particular occurrence of the regexp match (specified as `p_occurrence` param)
    FOR v_regexpres_row IN
    (SELECT rownum,
            regexpval,
            char_length(regexpval) AS value_len
       FROM (SELECT ROW_NUMBER() OVER (ORDER BY 1) AS rownum,
                    regexpval
               FROM (SELECT unnest(regexp_matches(v_src_string,
                                                  p_regexp_pat,
                                                  v_match_param)) AS regexpval
                    ) AS regexpvals
              WHERE char_length(regexpval) > 0
            ) AS rankexpvals
      ORDER BY rownum ASC)
    LOOP
        v_match_count := v_regexpres_row.rownum;
        v_regexp_val := v_regexpres_row.regexpval;
        v_src_string := substr(v_src_string, strpos(v_src_string, v_regexp_val) + v_regexpres_row.value_len);

        IF (v_match_count = v_occurrence) THEN
            v_res_string := v_regexp_val;
            EXIT;
        END IF;
    END LOOP;

    RETURN v_res_string;
END;
]]></complex-attribute>
                        <category _I_D="d83d1b93-7922-4a32-8905-d67bb12f6d9c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a7e220ee-1e37-4a1f-b042-d0e65660d739" name="return_v$nls_parameters" is-trigger-function="0" unique-function-name="return_v$nls_parameters" is-aggregate="f" language-name="plpgsql" context="return_v$nls_parameters" subcategories-loading="none" object-loading="extended" is-returning-set="t" ret-datatype="nls_param" schema-id="21999" function-type="RET_DATASET" count-arguments="0" function-id="22274" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="return_v$nls_parameters()">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    ret aws_oracle_ext.nls_param;
    vjsonrow JSON;
BEGIN
    PERFORM aws_oracle_ext.nls_parameters_init();

    WITH by_default AS
    (
        SELECT params_dictionary ->> 'NLS_CALENDAR' AS NLS_CALENDAR,
            params_dictionary ->> 'NLS_CHARACTERSET' AS NLS_CHARACTERSET,
            params_dictionary ->> 'NLS_COMP' AS NLS_COMP,
            params_dictionary ->> 'NLS_CURRENCY' AS NLS_CURRENCY,
            params_dictionary ->> 'NLS_DATE_FORMAT' AS NLS_DATE_FORMAT,
            params_dictionary ->> 'NLS_DATE_LANGUAGE' AS NLS_DATE_LANGUAGE,
            params_dictionary ->> 'NLS_DUAL_CURRENCY' AS NLS_DUAL_CURRENCY,
            params_dictionary ->> 'NLS_ISO_CURRENCY' AS NLS_ISO_CURRENCY,
            params_dictionary ->> 'NLS_LANGUAGE' AS NLS_LANGUAGE,
            params_dictionary ->> 'NLS_LENGTH_SEMANTICS' AS NLS_LENGTH_SEMANTICS,
            params_dictionary ->> 'NLS_NCHAR_CHARACTERSET' AS NLS_NCHAR_CHARACTERSET,
            params_dictionary ->> 'NLS_NCHAR_CONV_EXCP' AS NLS_NCHAR_CONV_EXCP,
            params_dictionary ->> 'NLS_NUMERIC_CHARACTERS' AS NLS_NUMERIC_CHARACTERS,
            params_dictionary ->> 'NLS_SORT' AS NLS_SORT,
            params_dictionary ->> 'NLS_TERRITORY' AS NLS_TERRITORY,
            params_dictionary ->> 'NLS_TIMESTAMP_FORMAT' AS NLS_TIMESTAMP_FORMAT,
            params_dictionary ->> 'NLS_TIMESTAMP_TZ_FORMAT' AS NLS_TIMESTAMP_TZ_FORMAT,
            params_dictionary ->> 'NLS_TIME_FORMAT' AS nls_time_format,
            params_dictionary ->> 'NLS_TIME_TZ_FORMAT' AS nls_time_tz_format
        FROM aws_oracle_ext.nls_parameters
        WHERE nls_territory ='AMERICA'
    ),
    cur_nls as
    (
        SELECT params_dictionary ->> 'NLS_CALENDAR' AS NLS_CALENDAR,
            params_dictionary ->> 'NLS_CHARACTERSET' AS NLS_CHARACTERSET,
            params_dictionary ->> 'NLS_COMP' AS NLS_COMP,
            params_dictionary ->> 'NLS_CURRENCY' AS NLS_CURRENCY,
            params_dictionary ->> 'NLS_DATE_FORMAT' AS NLS_DATE_FORMAT,
            params_dictionary ->> 'NLS_DATE_LANGUAGE' AS NLS_DATE_LANGUAGE,
            params_dictionary ->> 'NLS_DUAL_CURRENCY' AS NLS_DUAL_CURRENCY,
            params_dictionary ->> 'NLS_ISO_CURRENCY' AS NLS_ISO_CURRENCY,
            params_dictionary ->> 'NLS_LANGUAGE' AS NLS_LANGUAGE,
            params_dictionary ->> 'NLS_LENGTH_SEMANTICS' AS NLS_LENGTH_SEMANTICS,
            params_dictionary ->> 'NLS_NCHAR_CHARACTERSET' AS NLS_NCHAR_CHARACTERSET,
            params_dictionary ->> 'NLS_NCHAR_CONV_EXCP' AS NLS_NCHAR_CONV_EXCP,
            params_dictionary ->> 'NLS_NUMERIC_CHARACTERS' AS NLS_NUMERIC_CHARACTERS,
            params_dictionary ->> 'NLS_SORT' AS NLS_SORT,
            params_dictionary ->> 'NLS_TERRITORY' AS NLS_TERRITORY,
            params_dictionary ->> 'NLS_TIMESTAMP_FORMAT' AS NLS_TIMESTAMP_FORMAT,
            params_dictionary ->> 'NLS_TIMESTAMP_TZ_FORMAT' AS NLS_TIMESTAMP_TZ_FORMAT,
            params_dictionary ->> 'NLS_TIME_FORMAT' AS nls_time_format,
            params_dictionary ->> 'NLS_TIME_TZ_FORMAT' AS nls_time_tz_format
        FROM aws_oracle_ext.nls_parameters
        WHERE nls_territory = aws_oracle_ext.get_package_variable(variable_name => 'NLS_TERRITORY')
    ), vals as
    (
    SELECT COALESCE(aws_oracle_ext.get_package_variable(variable_name => 'NLS_CALENDAR'), cn.nls_calendar, bd.nls_calendar) AS nls_calendar,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_CHARACTERSET'), cn.nls_characterset, bd.nls_characterset) AS nls_characterset,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_COMP'), cn.nls_comp, bd.nls_comp) AS nls_comp,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_CURRENCY'), cn.nls_currency, bd.nls_currency) AS nls_currency,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_DATE_FORMAT'), cn.nls_date_format, bd.nls_date_format) AS nls_date_format,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_DATE_LANGUAGE'), cn.nls_date_language, bd.nls_date_language) AS nls_date_language,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_DUAL_CURRENCY'), cn.nls_dual_currency, bd.nls_dual_currency) AS nls_dual_currency,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_ISO_CURRENCY'), cn.nls_iso_currency, bd.nls_iso_currency) AS nls_iso_currency,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_LANGUAGE'), cn.nls_language, bd.nls_language) AS nls_language,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_LENGTH_SEMANTICS'), cn.nls_length_semantics, bd.nls_length_semantics) AS nls_length_semantics,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_NCHAR_CHARACTERSET'), cn.nls_nchar_characterset, bd.nls_nchar_characterset) AS nls_nchar_characterset,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_NCHAR_CONV_EXCP'), cn.nls_nchar_conv_excp, bd.nls_nchar_conv_excp) AS nls_nchar_conv_excp,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_NUMERIC_CHARACTERS'), cn.nls_numeric_characters, bd.nls_numeric_characters) AS nls_numeric_characters,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_SORT'), cn.nls_sort, bd.nls_sort) AS nls_sort,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_TERRITORY'), cn.nls_territory, bd.nls_territory) AS nls_territory,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_TIMESTAMP_FORMAT'), cn.nls_timestamp_format, bd.nls_timestamp_format) AS nls_timestamp_format,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_TIMESTAMP_TZ_FORMAT'), cn.nls_timestamp_tz_format, bd.nls_timestamp_tz_format) AS nls_timestamp_tz_format,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_TIME_FORMAT'), cn.nls_time_format, bd.nls_time_format) AS nls_time_format,
        COALESCE(aws_oracle_ext.get_extpack_variable(variable_name => 'NLS_TIME_TZ_FORMAT'), cn.nls_time_tz_format, bd.nls_time_tz_format) AS nls_time_tz_format
    FROM by_default bd
    LEFT JOIN cur_nls cn ON 1=1
    )
    SELECT ROW_TO_JSON(vals)
    INTO vjsonrow
    FROM vals;

    FOR ret IN
    SELECT UPPER(parameter),
        value,
        0 AS con_id
    FROM json_each_text(vjsonrow) AS t(parameter, value)
    LOOP

        RETURN NEXT ret;

    END LOOP;


END;
]]></complex-attribute>
                        <category _I_D="5a79f3b9-305b-4268-b9c4-41dc00b9f363" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="21cdafec-c30d-46db-ac9d-c55af7ca9720" name="round" is-trigger-function="0" unique-function-name="round(date)" is-aggregate="f" language-name="sql" context="round(date)" subcategories-loading="none" object-loading="extended" arguments-datatypes="date" comment="Round dates according to the specified format" unique-suffix="(date)" routine-number="22509" is-returning-set="f" ret-datatype="date" function-arguments="date" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22509" volatility="IMMUTABLE" is-window="f" function-identity-arguments="date" overload-function-count="6" proc-language="sql" function-signature="round(date)">
                        <complex-attribute name="sql"><![CDATA[ 
SELECT $1;
]]></complex-attribute>
                        <category _I_D="aa4eb348-50e6-4323-ab64-62f665e30279" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="59d063f8-1e9f-42f5-8328-f61476b36495" name="round" is-trigger-function="0" unique-function-name="round(value date, fmt text)" is-aggregate="f" language-name="sql" context="round(value date, fmt text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="date,text" comment="Round dates according to the specified format" unique-suffix="(value date, fmt text)" routine-number="22508" is-returning-set="f" ret-datatype="date" function-arguments="value date, fmt text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22508" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value date, fmt text" overload-function-count="6" proc-language="sql" function-signature="round(value date, fmt text)">
                        <complex-attribute name="sql"><![CDATA[ 
SELECT aws_oracle_ext.round($1::TIMESTAMP(0), $2)::DATE;
]]></complex-attribute>
                        <category _I_D="c7823e8b-a24f-4472-8228-6e025900daed" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="92cdc766-c661-4501-b48e-91942a0d00ef" name="round" is-trigger-function="0" unique-function-name="round(value timestamp with time zone)" is-aggregate="f" language-name="sql" context="round(value timestamp with time zone)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp with time zone" comment="Round dates according to the specified format" unique-suffix="(value timestamp with time zone)" routine-number="22511" is-returning-set="f" ret-datatype="timestamptz" function-arguments="value timestamp with time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22511" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value timestamp with time zone" overload-function-count="6" proc-language="sql" function-signature="round(value timestamp with time zone)">
                        <complex-attribute name="sql"><![CDATA[ 
SELECT aws_oracle_ext.round($1, 'DDD');
]]></complex-attribute>
                        <category _I_D="e5ac2e10-c3f8-493e-a84f-f79d070816dc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="27834002-a212-4e58-8627-768836b924c5" name="round" is-trigger-function="0" unique-function-name="round(value timestamp with time zone, fmt text)" is-aggregate="f" language-name="sql" context="round(value timestamp with time zone, fmt text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp with time zone,text" comment="Round dates according to the specified format" unique-suffix="(value timestamp with time zone, fmt text)" routine-number="22510" is-returning-set="f" ret-datatype="timestamptz" function-arguments="value timestamp with time zone, fmt text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22510" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value timestamp with time zone, fmt text" overload-function-count="6" proc-language="sql" function-signature="round(value timestamp with time zone, fmt text)">
                        <complex-attribute name="sql"><![CDATA[ 
SELECT NULL::TIMESTAMP WITH TIME ZONE;
]]></complex-attribute>
                        <category _I_D="0c09acf6-451f-4be6-ac10-918fb56eab44" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e29e642d-6f5b-45ca-b3b3-ae9fd06176ef" name="round" is-trigger-function="0" unique-function-name="round(value timestamp without time zone)" is-aggregate="f" language-name="sql" context="round(value timestamp without time zone)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone" comment="Round dates according to the specified format" unique-suffix="(value timestamp without time zone)" routine-number="22507" is-returning-set="f" ret-datatype="timestamp" function-arguments="value timestamp without time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22507" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value timestamp without time zone" overload-function-count="6" proc-language="sql" function-signature="round(value timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[ 
SELECT aws_oracle_ext.round($1, 'DDD'); 
]]></complex-attribute>
                        <category _I_D="8031013f-68cf-4c9e-97c4-3bba2d40db75" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="425e96c5-e54c-4725-ab68-2f1b086018aa" name="round" is-trigger-function="0" unique-function-name="round(value timestamp without time zone, fmt text)" is-aggregate="f" language-name="sql" context="round(value timestamp without time zone, fmt text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone,text" comment="Round dates according to the specified format" unique-suffix="(value timestamp without time zone, fmt text)" routine-number="22506" is-returning-set="f" ret-datatype="timestamp" function-arguments="value timestamp without time zone, fmt text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22506" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value timestamp without time zone, fmt text" overload-function-count="6" proc-language="sql" function-signature="round(value timestamp without time zone, fmt text)">
                        <complex-attribute name="sql"><![CDATA[
WITH cte0 AS (
SELECT
UPPER(fmt) AS fmt,
date_part('year',$1)::int AS y,
date_part('month',$1)::int AS m,
date_part('day',$1)::int AS d,
--
make_date(date_part('year',$1)::int, 1, 1) AS firstDayOfYear,
date_part('isodow',make_date(date_part('year',$1)::int, 1, 1))::int - 1 AS weekdayOfYear,
date_part('isodow',$1)::int - 1 AS weekdayOfMonth,
date_part('isodow',make_date(date_part('year',$1)::int, date_part('month',$1)::int, 1))::int - 1 AS weekdayOfMonth_W
)
, cte1 AS (
SELECT
cte0.*,
DATE_PART('isodow',$1)::int AS z_DAY,
DATE_PART('day',$1 - make_date(y, 1, 1))::int % 7 AS z_WW,
DATE_PART('day',$1 - make_date(y, m, 1))::int % 7 AS z_W,
--
weekdayOfYear - weekdayOfMonth AS diffDay,
CASE
  WHEN weekdayOfYear > 3
  THEN firstDayOfYear - weekdayOfYear * interval '1 day' + interval '1 week'
  ELSE firstDayOfYear - weekdayOfYear * interval '1 day'
END AS isoYear,
weekdayOfMonth_W - weekdayOfMonth AS diffDay_W
FROM cte0)
, cte2 AS (
SELECT
cte1.*,
date_part('isodow'
         ,make_date(date_part('year',isoYear)::int
                   ,date_part('month',isoYear)::int
                   ,date_part('day',isoYear)::int))::int - 1 AS isoWeekdayOfYear
FROM cte1)
, cte AS (
SELECT
cte2.*,
isoWeekdayOfYear - weekdayOfYear AS diffDay_IW
FROM cte2)
SELECT
/* ---------------------------------------------------------------------------- */
CASE
--Century
WHEN cte.fmt IN ('CC', 'SCC') THEN
  CASE
  WHEN date_part('year',$1)::int % 100 > 50
  THEN make_date(floor(date_part('year',$1) / 100)::int * 100 + 101, 1, 1)
  ELSE make_date(floor(date_part('year',$1) / 100)::int * 100 + 1, 1, 1)
  END
--Year
WHEN cte.fmt IN ('SYYYY','YYYY','YEAR','SYEAR','YYY','YY','Y') THEN
  CASE
  WHEN date_part('month',$1) > 6
  THEN date_trunc('year',$1) + interval '1 year'
  ELSE date_trunc('year',$1)
  END
--ISO Year
WHEN cte.fmt IN ('IYYY','IYY','IY','I') THEN
  CASE
  WHEN date_part('month', $1) <= 6
  THEN aws_oracle_ext.trunc($1::timestamp,'IYYY')
  ELSE aws_oracle_ext.trunc($1::timestamp + interval '1 year','IYYY')
  END
--Quarter
WHEN cte.fmt IN ('Q') THEN
  CASE
  WHEN date_part('month',$1) IN (1,4,7,10) OR (date_part('month',$1) IN (2,5,8,11) AND date_part('day',$1) <= 15)
  THEN make_date(date_part('year',$1)::int
                ,date_part('month',$1)::int - (date_part('month',$1)::int - 1) % 3
                ,1)
  WHEN date_part('month',$1) IN (3,6,9,12) OR (date_part('month',$1) IN (2,5,8,11) AND date_part('day',$1) > 15)
  THEN make_date(date_part('year',$1)::int + floor(date_part('month',$1)/11)::int
                ,(date_part('month',$1)::int + ((12 - date_part('month',$1)::int + 1) % 3)) % 12
                ,1)
  END
--Month
WHEN cte.fmt IN ('MONTH','MON','MM','RM') THEN
  CASE
  WHEN date_part('day',$1) >= 16
  THEN date_trunc('month',$1) + interval '1 month'
  ELSE date_trunc('month',$1)
  END
--Week (First day of the year/Same day of the week as the first day of the year)
WHEN cte.fmt IN ('WW') THEN
  CASE
  WHEN z_WW < 4
  THEN date_trunc('day',$1 - z_WW * interval '1 day')
  ELSE date_trunc('day',$1 - z_WW * interval '1 day' + 7 * interval '1 day')
  END
--Week (Monday of that week/Same day of the week as the first day of the ISO year)
WHEN cte.fmt IN ('IW') THEN
  CASE
  WHEN date_part('isodow',$1) < 4 OR (date_part('isodow',$1) = 4 AND date_part('hour',$1) <= 11)
  THEN date_trunc('week',$1)
  ELSE date_trunc('week',$1 + interval '1 week')
  END
--Week (First weekday on which the first day of the month falls/Same day of the week as the first day of the month)
WHEN cte.fmt IN ('W') THEN
  CASE
  WHEN z_W < 4
  THEN date_trunc('day',$1 - z_W * interval '1 day')
  ELSE date_trunc('day',$1 - z_W * interval '1 day' + 7 * interval '1 day')
  END
--Day
WHEN cte.fmt IN ('DDD', 'DD', 'J') THEN
  CASE
  WHEN date_part('hour',$1) > 11
  THEN date_trunc('day',$1) + interval '1 day'
  ELSE date_trunc('day',$1)
  END
--Starting day of the week
WHEN cte.fmt IN ('DAY', 'DY', 'D') THEN
  CASE
  WHEN y > 0
  THEN
    CASE
    WHEN z_DAY < 4
    THEN date_trunc('day',$1 - z_DAY * interval '1 day')
    ELSE date_trunc('day',$1 - z_DAY * interval '1 day' + 7 * interval '1 day')
    END
  ELSE
    CASE
    WHEN z_DAY > 0
    THEN date_trunc('day', $1 + (5 - CASE WHEN z_DAY > 1 THEN z_DAY ELSE z_DAY + 7 END) * interval '1 day')
    ELSE date_trunc('day', $1 + (5 - 7) * interval '1 day')
    END
  END
--Hour
WHEN cte.fmt IN ('HH24', 'HH12', 'HH') THEN
  CASE
  WHEN date_part('minute',$1) >= 30
  THEN date_trunc('hour',$1) + interval '1 hour'
  ELSE date_trunc('hour',$1)
  END
--Minute
WHEN cte.fmt IN ('MI') THEN
  CASE
  WHEN date_part('second',$1) >= 30
  THEN date_trunc('minute',$1) + interval '1 minute'
  ELSE date_trunc('minute',$1)
  END
END AS date_round
/* ---------------------------------------------------------------------------- */
FROM cte;
]]></complex-attribute>
                        <category _I_D="d5a010f5-590e-433a-bd5d-498528f51b6f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="afac7aa2-986a-452c-b8ef-134867978f51" name="rowidtochar" is-trigger-function="0" unique-function-name="rowidtochar" is-aggregate="f" language-name="sql" context="rowidtochar" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_data.rowid" is-returning-set="f" ret-datatype="text" function-arguments="p_rowid aws_oracle_data.rowid" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22999" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_rowid aws_oracle_data.rowid" overload-function-count="1" proc-language="sql" function-signature="rowidtochar(p_rowid aws_oracle_data.rowid)">
                        <complex-attribute name="sql"><![CDATA[
   SELECT p_rowid::text;
]]></complex-attribute>
                        <category _I_D="19d1b4f6-d66e-4fc8-81cb-5fa6685640b2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="40003a95-007a-4050-af04-fed658ee6627" name="sessiontimezone" is-trigger-function="0" unique-function-name="sessiontimezone" is-aggregate="f" language-name="sql" context="sessiontimezone" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22414" volatility="STABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sessiontimezone()">
                        <complex-attribute name="sql"><![CDATA[
  	
      SELECT  COALESCE(CURRENT_SETTING('TIMEZONE', TRUE), 'UTC');
      
]]></complex-attribute>
                        <category _I_D="5a72638a-f309-48ed-8e89-ae78e36978f3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="edaee83b-acf0-488c-9538-16f36e781cea" name="set_application_name" is-trigger-function="0" unique-function-name="set_application_name" is-aggregate="f" language-name="plpgsql" context="set_application_name" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="void" function-arguments="p_app_name jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23131" volatility="VOLATILE" is-window="f" function-identity-arguments="p_app_name jsonb" overload-function-count="1" proc-language="plpgsql" function-signature="set_application_name(p_app_name jsonb)">
                        <complex-attribute name="sql"><![CDATA[
begin
  	execute 'set application_name = ' || quote_ident(p_app_name::json::text);
end;
]]></complex-attribute>
                        <category _I_D="818f0a63-b2b3-4e18-9b1e-dc4e6f475ef4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c588cfb2-4611-4356-9335-b803df932773" name="set_extpack_variable" is-trigger-function="0" unique-function-name="set_extpack_variable" is-aggregate="f" language-name="sql" context="set_extpack_variable" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,anyelement" is-returning-set="f" ret-datatype="void" function-arguments="variable_name text, variable_value anyelement DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22052" volatility="VOLATILE" is-window="f" function-identity-arguments="variable_name text, variable_value anyelement" overload-function-count="1" proc-language="sql" function-signature="set_extpack_variable(variable_name text, variable_value anyelement)">
                        <complex-attribute name="sql"><![CDATA[
SELECT aws_oracle_ext.set_package_variable
(
    variable_name => $1,
    variable_value => $2
);
]]></complex-attribute>
                        <category _I_D="27290177-0058-487e-817e-5ea505df460d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1da206d7-4128-4cd9-9e9b-2f4645ed71e3" name="set_package_initialized" is-trigger-function="0" unique-function-name="set_package_initialized" is-aggregate="f" language-name="plpgsql" context="set_package_initialized" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" comment="&amp;#x000a; Sets a flag for the migrated package in state uninitialized in the current session, &amp;#x000a; to a re-execution for the initialization function.&amp;#x000a; &amp;#x000a; Parameters:&amp;#x000a;  schema_name -- migrated schema&amp;#x000a;  package_name -- migrated package&amp;#x000a;" is-returning-set="f" ret-datatype="void" function-arguments="schema_name text, package_name text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22415" volatility="VOLATILE" is-window="f" function-identity-arguments="schema_name text, package_name text" overload-function-count="1" proc-language="plpgsql" function-signature="set_package_initialized(schema_name text, package_name text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.set_package_variable
    (
        schema_name => set_package_initialized.schema_name,
        package_name => set_package_initialized.package_name,
        variable_name => 'Init$$',
        variable_value => TRUE
    );

END;
]]></complex-attribute>
                        <category _I_D="e20d4a0a-ad67-44b0-8eb6-5144e4ef545a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3cb8a27c-2116-4472-889b-f53734e80f50" name="set_package_uninitialized" is-trigger-function="0" unique-function-name="set_package_uninitialized" is-aggregate="f" language-name="plpgsql" context="set_package_uninitialized" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="schema_name text, package_name text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22416" volatility="VOLATILE" is-window="f" function-identity-arguments="schema_name text, package_name text" overload-function-count="1" proc-language="plpgsql" function-signature="set_package_uninitialized(schema_name text, package_name text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    PERFORM aws_oracle_ext.set_package_variable
    (
        schema_name => set_package_uninitialized.schema_name,
        package_name => set_package_uninitialized.package_name,
        variable_name => 'Init$$',
        variable_value => FALSE
    );

END;
]]></complex-attribute>
                        <category _I_D="97b4543d-e67b-49fa-a4a8-7a382732e25c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="fe381e3c-62a8-4ac7-a327-ac9125e4d61a" name="set_package_variable" is-trigger-function="0" unique-function-name="set_package_variable" is-aggregate="f" language-name="plpgsql" context="set_package_variable" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,anyelement" is-returning-set="f" ret-datatype="void" function-arguments="schema_name text DEFAULT 'AWS_ORACLE_EXT'::text, package_name text DEFAULT 'AWS_ORACLE_ENV'::text, variable_name text DEFAULT ''::text, variable_value anyelement DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22023" volatility="VOLATILE" is-window="f" function-identity-arguments="schema_name text, package_name text, variable_name text, variable_value anyelement" overload-function-count="1" proc-language="plpgsql" function-signature="set_package_variable(schema_name text, package_name text, variable_name text, variable_value anyelement)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vschema_name TEXT := schema_name;
    vpackage_name TEXT := package_name;
    name_is_quoted BOOLEAN DEFAULT FALSE;
BEGIN

    IF COALESCE(schema_name, 'AWS_ORACLE_EXT') <> 'AWS_ORACLE_EXT' AND

        COALESCE(package_name, 'AWS_ORACLE_ENV') <> 'AWS_ORACLE_ENV' THEN

        vschema_name := aws_oracle_ext.check_identifier_case(schema_name);
        vpackage_name := aws_oracle_ext.check_identifier_case(package_name);

        IF RIGHT(vpackage_name, 1) = '"' THEN

            name_is_quoted := TRUE;

        END IF;
    
        IF aws_oracle_ext.check_identifier_case(variable_name) <> 'init$$' THEN
        
            EXECUTE CONCAT
            (
                'SELECT ',
                schema_name,
                '.',
                CASE WHEN NOT name_is_quoted THEN package_name ELSE SUBSTR(package_name, 1, LENGTH(package_name) - 1) END,
                '$init',
                CASE WHEN name_is_quoted THEN '"' ELSE '' END,
                '()'
            );
    
        END IF;

    END IF;
    
    PERFORM aws_oracle_ext.set_package_variable_v8
    (
        sn => vschema_name,
        pn => vpackage_name,
        vn => aws_oracle_ext.check_identifier_case(variable_name),
        vv => variable_value::TEXT
    );

END;
]]></complex-attribute>
                        <category _I_D="b5c12b07-5d1c-42cb-b72e-856035c0ba69" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8087158a-e1b6-4ba6-b845-fc1794b96cde" name="set_package_variable_object" is-trigger-function="0" unique-function-name="set_package_variable_object" is-aggregate="f" language-name="plpgsql" context="set_package_variable_object" subcategories-loading="none" object-loading="extended" arguments-datatypes="name,name,name,anyelement" is-returning-set="f" ret-datatype="void" function-arguments="schema_name name, package_name name, object_name name, object_value anyelement" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22418" volatility="VOLATILE" is-window="f" function-identity-arguments="schema_name name, package_name name, object_name name, object_value anyelement" overload-function-count="1" proc-language="plpgsql" function-signature="set_package_variable_object(schema_name name, package_name name, object_name name, object_value anyelement)">
                        <complex-attribute name="sql"><![CDATA[  
  begin
    perform aws_oracle_ext.set_package_variable
      ( schema_name := schema_name
      , package_name := package_name
      , variable_name := object_name || '$OBJ'
      , variable_value := object_value::text );

    perform aws_oracle_ext.set_package_variable
      ( schema_name := schema_name
      , package_name := package_name
      , variable_name := object_name || '$TYPE'
      , variable_value := pg_typeof( object_value ) );
  end;
]]></complex-attribute>
                        <category _I_D="ecdbc725-6df7-4c7b-a685-14995df09423" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="fbc01e1f-f767-4687-92c2-fed28517a90b" name="set_package_variable_object_field" is-trigger-function="0" unique-function-name="set_package_variable_object_field" is-aggregate="f" language-name="plpgsql" context="set_package_variable_object_field" subcategories-loading="none" object-loading="extended" arguments-datatypes="name,name,name,text,anyelement" is-returning-set="f" ret-datatype="void" function-arguments="schema_name name, package_name name, variable_name name, field_name text, field_value anyelement" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22417" volatility="VOLATILE" is-window="f" function-identity-arguments="schema_name name, package_name name, variable_name name, field_name text, field_value anyelement" overload-function-count="1" proc-language="plpgsql" function-signature="set_package_variable_object_field(schema_name name, package_name name, variable_name name, field_name text, field_value anyelement)">
                        <complex-attribute name="sql"><![CDATA[
  begin
    perform aws_oracle_ext.set_package_variable
      ( schema_name, package_name, variable_name || '.' || field_name, field_value );
  end;
]]></complex-attribute>
                        <category _I_D="ee4e7a34-03a2-48f0-bbdc-7bb5ae83fcf2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ef767772-96d8-4c31-acc1-f6c5da2ac47d" name="set_service_setting" is-trigger-function="0" unique-function-name="set_service_setting" is-aggregate="f" language-name="sql" context="set_service_setting" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying" is-returning-set="f" ret-datatype="void" function-arguments="p_service character varying, p_setting character varying, p_value character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22419" volatility="VOLATILE" is-window="f" function-identity-arguments="p_service character varying, p_setting character varying, p_value character varying" overload-function-count="1" proc-language="sql" function-signature="set_service_setting(p_service character varying, p_setting character varying, p_value character varying)">
                        <complex-attribute name="sql"><![CDATA[
  WITH 
  upd AS (
       UPDATE aws_oracle_ext.service_settings
       SET    value = p_value
       WHERE  service_settings.service = p_service
         AND  service_settings.setting = p_setting
       RETURNING service_settings.service, service_settings.setting
  )
  INSERT INTO aws_oracle_ext.service_settings(service, setting, value)
  SELECT p_service, p_setting, p_value
  WHERE  ( p_service, p_setting ) NOT IN (SELECT service, setting FROM upd);
]]></complex-attribute>
                        <category _I_D="9313b7d1-24b7-4dcd-a64c-dbc6145f6acb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5c78047d-837b-4d05-8e86-5c8e13a57d82" name="set_version" is-trigger-function="0" unique-function-name="set_version" is-aggregate="f" language-name="plpgsql" context="set_version" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying" is-returning-set="f" ret-datatype="void" function-arguments="pcomponentversion character varying, pcomponentname character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22420" volatility="VOLATILE" is-window="f" function-identity-arguments="pcomponentversion character varying, pcomponentname character varying" overload-function-count="1" proc-language="plpgsql" function-signature="set_version(pcomponentversion character varying, pcomponentname character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  rowcount smallint;
BEGIN
	UPDATE aws_oracle_ext.versions 
	   SET componentversion = pComponentVersion
	 WHERE extpackcomponentname = pComponentName;	 
	GET DIAGNOSTICS rowcount = ROW_COUNT;
	
	IF rowcount < 1 THEN
	 INSERT INTO aws_oracle_ext.versions(extpackcomponentname,componentversion) 
	      VALUES (pComponentName,pComponentVersion);
	END IF;
END;
]]></complex-attribute>
                        <category _I_D="5d7a4d17-3af1-4a5c-8379-718a6e423604" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9c791cd9-b921-4f67-b69e-8db306d7b87e" name="sp_get_dbmail" is-trigger-function="0" unique-function-name="sp_get_dbmail" is-aggregate="f" language-name="plpgsql" context="sp_get_dbmail" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,bigint,xml" is-returning-set="t" ret-datatype="table" function-arguments="p_limit integer DEFAULT 1" schema-id="21999" function-type="RET_DATASET" count-arguments="1" function-id="22421" volatility="VOLATILE" is-window="f" function-identity-arguments="p_limit integer" overload-function-count="1" proc-language="plpgsql" function-signature="sp_get_dbmail(p_limit integer)">
                        <complex-attribute name="sql"><![CDATA[
declare
  l_now timestamp with time zone := clock_timestamp();
begin
  return query
    update aws_oracle_ext.mail_messages m
       set read_at = l_now
      from ( 
        select mm.id 
          from aws_oracle_ext.mail_messages mm 
         where mm.read_at is null
           and pg_try_advisory_xact_lock( mm.id )
         limit p_limit 
           for update
      ) i
     where m.id = i.id
    returning m.id, xmlelement( name mail, null, xmlconcat( xmlelement(name source, null, m.sender ), xmlelement( name rawmessage, null, m.body ) ) ) ;
end;
]]></complex-attribute>
                        <category _I_D="12470f4e-3de3-4445-a651-ecaaa883edfa" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3cf15b3c-2ce6-40fa-a21b-96b7cbffcf71" name="sp_set_dbmail" is-trigger-function="0" unique-function-name="sp_set_dbmail" is-aggregate="f" language-name="plpgsql" context="sp_set_dbmail" subcategories-loading="none" object-loading="extended" arguments-datatypes="bigint,integer,character varying,timestamp with time zone" is-returning-set="f" ret-datatype="void" function-arguments="par_mail_id bigint, par_sent_status integer, par_message character varying DEFAULT NULL::character varying, par_processed_at timestamp with time zone DEFAULT clock_timestamp()" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22422" volatility="VOLATILE" is-window="f" function-identity-arguments="par_mail_id bigint, par_sent_status integer, par_message character varying, par_processed_at timestamp with time zone" overload-function-count="1" proc-language="plpgsql" function-signature="sp_set_dbmail(par_mail_id bigint, par_sent_status integer, par_message character varying, par_processed_at timestamp with time zone)">
                        <complex-attribute name="sql"><![CDATA[
begin
  update aws_oracle_ext.mail_messages m
     set processed_at = par_processed_at
       , error_text = par_message
   where m.id = par_mail_id;
end;
]]></complex-attribute>
                        <category _I_D="3209248b-a657-4e4d-bd40-c0beeba4222f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="df8c94c3-a002-4f98-9c6c-8d5d54c223ec" name="sqs_aa_lambda_payload" is-trigger-function="0" unique-function-name="sqs_aa_lambda_payload" is-aggregate="f" language-name="plpgsql" context="sqs_aa_lambda_payload" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="fn_name text, fn_args text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22883" volatility="VOLATILE" is-window="f" function-identity-arguments="fn_name text, fn_args text" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_aa_lambda_payload(fn_name text, fn_args text)">
                        <complex-attribute name="sql"><![CDATA[
begin
	return aws_oracle_ext.awslambda_fn(fn_name, fn_args::json)::text;
end;
]]></complex-attribute>
                        <category _I_D="ae5915dc-6ba5-444b-8a98-a67340c2900e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c8c2981c-b484-4d04-a3fd-2738f22f8377" name="sqs_aq_create_queue" is-trigger-function="0" unique-function-name="sqs_aq_create_queue" is-aggregate="f" language-name="plpgsql" context="sqs_aq_create_queue" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="pvqueuename text, pvqueueattributes text DEFAULT aws_oracle_ext.sqs_default_queue_attributes()" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22884" volatility="VOLATILE" is-window="f" function-identity-arguments="pvqueuename text, pvqueueattributes text" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_aq_create_queue(pvqueuename text, pvqueueattributes text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	/*create queue*/
	LambdaArn constant varchar(250) := aws_oracle_ext.sqs_lu_inited_funcarn('CREATE_QUEUE');
	QueueName constant varchar(30) := 'QueueName';
	lvJSON text;
	lvResult text;
begin
	--
	if pvQueueName = '' then
		raise exception 'invalid value NULL, QUEUE_NAME should be defined'
		using hint  = 'Please check your user Queue name';
	end if;

	with q as (select key, pvQueueName as value
	             from json_each_text(pvQueueAttributes::json)
	            where lower(key) = lower(QueueName)
	           union all
	           select key, value
	             from json_each_text(pvQueueAttributes::json)
	            where lower(key) != lower(QueueName))
	select json_object(array_agg(key), array_agg(value))::text
	  into lvJSON
	 from (
	       select QueueName as key, pvQueueName as value
	       where not exists (select 1 from q where lower(key) = lower(QueueName))
			union all
		  select key, value from q
			) a;

	lvResult = aws_oracle_ext.sqs_aa_lambda_payload(LambdaArn, lvJSON);
	return lvResult;
end;
]]></complex-attribute>
                        <category _I_D="5eb2115d-b145-4de8-8799-56d1de9c538c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dbbc4c9d-e193-46f9-bed5-094a87059c57" name="sqs_aq_delete_message" is-trigger-function="0" unique-function-name="sqs_aq_delete_message" is-aggregate="f" language-name="plpgsql" context="sqs_aq_delete_message" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="pvqueueurl text, pvreceipthandle text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22889" volatility="VOLATILE" is-window="f" function-identity-arguments="pvqueueurl text, pvreceipthandle text" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_aq_delete_message(pvqueueurl text, pvreceipthandle text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	/*delete message*/
	LambdaArn constant varchar(4000) := aws_oracle_ext.sqs_lu_inited_funcarn('DELETE_MESSAGE');
	QueueUrl constant varchar(30) := 'QueueUrl';
	ReceiptHandle constant varchar(30) := 'ReceiptHandle';
	Service constant varchar(30) := 'sqs';
	lvJSON text;
	lvResult text;
begin
	with q (key, value) as (values (QueueUrl, pvQueueUrl), (ReceiptHandle, pvReceiptHandle)
	       )
    select json_object(array_agg(key), array_agg(value))
      into lvJSON
     from q;

    lvResult = aws_oracle_ext.sqs_aa_lambda_payload(LambdaArn, lvJSON);

    return lvResult;
end;
]]></complex-attribute>
                        <category _I_D="f0c32a55-5111-4fcc-90ca-c7b9b0e6bef3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4ff9bf21-08b8-4a3f-9144-5c83b29f9145" name="sqs_aq_delete_queue" is-trigger-function="0" unique-function-name="sqs_aq_delete_queue" is-aggregate="f" language-name="plpgsql" context="sqs_aq_delete_queue" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="text" function-arguments="pvqueueurl text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22885" volatility="VOLATILE" is-window="f" function-identity-arguments="pvqueueurl text" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_aq_delete_queue(pvqueueurl text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	/*delete queue*/
	LambdaArn constant varchar(250) := aws_oracle_ext.sqs_lu_inited_funcarn('DELETE_QUEUE');
	QueueUrl constant varchar(30) := 'QueueUrl';
	AttributeNames constant varchar(30) := 'AttributeNames';
	lvJSON text;
	lvResult text;
begin
	lvJSON = json_object(array_agg(QueueUrl), array_agg(pvQueueUrl));
	lvResult = aws_oracle_ext.sqs_aa_lambda_payload(LambdaArn, lvJSON);
	return lvResult;
end;
]]></complex-attribute>
                        <category _I_D="70838406-13e8-4d7c-afc9-e3ca57defb73" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="430e4731-bf56-4948-912f-b7d2563cf8eb" name="sqs_aq_get_message" is-trigger-function="0" unique-function-name="sqs_aq_get_message" is-aggregate="f" language-name="plpgsql" context="sqs_aq_get_message" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="text" function-arguments="pvqueueurl text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22886" volatility="VOLATILE" is-window="f" function-identity-arguments="pvqueueurl text" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_aq_get_message(pvqueueurl text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	/*receive message*/
	LambdaArn constant varchar(250) := aws_oracle_ext.sqs_lu_inited_funcarn('GET_MESSAGE');
	QueueUrl constant varchar(30) := 'QueueUrl';
	lvJSON text;
	lvResult text;
begin
	lvJSON = json_object(array_agg(QueueUrl), array_agg(pvQueueUrl));
	lvResult = aws_oracle_ext.sqs_aa_lambda_payload(LambdaArn, lvJSON);
	return lvResult;
end;
]]></complex-attribute>
                        <category _I_D="e05a774f-848e-42e6-abd3-a9bc5f5f4a83" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="81cb17d0-4886-4d01-a244-5cfabf4e6968" name="sqs_aq_get_messages_body" is-trigger-function="0" unique-function-name="sqs_aq_get_messages_body" is-aggregate="f" language-name="plpgsql" context="sqs_aq_get_messages_body" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,character varying,character varying,character varying,text" is-returning-set="t" ret-datatype="table" function-arguments="pvqueueurl text" schema-id="21999" function-type="RET_DATASET" count-arguments="1" function-id="22887" volatility="VOLATILE" is-window="f" function-identity-arguments="pvqueueurl text" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_aq_get_messages_body(pvqueueurl text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	lvStatusCode text;
	lvResult json;
begin
	lvResult := aws_oracle_ext.sqs_aq_get_message(pvQueueUrl)::json;

	lvStatusCode := trim(both '"' from json_extract_path(lvResult, 'statusCode')::text);

	if lvStatusCode = '200' then
		return query
		select "MessageId" as MessageId, "ReceiptHandle" as ReceiptHandle, "MD5OfBody" as MD5OfBody, "Body" as Body
		from json_to_recordset(json_extract_path(lvResult, aws_oracle_ext.sqs_queue_body())
		                      ) as x("MessageId" varchar(250),
		                             "ReceiptHandle" varchar(4000),
		                             "MD5OfBody" varchar(250),
		                             "Body" text);

    else
	    return query
	    select null::varchar(250) as MessageId, null::varchar(4000) as ReceiptHandle,
	           null::varchar(250) as MD5OfBody, lvResult::text as Body;
    end if;
end;
]]></complex-attribute>
                        <category _I_D="23dac5d6-8fe0-46d1-bf71-0243754db7bd" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="111ac498-9ffc-4d7c-9472-196c0223929a" name="sqs_aq_send_message" is-trigger-function="0" unique-function-name="sqs_aq_send_message" is-aggregate="f" language-name="plpgsql" context="sqs_aq_send_message" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="text" function-arguments="pvqueueurl text, pvmessagebody text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22888" volatility="VOLATILE" is-window="f" function-identity-arguments="pvqueueurl text, pvmessagebody text" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_aq_send_message(pvqueueurl text, pvmessagebody text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	QueueUrl constant varchar(30) := 'QueueUrl';
	MessageBody constant varchar(30) := 'MessageBody';
	LambdaArn constant varchar(250) := sqs_lu_inited_funcarn('SEND_MESSAGE');
	lvJSON text;
	lvResult text;
begin
	with q (key, value) as (values (QueueUrl, pvQueueUrl), (MessageBody, pvMessageBody)
	       )
    select json_object(array_agg(key), array_agg(value))
      into lvJSON
     from q;

    lvResult = sqs_aa_lambda_payload(LambdaArn, lvJSON);

    return lvResult;
end;
]]></complex-attribute>
                        <category _I_D="b69c81b6-694e-4344-8d21-dbfd7939a144" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="720d1160-b380-4bc4-abf3-705a8640f38b" name="sqs_before" is-trigger-function="0" unique-function-name="sqs_before" is-aggregate="f" language-name="sql" context="sqs_before" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22837" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_before()">
                        <complex-attribute name="sql"><![CDATA[ select 2]]></complex-attribute>
                        <category _I_D="b9d01c29-14ed-4863-ae75-f60d7a9a36d5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="de0ea811-5794-44c1-be20-1fe44e21c43b" name="sqs_browse" is-trigger-function="0" unique-function-name="sqs_browse" is-aggregate="f" language-name="sql" context="sqs_browse" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22838" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_browse()">
                        <complex-attribute name="sql"><![CDATA[ select 1]]></complex-attribute>
                        <category _I_D="64644152-b1d2-459d-b588-fd215fa253e3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7e3ee8c9-8fcf-48bc-b157-f63cb5690eb4" name="sqs_default_error" is-trigger-function="0" unique-function-name="sqs_default_error" is-aggregate="f" language-name="sql" context="sqs_default_error" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22839" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_default_error()">
                        <complex-attribute name="sql"><![CDATA[select 'ERROR.Something gone wrong!']]></complex-attribute>
                        <category _I_D="5ce746d9-08a1-45a6-9f2e-be3b344c1ba7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="91e5e7d1-b325-4bbe-a9bc-174b50cdb85b" name="sqs_default_queue_attributes" is-trigger-function="0" unique-function-name="sqs_default_queue_attributes" is-aggregate="f" language-name="sql" context="sqs_default_queue_attributes" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22840" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_default_queue_attributes()">
                        <complex-attribute name="sql"><![CDATA[select '{"QueueName": "", "FifoQueue": "true", "Policy": ""}']]></complex-attribute>
                        <category _I_D="2bbe9540-3846-45e6-8a57-0bc29b515f38" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0d9fc33f-e997-4fda-a0f9-19c65c407721" name="sqs_expired" is-trigger-function="0" unique-function-name="sqs_expired" is-aggregate="f" language-name="sql" context="sqs_expired" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22841" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_expired()">
                        <complex-attribute name="sql"><![CDATA[ select 3]]></complex-attribute>
                        <category _I_D="4909b307-d0f4-42ed-a106-e754b72ca05a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0e2c7648-eb1b-4dbc-bdf8-dd98b519a578" name="sqs_first_message" is-trigger-function="0" unique-function-name="sqs_first_message" is-aggregate="f" language-name="sql" context="sqs_first_message" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22842" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_first_message()">
                        <complex-attribute name="sql"><![CDATA[ select 1]]></complex-attribute>
                        <category _I_D="88e5978e-2afd-4c2d-97a9-a8145fe9536e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="cb902103-8ee2-488e-a5f0-04442147016f" name="sqs_forever" is-trigger-function="0" unique-function-name="sqs_forever" is-aggregate="f" language-name="sql" context="sqs_forever" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22843" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_forever()">
                        <complex-attribute name="sql"><![CDATA[ select -1]]></complex-attribute>
                        <category _I_D="7d23ac70-c774-4b4b-a047-5d2eacb8f728" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="657fc321-b767-43a8-85b5-16095067785e" name="sqs_immediate" is-trigger-function="0" unique-function-name="sqs_immediate" is-aggregate="f" language-name="sql" context="sqs_immediate" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22844" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_immediate()">
                        <complex-attribute name="sql"><![CDATA[ select 1]]></complex-attribute>
                        <category _I_D="296dd6ef-1391-4aa8-8693-b64a23116ea8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ca04869f-cb13-4343-838a-59d9f41b304b" name="sqs_init_aq$_agent" is-trigger-function="0" unique-function-name="sqs_init_aq$_agent" is-aggregate="f" language-name="sql" context="sqs_init_aq$_agent" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,double precision" is-returning-set="f" ret-datatype="sqs_aq$_agent" function-arguments="name text DEFAULT NULL::text, address text DEFAULT NULL::text, protocol double precision DEFAULT NULL::double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22867" volatility="IMMUTABLE" is-window="f" function-identity-arguments="name text, address text, protocol double precision" overload-function-count="1" proc-language="sql" function-signature="sqs_init_aq$_agent(name text, address text, protocol double precision)">
                        <complex-attribute name="sql"><![CDATA[ select (name, address, coalesce(protocol, 0)):: aws_oracle_ext.SQS_AQ$_AGENT;]]></complex-attribute>
                        <category _I_D="74675ee0-c7e7-48d5-bcad-cfd330bc2f27" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7321273a-7a88-438d-bc2b-b479269fe151" name="sqs_init_aq$_sig_prop" is-trigger-function="0" unique-function-name="sqs_init_aq$_sig_prop" is-aggregate="f" language-name="sql" context="sqs_init_aq$_sig_prop" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea,text,text,text,text,bytea" is-returning-set="f" ret-datatype="sqs_aq$_sig_prop" function-arguments="signature bytea DEFAULT NULL::bytea, canalgo text DEFAULT NULL::text, digalgo text DEFAULT NULL::text, sigalgo text DEFAULT NULL::text, certificate text DEFAULT NULL::text, digval bytea DEFAULT NULL::bytea" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22868" volatility="IMMUTABLE" is-window="f" function-identity-arguments="signature bytea, canalgo text, digalgo text, sigalgo text, certificate text, digval bytea" overload-function-count="1" proc-language="sql" function-signature="sqs_init_aq$_sig_prop(signature bytea, canalgo text, digalgo text, sigalgo text, certificate text, digval bytea)">
                        <complex-attribute name="sql"><![CDATA[ select (signature, canalgo, digalgo, sigalgo, certificate, digval)::aws_oracle_ext.SQS_aq$_sig_prop;
]]></complex-attribute>
                        <category _I_D="f241c7ab-40a8-4863-90cf-07b25be2a6cd" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="50e6db36-cbfb-4136-ac40-feb64dd37e48" name="sqs_init_dbms_aq$dequeue_options_t" is-trigger-function="0" unique-function-name="sqs_init_dbms_aq$dequeue_options_t" is-aggregate="f" language-name="sql" context="sqs_init_dbms_aq$dequeue_options_t" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,integer,integer,integer,integer,bytea,text,text,json,text,integer" is-returning-set="f" ret-datatype="dbms_aq$dequeue_options_t" function-arguments="consumer_name text DEFAULT NULL::text, dequeue_mode integer DEFAULT NULL::integer, navigation integer DEFAULT NULL::integer, visibility integer DEFAULT NULL::integer, wait integer DEFAULT NULL::integer, msgid bytea DEFAULT NULL::bytea, correlation text DEFAULT NULL::text, deq_condition text DEFAULT NULL::text, signature json DEFAULT NULL::json, transformation text DEFAULT NULL::text, delivery_mode integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="11" function-id="22869" volatility="IMMUTABLE" is-window="f" function-identity-arguments="consumer_name text, dequeue_mode integer, navigation integer, visibility integer, wait integer, msgid bytea, correlation text, deq_condition text, signature json, transformation text, delivery_mode integer" overload-function-count="1" proc-language="sql" function-signature="sqs_init_dbms_aq$dequeue_options_t(consumer_name text, dequeue_mode integer, navigation integer, visibility integer, wait integer, msgid bytea, correlation text, deq_condition text, signature json, transformation text, delivery_mode integer)">
                        <complex-attribute name="sql"><![CDATA[ select (
consumer_name ,
coalesce(dequeue_mode, aws_oracle_ext.sqs_remove()),
coalesce(navigation,aws_oracle_ext.sqs_next_message()),
coalesce(visibility,aws_oracle_ext.sqs_on_commit()),
coalesce(wait, aws_oracle_ext.sqs_forever()),
msgid,
correlation,
deq_condition,
json_populate_record(null::aws_oracle_ext.SQS_aq$_sig_prop, signature),
transformation,
coalesce(delivery_mode, aws_oracle_ext.sqs_persistent())
                      )::aws_oracle_ext.dbms_aq$dequeue_options_t;]]></complex-attribute>
                        <category _I_D="02069798-1da5-4d08-8b76-770a629223e7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e2ddb518-dbac-4b63-9532-1e6cb7f4e19d" name="sqs_init_dbms_aq$enqueue_options_t" is-trigger-function="0" unique-function-name="sqs_init_dbms_aq$enqueue_options_t" is-aggregate="f" language-name="sql" context="sqs_init_dbms_aq$enqueue_options_t" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,bytea,integer,text,integer" is-returning-set="f" ret-datatype="dbms_aq$enqueue_options_t" function-arguments="visibility integer DEFAULT NULL::integer, relative_msgid bytea DEFAULT NULL::bytea, sequence_deviation integer DEFAULT NULL::integer, transformation text DEFAULT NULL::text, delivery_mode integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="5" function-id="22870" volatility="IMMUTABLE" is-window="f" function-identity-arguments="visibility integer, relative_msgid bytea, sequence_deviation integer, transformation text, delivery_mode integer" overload-function-count="1" proc-language="sql" function-signature="sqs_init_dbms_aq$enqueue_options_t(visibility integer, relative_msgid bytea, sequence_deviation integer, transformation text, delivery_mode integer)">
                        <complex-attribute name="sql"><![CDATA[ select (coalesce(visibility, aws_oracle_ext.sqs_on_commit()),
                      relative_msgid, sequence_deviation, transformation,
                      coalesce(delivery_mode, aws_oracle_ext.sqs_persistent())
                      )::aws_oracle_ext.dbms_aq$enqueue_options_t;]]></complex-attribute>
                        <category _I_D="02cbe659-b234-4bf4-ad77-7e599826076f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d2103b1c-61f9-4a83-b0bc-913413efb32f" name="sqs_init_dbms_aq$message_properties_t" is-trigger-function="0" unique-function-name="sqs_init_dbms_aq$message_properties_t" is-aggregate="f" language-name="sql" context="sqs_init_dbms_aq$message_properties_t" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,integer,integer,text,integer,json,text,timestamp without time zone,integer,json,bytea,json,text,text,integer" is-returning-set="f" ret-datatype="dbms_aq$message_properties_t" function-arguments="priority integer DEFAULT NULL::integer, delay integer DEFAULT NULL::integer, expiration integer DEFAULT NULL::integer, correlation text DEFAULT NULL::text, attempts integer DEFAULT NULL::integer, recipient_list json DEFAULT NULL::json, exception_queue text DEFAULT NULL::text, enqueue_time timestamp without time zone DEFAULT NULL::timestamp without time zone, state integer DEFAULT NULL::integer, sender_id json DEFAULT NULL::json, original_msgid bytea DEFAULT NULL::bytea, signature json DEFAULT NULL::json, transaction_group text DEFAULT NULL::text, user_property text DEFAULT NULL::text, delivery_mode integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="15" function-id="22871" volatility="IMMUTABLE" is-window="f" function-identity-arguments="priority integer, delay integer, expiration integer, correlation text, attempts integer, recipient_list json, exception_queue text, enqueue_time timestamp without time zone, state integer, sender_id json, original_msgid bytea, signature json, transaction_group text, user_property text, delivery_mode integer" overload-function-count="1" proc-language="sql" function-signature="sqs_init_dbms_aq$message_properties_t(priority integer, delay integer, expiration integer, correlation text, attempts integer, recipient_list json, exception_queue text, enqueue_time timestamp without time zone, state integer, sender_id json, original_msgid bytea, signature json, transaction_group text, user_property text, delivery_mode integer)">
                        <complex-attribute name="sql"><![CDATA[ select (
coalesce(priority,1),
coalesce(delay, aws_oracle_ext.sqs_no_delay()),
coalesce(expiration, aws_oracle_ext.sqs_never()),
correlation,
attempts,
recipient_list,
exception_queue,
enqueue_time,
state,
json_populate_record(null::aws_oracle_ext.sqs_aq$_agent, sender_id),
original_msgid,
json_populate_record(null::aws_oracle_ext.sqs_aq$_sig_prop, signature),
transaction_group,
user_property,
coalesce(delivery_mode, aws_oracle_ext.sqs_persistent())
)::aws_oracle_ext.dbms_aq$message_properties_t;]]></complex-attribute>
                        <category _I_D="ab1fa418-1b6c-4900-b811-fc01d72683c0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="31cccebf-688e-4f7f-bfa5-4130ceb95948" name="sqs_locked" is-trigger-function="0" unique-function-name="sqs_locked" is-aggregate="f" language-name="sql" context="sqs_locked" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22845" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_locked()">
                        <complex-attribute name="sql"><![CDATA[ select 2]]></complex-attribute>
                        <category _I_D="533ca0ab-3da4-49da-981a-08544f98525d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="20255d64-0333-463a-8e9f-652edc75e8ec" name="sqs_lu_create_queue_table" is-trigger-function="0" unique-function-name="sqs_lu_create_queue_table" is-aggregate="f" language-name="plpgsql" context="sqs_lu_create_queue_table" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="pvtablename text, pvtypename text, pvtableschema text DEFAULT ''::text, pvtypeschema text DEFAULT ''::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22872" volatility="VOLATILE" is-window="f" function-identity-arguments="pvtablename text, pvtypename text, pvtableschema text, pvtypeschema text" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_lu_create_queue_table(pvtablename text, pvtypename text, pvtableschema text, pvtypeschema text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	lrT aws_oracle_ext.sqs_queues_tables%rowtype;

	TABLE_DDL  text = 'CREATE TABLE %s.%s '
						'(q_name VARCHAR(61), '
						'msgid BYTEA, '
						'corrid VARCHAR(128), '
						'priority DOUBLE PRECISION, '
						'state DOUBLE PRECISION, '
						'delay TIMESTAMP (6) WITHOUT TIME ZONE, '
						'expiration DOUBLE PRECISION, '
						'time_manager_info TIMESTAMP (6) WITHOUT TIME ZONE, '
						'local_order_no DOUBLE PRECISION, '
						'chain_no DOUBLE PRECISION, '
						'cscn DOUBLE PRECISION, '
						'dscn DOUBLE PRECISION, '
						'enq_time TIMESTAMP (6) WITHOUT TIME ZONE, '
						'enq_uid VARCHAR(30), '
						'enq_tid VARCHAR(30), '
						'deq_time TIMESTAMP (6) WITHOUT TIME ZONE, '
						'deq_uid VARCHAR(30), '
						'deq_tid VARCHAR(30), '
						'retry_count DOUBLE PRECISION, '
						'exception_qschema VARCHAR(30), '
						'exception_queue VARCHAR(30), '
						'step_no DOUBLE PRECISION, '
						'recipient_key DOUBLE PRECISION, '
						'dequeue_msgid BYTEA, '
						'sender_name VARCHAR(30), '
						'sender_address VARCHAR(1024), '
						'sender_protocol DOUBLE PRECISION, '
						'user_data %s.%s, '
						'user_prop VARCHAR(8000), '
						'primary KEY (MSGID)'
						')';
	REGISTER_TABLE text = 'INSERT INTO aws_oracle_ext.sqs_queues_tables '
						  '(tschema, tname, tdatatypeschema, tdatatypename) '
						  'VALUES '
						  '(%s, %s, %s, %s)';
	EXECUTE_BLOCK text = '%s;'
				         '%s;';
begin
	lrT.tschema := lower(coalesce(nullif(pvTableSchema, ''), current_schema()));
	lrT.tname := lower(pvTableName);
	lrT.tdatatypeschema := lower(coalesce(nullif(pvTypeSchema, ''), current_schema()));
	lrT.tdatatypename := lower(pvTypeName);

	select t.user_defined_type_schema,
		   t.user_defined_type_name
	  into lrT.tdatatypeschema,
	       lrT.tdatatypename
	  from information_schema.user_defined_types t
	 where t.user_defined_type_schema = lrT.tdatatypeschema
	   and t.user_defined_type_name = lrT.tdatatypename;

	if nullif(lrT.tdatatypeschema, '') is not null and nullif(lrT.tdatatypename, '') is not null then

		TABLE_DDL := format(TABLE_DDL, lrT.tschema, lrT.tname, lrT.tdatatypeschema, lrT.tdatatypename);
		REGISTER_TABLE := format(REGISTER_TABLE, quote_literal(lrT.tschema), quote_literal(lrT.tname), quote_literal(lrT.tdatatypeschema), quote_literal(lrT.tdatatypename));

		EXECUTE_BLOCK := format(EXECUTE_BLOCK, TABLE_DDL, REGISTER_TABLE);

		EXECUTE EXECUTE_BLOCK;
	else
		raise exception '%', aws_oracle_ext.sqs_default_error();
	end if;
end;
]]></complex-attribute>
                        <category _I_D="2ce1ddc3-4600-477e-b896-b0045e0a6667" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="55e5c20c-6ce6-4adb-987e-8183c6bdb614" name="sqs_lu_define_table" is-trigger-function="0" unique-function-name="sqs_lu_define_table" is-aggregate="f" language-name="plpgsql" context="sqs_lu_define_table" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="record" function-arguments="pvtablename text, OUT ovschemaname text, OUT ovtablename text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22873" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pvtablename text, OUT ovschemaname text, OUT ovtablename text" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_lu_define_table(pvtablename text, OUT ovschemaname text, OUT ovtablename text)">
                        <complex-attribute name="sql"><![CDATA[
begin
	ovtablename := coalesce(nullif(split_part(lower(pvtablename), '.', 2), ''), lower(pvtablename));

	if lower(pvtablename) = ovtablename then
		ovschemaname = current_schema();
	else
		ovschemaname := split_part(lower(pvtablename), '.', 1);
	end if;
end;
]]></complex-attribute>
                        <category _I_D="331f6521-ca05-4d0b-8c85-ad9ebe87cd00" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f9f79bae-bb8b-40a3-b740-86f7432dd5a1" name="sqs_lu_define_type" is-trigger-function="0" unique-function-name="sqs_lu_define_type" is-aggregate="f" language-name="plpgsql" context="sqs_lu_define_type" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="record" function-arguments="pvtypename text, OUT ovschemaname text, OUT ovtypename text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22874" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pvtypename text, OUT ovschemaname text, OUT ovtypename text" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_lu_define_type(pvtypename text, OUT ovschemaname text, OUT ovtypename text)">
                        <complex-attribute name="sql"><![CDATA[
begin
	select a.ovschemaname, a.ovtablename
	  into ovschemaname, ovtypename
 	from aws_oracle_ext.sqs_lu_define_table(pvtypename) a;
end;
]]></complex-attribute>
                        <category _I_D="77c1a3de-e20d-4e48-96a1-920dc096df48" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="24a14b9a-a015-4c7e-85b7-f3d695d527b2" name="sqs_lu_delete_queue_message" is-trigger-function="0" unique-function-name="sqs_lu_delete_queue_message" is-aggregate="f" language-name="plpgsql" context="sqs_lu_delete_queue_message" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="queue text, msgid text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22876" volatility="VOLATILE" is-window="f" function-identity-arguments="queue text, msgid text" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_lu_delete_queue_message(queue text, msgid text)">
                        <complex-attribute name="sql"><![CDATA[
declare
DELETE_DDL  text = 'DELETE FROM %s.%s t'
						' WHERE t.q_name = %s and'
						' t.msgid = %s';

lrT aws_oracle_ext.sqs_queues_tables%rowtype;
begin
	lrT := aws_oracle_ext.sqs_lu_inited_queuetbl(pvname := queue);
	DELETE_DDL := format(DELETE_DDL, lrT.tschema, lrT.tname, quote_literal(queue), quote_literal(msgid));

	EXECUTE DELETE_DDL;
end;
]]></complex-attribute>
                        <category _I_D="a5dc8372-a9b6-4d0c-86c3-997b54607b0b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="90d62f21-25e2-4070-9d80-15265c8fbf2b" name="sqs_lu_delete_queue_table" is-trigger-function="0" unique-function-name="sqs_lu_delete_queue_table" is-aggregate="f" language-name="plpgsql" context="sqs_lu_delete_queue_table" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="void" function-arguments="pvqueuename text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22875" volatility="VOLATILE" is-window="f" function-identity-arguments="pvqueuename text" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_lu_delete_queue_table(pvqueuename text)">
                        <complex-attribute name="sql"><![CDATA[
begin
	DELETE FROM aws_oracle_ext.sqs_queues_settings WHERE qname = pvqueuename;
end;
]]></complex-attribute>
                        <category _I_D="8203a7bf-9604-4978-b144-ed6fc56f2fe3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0906a320-fa5f-4dda-8aaf-e2a1fac1cfe2" name="sqs_lu_drop_queue_table" is-trigger-function="0" unique-function-name="sqs_lu_drop_queue_table" is-aggregate="f" language-name="plpgsql" context="sqs_lu_drop_queue_table" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="pvtablename text, pvschemaname text DEFAULT ''::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22877" volatility="VOLATILE" is-window="f" function-identity-arguments="pvtablename text, pvschemaname text" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_lu_drop_queue_table(pvtablename text, pvschemaname text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	lvSchemaName text := coalesce(nullif(pvschemaname, ''), current_schema());
	lvTableName text := pvtablename;
	UNREGISTER_TABLE text := 'DELETE FROM aws_oracle_ext.sqs_queues_tables WHERE tschema = %s and tname = %s';
	TABLE_DDL  text := 'DROP TABLE %s.%s';
	EXECUTE_BLOCK text := '%s;'
	                      '%s;';
	lnQueueRegistered int;
begin

  select count(1)
    into lnQueueRegistered
	from aws_oracle_ext.sqs_vw_queues_settings q
	where q.tschema = lvSchemaName
      and q.tname = lvTableName;

    if lnQueueRegistered = 0 then
		UNREGISTER_TABLE := format(UNREGISTER_TABLE, quote_literal(lvSchemaName),quote_literal(pvTableName));
		TABLE_DDL := format(TABLE_DDL, lvSchemaName, pvTableName);
		EXECUTE_BLOCK := format(EXECUTE_BLOCK, UNREGISTER_TABLE, TABLE_DDL);
		EXECUTE EXECUTE_BLOCK;
	else
		raise exception '%', aws_oracle_ext.sqs_default_error();
	end if;

end;
]]></complex-attribute>
                        <category _I_D="8b04b974-b364-43ca-a404-a48cbfa1b390" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7e8580e7-0e9d-4c9b-ad4a-f5738f705949" name="sqs_lu_inited_funcarn" is-trigger-function="0" unique-function-name="sqs_lu_inited_funcarn" is-aggregate="f" language-name="sql" context="sqs_lu_inited_funcarn" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="varchar" function-arguments="pvaction text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22878" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pvaction text" overload-function-count="1" proc-language="sql" function-signature="sqs_lu_inited_funcarn(pvaction text)">
                        <complex-attribute name="sql"><![CDATA[
	select f.Arn
	  from aws_oracle_ext.sqs_functions_settings f
	 where f.fAction = pvAction
	;
]]></complex-attribute>
                        <category _I_D="10ea66cc-4939-4392-8b4b-05a199e63e1c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a553cd64-bf68-458c-9b0e-43ab962093ff" name="sqs_lu_inited_queuetbl" is-trigger-function="0" unique-function-name="sqs_lu_inited_queuetbl" is-aggregate="f" language-name="plpgsql" context="sqs_lu_inited_queuetbl" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="sqs_queues_tables" function-arguments="pvname text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22879" volatility="VOLATILE" is-window="f" function-identity-arguments="pvname text" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_lu_inited_queuetbl(pvname text)">
                        <complex-attribute name="sql"><![CDATA[
declare
	lrT aws_oracle_ext.sqs_queues_tables%rowtype;
	lnTID integer;
begin

	select -1 id, tschema, tname, tdatatypeschema, tdatatypename
	  into lrT
	  from aws_oracle_ext.sqs_vw_queues_settings q
	 where q.qName = pvName
	;

	if lrT.Id is null or lrT.tname is null or lrT.tdatatypename is null then

	   select tableid
	   	 into lnTID
		 from aws_oracle_ext.sqs_queues_settings s
		where s.qname = pvname;

		if lnTID is null then
			raise exception '% does not exist or does not define', pvname
			using hint  = '-24010';
		else
			raise exception 'invalid value. Queue table or type does not exist or does not define for queue %', pvname
			using hint  = '-24000';
		end if;

	end if;

	return lrT;
end;
]]></complex-attribute>
                        <category _I_D="542ce9a2-a81a-4dc2-a291-35f01d1c332e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c23cd43a-1b22-4364-b2d9-16cc49175b88" name="sqs_lu_inited_queueurl" is-trigger-function="0" unique-function-name="sqs_lu_inited_queueurl" is-aggregate="f" language-name="sql" context="sqs_lu_inited_queueurl" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="varchar" function-arguments="pvname text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22880" volatility="IMMUTABLE" is-window="f" function-identity-arguments="pvname text" overload-function-count="1" proc-language="sql" function-signature="sqs_lu_inited_queueurl(pvname text)">
                        <complex-attribute name="sql"><![CDATA[
	select q.Url
	  from aws_oracle_ext.sqs_queues_settings q
	 where q.qName = pvName
	;
]]></complex-attribute>
                        <category _I_D="a8f49cd2-7a1e-460f-b761-57010471d379" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="71127280-364e-4919-bc9c-55e16170517e" name="sqs_lu_insert_func_arn" is-trigger-function="0" unique-function-name="sqs_lu_insert_func_arn" is-aggregate="f" language-name="sql" context="sqs_lu_insert_func_arn" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="varchar" function-arguments="pvaction text, pvfunctionname text, pvarn text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22881" volatility="VOLATILE" is-window="f" function-identity-arguments="pvaction text, pvfunctionname text, pvarn text" overload-function-count="1" proc-language="sql" function-signature="sqs_lu_insert_func_arn(pvaction text, pvfunctionname text, pvarn text)">
                        <complex-attribute name="sql"><![CDATA[
	with d (action_, functionname, arn) as
			  (select upper(pvaction) , lower(pvfunctionname) , lower(pvarn)
				where upper(pvaction) = any ('{DELETE_QUEUE,SEND_MESSAGE,DELETE_MESSAGE,CREATE_QUEUE,GET_MESSAGE,INIT_QUEUES}')
 		  		  and lower(pvfunctionname) = split_part(lower(pvarn), ':', 7)
 		  		  and pvfunctionname != ''
 		  		  and pvarn != ''
 	          )
	insert into aws_oracle_ext.sqs_functions_settings select action_, functionname, arn from d
	on conflict(faction) do
		update set fname = lower(pvfunctionname),
		           arn = lower(pvarn)
	returning fname;
]]></complex-attribute>
                        <category _I_D="b6f7e7df-f272-4ad1-97cb-18b5b63c769a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="03a988db-c71d-43d6-b946-ff7063b0728f" name="sqs_lu_insert_queue_table" is-trigger-function="0" unique-function-name="sqs_lu_insert_queue_table" is-aggregate="f" language-name="plpgsql" context="sqs_lu_insert_queue_table" subcategories-loading="none" object-loading="extended" arguments-datatypes="json,json" is-returning-set="f" ret-datatype="void" function-arguments="queue_table_record json, msg_record json" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22882" volatility="VOLATILE" is-window="f" function-identity-arguments="queue_table_record json, msg_record json" overload-function-count="1" proc-language="plpgsql" function-signature="sqs_lu_insert_queue_table(queue_table_record json, msg_record json)">
                        <complex-attribute name="sql"><![CDATA[
declare
USER_DATA text = 'json_populate_record(null::%s.%s, %s)';
TABLE_DDL  text = 'INSERT INTO %s.%s ('
						'q_name, msgid, corrid, '
						'priority, state, delay, '
						'expiration, time_manager_info, local_order_no, '
						'chain_no, cscn, dscn, '
						'enq_time, enq_uid, enq_tid, '
						'deq_time, deq_uid,  deq_tid, '
						'retry_count, exception_qschema, exception_queue, '
						'step_no, recipient_key, dequeue_msgid, '
						'sender_name, sender_address, sender_protocol, '
						'user_data, user_prop'
						')'
						'VALUES ( '
							'%s, %s::bytea, null, '
							'0, 0, null, '
							'null, null, 0, '
							'0, 0, 0, '
							'now(), current_user, txid_current() , '
							'null, null, null, '
							'0, null, null, '
							'0, 0, null::bytea, '
							'null, null, 0, '
							'%s, null'
							')';

lrT aws_oracle_ext.sqs_queues_tables%rowtype;
lrM aws_oracle_ext.sqs_queue_record;
begin
	lrT := json_populate_record(lrT, queue_table_record);
 	lrM := json_populate_record(lrM, msg_record);

	USER_DATA := format(USER_DATA, lrT.tdatatypeschema, lrT.tdatatypename, quote_literal(lrM.user_data));
	TABLE_DDL := format(TABLE_DDL, lrT.tschema, lrT.tname, quote_literal(lrM.q_name), quote_literal(lrM.msgid), USER_DATA);

	EXECUTE TABLE_DDL;
end;
]]></complex-attribute>
                        <category _I_D="d29467f5-bb67-4f83-a4bb-0640f8f9ad88" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0c3dbc11-56f2-4786-9bb0-29af203852a4" name="sqs_namespace_anonymous" is-trigger-function="0" unique-function-name="sqs_namespace_anonymous" is-aggregate="f" language-name="sql" context="sqs_namespace_anonymous" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22846" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_namespace_anonymous()">
                        <complex-attribute name="sql"><![CDATA[ select 0]]></complex-attribute>
                        <category _I_D="d8a84dc3-0c62-48a0-8241-c0cb497eea98" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2480dd59-8fca-467e-8fc3-85ebec994c0c" name="sqs_namespace_aq" is-trigger-function="0" unique-function-name="sqs_namespace_aq" is-aggregate="f" language-name="sql" context="sqs_namespace_aq" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22848" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_namespace_aq()">
                        <complex-attribute name="sql"><![CDATA[ select 1]]></complex-attribute>
                        <category _I_D="3a81d477-d0be-4a3e-bfe3-36eba9230f82" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bdaaaa83-9e4f-4d93-9d3a-661a98ae9957" name="sqs_never" is-trigger-function="0" unique-function-name="sqs_never" is-aggregate="f" language-name="sql" context="sqs_never" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22847" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_never()">
                        <complex-attribute name="sql"><![CDATA[ select -1]]></complex-attribute>
                        <category _I_D="5376cafc-a804-4204-8533-676ea4f89f4a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4e14c351-108b-4b47-a785-270a6318af17" name="sqs_next_message" is-trigger-function="0" unique-function-name="sqs_next_message" is-aggregate="f" language-name="sql" context="sqs_next_message" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22849" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_next_message()">
                        <complex-attribute name="sql"><![CDATA[ select 3]]></complex-attribute>
                        <category _I_D="61a29484-a3ed-4f46-a0dd-8ddb12c76d2c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="14104e1c-7d32-4c79-a2d3-c299c5e77e7d" name="sqs_no_delay" is-trigger-function="0" unique-function-name="sqs_no_delay" is-aggregate="f" language-name="sql" context="sqs_no_delay" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22850" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_no_delay()">
                        <complex-attribute name="sql"><![CDATA[ select 0]]></complex-attribute>
                        <category _I_D="5633077d-fe93-45a4-ab5c-280e041194e5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0d9c8c24-5845-4824-8298-ef6feb0f95bd" name="sqs_no_wait" is-trigger-function="0" unique-function-name="sqs_no_wait" is-aggregate="f" language-name="sql" context="sqs_no_wait" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22851" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_no_wait()">
                        <complex-attribute name="sql"><![CDATA[ select 0]]></complex-attribute>
                        <category _I_D="0f5e6608-2cc4-47b7-9eab-cc73247bc24a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7a2141f6-58ec-4f7d-bb3e-1bcecd546ef0" name="sqs_none" is-trigger-function="0" unique-function-name="sqs_none" is-aggregate="f" language-name="sql" context="sqs_none" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22852" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_none()">
                        <complex-attribute name="sql"><![CDATA[ select 0]]></complex-attribute>
                        <category _I_D="70af8bf3-f797-4e18-a0a7-cb7beb4cb854" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1b81946d-f06a-4565-98c6-eb7b23c1780e" name="sqs_normal_queue" is-trigger-function="0" unique-function-name="sqs_normal_queue" is-aggregate="f" language-name="sql" context="sqs_normal_queue" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22853" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_normal_queue()">
                        <complex-attribute name="sql"><![CDATA[ select 0]]></complex-attribute>
                        <category _I_D="05cf2917-23bf-4e25-aac0-a61e0fe28821" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="353986df-d7de-4445-a37d-816e716ce0fa" name="sqs_ntfn_grouping_forever" is-trigger-function="0" unique-function-name="sqs_ntfn_grouping_forever" is-aggregate="f" language-name="sql" context="sqs_ntfn_grouping_forever" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22854" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_ntfn_grouping_forever()">
                        <complex-attribute name="sql"><![CDATA[ select -1]]></complex-attribute>
                        <category _I_D="0cb07186-7b17-4ef2-a33d-423fe3f658e3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d69248d1-4625-44cb-ba84-c1d9f04d15d5" name="sqs_ntfn_grouping_type_last" is-trigger-function="0" unique-function-name="sqs_ntfn_grouping_type_last" is-aggregate="f" language-name="sql" context="sqs_ntfn_grouping_type_last" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22855" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_ntfn_grouping_type_last()">
                        <complex-attribute name="sql"><![CDATA[ select 2]]></complex-attribute>
                        <category _I_D="4292d479-1f04-4cda-a6cc-347c1fcb2507" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5490ada1-0bec-49bd-af36-38a0358f4679" name="sqs_ntfn_grouping_type_summary" is-trigger-function="0" unique-function-name="sqs_ntfn_grouping_type_summary" is-aggregate="f" language-name="sql" context="sqs_ntfn_grouping_type_summary" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22856" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_ntfn_grouping_type_summary()">
                        <complex-attribute name="sql"><![CDATA[ select 1]]></complex-attribute>
                        <category _I_D="21177ad8-171a-4796-bb1b-2bf97de74f49" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="02d982a6-fce3-4771-8142-37223fc083cf" name="sqs_on_commit" is-trigger-function="0" unique-function-name="sqs_on_commit" is-aggregate="f" language-name="sql" context="sqs_on_commit" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22857" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_on_commit()">
                        <complex-attribute name="sql"><![CDATA[ select 2]]></complex-attribute>
                        <category _I_D="f08de8de-1c5b-469a-a8a4-1f2f20e5b43a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="abf29bbf-8c69-47f0-b66e-24cd72562a3f" name="sqs_persistent" is-trigger-function="0" unique-function-name="sqs_persistent" is-aggregate="f" language-name="sql" context="sqs_persistent" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22858" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_persistent()">
                        <complex-attribute name="sql"><![CDATA[select 1]]></complex-attribute>
                        <category _I_D="fafc5253-6487-4f3e-908e-d4037443e1f3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="beac7b12-f25b-4b30-a16d-9f7796e8506f" name="sqs_processed" is-trigger-function="0" unique-function-name="sqs_processed" is-aggregate="f" language-name="sql" context="sqs_processed" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22859" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_processed()">
                        <complex-attribute name="sql"><![CDATA[ select 2]]></complex-attribute>
                        <category _I_D="b0311b98-70d1-4611-ab3b-d47ca5d05a2e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a17c1e82-46a7-4dc3-814c-13e50350607e" name="sqs_queue_body" is-trigger-function="0" unique-function-name="sqs_queue_body" is-aggregate="f" language-name="sql" context="sqs_queue_body" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22860" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_queue_body()">
                        <complex-attribute name="sql"><![CDATA[select 'body']]></complex-attribute>
                        <category _I_D="f6883be3-4f5a-4756-80ae-29aee7c6e701" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="083b049f-22d2-499b-910f-865954e6ea2c" name="sqs_queue_fifo" is-trigger-function="0" unique-function-name="sqs_queue_fifo" is-aggregate="f" language-name="sql" context="sqs_queue_fifo" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="varchar" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22861" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_queue_fifo()">
                        <complex-attribute name="sql"><![CDATA[select 'fifo']]></complex-attribute>
                        <category _I_D="d06293d5-4058-4536-8ce7-fcc4e2984aa8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9f4711b4-9af4-4b34-b631-9348892b2e53" name="sqs_ready" is-trigger-function="0" unique-function-name="sqs_ready" is-aggregate="f" language-name="sql" context="sqs_ready" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22862" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_ready()">
                        <complex-attribute name="sql"><![CDATA[ select 0]]></complex-attribute>
                        <category _I_D="e8070118-6fb0-41d6-b64e-b2efcd5f67a7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e4e860a9-a9e1-455b-9da3-980d48c5d226" name="sqs_remove" is-trigger-function="0" unique-function-name="sqs_remove" is-aggregate="f" language-name="sql" context="sqs_remove" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22863" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_remove()">
                        <complex-attribute name="sql"><![CDATA[ select 3]]></complex-attribute>
                        <category _I_D="c00df98a-7dff-4a50-ba0a-51acfd89c5d5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6d0e7024-14bb-4037-9ef3-3cc766b8a98d" name="sqs_remove_nodata" is-trigger-function="0" unique-function-name="sqs_remove_nodata" is-aggregate="f" language-name="sql" context="sqs_remove_nodata" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22864" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_remove_nodata()">
                        <complex-attribute name="sql"><![CDATA[ select 4]]></complex-attribute>
                        <category _I_D="b3620ccd-e4c3-4afc-8d4c-fa0d5424cc2f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9cfb66df-64aa-495e-9eb6-648c5adeab6c" name="sqs_top" is-trigger-function="0" unique-function-name="sqs_top" is-aggregate="f" language-name="sql" context="sqs_top" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22865" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_top()">
                        <complex-attribute name="sql"><![CDATA[ select 3]]></complex-attribute>
                        <category _I_D="f1030288-0584-42a4-acc9-55969acac0c7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5162747a-9fc9-4297-831e-769c83fef96d" name="sqs_waiting" is-trigger-function="0" unique-function-name="sqs_waiting" is-aggregate="f" language-name="sql" context="sqs_waiting" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22866" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sqs_waiting()">
                        <complex-attribute name="sql"><![CDATA[ select 1]]></complex-attribute>
                        <category _I_D="6f1df284-0364-4269-9670-c8fdfe56a286" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="eef8a854-00a0-4a0b-8dad-325bdac4dbbb" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(bigint, text)" is-aggregate="f" language-name="sql" context="standard_hash(bigint, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bigint,text" comment="This function computes a hash value for a given numeric (bigint) expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(bigint, text)" routine-number="23382" is-returning-set="f" ret-datatype="bytea" function-arguments="bigint, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23382" volatility="IMMUTABLE" is-window="f" function-identity-arguments="bigint, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(bigint, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(int8send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="ec819145-590e-4bc4-a630-f602480f9ec5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d6e0b64b-2aca-4e4b-9269-82cfcf996e6c" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(boolean, text)" is-aggregate="f" language-name="sql" context="standard_hash(boolean, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="boolean,text" comment="This function computes a hash value for a given boolean expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(boolean, text)" routine-number="23387" is-returning-set="f" ret-datatype="bytea" function-arguments="boolean, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23387" volatility="IMMUTABLE" is-window="f" function-identity-arguments="boolean, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(boolean, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(boolsend($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="600743ce-4f0d-4d7c-9fef-5d23b8c6d13d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="95248b79-db7f-4752-9b14-bc546e16135f" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(bytea, text)" is-aggregate="f" language-name="sql" context="standard_hash(bytea, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea,text" comment="This function computes a hash value for a given binary expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(bytea, text)" routine-number="23379" is-returning-set="f" ret-datatype="bytea" function-arguments="bytea, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23379" volatility="IMMUTABLE" is-window="f" function-identity-arguments="bytea, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(bytea, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce($1, ''), trim($2));
]]></complex-attribute>
                        <category _I_D="43864e86-3c26-4a42-8c0a-466c9061e359" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0db8ec18-2335-4ce6-9495-9021a6978208" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(date, text)" is-aggregate="f" language-name="sql" context="standard_hash(date, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="date,text" comment="This function computes a hash value for a given date expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(date, text)" routine-number="23388" is-returning-set="f" ret-datatype="bytea" function-arguments="date, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23388" volatility="IMMUTABLE" is-window="f" function-identity-arguments="date, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(date, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(date_send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="34f4980a-7ad4-4dae-8a46-78bf42711d4c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d86d11de-711b-4132-bba0-66e4db683be7" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(double precision, text)" is-aggregate="f" language-name="sql" context="standard_hash(double precision, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,text" comment="This function computes a hash value for a given numeric (double precision) expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(double precision, text)" routine-number="23385" is-returning-set="f" ret-datatype="bytea" function-arguments="double precision, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23385" volatility="IMMUTABLE" is-window="f" function-identity-arguments="double precision, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(double precision, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(float8send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="912ef143-9276-44dd-8af0-4e02db3aac06" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="84bd28f6-fc84-44b3-98b7-73a33e53872d" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(integer, text)" is-aggregate="f" language-name="sql" context="standard_hash(integer, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,text" comment="This function computes a hash value for a given numeric (integer) expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(integer, text)" routine-number="23381" is-returning-set="f" ret-datatype="bytea" function-arguments="integer, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23381" volatility="IMMUTABLE" is-window="f" function-identity-arguments="integer, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(integer, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(int4send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="c7a6bdd9-667a-434d-b1a4-ad861903a196" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="410dd2ad-6b1f-4814-949d-427ce604d5ec" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(interval, text)" is-aggregate="f" language-name="sql" context="standard_hash(interval, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="interval,text" comment="This function computes a hash value for a given time interval expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(interval, text)" routine-number="23393" is-returning-set="f" ret-datatype="bytea" function-arguments="interval, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23393" volatility="IMMUTABLE" is-window="f" function-identity-arguments="interval, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(interval, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(interval_send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="9f836b04-ae7f-410a-929d-5310a5af9370" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f9b3f47f-d2dd-4aa8-8324-7993614bd29c" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(json, text)" is-aggregate="f" language-name="sql" context="standard_hash(json, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="json,text" comment="This function computes a hash value for a given JSON expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(json, text)" routine-number="23394" is-returning-set="f" ret-datatype="bytea" function-arguments="json, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23394" volatility="IMMUTABLE" is-window="f" function-identity-arguments="json, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(json, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(json_send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="ad450097-2784-4327-b18a-e665b352d7e3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1ddd9427-b641-4b28-a7e2-4a1a72b56b86" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(jsonb, text)" is-aggregate="f" language-name="sql" context="standard_hash(jsonb, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb,text" comment="This function computes a hash value for a given binary JSON expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(jsonb, text)" routine-number="23395" is-returning-set="f" ret-datatype="bytea" function-arguments="jsonb, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23395" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(jsonb, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(jsonb_send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="8afa703b-09e3-46f1-bf3b-9c1c1fed14de" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="04e91f4f-9c0b-451b-8e76-c58343604225" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(money, text)" is-aggregate="f" language-name="sql" context="standard_hash(money, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="money,text" comment="This function computes a hash value for a given money expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(money, text)" routine-number="23386" is-returning-set="f" ret-datatype="bytea" function-arguments="money, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23386" volatility="IMMUTABLE" is-window="f" function-identity-arguments="money, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(money, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(numeric_send($1::NUMERIC), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="a60bb22c-6c23-4ecd-960f-3079d773a203" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="36ddae0a-462c-436d-b9d4-48e784723aaf" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(numeric, text)" is-aggregate="f" language-name="sql" context="standard_hash(numeric, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,text" comment="This function computes a hash value for a given numeric (numeric) expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(numeric, text)" routine-number="23383" is-returning-set="f" ret-datatype="bytea" function-arguments="numeric, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23383" volatility="IMMUTABLE" is-window="f" function-identity-arguments="numeric, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(numeric, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(numeric_send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="4415338b-16f8-422f-ad61-5e0c50174b53" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b5770574-786a-42f1-87ab-78d171df5e43" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(real, text)" is-aggregate="f" language-name="sql" context="standard_hash(real, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="real,text" comment="This function computes a hash value for a given numeric (real) expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(real, text)" routine-number="23384" is-returning-set="f" ret-datatype="bytea" function-arguments="real, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23384" volatility="IMMUTABLE" is-window="f" function-identity-arguments="real, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(real, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(float4send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="d4f109b8-f4ad-45d4-a251-2911dedf3295" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0eeab5ec-ad2a-4e32-b066-cfece90e5ad5" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(smallint, text)" is-aggregate="f" language-name="sql" context="standard_hash(smallint, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="smallint,text" comment="This function computes a hash value for a given numeric (smallint) expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(smallint, text)" routine-number="23380" is-returning-set="f" ret-datatype="bytea" function-arguments="smallint, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23380" volatility="IMMUTABLE" is-window="f" function-identity-arguments="smallint, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(smallint, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(int2send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="6080d7ee-cc11-4680-b320-586801c505f8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="67598210-c52a-4c7a-ba92-1b7cc83e20f6" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(text, text)" is-aggregate="f" language-name="sql" context="standard_hash(text, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" comment="This function computes a hash value for a given character (text) expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(text, text)" routine-number="23378" is-returning-set="f" ret-datatype="bytea" function-arguments="text, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23378" volatility="IMMUTABLE" is-window="f" function-identity-arguments="text, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(text, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce($1, ''), trim($2));
]]></complex-attribute>
                        <category _I_D="54e1d435-6936-40fc-a1da-6c703c48e250" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7a973ae5-d181-4430-922d-821cef16dd9d" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(time with time zone, text)" is-aggregate="f" language-name="sql" context="standard_hash(time with time zone, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="time with time zone,text" comment="This function computes a hash value for a given time expression (with time zone) using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(time with time zone, text)" routine-number="23392" is-returning-set="f" ret-datatype="bytea" function-arguments="time with time zone, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23392" volatility="IMMUTABLE" is-window="f" function-identity-arguments="time with time zone, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(time with time zone, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(timetz_send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="075ead98-0774-4895-827e-9f6f01999a25" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="02397bc9-daaf-4aa0-8cc8-ca9db2a86f03" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(time without time zone, text)" is-aggregate="f" language-name="sql" context="standard_hash(time without time zone, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="time without time zone,text" comment="This function computes a hash value for a given time expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(time without time zone, text)" routine-number="23391" is-returning-set="f" ret-datatype="bytea" function-arguments="time without time zone, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23391" volatility="IMMUTABLE" is-window="f" function-identity-arguments="time without time zone, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(time without time zone, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(time_send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="e9257cf5-6619-4f84-9e40-d70fb0747f35" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="88c4e2de-4b94-4b00-a713-d6b4ccd2acbb" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(timestamp with time zone, text)" is-aggregate="f" language-name="sql" context="standard_hash(timestamp with time zone, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp with time zone,text" comment="This function computes a hash value for a given datetime expression (with time zone) using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(timestamp with time zone, text)" routine-number="23390" is-returning-set="f" ret-datatype="bytea" function-arguments="timestamp with time zone, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23390" volatility="IMMUTABLE" is-window="f" function-identity-arguments="timestamp with time zone, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(timestamp with time zone, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(timestamptz_send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="1766e2f9-83fa-4574-bf07-b5904223fdd9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="446cf8c9-8aca-4dda-ac1e-390b6489edcc" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(timestamp without time zone, text)" is-aggregate="f" language-name="sql" context="standard_hash(timestamp without time zone, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone,text" comment="This function computes a hash value for a given datetime expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(timestamp without time zone, text)" routine-number="23389" is-returning-set="f" ret-datatype="bytea" function-arguments="timestamp without time zone, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23389" volatility="IMMUTABLE" is-window="f" function-identity-arguments="timestamp without time zone, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(timestamp without time zone, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(timestamp_send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="cc83866b-bcea-4d39-87df-baffa03e9696" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f54e6ddf-29ac-4f58-823c-d935d493e46b" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(uuid, text)" is-aggregate="f" language-name="sql" context="standard_hash(uuid, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="uuid,text" comment="This function computes a hash value for a given universally unique identifier (UUID) expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(uuid, text)" routine-number="23397" is-returning-set="f" ret-datatype="bytea" function-arguments="uuid, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23397" volatility="IMMUTABLE" is-window="f" function-identity-arguments="uuid, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(uuid, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(uuid_send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="a2f77591-8f51-4484-88a3-c77f80198004" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="14a3101e-78e4-4e46-98b7-b4aef5beef42" name="standard_hash" is-trigger-function="0" unique-function-name="standard_hash(xml, text)" is-aggregate="f" language-name="sql" context="standard_hash(xml, text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="xml,text" comment="This function computes a hash value for a given XML expression using one of several hash algorithms. Valid algorithms are SHA1 (default), SHA256, SHA384, SHA512, and MD5." unique-suffix="(xml, text)" routine-number="23396" is-returning-set="f" ret-datatype="bytea" function-arguments="xml, text DEFAULT 'sha1'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23396" volatility="IMMUTABLE" is-window="f" function-identity-arguments="xml, text" overload-function-count="20" proc-language="sql" function-signature="standard_hash(xml, text)">
                        <complex-attribute name="sql"><![CDATA[
SELECT digest(coalesce(xml_send($1), ''), trim($2));
]]></complex-attribute>
                        <category _I_D="0acc0010-91af-4e8b-bd3c-d804c86c9d79" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2a692b58-fb44-463f-9fd2-758c980e5761" name="strip_sql_comments" is-trigger-function="0" unique-function-name="strip_sql_comments" is-aggregate="f" language-name="plpgsql" context="strip_sql_comments" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,boolean,text[],boolean" comment="This function removes single and multi-line comments from SQL statement. Available validation (check for unpaired) of multi-line comments within SQL statement. Oracle Database Optimizer Hints removal can be skipped as well." is-returning-set="f" ret-datatype="text" function-arguments="p_sql_statement text, p_skip_hints boolean DEFAULT false, p_adv_quote_tags text[] DEFAULT ARRAY[''::text], p_validate_multiline boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22341" volatility="VOLATILE" is-window="f" function-identity-arguments="p_sql_statement text, p_skip_hints boolean, p_adv_quote_tags text[], p_validate_multiline boolean" overload-function-count="1" proc-language="plpgsql" function-signature="strip_sql_comments(p_sql_statement text, p_skip_hints boolean, p_adv_quote_tags text[], p_validate_multiline boolean)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    i_tag RECORD;
    v_tag_pos INTEGER;
    v_tag_len INTEGER;
    v_adv_tag TEXT;
    v_reversed_sql TEXT;
    v_sql_statement TEXT;
    i_multi_comment RECORD;
    v_unpaired_cnt INTEGER;
    v_comm_startpos INTEGER;
    v_comm_endpos INTEGER;
    v_comm_length INTEGER;
    v_adv_quote_tags TEXT[];
    v_adv_tag_idx INTEGER[];
    v_idx_offset INTEGER := 0;
    v_hints_single_regexp TEXT;
    v_hints_multi_regexp TEXT;
    v_hints_list_regexp TEXT;
    v_dml_multi_regexp TEXT;
    v_singlecomm_cnt INTEGER;
    v_adv_quote_tag_cnt INTEGER;
    v_left_multicomm_cnt INTEGER;
    v_right_multicomm_cnt INTEGER;
    v_adv_quote_tag_idx TEXT[];
    v_single_comm_idx INTEGER[];
    v_literal_start_idx INTEGER[];
    v_literal_end_idx INTEGER[];
    v_left_multicomm_idx INTEGER[];
    v_right_multicomm_idx INTEGER[];
    v_ambiguously_comm_pos INTEGER;
    v_within_literal_res SMALLINT := 0;
    v_dml_keywords_regexp CONSTANT TEXT := 'SELECT|INSERT|UPDATE|DELETE|MERGE';
    -- Full list of Oracle Database Optimizer Hints
    v_hints_list CONSTANT TEXT[] := ARRAY['ALL_ROWS', 'FIRST_ROWS', 'FIRST_ROWS_1', 'FIRST_ROWS_100', 'CHOOSE', 'RULE', 'NO_PUSH_PRED',
                                          'CLUSTER', 'FULL', 'HASH', 'ROWID', 'INDEX', 'NO_INDEX', 'INDEX_ASC', 'INDEX_DESC', 'USE_NL',
                                          'INDEX_COMBINE', 'INDEX_FFS', 'ORDERED', 'ORDERED_PREDICATES', 'STAR', 'DRIVING_SITE', 'NL_SJ',
                                          'HASH_SJ', 'MERGE_SJ', 'LEADING', 'USE_HASH', 'USE_MERGE', 'NOPARALLEL', 'PARALLEL_INDEX',
                                          'PARALLEL', 'PQ_DISTRIBUTE', 'NOPARALLEL_INDEX', 'STAR_TRANSFORMATION', 'USE_NL_WITH_INDEX',
                                          'NO_EXPAND', 'FACT', 'NOFACT', 'MERGE', 'NO_MERGE', 'REWRITE', 'NOREWRITE', 'USE_CONCAT',
                                          'APPEND', 'NOAPPEND', 'CACHE', 'NOCACHE', 'PUSH_PRED', 'AND_EQUAL', 'PUSH_SUBQ', 'NO_PUSH_SUBQ',
                                          'BYPASS_RECURSIVE_CHECK', 'BYPASS_UJVC', 'CACHE_CB', 'CACHE_TEMP_TABLE', 'CIV_GB',
                                          'COLLECTIONS_GET_REFS', 'CUBE_GB', 'CURSOR_SHARING_EXACT', 'DEREF_NO_REWRITE', 'DML_UPDATE',
                                          'DOMAIN_INDEX_NO_SORT', 'DOMAIN_INDEX_SORT', 'DYNAMIC_SAMPLING', 'DYNAMIC_SAMPLING_EST_CDN',
                                          'EXPAND_GSET_TO_UNION', 'FORCE_SAMPLE_BLOCK', 'GBY_CONC_ROLLUP', 'GLOBAL_TABLE_HINTS',
                                          'HWM_BROKERED', 'IGNORE_ON_CLAUSE', 'IGNORE_WHERE_CLAUSE', 'INDEX_RRS', 'INDEX_SS', 'UNNEST',
                                          'INDEX_SS_ASC', 'INDEX_SS_DESC', 'LIKE_EXPAND', 'LOCAL_INDEXES', 'MV_MERGE', 'NO_FILTERING',
                                          'NESTED_TABLE_GET_REFS', 'NESTED_TABLE_SET_REFS', 'NESTED_TABLE_SET_SETID', 'REMOTE_MAPPED',
                                          'NO_EXPAND_GSET_TO_UNION', 'NO_FACT', 'NO_ORDER_ROLLUPS', 'NO_PRUNE_GSETS', 'NO_STATS_GSETS',
                                          'NO_UNNEST', 'NOCPU_COSTING OVERFLOW_NOMOVE', 'PIV_GB', 'PIV_SSF', 'PQ_MAP', 'SCN_ASCENDING',
                                          'RESTORE_AS_INTERVALS', 'SAVE_AS_INTERVALS', 'SKIP_EXT_OPTIMIZER', 'PQ_NOMAP', 'TIV_SSF',
                                          'USE_TTT_FOR_GSETS', 'SQLLDR', 'SYS_DL_CURSOR', 'SYS_PARALLEL_TXN', 'SYS_RID_ORDER', 'PQ_SKEW',
                                          'HASH_AJ', 'INDEX_JOIN', 'NO_INDEX_FFS', 'NO_INDEX_SS', 'NO_QUERY_TRANSFORMATION', 'BITMAP',
                                          'NO_STAR_TRANSFORMATION', 'NO_USE_NL', 'NO_USE_MERGE', 'NO_USE_HASH', 'NO_PARALLEL', 'NL_AJ',
                                          'NO_PARALLEL_INDEX', 'QB_NAME', 'SPREAD_MIN_ANALYSIS', 'MERGE_AJ', 'NO_REWRITE', 'NO_USE_BAND',
                                          'CLUSTERING', 'NO_CLUSTERING', 'NATIVE_FULL_OUTER_JOIN', 'NO_NATIVE_FULL_OUTER_JOIN', 'TIV_GB',
                                          'NO_ZONEMAP', 'USE_BAND', 'NO_INMEMORY_PRUNING', 'INMEMORY_PRUNING', 'NO_PQ_CONCURRENT_UNION',
                                          'ENABLE_PARALLEL_DML', 'DISABLE_PARALLEL_DML', 'PQ_CONCURRENT_UNION', 'USE_CUBE', 'INMEMORY',
                                          'CHANGE_DUPKEY_ERROR_INDEX', 'IGNORE_ROW_ON_DUPKEY_INDEX', 'RETRY_ON_ROW_CHANGE', 'PQ_FILTER',
                                          'GATHER_OPTIMIZER_STATISTICS', 'NO_GATHER_OPTIMIZER_STATISTICS', 'GROUPING', 'PX_JOIN_FILTER',
                                          'MODEL_MIN_ANALYSIS', 'NO_PX_JOIN_FILTER', 'NO_XMLINDEX_REWRITE', 'NO_XML_QUERY_REWRITE',
                                          'NO_PQ_SKEW', 'APPEND_VALUES', 'CONTAINERS', 'NOCACHE', 'FRESH_MV', 'MONITOR', 'NO_MONITOR',
                                          'OPT_PARAM', 'CACHE', 'NOCACHE', 'NO_USE_CUBE', 'NO_INMEMORY'];
BEGIN
    v_sql_statement := trim(p_sql_statement);

    -- Checking for ambiguously defined multi-line comments
    v_ambiguously_comm_pos := position('*/*' in v_sql_statement);

    IF (v_ambiguously_comm_pos > 0) THEN
        RAISE escape_character_conflict;
    END IF;

    -- Composing complete hints regexp (HINT1|HINT2|HINTn)
    v_hints_list_regexp := array_to_string(v_hints_list, '|');

    IF (p_skip_hints) THEN
        v_dml_multi_regexp := format('(%s)\s*$', v_dml_keywords_regexp);
        v_hints_multi_regexp := format('^/\*\+\s*(%s)', v_hints_list_regexp);

        -- Composing regexp to remove single-line comments but skip Optimizer Hints
        v_hints_single_regexp := format('(?<!(?:%s)\s*)--\+\s*(%s).*|(?<=(?:%s)\s*)--\+(?!\s*(?:%s)).*|(?<=(?:\s*))--(?!\+).*',
                                        v_dml_keywords_regexp,
                                        v_hints_list_regexp,
                                        v_dml_keywords_regexp,
                                        v_hints_list_regexp);
    ELSE
        v_hints_single_regexp := '\s*--.*';
    END IF;

    -- Removing distinct and NULL values
    SELECT array_agg(DISTINCT adv_quote_tag)
      INTO v_adv_quote_tags
      FROM unnest(p_adv_quote_tags) tags (adv_quote_tag)
     WHERE adv_quote_tag IS NOT NULL;

    -- Determining the count of advanced quoting tags
    v_adv_quote_tag_cnt := coalesce(array_length(v_adv_quote_tags, 1), 0);

    IF (v_adv_quote_tag_cnt > 0)
    THEN
        -- Determining positions of each advanced quoting tag ($q$, $Q$, ...)
        FOREACH v_adv_tag IN ARRAY v_adv_quote_tags
        LOOP
            v_idx_offset := 0;
            v_adv_tag_idx := '{}'::INTEGER[];

            v_tag_len = char_length(v_adv_tag);
            v_tag_pos = position(v_adv_tag IN v_sql_statement);

            WHILE (v_tag_pos > 0)
            LOOP
                v_idx_offset := v_idx_offset + v_tag_pos;

                IF (aws_oracle_ext.regexp_count(substring(v_sql_statement, v_idx_offset), '''') % 2 = 1)
                THEN
                    v_idx_offset := v_idx_offset + v_tag_len;
                    v_tag_pos = position(v_adv_tag IN substring(v_sql_statement, v_idx_offset)) - 1;

                    CONTINUE;
                END IF;

                v_adv_tag_idx := array_append(v_adv_tag_idx, v_idx_offset);

                v_idx_offset := v_idx_offset + v_tag_len;
                v_tag_pos = position(v_adv_tag IN substring(v_sql_statement, v_idx_offset)) - 1;
            END LOOP;

            v_adv_quote_tag_idx := array_append(v_adv_quote_tag_idx, array_to_string(v_adv_tag_idx, ','));
            v_adv_tag_idx := '{}'::INTEGER[];
            v_adv_tag := NULL;
        END LOOP;

        -- Merging advanced quoting ($q$..$q$) sections
        FOR i_tag IN
        (WITH adv_quote_tags AS (
         SELECT tags,
                generate_subscripts(tags, 1) tag_num
           FROM (VALUES (v_adv_quote_tags)) adv_quote_tags (tags)
         ),
         adv_quote_tag_idx AS (
         SELECT tags[tag_num] tag,
                unnest(string_to_array((v_adv_quote_tag_idx)[tag_num], ','))::INTEGER tag_idx
           FROM adv_quote_tags
          ORDER BY tag_idx ASC)

         SELECT ROW_NUMBER() OVER (ORDER BY tag_idx) tag_num,
                tag_idx.*
           FROM adv_quote_tag_idx tag_idx)
        LOOP
            IF (v_adv_tag IS NULL)
            THEN
                v_adv_tag := i_tag.tag;
                v_literal_start_idx := array_append(v_literal_start_idx, i_tag.tag_idx);

                CONTINUE;
            END IF;

            CONTINUE WHEN i_tag.tag <> v_adv_tag;

            v_literal_end_idx := array_append(v_literal_end_idx,
                                              i_tag.tag_idx + char_length(v_adv_tag));
            v_adv_tag := NULL;
        END LOOP;

        -- Rearming offset
        v_idx_offset := 0;
    END IF;

    -- Counting single-line comments in SQL statement
    SELECT COUNT(1)
      INTO v_singlecomm_cnt
      FROM regexp_matches(v_sql_statement, '--', 'ngi');

    -- Searching for `literal` single-line comments
    FOR i_comment_num IN 1..v_singlecomm_cnt
    LOOP
        v_comm_startpos := aws_oracle_ext.regexp_instr(v_sql_statement, '--', p_occurrence => i_comment_num);

        -- Single-line comment is part of a string literal (single quotes)
        IF (aws_oracle_ext.regexp_count(v_sql_statement, '''', v_comm_startpos) % 2 = 1)
        THEN
            v_single_comm_idx := array_append(v_single_comm_idx, v_comm_startpos);

            CONTINUE;
        ELSIF (v_adv_quote_tag_cnt > 0) THEN
            SELECT COUNT(1)
              INTO v_within_literal_res
              FROM unnest(v_literal_start_idx,
                          v_literal_end_idx) adv_tag_positions (tag_start, tag_end)
             WHERE v_comm_startpos BETWEEN tag_start + 1
                                       AND tag_end;

            -- Single-line comment is part of a string literal (advanced quoting)
            IF (coalesce(v_within_literal_res, 0) > 0)
            THEN
                v_single_comm_idx := array_append(v_single_comm_idx, v_comm_startpos);

                CONTINUE;
            END IF;
        END IF;

        v_reversed_sql := reverse(substring(v_sql_statement, 1, v_comm_startpos));

        -- Single-line comment located inside multi-line comment
        IF (v_comm_startpos - CASE
                                 WHEN position('*/' in v_reversed_sql) = 0 THEN v_comm_startpos
                                 ELSE position('*/' in v_reversed_sql)
                              END > CASE
                                       WHEN position('/*' in v_reversed_sql) = 0 THEN 0
                                       ELSE v_comm_startpos
                                    END - position('/*' in v_reversed_sql))
        THEN
            v_single_comm_idx := array_append(v_single_comm_idx, v_comm_startpos);
        END IF;
    END LOOP;

    FOR i_comment_num IN 1..coalesce(array_length(v_single_comm_idx, 1), 0)
    LOOP
        -- Masking `literal` single-line comments with "<_($-$$-$)_>"
        v_sql_statement := overlay(v_sql_statement placing '<_($-$$-$)_>' -- 10 = length('<_($-$$-$)_>') - length('--')
                                                      from (v_single_comm_idx[i_comment_num] + (i_comment_num - 1) * 10)
                                                       for 2);
    END LOOP;

    -- Removing non-masked single-line comments
    v_sql_statement := regexp_replace(v_sql_statement, v_hints_single_regexp, '', 'ngi');

    -- Restoring masked single-line comments back to its originals
    v_sql_statement := replace(v_sql_statement, '<_($-$$-$)_>', '--');

    SELECT COUNT(1)
      INTO v_left_multicomm_cnt
      FROM regexp_matches(v_sql_statement, '/\*', 'ngi');

    FOR i_comment_num IN 1..v_left_multicomm_cnt
    LOOP
        v_within_literal_res := 0;
        v_comm_startpos := aws_oracle_ext.regexp_instr(v_sql_statement, '/\*', p_occurrence => i_comment_num);

        IF (v_adv_quote_tag_cnt > 0)
        THEN
            SELECT COUNT(1)
              INTO v_within_literal_res
              FROM unnest(v_literal_start_idx,
                          v_literal_end_idx) adv_tag_positions (tag_start, tag_end)
             WHERE v_comm_startpos BETWEEN tag_start + 1
                                       AND tag_end;

            v_within_literal_res := coalesce(v_within_literal_res, 0);
        END IF;

        -- Skip multi-line comments found inside string literals
        IF (aws_oracle_ext.regexp_count(v_sql_statement, '''', v_comm_startpos) % 2 = 0 AND v_within_literal_res = 0)
        THEN
            v_left_multicomm_idx := array_append(v_left_multicomm_idx, v_comm_startpos);
        END IF;
    END LOOP;

    SELECT COUNT(1)
      INTO v_right_multicomm_cnt
      FROM regexp_matches(v_sql_statement, '\*/', 'ngi');

    FOR i_comment_num IN 1..v_right_multicomm_cnt
    LOOP
        v_within_literal_res := 0;
        v_comm_endpos := aws_oracle_ext.regexp_instr(v_sql_statement, '\*/', p_occurrence => i_comment_num);

        IF (v_adv_quote_tag_cnt > 0)
        THEN
            SELECT COUNT(1)
              INTO v_within_literal_res
              FROM unnest(v_literal_start_idx,
                          v_literal_end_idx) adv_tag_positions (tag_start, tag_end)
             WHERE v_comm_endpos BETWEEN tag_start + 1
                                     AND tag_end;

            v_within_literal_res := coalesce(v_within_literal_res, 0);
        END IF;

        -- Skip multi-line comments found inside string literals
        IF (aws_oracle_ext.regexp_count(v_sql_statement, '''', v_comm_endpos) % 2 = 0 AND v_within_literal_res = 0)
        THEN
            v_right_multicomm_idx := array_append(v_right_multicomm_idx, v_comm_endpos);
        END IF;
    END LOOP;

    -- Removing multi-line comments
    FOR i_multi_comment IN
    (WITH src_data AS (
     SELECT left_part,
            right_part,
            coalesce(LAG(right_part, 1) OVER (ORDER BY right_part), 0) prev_right
       FROM unnest(v_left_multicomm_idx,
                   v_right_multicomm_idx) AS src (left_part, right_part)
     ),
     pair_set AS (
     SELECT (SELECT MIN(left_part)
               FROM src_data src2
              WHERE src2.left_part < src1.right_part
                AND src2.left_part > src1.prev_right
            ) left_part,
            src1.right_part
       FROM src_data src1
     UNION ALL
     SELECT left_part,
            NULL
       FROM src_data
      WHERE left_part > (SELECT MAX(right_part)
                           FROM src_data))
     SELECT *
       FROM pair_set
      WHERE NOT (left_part IS NULL AND
                 right_part IS NULL))
    LOOP
        v_comm_startpos := i_multi_comment.left_part;
        v_comm_endpos := i_multi_comment.right_part + 2; -- length of "*/"

        -- Checking if there are any unpaired multi-line comments
        IF (coalesce(v_comm_startpos, v_comm_endpos) = v_comm_endpos OR
            coalesce(v_comm_endpos, v_comm_startpos) = v_comm_startpos)
        THEN
            IF (p_validate_multiline) THEN
                -- Found unpaired multi-line comment
                RAISE invalid_xml_comment;
            ELSE
                CONTINUE;
            END IF;
        ELSIF (p_skip_hints) THEN
            IF (substring(v_sql_statement, 1, v_comm_startpos - v_idx_offset - 1) ~* v_dml_multi_regexp AND
                substring(v_sql_statement, v_comm_startpos - v_idx_offset) ~* v_hints_multi_regexp)
            THEN
                -- Skip hint removal
                CONTINUE;
            END IF;
        END IF;

        -- Offsetting comment start/stop indexes
        v_comm_length := v_comm_endpos - v_comm_startpos;
        v_comm_startpos := v_comm_startpos - v_idx_offset;
        v_idx_offset := v_idx_offset + v_comm_length - 1;

        -- Removing multi-line comment by substituting it with a space symbol
        v_sql_statement := overlay(v_sql_statement placing ' ' from v_comm_startpos
                                                       for v_comm_length);
    END LOOP;

    /* Removing any unnecessary blank strings and spaces
       from the beginning and the end of SQL statement */
    RETURN regexp_replace(v_sql_statement, '^\s*(?=\S*)|(?<=\S*)\s*$', '', 'gi');
EXCEPTION
    -- SQL statement contains ambiguously defined multi-line comment
    WHEN escape_character_conflict THEN
        RAISE USING MESSAGE := 'SQL statement contains ambiguously defined multi-line comment.',
                    DETAIL := format('Supplied SQL statement contains ambiguously defined (*/*) multi-line comment at position %s.', v_ambiguously_comm_pos),
                    HINT := 'Correct the SQL statement so that any multi-line comment opening\closing tag be explicitly defined.';
    -- SQL statement contains unpaired multi-line comment
    WHEN invalid_xml_comment THEN
        RAISE USING MESSAGE := 'SQL statement contains unpaired multi-line comment.',
                    DETAIL := 'Supplied SQL statement contains unpaired multi-line comment. Oracle error ''ORA-01742: comment not terminated properly''.',
                    HINT := 'Correct the SQL statement so that any multi-line comment has its own opening\closing tag.';
END;
]]></complex-attribute>
                        <category _I_D="781f441d-f066-49ee-9715-79a4b6ea27cd" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="bb84eb6d-3092-41a4-86e5-a133d09bca76" name="substr" is-trigger-function="0" unique-function-name="substr(text, numeric)" is-aggregate="f" language-name="sql" context="substr(text, numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric" comment="Implements Oracle SUBSTR(). Original PostgreSQL SUBSTR() uses different logic with negative arguments and rejects numeric argoments for position" unique-suffix="(text, numeric)" routine-number="22494" is-returning-set="f" ret-datatype="text" function-arguments="text, numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22494" volatility="IMMUTABLE" is-window="f" function-identity-arguments="text, numeric" overload-function-count="2" proc-language="sql" function-signature="substr(text, numeric)">
                        <complex-attribute name="sql"><![CDATA[
    
    SELECT
        CASE
            WHEN ABS(TRUNC($2)::INTEGER) > LENGTH($1) THEN
                
                NULL::TEXT

            WHEN TRUNC($2)::INTEGER >= 0 THEN

                SUBSTR($1, CASE WHEN TRUNC($2)::INTEGER = 0 THEN 1 ELSE TRUNC($2)::INTEGER END)

            ELSE
                
                SUBSTR($1, LENGTH($1) + TRUNC($2)::INTEGER + 1)
        END;

]]></complex-attribute>
                        <category _I_D="aa3c503b-bc0d-47e6-9484-087ab2f18d1d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7bcf7838-12f0-4988-b89b-fb3e2fba2ac7" name="substr" is-trigger-function="0" unique-function-name="substr(text, numeric, numeric)" is-aggregate="f" language-name="sql" context="substr(text, numeric, numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,numeric" comment="Implements Oracle SUBSTR(). Original PostgreSQL SUBSTR() uses different logic with negative arguments and rejects numeric argoments for position and length" unique-suffix="(text, numeric, numeric)" routine-number="22495" is-returning-set="f" ret-datatype="text" function-arguments="text, numeric, numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22495" volatility="IMMUTABLE" is-window="f" function-identity-arguments="text, numeric, numeric" overload-function-count="2" proc-language="sql" function-signature="substr(text, numeric, numeric)">
                        <complex-attribute name="sql"><![CDATA[
    
    SELECT
        CASE
            WHEN TRUNC($3)::INTEGER <= 0 THEN

                NULL::TEXT

            WHEN ABS(TRUNC($2)::INTEGER) > LENGTH($1) THEN
                
                NULL::TEXT

            WHEN TRUNC($2)::INTEGER >= 0 THEN

                SUBSTR($1, CASE WHEN TRUNC($2)::INTEGER = 0 THEN 1 ELSE TRUNC($2)::INTEGER END, TRUNC($3)::INTEGER)

            ELSE
                
                SUBSTR($1, LENGTH($1) + TRUNC($2)::INTEGER + 1, TRUNC($3)::INTEGER)
        END;

]]></complex-attribute>
                        <category _I_D="99d48d39-3693-4cd6-8819-91ec1016d057" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0ccd4320-66d9-43e9-a7de-90af2f3ca4b1" name="substrb" is-trigger-function="0" unique-function-name="substrb(text, numeric)" is-aggregate="f" language-name="sql" context="substrb(text, numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric" comment="Implements Oracle SUBSTRB(). Original PostgreSQL SUBSTRB() uses different logic with negative arguments and rejects numeric argoments for position" unique-suffix="(text, numeric)" routine-number="22496" is-returning-set="f" ret-datatype="text" function-arguments="text, numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22496" volatility="IMMUTABLE" is-window="f" function-identity-arguments="text, numeric" overload-function-count="2" proc-language="sql" function-signature="substrb(text, numeric)">
                        <complex-attribute name="sql"><![CDATA[
    
    SELECT
        CASE
            WHEN ABS(TRUNC($2)::INTEGER) > OCTET_LENGTH($1) THEN
                
                NULL::TEXT

            WHEN TRUNC($2)::INTEGER >= 0 THEN

                CONVERT_FROM(SUBSTR($1::BYTEA, CASE WHEN TRUNC($2)::INTEGER = 0 THEN 1 ELSE TRUNC($2)::INTEGER END),'UTF8')

            ELSE
                
                CONVERT_FROM(SUBSTR($1::BYTEA, OCTET_LENGTH($1) + TRUNC($2)::INTEGER + 1),'UTF8')
        END;

]]></complex-attribute>
                        <category _I_D="5c805b72-389d-4a7c-8993-27a61e1a9760" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="67cdeda9-8810-409c-84a4-6cfe124c9936" name="substrb" is-trigger-function="0" unique-function-name="substrb(text, numeric, numeric)" is-aggregate="f" language-name="sql" context="substrb(text, numeric, numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,numeric,numeric" comment="Implements Oracle SUBSTRB(). Original PostgreSQL SUBSTRB() uses different logic with negative arguments and rejects numeric argoments for position and length" unique-suffix="(text, numeric, numeric)" routine-number="22497" is-returning-set="f" ret-datatype="text" function-arguments="text, numeric, numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22497" volatility="IMMUTABLE" is-window="f" function-identity-arguments="text, numeric, numeric" overload-function-count="2" proc-language="sql" function-signature="substrb(text, numeric, numeric)">
                        <complex-attribute name="sql"><![CDATA[
    
    SELECT
        CASE
            WHEN TRUNC($3)::INTEGER <= 0 THEN

                NULL::TEXT

            WHEN ABS(TRUNC($2)::INTEGER) > OCTET_LENGTH($1) THEN
                
                NULL::TEXT

            WHEN TRUNC($2)::INTEGER >= 0 THEN
                
                CONVERT_FROM(SUBSTR($1::BYTEA, CASE WHEN TRUNC($2)::INTEGER = 0 THEN 1 ELSE TRUNC($2)::INTEGER END, TRUNC($3)::INTEGER),'UTF8')

            ELSE
                
                CONVERT_FROM(SUBSTR($1::BYTEA, OCTET_LENGTH($1) + TRUNC($2)::INTEGER + 1, TRUNC($3)::INTEGER),'UTF8')
        END;

]]></complex-attribute>
                        <category _I_D="0cc6aa34-9b93-4ba8-b79e-b0a330295994" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="89921f5d-0a3d-443e-aa40-f3573efc47ce" name="sys_anydata$accessbdouble" is-trigger-function="0" unique-function-name="sys_anydata$accessbdouble" is-aggregate="f" language-name="sql" context="sys_anydata$accessbdouble" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="float8" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23157" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessbdouble(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN (aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.BINARY_DOUBLE')
   AND ($1 ->> 'SYS.BINARY_DOUBLE' <> '') 
  THEN
	 ($1->> 'SYS.BINARY_DOUBLE')::DOUBLE PRECISION
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="421ed263-c379-40c2-9c0d-a5a2d1763be0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9581d347-2c43-417d-a72c-1f3aa4d4aef7" name="sys_anydata$accessbfile" is-trigger-function="0" unique-function-name="sys_anydata$accessbfile" is-aggregate="f" language-name="sql" context="sys_anydata$accessbfile" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="varchar" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23158" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessbfile(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.BFILE' THEN
     ($1->> 'SYS.BFILE')::CHARACTER VARYING
  ELSE
    NULL
  END;
]]></complex-attribute>
                        <category _I_D="b6d0b68c-8ecd-4ff5-840c-e5f14c507121" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4856a990-b250-4c32-b528-0fab06fbcc6e" name="sys_anydata$accessbfloat" is-trigger-function="0" unique-function-name="sys_anydata$accessbfloat" is-aggregate="f" language-name="sql" context="sys_anydata$accessbfloat" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="float4" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23159" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessbfloat(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN (aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.BINARY_FLOAT')
   AND ($1 ->> 'SYS.BINARY_FLOAT' <> '') 
  THEN
	 ($1->> 'SYS.BINARY_FLOAT')::REAL
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="792950b3-7e7f-4685-89fb-249aa230f4b7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="62a1d19f-3f1d-4ce1-abc9-652a36a03e24" name="sys_anydata$accessblob" is-trigger-function="0" unique-function-name="sys_anydata$accessblob" is-aggregate="f" language-name="sql" context="sys_anydata$accessblob" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="bytea" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23160" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessblob(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN (aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.BLOB')
   AND ($1 ->> 'SYS.BLOB' <> '') 
  THEN
	 ($1->> 'SYS.BLOB')::BYTEA
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="eea95e7f-6a04-4879-b5cd-36bf31e79a67" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a15e7f54-7f61-46d5-8205-d5dd72ecf640" name="sys_anydata$accesschar" is-trigger-function="0" unique-function-name="sys_anydata$accesschar" is-aggregate="f" language-name="sql" context="sys_anydata$accesschar" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="bpchar" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23161" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accesschar(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN (aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.CHAR')
   AND ($1 ->> 'SYS.CHAR' <> '') 
  THEN
	 ($1->> 'SYS.CHAR')::CHARACTER
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="115922e0-a861-444d-a03a-685d0059179b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3f786969-02aa-4729-90fd-fade58128c3a" name="sys_anydata$accessclob" is-trigger-function="0" unique-function-name="sys_anydata$accessclob" is-aggregate="f" language-name="sql" context="sys_anydata$accessclob" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="text" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23162" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessclob(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.CLOB' 
    AND ($1 ->> 'SYS.CLOB' <> '')
  THEN
     ($1->> 'SYS.CLOB')
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="75fb9d69-096d-42ec-82ea-f510d9cd2e0e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6cc211d8-00a3-4e3c-9b16-f1c1592aedee" name="sys_anydata$accessdate" is-trigger-function="0" unique-function-name="sys_anydata$accessdate" is-aggregate="f" language-name="sql" context="sys_anydata$accessdate" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="timestamp" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23163" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessdate(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.DATE' AND ($1 ->> 'SYS.DATE' <> '') 
  THEN
     ($1 ->> 'SYS.DATE')::TIMESTAMP(0) WITHOUT TIME ZONE    
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="cf3dc11a-a0ce-411e-9354-d116a6bc30d7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="89dc7dff-65a5-48a7-9bc2-cd1907d5c20b" name="sys_anydata$accessintervalds" is-trigger-function="0" unique-function-name="sys_anydata$accessintervalds" is-aggregate="f" language-name="sql" context="sys_anydata$accessintervalds" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="interval" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23164" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessintervalds(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN (aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.INTERVAL_DAY_SECOND')
   AND ($1 ->> 'SYS.INTERVAL_DAY_SECOND' <> '') 
  THEN
	 ($1->> 'SYS.INTERVAL_DAY_SECOND')::INTERVAL DAY TO SECOND
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="9d5216ec-51b4-4d2f-9e38-d43b350672c3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6fdf19fc-a9eb-498b-93e0-91e084ae863a" name="sys_anydata$accessintervalym" is-trigger-function="0" unique-function-name="sys_anydata$accessintervalym" is-aggregate="f" language-name="sql" context="sys_anydata$accessintervalym" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="interval" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23165" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessintervalym(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN (aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.INTERVAL_YEAR_MONTH')
   AND ($1 ->> 'SYS.INTERVAL_YEAR_MONTH' <> '') 
  THEN
	 ($1->> 'SYS.INTERVAL_YEAR_MONTH')::INTERVAL YEAR TO MONTH
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="1cc0f8e8-e8f1-4fe9-99f5-be4d5f7f11ae" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="49c03495-ac6c-484e-b84a-f9fdaddf1b4d" name="sys_anydata$accessnchar" is-trigger-function="0" unique-function-name="sys_anydata$accessnchar" is-aggregate="f" language-name="sql" context="sys_anydata$accessnchar" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="bpchar" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23166" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessnchar(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN (aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.NCHAR')
   AND ($1 ->> 'SYS.NCHAR' <> '') 
  THEN
	 ($1->> 'SYS.NCHAR')
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="8bcee23e-c9db-49ea-bbb7-16e38d1faded" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="94743114-29f7-4963-9f07-40678e362464" name="sys_anydata$accessnclob" is-trigger-function="0" unique-function-name="sys_anydata$accessnclob" is-aggregate="f" language-name="sql" context="sys_anydata$accessnclob" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="text" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23167" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessnclob(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN (aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.NCLOB')
   AND ($1 ->> 'SYS.NCLOB' <> '') 
  THEN
	 ($1->> 'SYS.NCLOB')
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="9c4e9ca1-5057-435a-90a1-bfc4f7c4b2d1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7a9accfa-1c93-49f7-9c57-a2a1af0ee3f4" name="sys_anydata$accessnumber" is-trigger-function="0" unique-function-name="sys_anydata$accessnumber" is-aggregate="f" language-name="sql" context="sys_anydata$accessnumber" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="numeric" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23168" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessnumber(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN (aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.NUMBER')
   AND ($1 ->> 'SYS.NUMBER' <> '') 
  THEN
	 ($1->> 'SYS.NUMBER')::NUMERIC
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="f4f84bc0-580a-473e-88bf-ee6c196e6056" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e009e104-7868-44a1-afe6-9c5d85e6cacb" name="sys_anydata$accessnvarchar2" is-trigger-function="0" unique-function-name="sys_anydata$accessnvarchar2" is-aggregate="f" language-name="sql" context="sys_anydata$accessnvarchar2" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="text" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23169" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessnvarchar2(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN (aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.NVARCHAR2')
   AND ($1 ->> 'SYS.NVARCHAR2' <> '') 
  THEN
	 ($1->> 'SYS.NVARCHAR2')
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="3ea54413-eb16-4e55-af85-ed745756dc0c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="59da1952-ca3a-4681-ba97-b4d5f69e4909" name="sys_anydata$accessraw" is-trigger-function="0" unique-function-name="sys_anydata$accessraw" is-aggregate="f" language-name="sql" context="sys_anydata$accessraw" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="bytea" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23170" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessraw(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN (aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.RAW')
   AND ($1 ->> 'SYS.RAW' <> '') 
  THEN
	 ($1->> 'SYS.RAW')::BYTEA
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="b6ea09ab-bad2-41d9-9873-f79c956297c3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a47dffa0-2d36-4b49-a7bd-51c4689c8e15" name="sys_anydata$accesstimestamp" is-trigger-function="0" unique-function-name="sys_anydata$accesstimestamp" is-aggregate="f" language-name="sql" context="sys_anydata$accesstimestamp" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="timestamp" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23171" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accesstimestamp(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.TIMESTAMP' AND ($1 ->> 'SYS.TIMESTAMP' <> '') THEN
     ($1 ->> 'SYS.TIMESTAMP')::TIMESTAMP WITHOUT TIME ZONE    
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="4183dcdd-cd62-42ac-9d96-6983cc19eaae" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ebcce261-6aba-4ea9-b499-50f8b9d177c5" name="sys_anydata$accesstimestampltz" is-trigger-function="0" unique-function-name="sys_anydata$accesstimestampltz" is-aggregate="f" language-name="sql" context="sys_anydata$accesstimestampltz" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="timestamp" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23172" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accesstimestampltz(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.TIMESTAMP_WITH_LTZ' AND ($1 ->> 'SYS.TIMESTAMP_WITH_LTZ' <> '') THEN
     ($1 ->> 'SYS.TIMESTAMP_WITH_LTZ')::TIMESTAMP WITHOUT TIME ZONE
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="c99527e9-00e4-4623-aa28-48c3b7f6d30e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dcf8203f-736d-4e7f-8c7c-e999899518a4" name="sys_anydata$accesstimestamptz" is-trigger-function="0" unique-function-name="sys_anydata$accesstimestamptz" is-aggregate="f" language-name="sql" context="sys_anydata$accesstimestamptz" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="timestamptz" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23173" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accesstimestamptz(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.TIMESTAMP_WITH_TIMEZONE' AND ($1 ->> 'SYS.TIMESTAMP_WITH_TIMEZONE' <> '') THEN
     ($1 ->> 'SYS.TIMESTAMP_WITH_TIMEZONE')::TIMESTAMP WITH TIME ZONE
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="10d6f20a-0f61-4040-a972-f4765e7f7275" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d3b414f5-631d-40de-9825-076cc06a8920" name="sys_anydata$accessurowid" is-trigger-function="0" unique-function-name="sys_anydata$accessurowid" is-aggregate="f" language-name="sql" context="sys_anydata$accessurowid" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="text" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23174" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessurowid(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN (aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.UROWID') AND ($1 ->> 'SYS.UROWID' <> '') 
  THEN
	 ($1->> 'SYS.UROWID')
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="5605393b-552b-434b-8cd2-fc1f18af88a0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b22e64f3-4c34-4b6e-84dd-37490be9e6d7" name="sys_anydata$accessvarchar" is-trigger-function="0" unique-function-name="sys_anydata$accessvarchar" is-aggregate="f" language-name="sql" context="sys_anydata$accessvarchar" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="text" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23176" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessvarchar(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN (aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.VARCHAR')
   AND ($1 ->> 'SYS.VARCHAR' <> '') 
  THEN
	 ($1->> 'SYS.VARCHAR')
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="d1454cec-f0c5-4fd3-9ba4-9e611109ec07" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8b57475c-6039-4148-aed6-5234d4cca772" name="sys_anydata$accessvarchar2" is-trigger-function="0" unique-function-name="sys_anydata$accessvarchar2" is-aggregate="f" language-name="sql" context="sys_anydata$accessvarchar2" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="text" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23175" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$accessvarchar2(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
  CASE WHEN (aws_oracle_ext.sys_anydata$gettypename($1) = 'SYS.VARCHAR2')
   AND ($1 ->> 'SYS.VARCHAR2' <> '') 
  THEN
	 ($1->> 'SYS.VARCHAR2')
  ELSE
     NULL
  END;
]]></complex-attribute>
                        <category _I_D="9caa9e1d-9468-492c-a46f-a2488f8f12b2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b146e9a5-803d-4217-b883-eb616c39d60d" name="sys_anydata$convertbdouble" is-trigger-function="0" unique-function-name="sys_anydata$convertbdouble" is-aggregate="f" language-name="sql" context="sys_anydata$convertbdouble" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision" is-returning-set="f" ret-datatype="jsonb" function-arguments="value double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23177" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value double precision" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertbdouble(value double precision)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.BINARY_DOUBLE', $1);
]]></complex-attribute>
                        <category _I_D="b76909f1-1998-461c-bdcc-764c06be3675" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0af4b4f3-f948-4587-b32e-d1c5a56e3124" name="sys_anydata$convertbfile" is-trigger-function="0" unique-function-name="sys_anydata$convertbfile" is-aggregate="f" language-name="sql" context="sys_anydata$convertbfile" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="jsonb" function-arguments="value character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23178" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value character varying" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertbfile(value character varying)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.BFILE', $1);    
]]></complex-attribute>
                        <category _I_D="365ac6f8-1254-48ce-a693-cee925b281df" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2d914b69-5711-498d-b612-7d947e3a6416" name="sys_anydata$convertbfloat" is-trigger-function="0" unique-function-name="sys_anydata$convertbfloat" is-aggregate="f" language-name="sql" context="sys_anydata$convertbfloat" subcategories-loading="none" object-loading="extended" arguments-datatypes="real" is-returning-set="f" ret-datatype="jsonb" function-arguments="value real" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23179" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value real" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertbfloat(value real)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.BINARY_FLOAT', $1);    
]]></complex-attribute>
                        <category _I_D="bfb46c90-b476-420f-adf0-f1eedd9940cc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e5a1742b-982d-42ca-9960-0bc709c10fbc" name="sys_anydata$convertblob" is-trigger-function="0" unique-function-name="sys_anydata$convertblob" is-aggregate="f" language-name="sql" context="sys_anydata$convertblob" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea" is-returning-set="f" ret-datatype="jsonb" function-arguments="value bytea" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23180" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value bytea" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertblob(value bytea)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.BLOB', $1);    
]]></complex-attribute>
                        <category _I_D="2e89356c-fc2a-4565-a431-4d87a37604a7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="52e18a62-719a-4a73-aeac-230fc6822404" name="sys_anydata$convertchar" is-trigger-function="0" unique-function-name="sys_anydata$convertchar" is-aggregate="f" language-name="sql" context="sys_anydata$convertchar" subcategories-loading="none" object-loading="extended" arguments-datatypes="character" is-returning-set="f" ret-datatype="jsonb" function-arguments="value character" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23181" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value character" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertchar(value character)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.CHAR', $1);     
]]></complex-attribute>
                        <category _I_D="9f604d32-0c66-4e74-a4f3-7b840331bb4b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5e407cac-9a3b-44b0-bd4d-63dbf6e343b9" name="sys_anydata$convertclob" is-trigger-function="0" unique-function-name="sys_anydata$convertclob" is-aggregate="f" language-name="sql" context="sys_anydata$convertclob" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="jsonb" function-arguments="value text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23191" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value text" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertclob(value text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.CLOB', $1);     
]]></complex-attribute>
                        <category _I_D="620d3102-b936-4609-a97f-fde2f95c7747" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="01b1ef04-0088-4b83-a67b-4dc02a300cc8" name="sys_anydata$convertdate" is-trigger-function="0" unique-function-name="sys_anydata$convertdate" is-aggregate="f" language-name="sql" context="sys_anydata$convertdate" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone" is-returning-set="f" ret-datatype="jsonb" function-arguments="value timestamp without time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23192" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value timestamp without time zone" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertdate(value timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.DATE', $1);  
]]></complex-attribute>
                        <category _I_D="4e3ab4c7-73fa-4b51-93a5-c8f8a026e7a9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="91f47c95-22c4-4a2a-a273-133e5ecfc8ad" name="sys_anydata$convertintervalds" is-trigger-function="0" unique-function-name="sys_anydata$convertintervalds" is-aggregate="f" language-name="sql" context="sys_anydata$convertintervalds" subcategories-loading="none" object-loading="extended" arguments-datatypes="interval" is-returning-set="f" ret-datatype="jsonb" function-arguments="value interval" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23182" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value interval" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertintervalds(value interval)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.INTERVAL_DAY_SECOND', $1);  
]]></complex-attribute>
                        <category _I_D="2b4757ae-bcf5-4074-adda-ddce882c3a51" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4b5b9621-1c7a-438f-9088-8064d2e91254" name="sys_anydata$convertintervalym" is-trigger-function="0" unique-function-name="sys_anydata$convertintervalym" is-aggregate="f" language-name="sql" context="sys_anydata$convertintervalym" subcategories-loading="none" object-loading="extended" arguments-datatypes="interval" is-returning-set="f" ret-datatype="jsonb" function-arguments="value interval" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23183" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value interval" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertintervalym(value interval)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.INTERVAL_YEAR_MONTH', $1);  
]]></complex-attribute>
                        <category _I_D="71db4264-70ac-428f-a0d5-f10ecfb8031d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="864627f1-1564-4a2f-9625-fa668a74e5de" name="sys_anydata$convertnchar" is-trigger-function="0" unique-function-name="sys_anydata$convertnchar" is-aggregate="f" language-name="sql" context="sys_anydata$convertnchar" subcategories-loading="none" object-loading="extended" arguments-datatypes="character" is-returning-set="f" ret-datatype="jsonb" function-arguments="value character" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23184" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value character" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertnchar(value character)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.NCHAR', $1);  
]]></complex-attribute>
                        <category _I_D="eac10394-357a-49ad-aee6-97e5dbb3030e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9ce0d1a4-e3da-40c7-92eb-d4dc22cacc57" name="sys_anydata$convertnclob" is-trigger-function="0" unique-function-name="sys_anydata$convertnclob" is-aggregate="f" language-name="sql" context="sys_anydata$convertnclob" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="jsonb" function-arguments="value text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23185" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value text" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertnclob(value text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.NCLOB', $1);  
]]></complex-attribute>
                        <category _I_D="e25c8dac-7745-44fd-87a2-686c8f076415" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="19fee62e-6a09-430f-8d14-d913d25fdb8c" name="sys_anydata$convertnumber" is-trigger-function="0" unique-function-name="sys_anydata$convertnumber" is-aggregate="f" language-name="sql" context="sys_anydata$convertnumber" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" is-returning-set="f" ret-datatype="jsonb" function-arguments="value numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23193" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value numeric" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertnumber(value numeric)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.NUMBER', $1);  
]]></complex-attribute>
                        <category _I_D="7f0fe182-0d57-4930-926f-3fcdddc18300" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7837e69b-3ce3-4f75-ac9c-5ec555c6d4af" name="sys_anydata$convertnvarchar2" is-trigger-function="0" unique-function-name="sys_anydata$convertnvarchar2" is-aggregate="f" language-name="sql" context="sys_anydata$convertnvarchar2" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="jsonb" function-arguments="value text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23186" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value text" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertnvarchar2(value text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.NVARCHAR2', $1);    
]]></complex-attribute>
                        <category _I_D="35c45cfb-5340-42b3-bfce-412947baa325" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8c854aac-d9ac-4856-8e9f-f25f2b1de627" name="sys_anydata$convertraw" is-trigger-function="0" unique-function-name="sys_anydata$convertraw" is-aggregate="f" language-name="sql" context="sys_anydata$convertraw" subcategories-loading="none" object-loading="extended" arguments-datatypes="bytea" is-returning-set="f" ret-datatype="jsonb" function-arguments="value bytea" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23187" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value bytea" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertraw(value bytea)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.RAW', $1);     
]]></complex-attribute>
                        <category _I_D="19b0e100-fa15-4b7f-9953-d53072758d4e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="30b4be6c-7209-4d38-a4ac-cd54caa12ff2" name="sys_anydata$converttimestamp" is-trigger-function="0" unique-function-name="sys_anydata$converttimestamp" is-aggregate="f" language-name="sql" context="sys_anydata$converttimestamp" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone" is-returning-set="f" ret-datatype="jsonb" function-arguments="value timestamp without time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23194" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value timestamp without time zone" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$converttimestamp(value timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.TIMESTAMP', $1);     
]]></complex-attribute>
                        <category _I_D="4eb5ebb5-3d66-4322-a6b1-56c9f78c8d51" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f2e96cd0-a8b0-46a0-b195-827e23e6b8ed" name="sys_anydata$converttimestampltz" is-trigger-function="0" unique-function-name="sys_anydata$converttimestampltz" is-aggregate="f" language-name="sql" context="sys_anydata$converttimestampltz" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone" is-returning-set="f" ret-datatype="jsonb" function-arguments="value timestamp without time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23188" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value timestamp without time zone" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$converttimestampltz(value timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.TIMESTAMP_WITH_LTZ', $1);     
]]></complex-attribute>
                        <category _I_D="2b5bd248-cf43-4d76-a5da-d3130a38fad5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1ad41de1-1cdd-4b95-93f3-79232c1e90bd" name="sys_anydata$converttimestamptz" is-trigger-function="0" unique-function-name="sys_anydata$converttimestamptz" is-aggregate="f" language-name="sql" context="sys_anydata$converttimestamptz" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp with time zone" is-returning-set="f" ret-datatype="jsonb" function-arguments="value timestamp with time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23189" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value timestamp with time zone" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$converttimestamptz(value timestamp with time zone)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.TIMESTAMP_WITH_TIMEZONE', $1);        
]]></complex-attribute>
                        <category _I_D="c3040e12-396f-4927-bb2d-50e561ade69d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7f4a0676-0143-4a99-8b21-5695aa89a9ac" name="sys_anydata$converturowid" is-trigger-function="0" unique-function-name="sys_anydata$converturowid" is-aggregate="f" language-name="sql" context="sys_anydata$converturowid" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="jsonb" function-arguments="value text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23190" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value text" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$converturowid(value text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.UROWID', $1); 
]]></complex-attribute>
                        <category _I_D="89a91818-9c62-43db-b97e-459814692105" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3029ca52-0750-4aba-ae1a-68ce5d24ce6a" name="sys_anydata$convertvarchar" is-trigger-function="0" unique-function-name="sys_anydata$convertvarchar" is-aggregate="f" language-name="sql" context="sys_anydata$convertvarchar" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="jsonb" function-arguments="value text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23195" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value text" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertvarchar(value text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.VARCHAR', $1); 
]]></complex-attribute>
                        <category _I_D="f91039c8-9331-4f1c-853c-dd5e3d55f643" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ae1e688f-36ee-460c-bd97-3bc935f67108" name="sys_anydata$convertvarchar2" is-trigger-function="0" unique-function-name="sys_anydata$convertvarchar2" is-aggregate="f" language-name="sql" context="sys_anydata$convertvarchar2" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="jsonb" function-arguments="value text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23196" volatility="IMMUTABLE" is-window="f" function-identity-arguments="value text" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$convertvarchar2(value text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT JSONB_BUILD_OBJECT('SYS.VARCHAR2', $1);
]]></complex-attribute>
                        <category _I_D="d124af6e-bc65-4046-a8be-9d55b505d700" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="be927ecf-6fbc-4019-b086-ccea5a62873d" name="sys_anydata$gettypename" is-trigger-function="0" unique-function-name="sys_anydata$gettypename" is-aggregate="f" language-name="sql" context="sys_anydata$gettypename" subcategories-loading="none" object-loading="extended" arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="varchar" function-arguments="jsonb_value jsonb" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23156" volatility="IMMUTABLE" is-window="f" function-identity-arguments="jsonb_value jsonb" overload-function-count="1" proc-language="sql" function-signature="sys_anydata$gettypename(jsonb_value jsonb)">
                        <complex-attribute name="sql"><![CDATA[
  SELECT
  case
      WHEN jsonb_value ? 'SYS.NUMBER' then 'SYS.NUMBER'
      WHEN jsonb_value ? 'SYS.DATE' then 'SYS.DATE'
      WHEN jsonb_value ? 'SYS.CHAR' then 'SYS.CHAR'
      WHEN jsonb_value ? 'SYS.VARCHAR' then 'SYS.VARCHAR'
      WHEN jsonb_value ? 'SYS.VARCHAR2' then 'SYS.VARCHAR2'
      WHEN jsonb_value ? 'SYS.RAW' then 'SYS.RAW'
      WHEN jsonb_value ? 'SYS.CLOB' then 'SYS.CLOB'
      WHEN jsonb_value ? 'SYS.BLOB' then 'SYS.BLOB'
      WHEN jsonb_value ? 'SYS.BFILE' then 'SYS.BFILE'
      WHEN jsonb_value ? 'SYS.TIMESTAMP' then 'SYS.TIMESTAMP'
      WHEN jsonb_value ? 'SYS.TIMESTAMP_WITH_TIMEZONE' then 'SYS.TIMESTAMP_WITH_TIMEZONE'
      WHEN jsonb_value ? 'SYS.TIMESTAMP_WITH_LTZ' then 'SYS.TIMESTAMP_WITH_LTZ'
      WHEN jsonb_value ? 'SYS.INTERVAL_YEAR_MONTH' then 'SYS.INTERVAL_YEAR_MONTH'
      WHEN jsonb_value ? 'SYS.INTERVAL_DAY_SECOND' then 'SYS.INTERVAL_DAY_SECOND'
      WHEN jsonb_value ? 'SYS.NCHAR' then 'SYS.NCHAR'
      WHEN jsonb_value ? 'SYS.NVARCHAR2' then 'SYS.NVARCHAR2'
      WHEN jsonb_value ? 'SYS.NCLOB' then 'SYS.NCLOB'
      WHEN jsonb_value ? 'SYS.BINARY_FLOAT' then 'SYS.BINARY_FLOAT'
      WHEN jsonb_value ? 'SYS.BINARY_DOUBLE' then 'SYS.BINARY_DOUBLE'
      WHEN jsonb_value ? 'SYS.UROWID' then 'SYS.UROWID'
      ELSE NULL
  end;
]]></complex-attribute>
                        <category _I_D="9b3c4385-befb-46b3-86a5-5ff600d3b31e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="67715317-4611-4362-8e31-47905931c1cd" name="sys_context" is-trigger-function="0" unique-function-name="sys_context" is-aggregate="f" language-name="plpgsql" context="sys_context" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying,character varying" is-returning-set="f" ret-datatype="varchar" function-arguments="namespace character varying, attribute character varying, username character varying DEFAULT NULL::character varying, client_id character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22423" volatility="VOLATILE" is-window="f" function-identity-arguments="namespace character varying, attribute character varying, username character varying, client_id character varying" overload-function-count="1" proc-language="plpgsql" function-signature="sys_context(namespace character varying, attribute character varying, username character varying, client_id character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  v_res character varying;
  l_namespace text;
  l_attribute text;

begin
  
  l_namespace := aws_oracle_ext.format_identifier_case(namespace);
  l_attribute := aws_oracle_ext.format_identifier_case(attribute);
  
  case l_namespace
    when 'USERENV' then 
      v_res = aws_oracle_ext.SYS_CONTEXT_USERENV(l_attribute);
    when 'CLIENTCONTEXT'  then 
     v_res = aws_oracle_ext.get_extpack_variable(variable_name => l_namespace||'_'||l_attribute)::character varying; 
  else 
    v_res = aws_oracle_ext.get_application_context(l_namespace, l_attribute, username, client_id);
  end case;

  return v_res;
  
  exception 
    when internal_error then return null; 
end;
]]></complex-attribute>
                        <category _I_D="5f9a7e97-8695-46dc-aa57-69ddf9ba706a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2f4cb7aa-b09f-431a-be87-b5722d9f5628" name="sys_context_userenv" is-trigger-function="0" unique-function-name="sys_context_userenv" is-aggregate="f" language-name="plpgsql" context="sys_context_userenv" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="varchar" function-arguments="parameter character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="23135" volatility="STABLE" is-window="f" function-identity-arguments="parameter character varying" overload-function-count="1" proc-language="plpgsql" function-signature="sys_context_userenv(parameter character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare l_context json;
begin 
  case upper(parameter)
    when 'ACTION' then return (select action_name from aws_oracle_ext.dbms_application_info$read_module());
    when 'AUDITED_CURSORID' then return null;
    when 'AUTHENTICATED_IDENTITY' then return null;
    when 'AUTHENTICATION_DATA' then return null;
    when 'AUTHENTICATION_METHOD' then return null;
	when 'AUTHENTICATION_TYPE' then return null;
    when 'BG_JOB_ID' then return null;
    when 'CLIENT_IDENTIFIER' then return aws_oracle_ext.get_extpack_variable(upper(parameter));     
    when 'CLIENT_INFO' then return (select client_info from aws_oracle_ext.dbms_application_info$read_client_info());
    when 'CURRENT_BIND' then return null;
    when 'CURRENT_SCHEMA' then return current_schema::character varying;
    when 'CURRENT_SCHEMAID' then return null;
    when 'CURRENT_SQL' then return (select query from pg_stat_activity where pid = pg_backend_pid())::character varying;
    when 'CURRENT_SQL_LENGTH' then return char_length((select query from pg_stat_activity where pid = pg_backend_pid()))::character varying;
	when 'CURRENT_USER' then return current_user::character varying;
	when 'CURRENT_USERID' then return (select usesysid from pg_catalog.pg_user where usename = current_user limit 1)::character varying;	
    when 'DB_DOMAIN' then return null;
    when 'DB_NAME' then return current_database()::character varying;    
    when 'DB_UNIQUE_NAME' then return current_database()::character varying;        
    when 'ENTRYID' then return null;            
    when 'ENTERPRISE_IDENTITY' then return null;            
    when 'FG_JOB_ID' then return null;            
    when 'GLOBAL_CONTEXT_MEMORY' then return '0'::character varying;                
    when 'GLOBAL_UID' then return '0'::character varying; 
    when 'HOST' then return (select client_hostname from pg_stat_activity where pid = pg_backend_pid())::character varying;
    when 'IDENTIFICATION_TYPE' then return null;            
    when 'INSTANCE' then return null;            
    when 'INSTANCE_NAME' then return inet_server_addr()::character varying;           
    when 'IP_ADDRESS' then return inet_client_addr()::character varying;  
    when 'ISDBA'  then return (select usesuper from pg_catalog.pg_user where usename = user limit 1)::character varying;
    when 'LANG' then return (select pg_encoding_to_char(encoding) from pg_database where datname = current_database())::character varying;
    when 'LANGUAGE' then return (select datctype from pg_database where datname = current_database())::character varying;    
    when 'MODULE' then return (select module_name from aws_oracle_ext.dbms_application_info$read_module());            
    when 'NETWORK_PROTOCOL' then return null;                
    when 'NLS_CALENDAR' then return aws_oracle_ext.get_extpack_variable(upper(parameter));     
    when 'NLS_CURRENCY' then return aws_oracle_ext.get_extpack_variable(upper(parameter));
    when 'NLS_DATE_FORMAT' then return aws_oracle_ext.get_extpack_variable(upper(parameter));     
    when 'NLS_DATE_LANGUAGE' then return aws_oracle_ext.get_extpack_variable(upper(parameter));     
    when 'NLS_SORT' then return aws_oracle_ext.get_extpack_variable(upper(parameter));     
    when 'NLS_TERRITORY' then return aws_oracle_ext.get_extpack_variable(upper(parameter));     
    when 'OS_USER' then return null;            
    when 'POLICY_INVOKER' then return null;                
    when 'PROXY_ENTERPRISE_IDENTITY' then return null;            
    when 'PROXY_GLOBAL_UID' then return null;                
    when 'PROXY_USER' then return null;            
    when 'PROXY_USERID' then return null;                
    when 'SERVER_HOST' then  return inet_server_addr()::character varying;           
    when 'SERVICE_NAME' then return null;                
    when 'SESSION_USER' then return SESSION_USER::character varying;            
    when 'SESSION_USERID' then return (select usesysid from pg_catalog.pg_user where usename = user limit 1)::character varying;
    when 'SESSIONID' then return pg_backend_pid()::character varying;
    when 'SID' then return null;                
    when 'STATEMENTID' then return null;                
    when 'TERMINAL' then return null;                
    else raise exception 'invalid parameter';  
  end case;
  
  exception
    when internal_error then
      return null;
end;
]]></complex-attribute>
                        <category _I_D="bec693ee-ac3e-416a-a82c-bf712cc6f058" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5e9998b6-12db-4e8f-8b31-b281eb031030" name="sys_guid" is-trigger-function="0" unique-function-name="sys_guid" is-aggregate="f" language-name="sql" context="sys_guid" subcategories-loading="none" object-loading="extended" comment="This function generates and returns a globally unique identifier GUID made up of 16 bytes. It is a nonrepeating binary value (sequence of bytes)." is-returning-set="f" ret-datatype="text" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22425" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sys_guid()">
                        <complex-attribute name="sql"><![CDATA[
SELECT upper(replace(gen_random_uuid()::TEXT, '-', ''));
]]></complex-attribute>
                        <category _I_D="6242fda5-51a6-4390-90cb-607c17840e9a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1ae04008-6bbb-4871-9708-a04a901c69f7" name="sysdate" is-trigger-function="0" unique-function-name="sysdate" is-aggregate="f" language-name="sql" context="sysdate" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="timestamp" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22424" volatility="STABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="sysdate()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT
    (
        COALESCE
        (
            MAX(tz_offset),
            0
        )::TEXT,
        ' HOURS'
    )::INTERVAL + clock_timestamp()::TIMESTAMP(0) 
    FROM aws_oracle_data.aws_oracle_ext_session_local_tz;
    
]]></complex-attribute>
                        <category _I_D="adb76597-0b8c-4839-9b2f-16cf03cade48" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="974be8f3-9058-4052-8d8a-a020e8bbb16a" name="systimestamp" is-trigger-function="0" unique-function-name="systimestamp" is-aggregate="f" language-name="sql" context="systimestamp" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="timestamptz" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22426" volatility="STABLE" is-window="f" overload-function-count="1" proc-language="sql" function-signature="systimestamp()">
                        <complex-attribute name="sql"><![CDATA[

    SELECT CONCAT
    (
        COALESCE
        (
            MAX(tz_offset),
            0
        )::TEXT,
        ' HOURS'
    )::INTERVAL + clock_timestamp() 
    FROM aws_oracle_data.aws_oracle_ext_session_local_tz;
    
]]></complex-attribute>
                        <category _I_D="8e741bee-b1dc-47b2-9359-b76b4b3898bd" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="92ea4ce6-9cbd-461a-a90c-4bd7b90df67a" name="table" is-trigger-function="0" unique-function-name="table" is-aggregate="f" language-name="plpgsql" context="table" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyelement,character varying,character varying,bigint[]" is-returning-set="t" ret-datatype="record" function-arguments="pval anyelement, pvaltype character varying, ptypetocast character varying DEFAULT NULL::character varying, pindexes bigint[] DEFAULT NULL::bigint[]" schema-id="21999" function-type="RET_DATASET" count-arguments="4" function-id="22024" volatility="VOLATILE" is-window="f" function-identity-arguments="pval anyelement, pvaltype character varying, ptypetocast character varying, pindexes bigint[]" overload-function-count="1" proc-language="plpgsql" function-signature="table(pval anyelement, pvaltype character varying, ptypetocast character varying, pindexes bigint[])">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vSQL TEXT;
    vcol TEXT;
    vcolumns TEXT[];
    vpos SMALLINT DEFAULT 0;
BEGIN

    CASE
        WHEN pValType = 'NESTED' THEN

            IF pIndexes IS NOT NULL THEN

                vSQL := CONCAT
                (
                    'SELECT CAST(ROW(src.v) AS ',
                    pTypeToCast,
                    ')',
                    CHR(10),
                    'FROM UNNEST($1) WITH ORDINALITY AS src(v, rownum)',
                    CHR(10),
                    'JOIN UNNEST($2) WITH ORDINALITY AS lim(v, rownum) ON src.rownum = lim.v',
                    CHR(10),
                    'ORDER BY lim.rownum'
                );

                RETURN QUERY EXECUTE vSQL USING pVal, pIndexes;
            
            ELSE

                vSQL := CONCAT('SELECT CAST(ROW(v) AS ', pTypeToCast, ') FROM UNNEST($1) WITH ORDINALITY AS v');
                RETURN QUERY EXECUTE vSQL USING pVal;

            END IF;
                        
        WHEN pValType = 'NESTEDREC' THEN

            vSQL := CONCAT
            (
                'SELECT ARRAY(SELECT JSON_OBJECT_KEYS(ROW_TO_JSON(s)) FROM ',
                '(',
                'SELECT (NULL::',
                pTypeToCast,
                ').*',
                ') AS s)'
            );

            EXECUTE vSQL INTO vcolumns;

            vSQL := '';

            vpos := CARDINALITY(vcolumns);

            FOREACH vcol IN ARRAY vcolumns LOOP

                vpos := vpos - 1;

                vSQL := CONCAT
                (
                    vSQL,
                    'src.',
                    vcol,
                    CASE WHEN vpos <> 0  THEN ', ' ELSE '' END
                );

            END LOOP;

            IF pIndexes IS NOT NULL THEN

                vSQL := CONCAT
                (
                    'SELECT ROW(',
                    vSQL,
                    ')::',
                    pTypeToCast,
                    ' FROM UNNEST($1) WITH ORDINALITY AS src JOIN UNNEST($2) WITH ORDINALITY AS lim(v, rownum) ON src.ordinality = lim.v ORDER BY lim.rownum'
                );

                RETURN QUERY EXECUTE vSQL USING pVal, pIndexes;

            ELSE

                vSQL := CONCAT
                (
                    'SELECT ROW(',
                    vSQL,
                    ')::',
                    pTypeToCast,
                    ' FROM UNNEST($1) WITH ORDINALITY AS src'
                );

                RETURN QUERY EXECUTE vSQL USING pVal;

            END IF;

        WHEN pValType = 'ASSOC' THEN

            IF PG_TYPEOF(pVal)::TEXT <> 'jsonb' THEN

                RAISE USING MESSAGE := 'Associative array is incorrect. Please, specify procedure name and array path';

            END IF;

            vSQL := FORMAT
            (
                $$
SELECT JSONB_POPULATE_RECORD(null::%s, z.*)
FROM aws_oracle_ext.collection_to_table
(
    p_val => $1,
    pindexes => $2
) AS z
                $$,
                pTypeToCast
            );

            RETURN QUERY EXECUTE vSQL USING pVal, pindexes;

        ELSE
            NULL;
    END CASE;

END;
]]></complex-attribute>
                        <category _I_D="c819aca9-65b6-41f5-b9c8-5356bead25cc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a93289a5-71c0-4625-82fa-4ab7d6acf9c4" name="to_base" is-trigger-function="0" unique-function-name="to_base" is-aggregate="f" language-name="plpgsql" context="to_base" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,numeric" comment="Convert decimal to any specified base" is-returning-set="f" ret-datatype="text" function-arguments="p_dec numeric, p_base numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22517" volatility="VOLATILE" is-window="f" function-identity-arguments="p_dec numeric, p_base numeric" overload-function-count="1" proc-language="plpgsql" function-signature="to_base(p_dec numeric, p_base numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  l_str CHARACTER VARYING(255) DEFAULT '';
  l_num NUMERIC(78,1) DEFAULT p_dec;
  l_hex CHARACTER VARYING(16) DEFAULT '0123456789abcdef';
BEGIN
  IF TRUNC (p_dec) <> p_dec OR p_dec < 0
  THEN
    RAISE plpgsql_error;
  END IF;

  LOOP
    l_str := SUBSTR(l_hex, (MOD(l_num, p_base) + 1)::int, 1) || l_str;
    l_num := TRUNC(l_num / p_base);
    EXIT WHEN l_num = 0;
  END LOOP;

  RETURN l_str;
END;
]]></complex-attribute>
                        <category _I_D="9c73f97c-b284-454d-9d9b-0457334a95e0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="58635a49-9037-4318-b407-089e8469a431" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval character varying)" is-aggregate="f" language-name="plpgsql" context="to_char(pval character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" comment="to_char convertion VARCHAR2 as Oracle does" unique-suffix="(pval character varying)" routine-number="22448" is-returning-set="f" ret-datatype="varchar" function-arguments="pval character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22448" volatility="VOLATILE" is-window="f" function-identity-arguments="pval character varying" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vResult VARCHAR DEFAULT NULL;
BEGIN

    IF pVal IS NOT NULL AND pVal <> '' THEN
    
        vResult := aws_oracle_ext.to_char_formatter
        (
            pVal => pVal
        );
    END IF;

    RETURN vResult;
    
END;
]]></complex-attribute>
                        <category _I_D="857d46e0-c89f-487d-a15f-3e72d5c41559" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f92884ed-adb8-419d-8f20-cc40f367cf34" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval character)" is-aggregate="f" language-name="plpgsql" context="to_char(pval character)" subcategories-loading="none" object-loading="extended" arguments-datatypes="character" comment="to_char convertion CHAR as Oracle does" unique-suffix="(pval character)" routine-number="22427" is-returning-set="f" ret-datatype="varchar" function-arguments="pval character" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22427" volatility="VOLATILE" is-window="f" function-identity-arguments="pval character" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval character)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vResult VARCHAR DEFAULT NULL;
    vargs TEXT;
BEGIN

    IF pVal IS NOT NULL AND pVal <> '' THEN
        

        vResult := aws_oracle_ext.to_char_formatter
        (
            pVal => pVal
        );

    END IF;

    RETURN vResult;
    
END;
]]></complex-attribute>
                        <category _I_D="ba377e5f-dddb-41ac-abef-bca913ca20f9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="89c12403-301d-4e61-826b-bab5b2b85ac3" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval date)" is-aggregate="f" language-name="plpgsql" context="to_char(pval date)" subcategories-loading="none" object-loading="extended" arguments-datatypes="date" unique-suffix="(pval date)" routine-number="22444" is-returning-set="f" ret-datatype="varchar" function-arguments="pval date" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22444" volatility="VOLATILE" is-window="f" function-identity-arguments="pval date" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval date)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vFmt VARCHAR;
BEGIN

    SELECT value
    INTO vFmt
    FROM aws_oracle_ext.v$nls_parameters
    WHERE parameter = 'NLS_DATE_FORMAT';

    RETURN aws_oracle_ext.to_char
    (
        pVal => pVal::TIMESTAMP(0),
        pFmt => vFmt
    );

END;
]]></complex-attribute>
                        <category _I_D="b8611a6a-616a-4083-92b5-94cc15bffd09" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7eea5218-47f9-42a4-84c2-9b9a3838c473" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval date, pfmt character varying, pnlsparam character varying)" is-aggregate="f" language-name="sql" context="to_char(pval date, pfmt character varying, pnlsparam character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="date,character varying,character varying" unique-suffix="(pval date, pfmt character varying, pnlsparam character varying)" routine-number="22449" is-returning-set="f" ret-datatype="varchar" function-arguments="pval date, pfmt character varying, pnlsparam character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22449" volatility="VOLATILE" is-window="f" function-identity-arguments="pval date, pfmt character varying, pnlsparam character varying" overload-function-count="19" proc-language="sql" function-signature="to_char(pval date, pfmt character varying, pnlsparam character varying)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT aws_oracle_ext.to_char
    (
        $1::TIMESTAMP(0),
        $2,
        $3
    );
]]></complex-attribute>
                        <category _I_D="54f08c53-0881-4742-832f-cc44eca9a6d1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c2ead34e-a507-4930-85b9-d98e30634a59" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval double precision)" is-aggregate="f" language-name="plpgsql" context="to_char(pval double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision" comment="to_char convertion Number as Oracle does" unique-suffix="(pval double precision)" routine-number="22428" is-returning-set="f" ret-datatype="varchar" function-arguments="pval double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22428" volatility="VOLATILE" is-window="f" function-identity-arguments="pval double precision" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval double precision)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vFmt     VARCHAR;
    vResult  VARCHAR DEFAULT NULL;
BEGIN

    IF pVal IS NOT NULL THEN
        

        vFmt := aws_oracle_ext.to_char_formatter
        (
            pVal      => pVal,
            pFormat   => '', -- not used
            pNoNumberFormat => '' -- value is just a flag
        );

        vResult := vFmt;

    END IF;

    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="de5308e6-a0bb-420a-8145-81a63118253b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="94e21ede-4f6b-43ec-81f9-2c8da6f4566b" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval double precision, pfmt character varying, pnlsparam character varying)" is-aggregate="f" language-name="plpgsql" context="to_char(pval double precision, pfmt character varying, pnlsparam character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision,character varying,character varying" comment="to_char convertion Number as Oracle does. Some Format models could return incorrect results. Only NLS_DATE_LANGUAGE is allowed for NLS param. Value must be correct as lc_time value" unique-suffix="(pval double precision, pfmt character varying, pnlsparam character varying)" routine-number="22429" is-returning-set="f" ret-datatype="varchar" function-arguments="pval double precision, pfmt character varying, pnlsparam character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22429" volatility="VOLATILE" is-window="f" function-identity-arguments="pval double precision, pfmt character varying, pnlsparam character varying" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval double precision, pfmt character varying, pnlsparam character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vFmt     VARCHAR;
    vResult  VARCHAR DEFAULT NULL;
BEGIN

    IF pVal IS NOT NULL THEN

        vFmt := aws_oracle_ext.to_char_formatter
        (
            pVal      => pVal,
            pFormat   => pFmt,
            pNlsParam => pNlsParam
        );

        vResult := vFmt;

    END IF;

    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="c8386521-9f96-471c-aa71-8cc20e6d18ba" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="53db920b-81d7-4744-b058-368aaa816b04" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval integer)" is-aggregate="f" language-name="plpgsql" context="to_char(pval integer)" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer" comment="to_char convertion Number as Oracle does" unique-suffix="(pval integer)" routine-number="22432" is-returning-set="f" ret-datatype="varchar" function-arguments="pval integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22432" volatility="VOLATILE" is-window="f" function-identity-arguments="pval integer" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vFmt     VARCHAR;
    vResult  VARCHAR DEFAULT NULL;
BEGIN

    IF pVal IS NOT NULL THEN

        vFmt := aws_oracle_ext.to_char_formatter
        (
            pVal      => pVal,
            pFormat   => '', -- not used
            pNoNumberFormat => '' -- value is just a flag
        );

        vResult := vFmt;

    END IF;

    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="c2565741-ca1d-4d60-9501-2e2a3b3befd8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="abf916be-bb3d-445a-9536-6ed1b9c2a8a7" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval integer, pfmt character varying, pnlsparam character varying)" is-aggregate="f" language-name="plpgsql" context="to_char(pval integer, pfmt character varying, pnlsparam character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="integer,character varying,character varying" comment="to_char convertion Number as Oracle does. Some Format models could return incorrect results. Only NLS_DATE_LANGUAGE is allowed for NLS param. Value must be correct as lc_time value" unique-suffix="(pval integer, pfmt character varying, pnlsparam character varying)" routine-number="22433" is-returning-set="f" ret-datatype="varchar" function-arguments="pval integer, pfmt character varying, pnlsparam character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22433" volatility="VOLATILE" is-window="f" function-identity-arguments="pval integer, pfmt character varying, pnlsparam character varying" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval integer, pfmt character varying, pnlsparam character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vFmt     VARCHAR;
    vResult  VARCHAR DEFAULT NULL;
BEGIN

    IF pVal IS NOT NULL THEN
        

        vFmt := aws_oracle_ext.to_char_formatter
        (
            pVal      => pVal,
            pFormat   => pFmt,
            pNlsParam => pNlsParam
        );

        vResult := vFmt;

    END IF;

    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="2498e944-6557-4fe0-9d6f-5bd99391de83" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="524c2075-6c9f-4550-9d43-2123c1e32ff3" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval interval)" is-aggregate="f" language-name="plpgsql" context="to_char(pval interval)" subcategories-loading="none" object-loading="extended" arguments-datatypes="interval" comment="to_char convertion interval with TZ as Oracle does" unique-suffix="(pval interval)" routine-number="22434" is-returning-set="f" ret-datatype="varchar" function-arguments="pval interval" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22434" volatility="VOLATILE" is-window="f" function-identity-arguments="pval interval" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval interval)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    RETURN aws_oracle_ext.to_char
    (
        pVal => pVal,
        pFmt => 'd' -- won't be used, just to pass something correct
    );
    
END;
]]></complex-attribute>
                        <category _I_D="35eaf892-ecd1-4e86-aebd-ed55f1129463" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c2cd43c1-f88c-4ba8-9d02-56461f900ea6" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval interval, pfmt character varying, pnlsparam character varying)" is-aggregate="f" language-name="plpgsql" context="to_char(pval interval, pfmt character varying, pnlsparam character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="interval,character varying,character varying" comment="to_char convertion interval with TZ as Oracle does. Some Format models could return incorrect results. Only NLS_DATE_LANGUAGE is allowed for NLS param. Value must be correct as lc_time value" unique-suffix="(pval interval, pfmt character varying, pnlsparam character varying)" routine-number="22435" is-returning-set="f" ret-datatype="varchar" function-arguments="pval interval, pfmt character varying, pnlsparam character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22435" volatility="VOLATILE" is-window="f" function-identity-arguments="pval interval, pfmt character varying, pnlsparam character varying" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval interval, pfmt character varying, pnlsparam character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vResult VARCHAR DEFAULT NULL;
    vFmt VARCHAR;
BEGIN

    IF pVal IS NOT NULL THEN
        
        IF LENGTH(pFmt) <> 0 THEN

            vFmt := aws_oracle_ext.to_char_formatter
            (
                pVal      => pVal,
                pFormat   => pFmt,
                pNlsParam => pNlsParam
            );
            -- it is year to month 
            IF pVal::TEXT ~* 'YEAR' OR pVal::TEXT ~* 'MON' THEN

                vResult := CONCAT
                (
                    COALESCE(SUBSTRING(EXTRACT(year FROM pVal)::TEXT FROM '-'), '+'),
                    SUBSTRING(EXTRACT(year FROM pVal)::TEXT FROM '\d+'),
                    '-',
                    LPAD(ABS(EXTRACT(month FROM pVal))::TEXT, 2, '0')
                );
            -- it is day to second
            ELSE

                vResult := CONCAT
                (
                    COALESCE(SUBSTRING(EXTRACT(day FROM pVal)::TEXT FROM '\-'),'+'),
                    LPAD(SUBSTRING(EXTRACT(day FROM pVal)::TEXT FROM '\d+'), 2, '0'),
                    ' ',
                    LPAD(EXTRACT(hour FROM pVal)::TEXT, 2, '0'),
                    ':',
                    LPAD(EXTRACT(minute FROM pVal)::TEXT, 2, '0'),
                    ':',
                    CASE 
                        WHEN STRPOS(pVal::TEXT, '.') > 0
                        THEN
                            REGEXP_REPLACE(LPAD(EXTRACT(microseconds FROM pVal)::TEXT, 8, '0'), '(\d\d)(\d+)', '\1.\2')
                        ELSE
                            LPAD(TRANSLATE(EXTRACT(seconds FROM pVal)::TEXT, '.0', ''), 2, '0')
                    END
                );

            END IF;

        END IF;

    END IF;

    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="f3809654-29ce-40bf-b511-9307286b22a3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="db65dd3a-9ce4-49aa-b801-31d59f43a22e" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval numeric)" is-aggregate="f" language-name="plpgsql" context="to_char(pval numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" comment="to_char convertion Number as Oracle does" unique-suffix="(pval numeric)" routine-number="22436" is-returning-set="f" ret-datatype="varchar" function-arguments="pval numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22436" volatility="VOLATILE" is-window="f" function-identity-arguments="pval numeric" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vFmt     VARCHAR;
    vResult  VARCHAR DEFAULT NULL;
BEGIN

    IF pVal IS NOT NULL THEN
        
        vFmt := aws_oracle_ext.to_char_formatter
        (
            pVal      => pVal,
            pFormat   => '', -- not used
            pNoNumberFormat => '' -- value is just a flag
        );

        vResult := vFmt;

    END IF;

    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="adf0d0c0-b427-4b44-a132-93dbb18c243a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ed2afb6e-0611-4086-a44d-d15aed411979" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval numeric, pfmt character varying, pnlsparam character varying)" is-aggregate="f" language-name="plpgsql" context="to_char(pval numeric, pfmt character varying, pnlsparam character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,character varying,character varying" comment="to_char convertion Number as Oracle does. Some Format models could return incorrect results. Only NLS_DATE_LANGUAGE is allowed for NLS param. Value must be correct as lc_time value" unique-suffix="(pval numeric, pfmt character varying, pnlsparam character varying)" routine-number="22437" is-returning-set="f" ret-datatype="varchar" function-arguments="pval numeric, pfmt character varying, pnlsparam character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22437" volatility="VOLATILE" is-window="f" function-identity-arguments="pval numeric, pfmt character varying, pnlsparam character varying" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval numeric, pfmt character varying, pnlsparam character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vFmt     VARCHAR;
    vResult  VARCHAR DEFAULT NULL;
BEGIN

    IF pVal IS NOT NULL THEN

        vFmt := aws_oracle_ext.to_char_formatter
        (
            pVal      => pVal,
            pFormat   => pFmt,
            pNlsParam => pNlsParam
        );

        vResult := vFmt;

    END IF;

    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="7ab74b57-c852-4810-9fca-e0a023de699a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2dacd3c9-a842-4e5d-a634-b85f75235362" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval real)" is-aggregate="f" language-name="plpgsql" context="to_char(pval real)" subcategories-loading="none" object-loading="extended" arguments-datatypes="real" comment="to_char convertion Number as Oracle does" unique-suffix="(pval real)" routine-number="22440" is-returning-set="f" ret-datatype="varchar" function-arguments="pval real" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22440" volatility="VOLATILE" is-window="f" function-identity-arguments="pval real" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval real)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vFmt     VARCHAR;
    vResult  VARCHAR DEFAULT NULL;
BEGIN

    IF pVal IS NOT NULL THEN

        vFmt := aws_oracle_ext.to_char_formatter
        (
            pVal      => pVal,
            pFormat   => '', -- not used
            pNoNumberFormat => '' -- value is just a flag
        );

        vResult := vFmt;

    END IF;

    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="bb9582b2-054e-469d-a98e-931c651df2d7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="66e292c9-6c95-4817-a81a-86001849a437" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval real, pfmt character varying, pnlsparam character varying)" is-aggregate="f" language-name="plpgsql" context="to_char(pval real, pfmt character varying, pnlsparam character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="real,character varying,character varying" comment="to_char convertion Number as Oracle does. Some Format models could return incorrect results. Only NLS_DATE_LANGUAGE is allowed for NLS param. Value must be correct as lc_time value" unique-suffix="(pval real, pfmt character varying, pnlsparam character varying)" routine-number="22441" is-returning-set="f" ret-datatype="varchar" function-arguments="pval real, pfmt character varying, pnlsparam character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22441" volatility="VOLATILE" is-window="f" function-identity-arguments="pval real, pfmt character varying, pnlsparam character varying" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval real, pfmt character varying, pnlsparam character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vFmt     VARCHAR;
    vResult  VARCHAR DEFAULT NULL;
BEGIN

    IF pVal IS NOT NULL THEN

        vFmt := aws_oracle_ext.to_char_formatter
        (
            pVal      => pVal,
            pFormat   => pFmt,
            pNlsParam => pNlsParam
        );

        vResult := vFmt;

    END IF;

    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="020168e2-743c-4798-b76d-fa46f267891b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="1a66556b-8219-4aac-aaa9-cd61ca8fc0c0" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval text)" is-aggregate="f" language-name="plpgsql" context="to_char(pval text)" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="to_char convertion CLOB as Oracle does" unique-suffix="(pval text)" routine-number="22442" is-returning-set="f" ret-datatype="varchar" function-arguments="pval text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22442" volatility="VOLATILE" is-window="f" function-identity-arguments="pval text" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vResult VARCHAR DEFAULT NULL;
BEGIN

    IF pVal IS NOT NULL AND pVal <> '' THEN
        
            vResult := aws_oracle_ext.to_char_formatter
            (
                pVal => pVal
            );

    END IF;

    RETURN vResult;
    
END;
]]></complex-attribute>
                        <category _I_D="ac1fe984-6384-4610-8fe4-93d348106106" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0e2b9864-fb7e-47bc-b031-3b091c0be902" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval timestamp with time zone)" is-aggregate="f" language-name="plpgsql" context="to_char(pval timestamp with time zone)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp with time zone" comment="to_char convertion timestamp with TZ as Oracle does" unique-suffix="(pval timestamp with time zone)" routine-number="22446" is-returning-set="f" ret-datatype="varchar" function-arguments="pval timestamp with time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22446" volatility="VOLATILE" is-window="f" function-identity-arguments="pval timestamp with time zone" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval timestamp with time zone)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vFmt VARCHAR;
BEGIN

    SELECT value
    INTO vFmt
    FROM aws_oracle_ext.v$nls_parameters
    WHERE parameter = 'NLS_TIMESTAMP_TZ_FORMAT';

    RETURN aws_oracle_ext.to_char
    (
        pVal => pVal,
        pFmt => vFmt
    );
    
END;
]]></complex-attribute>
                        <category _I_D="49b7b0dd-3ab0-47bb-bac1-425bf80645e6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="23bb84ce-03d8-47de-b755-f9401f836f07" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval timestamp with time zone, pfmt character varying, pnlsparam character varying)" is-aggregate="f" language-name="plpgsql" context="to_char(pval timestamp with time zone, pfmt character varying, pnlsparam character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp with time zone,character varying,character varying" comment="to_char convertion timestamp with TZ as Oracle does. Some Format models could return incorrect results. Only NLS_DATE_LANGUAGE is allowed for NLS param. Value must be correct as lc_time value" unique-suffix="(pval timestamp with time zone, pfmt character varying, pnlsparam character varying)" routine-number="22447" is-returning-set="f" ret-datatype="varchar" function-arguments="pval timestamp with time zone, pfmt character varying, pnlsparam character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22447" volatility="VOLATILE" is-window="f" function-identity-arguments="pval timestamp with time zone, pfmt character varying, pnlsparam character varying" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval timestamp with time zone, pfmt character varying, pnlsparam character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vResult VARCHAR DEFAULT NULL;
    vFmt VARCHAR;
BEGIN

    IF pVal IS NOT NULL THEN

        vFmt := aws_oracle_ext.to_char_formatter
        (
            pVal      => pVal,
            pFormat   => pFmt,
            pNlsParam => pNlsParam
        );

        vResult := TO_CHAR(pVal, vFmt);

    END IF;

    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="31ae6c39-c405-4a30-a3e6-b23f4f3ddf9e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="21392aa2-a3ff-4312-938e-5b2dbf58f139" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval timestamp without time zone)" is-aggregate="f" language-name="plpgsql" context="to_char(pval timestamp without time zone)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone" comment="to_char convertion date or timestamp without TZ as Oracle does" unique-suffix="(pval timestamp without time zone)" routine-number="22443" is-returning-set="f" ret-datatype="varchar" function-arguments="pval timestamp without time zone" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22443" volatility="VOLATILE" is-window="f" function-identity-arguments="pval timestamp without time zone" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vFmt VARCHAR;
BEGIN

    IF SUBSTRING(TO_CHAR(EXTRACT('epoch' FROM pVal), '9999999999D9999999'),12,6) = '.00000' THEN

        SELECT value
        INTO vFmt
        FROM aws_oracle_ext.v$nls_parameters
        WHERE parameter = 'NLS_DATE_FORMAT';

    ELSE

        SELECT value
        INTO vFmt
        FROM aws_oracle_ext.v$nls_parameters
        WHERE parameter = 'NLS_TIMESTAMP_FORMAT';

    END IF;

    RETURN aws_oracle_ext.to_char
    (
        pVal => pVal,
        pFmt => vFmt
    );

END;
]]></complex-attribute>
                        <category _I_D="3ba1283b-fcb3-47ac-aeda-37a51cf46c3a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a5e85389-0846-41da-bcbe-e8a6ffee8440" name="to_char" is-trigger-function="0" unique-function-name="to_char(pval timestamp without time zone, pfmt character varying, pnlsparam character varying)" is-aggregate="f" language-name="plpgsql" context="to_char(pval timestamp without time zone, pfmt character varying, pnlsparam character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone,character varying,character varying" comment="to_char convertion date or timestamp without TZ as Oracle does. Some Format models could return incorrect results. Only NLS_DATE_LANGUAGE is allowed for NLS param. Value must be correct as lc_time value" unique-suffix="(pval timestamp without time zone, pfmt character varying, pnlsparam character varying)" routine-number="22445" is-returning-set="f" ret-datatype="varchar" function-arguments="pval timestamp without time zone, pfmt character varying, pnlsparam character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22445" volatility="VOLATILE" is-window="f" function-identity-arguments="pval timestamp without time zone, pfmt character varying, pnlsparam character varying" overload-function-count="19" proc-language="plpgsql" function-signature="to_char(pval timestamp without time zone, pfmt character varying, pnlsparam character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vResult VARCHAR DEFAULT NULL;
    vFmt VARCHAR;
BEGIN

    IF pVal IS NOT NULL THEN

        vFmt := aws_oracle_ext.to_char_formatter
        (
            pVal      => pVal,
            pFormat   => pFmt,
            pNlsParam => pNlsParam
        );

        vResult := TO_CHAR(pVal, vFmt);

    END IF;

    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="b45845ed-9b42-4eb0-8e34-3b263aa67401" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="14f01395-5660-4ced-80f9-5d8f40998330" name="to_char_formatter" is-trigger-function="0" unique-function-name="to_char_formatter" is-aggregate="f" language-name="plpgsql" context="to_char_formatter" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyelement,character varying,character varying,character varying" comment="Utility function making to_char results similar to expected on Oracle side" is-returning-set="f" ret-datatype="varchar" function-arguments="pval anyelement, pformat character varying DEFAULT NULL::character varying, pnlsparam character varying DEFAULT NULL::character varying, pnonumberformat character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22430" volatility="VOLATILE" is-window="f" function-identity-arguments="pval anyelement, pformat character varying, pnlsparam character varying, pnonumberformat character varying" overload-function-count="1" proc-language="plpgsql" function-signature="to_char_formatter(pval anyelement, pformat character varying, pnlsparam character varying, pnonumberformat character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vFmt VARCHAR;
    rec RECORD;
    vResult VARCHAR;
    vDataType VARCHAR;
    vIsDateTime BOOLEAN DEFAULT FALSE;
    cAllowedDatatypes CONSTANT VARCHAR[] := ARRAY
    [
        -- numeric
        'REAL',
        'DOUBLE PRECISION',
        'NUMERIC',
        'INTEGER',
        --datetime
        'INTERVAL',
        'TIMESTAMP WITHOUT TIME ZONE',
        'TIMESTAMP WITH TIME ZONE',
        -- char
        'CHARACTER',
        'CHARACTER VARYING',
        'TEXT'

    ];
    cpellmodels CONSTANT TEXT[] := ARRAY
    [
        'SSSP',
        'Y,YYYSP',
        'SYYYYSP',
        'YYYYSP',
        'YYYSP',
        'YYSP',
        'YSP',
        'SCCSP',
        'CCSP',
        'RRRRSP',
        'RRSP',
        'HH24SP',
        'HH12SP',
        'HHSP',
        'DDDSP',
        'DDSP',
        'DSP',
        'MISP',
        'MMSP',
        'QSP',
        'TZHSP',
        'TZMSP',
        'FFSP',
        'FF1SP',
        'FF2SP',
        'FF3SP',
        'FF4SP',
        'FF5SP',
        'FF6SP',
        'FF7SP',
        'FF8SP',
        'FF9SP'
    ];
    vIsNumeric BOOLEAN DEFAULT FALSE;
    vIsChar BOOLEAN DEFAULT FALSE;

    verrorMessages CONSTANT VARCHAR[] := ARRAY
    [
        'ORA-01722: invalid number', --1
        'ORA-01821: date format not recognized', --2
        'ORA-01822: era format code is not valid with this calendar', --3
        'not implemented', --4
        'ORA-12702: invalid NLS parameter string used in SQL function', --5
        'ORA-01481: invalid number format model', --6
        'ORA-22835: Buffer too small for CLOB to CHAR', --7
        'ORA-00902: invalid datatype' --8
    ];

    v_lctime VARCHAR;
    vNlsParam VARCHAR;
    vNlsParamCopy VARCHAR;
    vDayMaxLengh INTEGER;
    vDyMaxLengh INTEGER;
    vMonthMaxLength INTEGER;
    vMonMaxLength INTEGER;
    --used to calculate localized day/month names
    cDayMonthNumbers CONSTANT INTEGER[] := ARRAY[1,2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    vTm VARCHAR;

    vtail VARCHAR;
    vfm VARCHAR;

    vurrisset BOOLEAN DEFAULT FALSE;
    vGroupSeparator VARCHAR(2) DEFAULT NULL;
    vDecimalSeparator VARCHAR(2) DEFAULT NULL;
    vCurrencySymbol VARCHAR;
    vIsoCurrency VARCHAR;
    vDualCurrency VARCHAR;
    bd BOOLEAN DEFAULT FALSE;
    vln INTEGER;

BEGIN

    vDataType := UPPER(PG_TYPEOF(pVal)::TEXT);

    IF ARRAY_POSITION(cAllowedDatatypes,  vDataType) IS NULL THEN

        RAISE USING MESSAGE := verrorMessages[8];

    END IF;

    CASE
        WHEN vDataType IN
        (
            'INTERVAL',
            'TIMESTAMP WITHOUT TIME ZONE',
            'TIMESTAMP WITH TIME ZONE'
        ) THEN

            vIsDateTime := TRUE;

        WHEN vDataType IN
        (
            'REAL',
            'DOUBLE PRECISION',
            'NUMERIC',
            'INTEGER'
        ) THEN

            vIsNumeric := TRUE;

        ELSE

            vIsChar := TRUE; 

    END CASE;

    IF (vIsDateTime OR  (vIsNumeric AND pNoNumberFormat IS NULL)) AND (pFormat IS NULL OR pFormat = '') THEN

        IF vIsNumeric AND pFormat = '' THEN

            vResult := '#';
        
        ELSE

            vResult := NULL;

        END IF;

    ELSE

        CASE
            WHEN vIsDateTime AND vDataType <> 'INTERVAL' AND pFormat ~* '^FX$' THEN

                vResult := NULL;

            WHEN vIsDateTime THEN

                IF pNlsParam IS NOT NULL THEN

                    bd := TRUE;

                    vNlsParam := REPLACE(pNlsParam,' ', '');

                    SELECT STRING_AGG(TRIM(nls),'')
                    INTO vNlsParam
                    FROM  REGEXP_SPLIT_TO_TABLE
                    ( 
                        vNlsParam,
                        'NLS_',
                        'i'
                    ) nls
                    WHERE TRIM(nls) <> '' AND TRIM(nls) !~* 'CALENDAR';

                    IF vNlsParam IS NOT NULL THEN

                        IF vNlsParam  !~* 'DATE_LANGUAGE=' THEN

                            RAISE USING MESSAGE := verrorMessages[5];

                        END IF;

                        -- store original language
                        v_lctime := CURRENT_SETTING('lc_time');

                        vNlsParam := REGEXP_REPLACE(vNlsParam, 'DATE_LANGUAGE=', '', 'i');

                        -- try to set NLS
                        BEGIN

                            vTm := SET_CONFIG
                            (
                                'lc_time',
                                vNlsParam,
                                TRUE
                            );

                        EXCEPTION 
                            WHEN OTHERS THEN

                                RAISE USING MESSAGE := verrorMessages[5]; 
                        END;

                    END IF;

                END IF;

                IF NOT bd THEN

                    vResult := aws_oracle_ext.get_cache_value
                    (
                        typeofcache => 'fromdate',
                        sourecmodel => pFormat
                    );

                    IF vResult IS NOT NULL THEN

                        RETURN vResult;

                    END IF;

                END IF;
        
                vtail:= pFormat;

                LOOP

                    SELECT ok, tail, fm
                    INTO vFmt, vtail, vfm
                    FROM aws_oracle_ext.to_char_parser
                    (
                        pStr  => vtail,
                        pType => 'datetime',
                        pFm   => vfm
                    );

                    IF vFmt !~ '"' THEN

                        IF vDataType IN ('TIMESTAMP WITHOUT TIME ZONE', 'TIMESTAMP WITH TIME ZONE') THEN

                            IF vFmt ~* 'SP$' THEN

                                IF EXISTS (SELECT 1 FROM UNNEST(cpellmodels) t WHERE t = UPPER(vFmt)) THEN

                                    bd := TRUE;
                                    IF vDataType = 'TIMESTAMP WITH TIME ZONE' THEN

                                        vFmt := aws_oracle_ext.spell_timestamptz
                                        (
                                            pval => pVal,
                                            pfmt => vFmt
                                        );

                                    ELSE

                                        vFmt := aws_oracle_ext.spell_timestamp
                                        (
                                            pval => pVal,
                                            pfmt => vFmt
                                        );

                                    END IF;
                                    vFmt := CONCAT
                                    (
                                        '"',
                                        vFmt,
                                        '"'
                                    );

                                    vResult := CONCAT(vResult, vFmt);
                                    EXIT WHEN vtail IS NULL;
                                    CONTINUE;

                                END IF;

                            END IF;

                        END IF;

                        -- exact set of dates is chosen to be sure about day names
                        --calculate max day of week name length for language
                        IF vDataType <> 'INTERVAL' THEN

                            IF vFmt ~* '^tmMON$' OR vFmt ~* '^tmMONTH$' OR vFmt ~* '^tmDAY$' OR vFmt ~* '^tmDY$' THEN

                                bd := TRUE;

                                SELECT MAX(LENGTH(TO_CHAR(TO_DATE(CONCAT(LPAD(val::TEXT, 2, '0') , '102017'), 'ddmmyyyy'),'TMDAY'))),
                                            MAX(LENGTH(TO_CHAR(TO_DATE(CONCAT(LPAD(val::TEXT, 2, '0'), '102017'), 'ddmmyyyy'),'TMDY')))
                                INTO vDayMaxLengh,
                                    vDyMaxLengh
                                FROM UNNEST(cDayMonthNumbers) AS val
                                WHERE val BETWEEN 2 AND 8;

                                --calculate max month name length for language
                                SELECT MAX(LENGTH(TO_CHAR(TO_DATE(CONCAT(LPAD(val::TEXT, 2, '0'), '2017'), 'mmyyyy'),'TMMONTH'))),
                                    MAX(LENGTH(TO_CHAR(TO_DATE(CONCAT(LPAD(val::TEXT, 2, '0'), '2017'), 'mmyyyy'),'TMMON')))
                                INTO vMonthMaxLength,
                                    vMonMaxLength
                                FROM UNNEST(cDayMonthNumbers) AS val;

                            END IF;

                        END IF;

                        IF vDataType <> 'INTERVAL' THEN
    
                            FOR rec IN
                            (
                                SELECT fm.fmt
                                FROM aws_oracle_ext.format_models fm
                                WHERE fm.tp = 'datetime'
                                AND fm.grp = UPPER(SUBSTR(vFmt,1,1))
                                AND
                                (
                                    fm.fmt LIKE '%SP%' OR
                                    fm.fmt IN ('SYEAR', 'YEAR')
                                )
                            )
                            LOOP

                                
                                IF vFmt ~* CONCAT('^', rec.fmt, '$') THEN

                                    RAISE USING MESSAGE := verrorMessages[4];
                                
                                END IF;

                            END LOOP;


                            IF vFmt ~* '^E$' OR vFmt ~* '^EE$' THEN

                                RAISE USING MESSAGE := verrorMessages[3];

                            END IF;
                       
                        END IF;

                        IF vFmt ~* 'TZ[HM]' AND vDataType = 'TIMESTAMP WITHOUT TIME ZONE' THEN

                            FOR rec IN
                            (
                                SELECT fm.fmt
                                FROM aws_oracle_ext.format_models fm
                                WHERE fm.tp = 'datetime'
                                AND fm.grp = UPPER(SUBSTR(vFmt,1,1))
                                AND 
                                (
                                    fm.fmt LIKE 'TZH%' OR 
                                    fm.fmt LIKE 'TZM%'
                                )
                            )
                            LOOP

                                IF vFmt ~* CONCAT('^', rec.fmt) THEN

                                    RAISE USING MESSAGE := verrorMessages[2];

                                END IF;

                            END LOOP;

                        END IF;

                        IF vDataType <> 'INTERVAL' THEN
                        
                            IF vDataType = 'TIMESTAMP WITHOUT TIME ZONE' AND vFmt ~* 'tzr' THEN

                                bd := TRUE;

                                vFmt := REGEXP_REPLACE(vFmt, 'tzr', '"+00:00"', 'ig');

                            END IF;

                            vFmt := REGEXP_REPLACE(vFmt, 'tzd', '', 'ig');

                            -- Unable to calculate TS correctly, will produce
                            -- Oracle behavior 9:01:01 AM
                            IF vFmt ~* 'TS' THEN

                                bd := TRUE;
                            
                                vFmt := REGEXP_REPLACE
                                (
                                    vFmt,
                                    'ts',
                                    CONCAT
                                    (
                                        '"',
                                        TRIM(TO_CHAR(pVal, 'hh'),'0'),
                                        ':',
                                        TO_CHAR(pVal, 'mi'),
                                        ':',
                                        TO_CHAR(pVal, 'ss'),
                                        ' ',
                                        TO_CHAR(pVal, 'AM'),
                                        '"'
                                    ),
                                    'ig'
                                );

                            END IF;

                            -- X will be .
                            IF vFmt !~* 'FX' AND vFmt ~* '^x' THEN

                                vFmt := REGEXP_REPLACE(vFmt, 'x', '.', 'ig');

                            END IF;

                            -- Fix cases
                            vFmt := REPLACE(vFmt, 'A.d.', 'A.D.');
                            vFmt := REPLACE(vFmt, 'A.m.', 'A.M.');
                            vFmt := REPLACE(vFmt, 'B.c.', 'B.C.');
                            vFmt := REPLACE(vFmt, 'P.m.', 'P.M.');

                            FOR rec IN
                            (
                                SELECT
                                    ARRAY_TO_STRING
                                    (
                                        REGEXP_MATCHES(vFmt, 'Rm|Ad|Bc|Pm|Am', 'g'),
                                        ''
                                    ) case_match
                            ) LOOP

                                vFmt := REPLACE
                                (
                                    vFmt,
                                    rec.case_match,
                                    CONCAT
                                    (
                                        '"',
                                        INITCAP(TO_CHAR(pVal, UPPER(rec.case_match))),
                                        '"'
                                    )
                                );

                                bd := TRUE;

                            END LOOP;

                            -- PG 13+ does not need THIS
                            -- PG has SSSS, but Oracle SSSSS, so we need to convert SSSSS to SSSS
                            -- ssss to ss + ss
                            IF NOT (current_setting('server_version_num')::int) >= 130000 THEN

                                IF vFmt ~* '^FMS{2}$' OR vFmt ~* '^S{2}$' THEN

                                    bd := TRUE;

                                    vFmt := CONCAT
                                    (
                                        '"',
                                        TO_CHAR(pVal, 'ss'),
                                        '"'
                                    );

                                END IF;

                                IF vFmt ~* '^FMS{5}$' OR vFmt ~* '^S{5}$' THEN

                                        bd := TRUE;

                                        vFmt := CONCAT
                                        (
                                            '"',
                                            TO_CHAR(pVal, REGEXP_REPLACE(vFmt, 's{5}', 'ssss', 'i')),
                                            '"'
                                        );

                                END IF;

                            END IF;

                            -- PG has ID, but Oracle use it as I + D, no ID
                            IF vFmt ~* '^i$' THEN
                                
                                bd := TRUE;

                                vFmt := 
                                    CONCAT
                                    (
                                        '"',
                                        TO_CHAR(pVal, 'I'),
                                        '"'
                                    );
                            
                            END IF;

                            /* PG unable to convert TH if contains lower case letters in model */
                            IF vFmt ~* 'TH' AND vFmt !~* 'MONTH' AND vFmt ~ '[[:lower:]]' THEN

                                bd := TRUE;

                                vFmt := CONCAT
                                (
                                    '"',
                                    REGEXP_REPLACE(TO_CHAR(pVal, vFmt), '(\d+)(\D+)', '\1', 'i'),
                                    LOWER(REGEXP_REPLACE(TO_CHAR(pVal, UPPER(vFmt)), '(\d+)(\D+)', '\2', 'i')),
                                    '"'
                                );
                            
                            END IF;

                            -- hard to calculate correct DS format, will set to fmmm/fmdd/fmyyyy
                            IF vFmt ~* 'ds' THEN

                                bd := TRUE;
                            
                                vFmt := REGEXP_REPLACE
                                (
                                    vFmt,
                                    'ds',
                                    CONCAT
                                    (
                                        '"',
                                        LTRIM(TO_CHAR(pVal, 'mm'), '0'),
                                        '/',
                                        LTRIM(TO_CHAR(pVal, 'dd'), '0'),
                                        '/',
                                        LTRIM(TO_CHAR(pVal, 'yyyy'), '0'), 
                                        '"'
                                    ),
                                    'ig'
                                );

                            END IF;

                            IF vFmt ~* 'SYYYY' THEN

                                bd := TRUE;
                            
                                vFmt := REGEXP_REPLACE
                                (
                                    vFmt,
                                    'syyyy',
                                    CONCAT
                                    (
                                        '"',
                                        CASE
                                            WHEN TO_CHAR(pVal,'BC') = 'BC' THEN
                                                CONCAT('-', TO_CHAR(pVal, 'YYYY'))
                                            ELSE
                                                CONCAT(' ', TO_CHAR(pVal, 'YYYY'))
                                        END,
                                        '"'
                                    ),
                                    'ig'
                                );

                            END IF;

                            IF vFmt ~* 'CC' AND vFmt !~* 'SCC' THEN

                                bd := TRUE;

                                vFmt := REGEXP_REPLACE
                                (
                                    vFmt,
                                    'cc',
                                    CONCAT
                                    (
                                        '"',
                                        CASE
                                            WHEN TO_CHAR(pVal,'BC') = 'BC' THEN
                                                REPLACE(TO_CHAR(pVal, 'CC'),'-','')
                                            ELSE
                                                TO_CHAR(pVal, 'CC')
                                        END,
                                        '"'
                                    ),
                                    'ig'
                                );

                            END IF;

                            IF vFmt ~* 'SCC' THEN

                                bd := TRUE;

                                vFmt := REGEXP_REPLACE
                                (
                                    vFmt,
                                    'scc',
                                    CONCAT
                                    (
                                        '"',
                                        CASE
                                            WHEN TO_CHAR(pVal,'BC') = 'BC' THEN
                                                TO_CHAR(pVal, 'CC')
                                            ELSE
                                                CONCAT(' ', TO_CHAR(pVal, 'CC'))
                                        END,
                                        '"'
                                    ),
                                    'ig'
                                );

                            END IF;

                            IF vFmt ~* 'TZH' THEN

                                bd := TRUE;

                                vFmt := REGEXP_REPLACE
                                (
                                    vFmt,
                                    'tzh',
                                    CONCAT
                                    (
                                        '"',
                                        SUBSTRING(EXTRACT(TIMEZONE_HOUR FROM pVal)::TEXT FROM '\D'),
                                        LPAD
                                        (
                                            SUBSTRING(EXTRACT(TIMEZONE_HOUR FROM pVal)::TEXT FROM '\d+'),
                                            2,
                                            '0'
                                        ),
                                        '"'
                                    ),
                                    'ig'
                                );

                            END IF;

                            IF vFmt ~* 'TZM' THEN

                                bd := TRUE;

                                vFmt := REGEXP_REPLACE
                                (
                                    vFmt,
                                    'tzm',
                                    CONCAT
                                    (
                                        '"',
                                        SUBSTRING(EXTRACT(TIMEZONE_MINUTES FROM pVal)::TEXT FROM '\D'),
                                        LPAD
                                        (
                                            SUBSTRING(EXTRACT(TIMEZONE_MINUTES FROM pVal)::TEXT FROM '\d+'),
                                            2,
                                            '0'
                                        ),
                                        '"'
                                    ),
                                    'ig'
                                );

                            END IF;

                            IF vFmt ~* 'TZR' THEN

                                bd := TRUE;

                                vFmt := REGEXP_REPLACE
                                (
                                    vFmt,
                                    'tzr',
                                    CONCAT
                                    (
                                        '"',
                                        SUBSTRING(EXTRACT(TIMEZONE_HOUR FROM pVal)::TEXT FROM '\D'),
                                        LPAD
                                        (
                                            SUBSTRING(EXTRACT(TIMEZONE_HOUR FROM pVal)::TEXT FROM '\d+'),
                                            2,
                                            '0'
                                        ),
                                        ':',
                                        SUBSTRING(EXTRACT(TIMEZONE_MINUTES FROM pVal)::TEXT FROM '\D'),
                                        LPAD
                                        (
                                            SUBSTRING(EXTRACT(TIMEZONE_MINUTES FROM pVal)::TEXT FROM '\d+'),
                                            2,
                                            '0'
                                        ),
                                        '"'
                                    ),
                                    'ig'
                                );

                            END IF;

                            -- hard to calculate correct DL, set to hardcoded format
                            IF vFmt ~* '^DL' THEN

                                bd := TRUE;

                                vFmt := 
                                    CONCAT
                                    (
                                        '"',
                                        TRIM(TO_CHAR(pVal, 'TMDay')),
                                        ', ',
                                        TRIM(TO_CHAR(pVal, 'TMMonth')),
                                        ' ',
                                        TO_CHAR(pVal, 'dd'),
                                        ', ',
                                        TO_CHAR(pVal, 'yyyy'),
                                        
                                        '"'
                                    );

                            END IF;

                            -- PG13+ does not need this
                            --FF[1..9] FF = FF6 here
                            IF NOT (current_setting('server_version_num')::int) >= 130000 THEN
                            
                                IF vFmt ~* '^FF\d' THEN

                                    bd := TRUE;

                                    vln := SUBSTRING(vFmt FROM '\d')::INTEGER;

                                    IF vln < 6 THEN

                                        vFmt := CONCAT('"', SUBSTR(TO_CHAR(pVal, 'US'), 1, vln), '"');

                                    ELSE

                                        vFmt := CONCAT('"', RPAD(TO_CHAR(pVal, 'US'), vln, '0'), '"');

                                    END IF;

                                END IF;

                            END IF;

                            IF vFmt ~* '^tmMON$' THEN

                                bd := TRUE;

                                vFmt := CONCAT
                                (
                                    '"',
                                    RPAD(TO_CHAR(pVal, vFmt), vMonMaxLength),
                                    '"'
                                );

                            END IF;

                            IF vFmt ~* '^tmMONTH$' THEN

                                bd := TRUE;

                                vFmt := CONCAT
                                (
                                    '"',
                                    RPAD(TO_CHAR(pVal, vFmt), vMonthMaxLength),
                                    '"'
                                );

                            END IF;

                            IF vFmt ~* '^tmDAY$' THEN

                                bd := TRUE;

                                vFmt := CONCAT
                                (
                                    '"',
                                    RPAD(TO_CHAR(pVal, vFmt), vDayMaxLengh),
                                    '"'
                                );

                            END IF;

                            IF vFmt ~* '^tmDY$' THEN

                                bd := TRUE;

                                vFmt := CONCAT
                                (
                                    '"',
                                    RPAD(TO_CHAR(pVal, vFmt), vDyMaxLengh),
                                    '"'
                                );

                            END IF;

                        END IF;

                    END IF;

                    IF vResult ~ 'Dd' THEN

                        vResult := REPLACE(vResult, 'Dd', 'dd');

                    END IF;

                    IF vResult ~ 'dD' THEN

                        vResult := REPLACE(vResult, 'dD', 'dd');

                    END IF;

                    vResult := CONCAT(vResult, vFmt);

                    EXIT WHEN vtail IS NULL;

                END LOOP;

                IF NOT bd THEN

                    PERFORM aws_oracle_ext.set_cache_value
                    (
                        typeofcache => 'fromdate',
                        sourecmodel => pFormat,
                        targetmodel => vResult
                    );

                END IF;

                -- restore language setting if they were changed
                IF CURRENT_SETTING('lc_time') <> v_lctime THEN

                    vTm := SET_CONFIG('lc_time', v_lctime, TRUE);

                END IF;

            WHEN vIsNumeric AND pNoNumberFormat IS NULL AND pNlsParam = '' THEN

                vResult := NULL;

            WHEN vIsNumeric THEN

                IF pNoNumberFormat IS NULL THEN

                    IF pNlsParam IS NOT NULL THEN

                        bd := TRUE;

                        SELECT STRING_AGG(CASE WHEN nls ~* 'CALENDAR' THEN '' ELSE nls END, '')
                        INTO vNlsParamCopy
                        FROM REGEXP_SPLIT_TO_TABLE
                        ( 
                            TRIM(E'\n\ ' FROM pNlsParam),
                            'NLS_',
                        'i') nls;

                        -- check if paramters are allowed
                        IF pNlsParam ~ '^\s+$' THEN

                            RAISE USING MESSAGE := verrorMessages[5];

                        END IF;

                        vNlsParam := REGEXP_REPLACE
                        (
                            vNlsParamCopy,
                            $$NUMERIC_CHARACTERS\s*=\s*('?)(.+?)('?)$$,
                            '',
                            'i'
                        );

                        vNlsParam := REGEXP_REPLACE
                        (
                            vNlsParam,
                            $$ISO_CURRENCY\s*=\s*('?)(.+?)('?)$$,
                            '',
                            'i'
                        );
              
                        vNlsParam := REGEXP_REPLACE
                        (
                            vNlsParam,
                            $$CURRENCY\s*=\s*('?)(.+?)('?)$$,
                            '',
                            'i'
                        );

                        IF LENGTH(TRIM(E'\n\ ' FROM vNlsParam)) > 0 THEN

                            RAISE USING MESSAGE := verrorMessages[5];

                        END IF;
                        
                        -- Try to get set NLS parts
                        FOR rec IN 
                        (
                            SELECT REGEXP_MATCHES
                            (
                                vNlsParamCopy,
                                $$NUMERIC_CHARACTERS\s*=\s*('?)(.+?)('?)$$,
                                'i'
                            ) m
                        ) LOOP

                            vDecimalSeparator := SUBSTR((rec.m)[2], 1, 1);
                            
                            IF LENGTH(vDecimalSeparator) = 0 THEN

                                RAISE USING MESSAGE := verrorMessages[5];

                            END IF;

                            vGroupSeparator := SUBSTR((rec.m)[2], 2, 1);

                            IF LENGTH(vGroupSeparator) = 0 THEN

                                RAISE USING MESSAGE := verrorMessages[5];

                            END IF;

                        END LOOP;

                        FOR rec IN 
                        (
                            SELECT REGEXP_MATCHES
                            (
                                vNlsParamCopy,
                                $$CURRENCY\s*=\s*('?)(.+?)('?)$$,
                                'i'
                            ) m
                        ) LOOP

                            vCurrencySymbol := (rec.m)[2];

                            IF LENGTH(vCurrencySymbol) = 0 THEN

                                RAISE USING MESSAGE := verrorMessages[5];

                            END IF;

                        END LOOP;

                        FOR rec IN 
                        (
                            SELECT REGEXP_MATCHES
                            (
                                vNlsParamCopy,
                                $$ISO_CURRENCY\s*=\s*('?)(.+?)('?)$$,
                                'i'
                            ) m
                        ) LOOP

                            vIsoCurrency := (rec.m)[2];

                            IF LENGTH(vIsoCurrency) = 0 THEN

                                RAISE USING MESSAGE := verrorMessages[5];

                            END IF;

                            SELECT icl.code
                            INTO vIsoCurrency
                            FROM aws_oracle_ext.iso_currency_list icl
                            WHERE icl.nls_iso_currency = (rec.m)[2];

                        END LOOP;

                    END IF;

                    IF NOT bd THEN

                        vFmt := aws_oracle_ext.get_cache_value
                        (
                            typeofcache => 'fromnumber',
                            sourecmodel => pFormat
                        );

                        IF vFmt IS NOT NULL THEN

                            vResult := TO_CHAR
                            (
                                pVal,
                                REGEXP_REPLACE(vFmt, 'FM', 'FM', 'i')
                            );

                            IF vResult ~ '#' AND NOT pFormat ~* '[^09GD\.]' THEN

                                vResult := REPEAT('#', LENGTH(pFormat) + 1);

                            END IF;
                            
                            RETURN vResult;

                        END IF;

                    END IF;

                    vtail:= pFormat;

                    LOOP

                        SELECT ok, tail, fm
                        INTO vFmt, vtail, vfm
                        FROM aws_oracle_ext.to_char_parser
                        (
                            pStr  => vtail,
                            pType => 'number',
                            pFm   => vfm
                        );
                        
                    
                        vResult := CONCAT(vResult, vFmt);

                        EXIT WHEN vtail IS NULL;

                    END LOOP;

                    /* Restrictions */
                    --A comma element cannot begin a number format model
                    IF SUBSTR(vResult, 1, 1) = ',' THEN

                        RAISE USING MESSAGE := verrorMessages[6];

                    END IF;
                    -- A comma cannot appear to the right of a decimal
                    -- character or period in a number format model
                    CASE 
                        WHEN vResult ~* '[\.D].*\,' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        --only one period in a number format model
                        WHEN vResult ~ '\..*\.' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- only one decimal character in a number format model
                        WHEN vResult ~* 'd.*d' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- group separator cannot appear to the right of a decimal 
                        -- character or period in a number format model
                        -- V also
                        WHEN vResult ~* '[\.DV].*g' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- Start with g is not allowed
                        WHEN vResult ~* '^G' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- It's not allowed to mix different type group and
                        -- decimal model symbols
                        WHEN vResult ~ '\.|\,' AND vResult ~* 'D|G' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- The MI format element can appear only in the last position 
                        -- of a number format model
                        WHEN vResult ~* 'MI.+' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        --The PR format element can appear only in the last position
                        -- of a number format model
                        WHEN vResult ~* 'PR.+' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- The S format element can appear only in the first 
                        -- or last position of a number format model
                        WHEN vResult ~* '[^S]+S[^S]+' OR vResult ~* 'S[^S]*S' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- You cannot precede this element with any other element
                        WHEN vResult ~* '.+TM' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- You can follow this element only with one 9 or 
                        -- one E (or e), but not with any combination of these
                        WHEN vResult ~* 'TM.{2,}' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        WHEN vResult ~* 'TM[^9e]' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- You can precede this element only with 0 (which returns leading zeroes)
                        -- or FM. Any other elements return an error
                        WHEN vResult ~* '.*X.?'
                            AND vResult !~* '^0+X{1,}$'
                            AND vResult !~* '^FMX{1,}$'
                            AND vResult !~* '^FM0{1,}X{1,}$'
                            AND vResult !~* '^X{1,}$' THEN

                                RAISE USING MESSAGE := verrorMessages[6];
                        -- only one $ allowed
                        WHEN vResult ~ '\$.*\$' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- only one C allowed
                        WHEN vResult ~* 'C.*C' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- only one L allowed
                        WHEN vResult ~* 'L.*L' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- only one U allowed
                        WHEN vResult ~* 'U.*U' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- C, L, $, U together is not allowed
                        WHEN vResult ~* 'C.*[\$LU]' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        WHEN vResult ~* '[UL\$].*C' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- only one V allowed
                        WHEN vResult ~* 'V.*V' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- V and period or decimal is not allowed
                        WHEN vResult ~* 'V.*[\.D]' OR vResult ~* '[\.D].*V' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- If RN - no other models allowed
                        WHEN vResult ~* '.+RN' OR vResult ~* 'RN.+' THEN

                            RAISE USING MESSAGE := verrorMessages[6];
                        -- Only EEEE is not allowed. No chars after EEEE. No comma before EEEE
                        WHEN vResult ~* '^EEEE$' 
                            OR vResult ~* 'EEEE[^S]+' 
                            OR vResult ~* '\,.*EEEE'
                            OR vResult ~* 'EEEE.{2,}' THEN

                                RAISE USING MESSAGE := verrorMessages[6];
                        ELSE

                            NULL;
                    END CASE;

                    /* Some Oracle actions repeated */
                    IF UPPER(vResult) = 'S' THEN

                        bd := TRUE;

                        vResult := '#';

                    END IF;

                    IF vResult ~* 'U|C|L' THEN

                        bd := TRUE;

                        IF vResult ~* 'U' THEN

                            IF vDualCurrency IS NULL THEN

                                SELECT value
                                INTO vDualCurrency
                                FROM aws_oracle_ext.v$nls_parameters WHERE parameter = 'NLS_DUAL_CURRENCY';

                            END IF;

                            vResult := REGEXP_REPLACE(vResult, 'U',  CONCAT('"', vDualCurrency, '"') , 'i');
                            vurrisset := true;

                        END IF;

                        IF vResult ~* 'C' AND NOT vurrisset THEN

                            IF vIsoCurrency IS NULL THEN

                                SELECT icl.code
                                INTO vIsoCurrency
                                FROM aws_oracle_ext.iso_currency_list icl
                                WHERE icl.nls_iso_currency = (SELECT value
                                FROM aws_oracle_ext.v$nls_parameters WHERE parameter = 'NLS_ISO_CURRENCY');

                            END IF;

                            vResult := REGEXP_REPLACE(vResult, 'C',  CONCAT('"', vIsoCurrency, '"') , 'i');
                            vurrisset := true;

                        END IF;

                        IF vResult ~* 'L' AND NOT vurrisset THEN

                            IF vCurrencySymbol IS NULL THEN

                                SELECT value
                                INTO vCurrencySymbol
                                FROM aws_oracle_ext.v$nls_parameters
                                WHERE parameter = 'NLS_CURRENCY';

                            END IF;

                            vResult := REGEXP_REPLACE(vResult, 'L',  CONCAT('"', vCurrencySymbol, '"') , 'i');
                            vurrisset := true;

                        END IF;

                    END IF;

                    IF vResult ~ '\$' AND vResult !~ '"\$"' THEN

                        bd := TRUE;

                        vResult := CONCAT('"$"', REPLACE(vResult, '$', ''));

                    END IF;

                    IF vResult ~* 'TMe' THEN

                        vResult = REGEXP_REPLACE(vResult, 'TMe', '9.9EEEE', 'i');

                    END IF;

                    -- converting

                    CASE
                        WHEN vResult ~* 'X' AND vResult !~ '"' THEN

                            bd := TRUE;
                            
                            vResult := CONCAT
                            (
                                CASE
                                    WHEN vResult ~* 'FM' THEN
                                        ''
                                    ELSE
                                        ' '
                                    END,
                                LPAD
                                (
                                    CASE
                                        WHEN vResult ~ 'X' THEN
                                            UPPER(TO_HEX(ROUND(pVal,0)::INTEGER)::TEXT)
                                        ELSE TO_HEX(ROUND(pVal,0)::INTEGER)::TEXT
                                    END,
                                    LENGTH
                                    (
                                        REGEXP_REPLACE
                                        (
                                            vResult,
                                            'FM',
                                            '',
                                            'i'
                                        )
                                    ),
                                    '0'
                                )
                            );
                            
                        WHEN vResult ~* 'EEEE' THEN

                            bd := TRUE;

                            vResult := 
                            CASE 
                                WHEN vResult ~* 'FM' THEN 
                                    LTRIM
                                    (
                                        REPLACE
                                        (
                                            REGEXP_REPLACE
                                            (
                                                TO_CHAR
                                                (
                                                    pVal,
                                                    REGEXP_REPLACE(vResult, 'FM', '', 'i')
                                                ),
                                                '00(\d)',
                                                '0\1'
                                            ),
                                            'e',
                                            'E'
                                        )
                                    )
                                ELSE
                                    CONCAT(' ', REPLACE(REGEXP_REPLACE(TO_CHAR(pVal, vResult), '00(\d)', '0\1'), 'e', 'E'))
                            END;

                            IF vDecimalSeparator IS NOT NULL THEN

                                vFmt := REPLACE(TO_CHAR(1.1, 'FM9D9'),'1','');
                                vResult := REPLACE(vResult, vFmt, '#.');    
                                vResult := REPLACE(vResult, '#.', vDecimalSeparator);

                            END IF;

                        WHEN vResult ~* 'G|D' AND vDecimalSeparator IS NOT NULL AND vGroupSeparator IS NOT NULL THEN

                            bd := TRUE;
                            vResult := TO_CHAR(pVal, REGEXP_REPLACE(vResult, 'FM', 'FM', 'i'));

                            vFmt := REPLACE(TO_CHAR(1.1, 'FM9D9'),'1','');
                            vResult := REPLACE(vResult, vFmt, '#.');
                            vFmt := REPLACE(TO_CHAR(1111, 'FM9G999'),'1','');
                            vResult := REPLACE(vResult, vFmt, '#,');

                            vResult := REPLACE(vResult, '#,', vGroupSeparator);
                            vResult := REPLACE(vResult, '#.', vDecimalSeparator);
                        
                        --  case with format = '.999'  
                        WHEN vResult ~* '^\.(?=\d+$)' THEN  

                            bd := TRUE;
                            
                            vResult :=
                            REGEXP_REPLACE
                            (
                                TO_CHAR
                                    (
                                        pVal,
                                        REGEXP_REPLACE
                                        (
                                            vResult, 
                                            '^\.(?=\d+$)', 
                                            '0.', 
                                            'g'
                                        )
                                    ),
                                '^\ ?0\.',
                                ' .',
                                'g'
                            );
                        WHEN vResult ~* 'TM9?' THEN

                            vResult := pVal::TEXT;

                            IF vDecimalSeparator IS NOT NULL THEN

                                vResult := REPLACE(vResult, '.', vDecimalSeparator);

                            END IF;

						ELSE

                            vResult := TO_CHAR
                            (
                                pVal,
                                REGEXP_REPLACE(vResult, 'FM', 'FM', 'i')
                            );

                            IF vResult ~ '#' AND NOT pFormat ~* '[^09GD\.]' THEN

                                bd := TRUE;

                                vResult := REPEAT('#', LENGTH(pFormat) + 1);

                            END IF;

                            IF NOT bd THEN

                                PERFORM aws_oracle_ext.set_cache_value
                                (
                                    typeofcache => 'fromnumber',
                                    sourecmodel => pFormat,
                                    targetmodel => pFormat
                                );

                            END IF;

                    END CASE;
                
                ELSE

                        IF pVal = 0 THEN

                            vResult := '0';
                            
                        ELSE

                            vResult := REGEXP_REPLACE(REGEXP_REPLACE(REGEXP_REPLACE(pVal::TEXT, '^0\.(\d+)', '.\1'), '\.0{2,}$', ''), '\.$', '');

                            vResult := REGEXP_REPLACE(vResult, '^-0\.(\d+)', '-.\1');

                            IF vResult ~ '\.' THEN

                                vResult := REGEXP_REPLACE(REGEXP_REPLACE(vResult, '0+$', ''), '\.$', '');

                            END IF;
                        
                        END IF;

                END IF;
                
            ELSE

                IF pFormat IS NOT NULL THEN
                    
                    RAISE USING MESSAGE := verrorMessages[1];

                END IF;
                
                IF LENGTH(pVal) > 4000 THEN

                    RAISE USING MESSAGE := verrorMessages[7];

                END IF;

                vResult := pVal::VARCHAR;

        END CASE;

    END IF;

    RETURN vResult;

END;

]]></complex-attribute>
                        <category _I_D="78f870e1-9ef8-4de1-b899-8e200b898d66" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9ba8cb4b-691d-4787-b23b-eda0e170b7e6" name="to_char_parser" is-trigger-function="0" unique-function-name="to_char_parser" is-aggregate="f" language-name="plpgsql" context="to_char_parser" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying,character varying,character varying,character varying" comment="Parse to_char format parameter value to check it against Oracle rules" is-returning-set="t" ret-datatype="table" function-arguments="pstr character varying, ptype character varying, pfm character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_DATASET" count-arguments="3" function-id="22438" volatility="VOLATILE" is-window="f" function-identity-arguments="pstr character varying, ptype character varying, pfm character varying" overload-function-count="1" proc-language="plpgsql" function-signature="to_char_parser(pstr character varying, ptype character varying, pfm character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vRes VARCHAR;
    vStr VARCHAR;
    vPos INTEGER;
    vChunk VARCHAR;
    vGrp VARCHAR;
    vWrapTo VARCHAR;
    vYYYY VARCHAR;
    
    curDateFmtModels CURSOR (pGrp VARCHAR, pYYY VARCHAR) FOR
    SELECT fm.fmt,
        fm.wrapto
    FROM aws_oracle_ext.format_models fm
    WHERE tp = 'datetime'
    AND grp = pGrp
    AND (pYYY IS NULL OR (pYYY IS NOT NULL AND fm.fmt = pYYY))
    ORDER BY ord,
        fmt;

    eDateFormatNotRecognized CONSTANT VARCHAR := 'ORA-01821: date format not recognized';

    curNumberFmtModels CURSOR (pGrp VARCHAR) FOR
    SELECT fmt
    FROM aws_oracle_ext.format_models fm
    WHERE tp = 'number'
    AND grp = pGrp
    ORDER BY grp, ord;

    eInvalidNumberFormat CONSTANT VARCHAR := 'ORA-01481: invalid number format model';

    vModel VARCHAR;

    vFM VARCHAR;
BEGIN

    vStr := pStr;
    vPos := 1;

    vFm := COALESCE(pFm,'');

    CASE
        
        WHEN pType = 'number' THEN

            vGrp := UPPER(SUBSTR(vStr,1,1));
            
            OPEN curNumberFmtModels(vGrp);
            
            LOOP
                            
                FETCH curNumberFmtModels INTO vModel;
                
                EXIT WHEN NOT FOUND;

                vChunk := SUBSTR(vStr,1,  LENGTH(REPLACE(vModel, '\', '')));

                IF UPPER(vChunk) <> REPLACE(vModel, '\', '') THEN

                    vChunk := NULL;

                END IF;
                            
                IF vChunk IS NOT NULL THEN

                    vRes := CONCAT(vRes, SUBSTR(vStr, 1, LENGTH(vChunk)));
                    vPos := vPos + LENGTH(vChunk);
                    vStr := SUBSTR(vStr, vPos);

                    EXIT;

                END IF;

            END LOOP;

            CLOSE curNumberFmtModels;

            IF vChunk IS NULL THEN
                            
                RAISE USING MESSAGE := eInvalidNumberFormat;

            END IF;

        ELSE

            LOOP
            
                    -- special treat for FM/FX
                    IF UPPER(SUBSTR(vStr,1,2)) = 'FM' THEN

                        vFM := CASE WHEN vFM <> 'FM' THEN 'FM' ELSE '' END;
                        vStr := SUBSTR(vStr,3);
                    
                    END IF;

                    --If quotted - grab it
                    IF SUBSTR(vStr,1,1) = '"' THEN

                        vChunk := SUBSTRING(vStr FROM '"[^"]*"');

                        -- if unclosed quota - raise
                        IF vChunk IS NULL THEN

                            RAISE USING MESSAGE := eDateFormatNotRecognized;

                        END IF;

                        vRes := CONCAT(vFm, vRes, vChunk);
                        vPos := vPos + LENGTH(vChunk);
                        vStr := SUBSTR(vStr, vPos);

                        EXIT;

                    END IF;

                    -- spacers grab it
                    -- we will treat , and . specialy because of A.M. likes or Y,YYYY
                    IF SUBSTR(vStr,1,1) ~ '^[\.\,]' THEN

                        vChunk := SUBSTRING(vStr FROM '[\.\,]+');
                        vRes := CONCAT(vFM, vRes, vChunk);
                        vPos := vPos + LENGTH(vChunk);
                        vStr := SUBSTR(vStr, vPos);

                        EXIT;

                    END IF;

                    IF SUBSTR(vStr,1,1) ~ '[\s\!\\\/\#\$\%\&\''\(\)\*\+\\\-\:\;\<\=\>\?\@\[\]\^\_\`\{\|\}\~]' THEN
                        
                        vChunk := SUBSTRING(vStr FROM '[\s\!\\\/\#\$\%\&\''\(\)\*\+\\\-\:\;\<\=\>\?\@\[\]\^\_\`\{\|\}\~]+');
                        vRes := CONCAT(vFM, vRes, vChunk);
                        vPos := vPos + LENGTH(vChunk);
                        vStr := SUBSTR(vStr, vPos);

                        EXIT;

                    END IF;

                    vGrp := UPPER(SUBSTR(vStr,1,1));
                    
                    IF vGrp = 'Y' THEN
			
                        CASE
                            WHEN UPPER(SUBSTR(vStr,1,9)) IN ('Y,YYYTHSP', 'Y,YYYSPTH') THEN
                                vYYYY := REPLACE(UPPER(SUBSTR(vStr,1,9)),',','\,');
                            WHEN UPPER(SUBSTR(vStr,1,7)) IN ('Y,YYYTH', 'Y,YYYSP') THEN
                                vYYYY := REPLACE(UPPER(SUBSTR(vStr,1,7)),',','\,');
                            WHEN UPPER(SUBSTR(vStr,1,5)) = 'Y,YYY' THEN
                                vYYYY := REPLACE(UPPER(SUBSTR(vStr,1,5)),',','\,');
                            ELSE
                                vYYYY := NULL;
                        END CASE;

                    END IF;

                    OPEN curDateFmtModels(CASE WHEN vGrp = 'E' THEN 'Y' ELSE vGrp END, vYYYY);

                    LOOP
                        
                        FETCH curDateFmtModels INTO vModel, vWrapTo;
                        
                        EXIT WHEN NOT FOUND;
        
                        vChunk := SUBSTR(vStr,1,  LENGTH(REPLACE(vModel, '\', '')));

                        IF UPPER(vChunk) <> REPLACE(vModel, '\', '') THEN

                            vChunk := NULL;

                        END IF;
                        
                        IF vChunk IS NOT NULL THEN

                            vRes := CONCAT
                            (
                                vFM,
                                vRes,
                                CASE 
                                    WHEN vWrapTo IS NOT NULL THEN
                                        CASE 
                                            WHEN  vWrapTo = 'R->Y' THEN
                                                REPLACE(REPLACE(vChunk, 'R', 'Y'), 'r', 'y')
                                            ELSE
                                                REGEXP_REPLACE(SUBSTR(vStr, 1, LENGTH(vChunk)), CONCAT('(',SUBSTR(vStr, 1, LENGTH(vChunk)),')'), vWrapTo)
                                        END
                                    ELSE 
                                        SUBSTR(vStr, 1, LENGTH(vChunk)) 
                                END
                            );
                            vPos := vPos + LENGTH(vChunk);
                            vStr := SUBSTR(vStr, vPos);

                            EXIT;

                        END IF;

                    END LOOP;

                    CLOSE curDateFmtModels;

                    IF vChunk IS NULL THEN
                        
                        RAISE USING MESSAGE := eDateFormatNotRecognized;

                    END IF;

                    EXIT;

                END LOOP;

        END CASE;

    RETURN QUERY VALUES (vRes, CASE WHEN LENGTH(vStr) = 0 THEN NULL::VARCHAR ELSE vStr END, vFM);
        
END;
]]></complex-attribute>
                        <category _I_D="ba0f8fef-9070-4300-8dde-31c96170c1b0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="675d7584-a06a-4c79-a3d9-3192cbdf3333" name="to_date" is-trigger-function="0" unique-function-name="to_date(pval character varying)" is-aggregate="f" language-name="plpgsql" context="to_date(pval character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" comment="Converts VARCHAR2 to DATE as Oracle does" unique-suffix="(pval character varying)" routine-number="22452" is-returning-set="f" ret-datatype="timestamp" function-arguments="pval character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22452" volatility="VOLATILE" is-window="f" function-identity-arguments="pval character varying" overload-function-count="2" proc-language="plpgsql" function-signature="to_date(pval character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vResult TIMESTAMP DEFAULT NULL;
    vFmt VARCHAR;
BEGIN
    
    SELECT value
    INTO vFmt
    FROM aws_oracle_ext.v$nls_parameters
    WHERE parameter = 'NLS_DATE_FORMAT';

    vResult := aws_oracle_ext.to_date
    (
        pVal => pVal,
        pFmt => vFmt
    );

    RETURN vResult::TIMESTAMP(0);

END;
]]></complex-attribute>
                        <category _I_D="913aea89-f68e-4794-a7f1-9552fd2532c9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2e32b1a9-5981-47d8-a4be-d4e949c808a0" name="to_date" is-trigger-function="0" unique-function-name="to_date(pval character varying, pfmt character varying, pnlsparam character varying)" is-aggregate="f" language-name="plpgsql" context="to_date(pval character varying, pfmt character varying, pnlsparam character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying" comment="Converts VARCHAR2 to DATE as Oracle does. Some Format models could return incorrect results. Only NLS_DATE_LANGUAGE is allowed for NLS param. Value must be correct as lc_time value" unique-suffix="(pval character varying, pfmt character varying, pnlsparam character varying)" routine-number="22453" is-returning-set="f" ret-datatype="timestamp" function-arguments="pval character varying, pfmt character varying, pnlsparam character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22453" volatility="VOLATILE" is-window="f" function-identity-arguments="pval character varying, pfmt character varying, pnlsparam character varying" overload-function-count="2" proc-language="plpgsql" function-signature="to_date(pval character varying, pfmt character varying, pnlsparam character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE

    vResult TIMESTAMP DEFAULT NULL;
    vFmt VARCHAR;
    vValFormatted VARCHAR;

BEGIN

    IF pVal IS NOT NULL AND pVal <> '' THEN
        
        IF pNlsParam IS NULL THEN

            vFmt := aws_oracle_ext.get_cache_value
            (
                typeofcache => 'todate',
                sourecmodel => pFmt
            );

            IF vFmt IS NOT NULL THEN

                RETURN TO_TIMESTAMP(pVal, vFmt)::TIMESTAMP(0);

            END IF;

        END IF;
        
        SELECT vval,
            format
        INTO vValFormatted,
            vFmt
        FROM aws_oracle_ext.to_date_formatter
        (
            pVal      => pVal,
            pFormat   => pFmt,
            pNlsParam => pNlsParam
        );

        vResult := TO_TIMESTAMP(vValFormatted, vFmt);

    END IF;

    RETURN vResult::TIMESTAMP(0);

END;
]]></complex-attribute>
                        <category _I_D="820d16d6-cc24-4c8e-90b5-62894934d15f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d5391025-7328-4100-9ef7-d3693ac8da15" name="to_date_formatter" is-trigger-function="0" unique-function-name="to_date_formatter" is-aggregate="f" language-name="plpgsql" context="to_date_formatter" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying,character varying,character varying" comment="Utility function making to_char results similar to expected on Oracle side" is-returning-set="t" ret-datatype="table" function-arguments="pval character varying, pformat character varying DEFAULT NULL::character varying, pnlsparam character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_DATASET" count-arguments="3" function-id="22450" volatility="VOLATILE" is-window="f" function-identity-arguments="pval character varying, pformat character varying, pnlsparam character varying" overload-function-count="1" proc-language="plpgsql" function-signature="to_date_formatter(pval character varying, pformat character varying, pnlsparam character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE

    v_lctime VARCHAR;
    vNlsParam VARCHAR;

    vFmt VARCHAR;
    rec RECORD;
    vVal VARCHAR;
    vResult VARCHAR;

    vtail VARCHAR;
    vfm VARCHAR;

    verrorMessages CONSTANT VARCHAR[] := ARRAY
    [
        'ORA-01821: date format not recognized', --1
        'not implemented', --2
        'ORA-12702: invalid NLS parameter string used in SQL function', --3
        'ORA-01843: not a valid month', --4
        'ORA-01846: not a valid day of the week' --5
    ];
    --used to calculate localized day/month names
    cDayMonthNumbers CONSTANT INTEGER[] := ARRAY[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    vMonthNumber INTEGER DEFAULT NULL;
    vLocalName VARCHAR;
    vGlobalName VARCHAR;
    vDayNumber INTEGER DEFAULT NULL;
    vIncompleteYear INTEGER;
    bd BOOLEAN DEFAULT FALSE;
BEGIN

    vVal := pVal;

    IF pFormat = '' THEN

        vResult := NULL;

    ELSE
    
        vtail:= pFormat;

        LOOP

            SELECT ok, tail, fm
            INTO vFmt, vtail, vfm
            FROM aws_oracle_ext.to_char_parser
            (
                pStr  => vtail,
                pType => 'datetime',
                pFm   => vfm
            );

            vResult := CONCAT(vResult, vFmt);

            EXIT WHEN vtail IS NULL;

        END LOOP;

    END IF;
    
    -- store original language
    v_lctime := CURRENT_SETTING('lc_time');

    IF pNlsParam IS NOT NULL THEN

        vNlsParam := REPLACE(pNlsParam,' ', '');

        SELECT STRING_AGG(TRIM(nls),'')
        INTO vNlsParam
        FROM  REGEXP_SPLIT_TO_TABLE
        ( 
            vNlsParam,
            'NLS_',
            'i'
        ) nls
        WHERE TRIM(nls) <> '' AND TRIM(nls) !~* 'CALENDAR';

        IF vNlsParam IS NOT NULL THEN

            IF vNlsParam  !~* 'DATE_LANGUAGE=' THEN

                RAISE USING MESSAGE := verrorMessages[3];

            END IF;

            vNlsParam := REGEXP_REPLACE(vNlsParam, 'DATE_LANGUAGE=', '', 'i');

            -- try to set NLS
            BEGIN

                PERFORM SET_CONFIG('lc_time', vNlsParam, TRUE);

            EXCEPTION 
                WHEN OTHERS THEN

                    RAISE USING MESSAGE := verrorMessages[3]; 
            END;
            
        END IF;

    END IF;

    --PG13+ does not need this
    IF NOT (current_setting('server_version_num')::int) >= 130000 THEN

        -- month literal
        IF vResult ~* 'TMMONTH' THEN

            FOR rec IN
            (
                WITH mnames AS
                (
                    SELECT val,
                        TO_CHAR(TO_DATE(CONCAT(LPAD(val::TEXT, 2, '0'), '2017'), 'mmyyyy'), 'TMMONTH') AS localMonthName,
                        TO_CHAR(TO_DATE(CONCAT(LPAD(val::TEXT, 2, '0'), '2017'), 'mmyyyy'), 'MONTH') AS monthName
                    FROM UNNEST(cDayMonthNumbers) AS val
                )
                SELECT m.val,
                    m.localMonthName,
                    m.monthName
                FROM mnames m
                WHERE pVal ~* m.localMonthName
            )
            LOOP

                vMonthNumber := rec.val;
                vLocalName := rec.localMonthName;
                vGlobalName := rec.monthName;

            END LOOP;

            IF vMonthNumber IS NULL THEN

                RAISE USING MESSAGE := verrorMessages[4];

            END IF;

            vResult := REGEXP_REPLACE(vResult, 'TMMONTH', 'MONTH', 'i');
            vVal := REGEXP_REPLACE(vVal, vLocalName, vGlobalName, 'i');
            bd := TRUE;

        END IF;

        IF vResult ~* 'TMMON' THEN

            FOR rec IN
            (
                WITH mnames AS
                (
                    SELECT val,
                        TO_CHAR(TO_DATE(CONCAT(LPAD(val::TEXT, 2, '0'), '2017'), 'mmyyyy'), 'TMMON') AS localMonthName,
                        TO_CHAR(TO_DATE(CONCAT(LPAD(val::TEXT, 2, '0'), '2017'), 'mmyyyy'), 'MON') AS monthName
                    FROM UNNEST(cDayMonthNumbers) AS val
                )
                SELECT m.val,
                    m.localMonthName,
                    m.monthName
                FROM mnames m
                WHERE pVal ~* m.localMonthName
            )
            LOOP

                vMonthNumber := rec.val;
                vLocalName := rec.localMonthName;
                vGlobalName := rec.monthName;

            END LOOP;

            IF vMonthNumber IS NULL THEN

                RAISE USING MESSAGE := verrorMessages[4];

            END IF;

                vResult := REGEXP_REPLACE(vResult, 'TMMON', 'MON', 'i');
                vVal := REGEXP_REPLACE(vVal, vLocalName, vGlobalName, 'i');
                bd := TRUE;

        END IF;
        -- day literal
        IF vResult ~* 'TMDAY' THEN

            FOR rec IN
            (
                WITH mnames AS
                (
                    SELECT val,
                        TO_CHAR(TO_DATE(CONCAT(LPAD(val::TEXT, 2, '0'), '102017'), 'ddmmyyyy'), 'TMDAY') AS localDayName,
                        TO_CHAR(TO_DATE(CONCAT(LPAD(val::TEXT, 2, '0'), '102017'), 'ddmmyyyy'), 'DAY') AS dayName
                    FROM UNNEST(cDayMonthNumbers) AS val
                    WHERE val BETWEEN 2 AND 8
                )
                SELECT m.val,
                    m.localDayName,
                    m.dayName
                FROM mnames m
                WHERE pVal ~* m.localDayName
            )
            LOOP

                vDayNumber := rec.val;
                vLocalName := rec.localDayName;
                vGlobalName := rec.dayName;

            END LOOP;

            IF vDayNumber IS NULL THEN

                RAISE USING MESSAGE := verrorMessages[5];

            END IF;

                vResult := REGEXP_REPLACE(vResult, 'TMDAY', 'DAY', 'i');
                vVal := REGEXP_REPLACE(vVal, vLocalName, vGlobalName, 'i');
                bd := TRUE;

        END IF;

        IF vResult ~* 'TMDY' THEN

            FOR rec IN
            (
                WITH mnames AS
                (
                    SELECT val,
                        TO_CHAR(TO_DATE(CONCAT(LPAD(val::TEXT, 2, '0'), '102017'), 'ddmmyyyy'), 'TMDY') AS localDayName,
                        TO_CHAR(TO_DATE(CONCAT(LPAD(val::TEXT, 2, '0'), '102017'), 'ddmmyyyy'), 'DY') AS dayName
                    FROM UNNEST(cDayMonthNumbers) AS val
                    WHERE val BETWEEN 2 AND 8
                )
                SELECT m.val,
                    m.localDayName,
                    m.dayName
                FROM mnames m
                WHERE pVal ~* m.localDayName
            )
            LOOP

                vDayNumber := rec.val;
                vLocalName := rec.localDayName;
                vGlobalName := rec.dayName;

            END LOOP;

            IF vDayNumber IS NULL THEN

                RAISE USING MESSAGE := verrorMessages[5];

            END IF;

                vResult := REGEXP_REPLACE(vResult, 'TMDY', 'DY', 'i');
                vVal := REGEXP_REPLACE(vVal, vLocalName, vGlobalName, 'i');
                bd := TRUE;

        END IF;

    END IF;

    IF vResult ~* 'MI' THEN
        
        vResult := REGEXP_REPLACE(vResult, 'MI', 'mi', 'i');

    END IF;

    IF vResult ~ 'Dd' THEN

        vResult := REPLACE(vResult, 'Dd', 'dd');

    END IF;

    IF vResult ~ 'dD' THEN

        vResult := REPLACE(vResult, 'dD', 'dd');

    END IF;

    -- try to calculate incomplete dates
    BEGIN

        vIncompleteYear := EXTRACT(YEAR FROM TO_TIMESTAMP(vVal, vResult));

    EXCEPTION
        WHEN OTHERS THEN

            vIncompleteYear := -1;
    END;

    IF vIncompleteYear = -1 THEN

        vVal := CONCAT
        (
            LPAD(EXTRACT(YEAR FROM CLOCK_TIMESTAMP()::TIMESTAMP(0))::TEXT, 4, '0'),
            CASE 
                WHEN vResult !~* 'MM|MON|MONTH' THEN LPAD(EXTRACT(MONTH FROM CLOCK_TIMESTAMP()::TIMESTAMP(0))::TEXT, 2, '0') ELSE '' END,
            vVal
        );
        bd := TRUE;

        vResult := CONCAT
        (
            'YYYY',
            CASE WHEN vResult !~* 'MM|MON|MONTH' THEN 'MM' ELSE '' END,
            vResult
        );

    END IF;

    -- restore language setting if they were changed
    IF CURRENT_SETTING('lc_time') <> v_lctime THEN

        v_lctime := SET_CONFIG('lc_time', v_lctime, TRUE);

    END IF;

    IF NOT bd THEN

        PERFORM aws_oracle_ext.set_cache_value
        (
            typeofcache => 'todate',
            sourecmodel => pFormat,
            targetmodel => vResult
        );

    END IF;

    RETURN QUERY VALUES(vVal, vResult);

END;

]]></complex-attribute>
                        <category _I_D="992d260e-22d0-46ea-88db-7608446cc2d0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0b0fcef5-8f1d-44aa-a8d6-a14f5249d6ba" name="to_hex" is-trigger-function="0" unique-function-name="to_hex" is-aggregate="f" language-name="sql" context="to_hex" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" comment="Convert decimal to hexadecimal" is-returning-set="f" ret-datatype="text" function-arguments="p_dec numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22518" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_dec numeric" overload-function-count="1" proc-language="sql" function-signature="to_hex(p_dec numeric)">
                        <complex-attribute name="sql"><![CDATA[
  SELECT aws_oracle_ext.to_base($1, 16); 
]]></complex-attribute>
                        <category _I_D="d3602dd6-6119-47cb-8894-8f944bf7710f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2c4852fc-544a-486e-93a3-d53eccaf4218" name="to_multi_byte" is-trigger-function="0" unique-function-name="to_multi_byte" is-aggregate="f" language-name="plpgsql" context="to_multi_byte" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="Returns char with all of its single-byte characters converted to their corresponding multibyte characters." is-returning-set="f" ret-datatype="text" function-arguments="p_str text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22512" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_str text" overload-function-count="1" proc-language="plpgsql" function-signature="to_multi_byte(p_str text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  db_encoding TEXT;

  TO_MULTI_BYTE_UTF8 CONSTANT TEXT[95] :=
  ARRAY
  [
	'\343\200\200',
	'\357\274\201',
	'\342\200\235',
	'\357\274\203',
	'\357\274\204',
	'\357\274\205',
	'\357\274\206',
	'\342\200\231',
	'\357\274\210',
	'\357\274\211',
	'\357\274\212',
	'\357\274\213',
	'\357\274\214',
	'\357\274\215',
	'\357\274\216',
	'\357\274\217',
	'\357\274\220',
	'\357\274\221',
	'\357\274\222',
	'\357\274\223',
	'\357\274\224',
	'\357\274\225',
	'\357\274\226',
	'\357\274\227',
	'\357\274\230',
	'\357\274\231',
	'\357\274\232',
	'\357\274\233',
	'\357\274\234',
	'\357\274\235',
	'\357\274\236',
	'\357\274\237',
	'\357\274\240',
	'\357\274\241',
	'\357\274\242',
	'\357\274\243',
	'\357\274\244',
	'\357\274\245',
	'\357\274\246',
	'\357\274\247',
	'\357\274\250',
	'\357\274\251',
	'\357\274\252',
	'\357\274\253',
	'\357\274\254',
	'\357\274\255',
	'\357\274\256',
	'\357\274\257',
	'\357\274\260',
	'\357\274\261',
	'\357\274\262',
	'\357\274\263',
	'\357\274\264',
	'\357\274\265',
	'\357\274\266',
	'\357\274\267',
	'\357\274\270',
	'\357\274\271',
	'\357\274\272',
	'\357\274\273',
	'\357\277\245',
	'\357\274\275',
	'\357\274\276',
	'\357\274\277',
	'\342\200\230',
	'\357\275\201',
	'\357\275\202',
	'\357\275\203',
	'\357\275\204',
	'\357\275\205',
	'\357\275\206',
	'\357\275\207',
	'\357\275\210',
	'\357\275\211',
	'\357\275\212',
	'\357\275\213',
	'\357\275\214',
	'\357\275\215',
	'\357\275\216',
	'\357\275\217',
	'\357\275\220',
	'\357\275\221',
	'\357\275\222',
	'\357\275\223',
	'\357\275\224',
	'\357\275\225',
	'\357\275\226',
	'\357\275\227',
	'\357\275\230',
	'\357\275\231',
	'\357\275\232',
	'\357\275\233',
	'\357\275\234',
	'\357\275\235',
	'\357\275\236',
	'\357\277\243'
  ];

  TO_MULTI_BYTE_EUCJP CONSTANT TEXT[95] :=
  ARRAY
  [
	'\241\241',
	'\241\252',
	'\241\311',
	'\241\364',
	'\241\360',
	'\241\363',
	'\241\365',
	'\241\307',
	'\241\312',
	'\241\313',
	'\241\366',
	'\241\334',
	'\241\244',
	'\241\335',
	'\241\245',
	'\241\277',
	'\243\260',
	'\243\261',
	'\243\262',
	'\243\263',
	'\243\264',
	'\243\265',
	'\243\266',
	'\243\267',
	'\243\270',
	'\243\271',
	'\241\247',
	'\241\250',
	'\241\343',
	'\241\341',
	'\241\344',
	'\241\251',
	'\241\367',
	'\243\301',
	'\243\302',
	'\243\303',
	'\243\304',
	'\243\305',
	'\243\306',
	'\243\307',
	'\243\310',
	'\243\311',
	'\243\312',
	'\243\313',
	'\243\314',
	'\243\315',
	'\243\316',
	'\243\317',
	'\243\320',
	'\243\321',
	'\243\322',
	'\243\323',
	'\243\324',
	'\243\325',
	'\243\326',
	'\243\327',
	'\243\330',
	'\243\331',
	'\243\332',
	'\241\316',
	'\241\357',
	'\241\317',
	'\241\260',
	'\241\262',
	'\241\306',
	'\243\341',
	'\243\342',
	'\243\343',
	'\243\344',
	'\243\345',
	'\243\346',
	'\243\347',
	'\243\350',
	'\243\351',
	'\243\352',
	'\243\353',
	'\243\354',
	'\243\355',
	'\243\356',
	'\243\357',
	'\243\360',
	'\243\361',
	'\243\362',
	'\243\363',
	'\243\364',
	'\243\365',
	'\243\366',
	'\243\367',
	'\243\370',
	'\243\371',
	'\243\372',
	'\241\320',
	'\241\303',
	'\241\321',
	'\241\301',
	'\241\261'
  ];

  map TEXT[];
  result TEXT;
BEGIN
  IF p_str ='' THEN RETURN NULL::TEXT; END IF;

  SELECT character_set_name FROM information_schema.character_sets INTO db_encoding;

  CASE db_encoding
    WHEN 'UTF8' THEN map := TO_MULTI_BYTE_UTF8;
    WHEN 'EUC_JP' THEN map := TO_MULTI_BYTE_EUCJP;
    WHEN 'PG_EUC_JIS_2004' THEN map := TO_MULTI_BYTE_EUCJP;
    ELSE RETURN p_str; --no need to convert
  END CASE;

  SELECT ARRAY_TO_STRING(ARRAY_AGG(CONCAT(CASE
                                            WHEN i BETWEEN 32 AND 126
                                            THEN CONVERT_FROM(DECODE(map[i - 32 + 1],'escape'),db_encoding)
                                            ELSE v
                                          END
                                         ,'')
                                  )
                        ,'')
    FROM (SELECT v, aws_oracle_ext.hex_to_int(LTRIM(v::BYTEA::text,'\x')) AS i
            FROM REGEXP_SPLIT_TO_TABLE(p_str,'') AS v) t
    INTO result;

  RETURN result;
END;
]]></complex-attribute>
                        <category _I_D="4299b023-2650-40a0-bf37-e1cf0d0c180b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2bd102c2-82e9-4eba-8823-088cd2440b20" name="to_number" is-trigger-function="0" unique-function-name="to_number(pval character varying)" is-aggregate="f" language-name="plpgsql" context="to_number(pval character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" comment="Converts VARCHAR to NUMBER when no additional params set" unique-suffix="(pval character varying)" routine-number="22460" is-returning-set="f" ret-datatype="numeric" function-arguments="pval character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22460" volatility="VOLATILE" is-window="f" function-identity-arguments="pval character varying" overload-function-count="6" proc-language="plpgsql" function-signature="to_number(pval character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vResult NUMERIC DEFAULT NULL;
BEGIN

    IF pVal IS NOT NULL AND pVal <> '' THEN

        vResult := aws_oracle_ext.to_number_formatter
        (
            pVal => pVal,
            pNoNumberFormat => 'Y'
        );

    END IF;

    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="b4027a54-7bd2-46e9-9d1d-7a0c9b92a458" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="69af90c7-870e-4775-8de1-9145ab6539ad" name="to_number" is-trigger-function="0" unique-function-name="to_number(pval character varying, pformat character varying, pnlsparam character varying)" is-aggregate="f" language-name="plpgsql" context="to_number(pval character varying, pformat character varying, pnlsparam character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,character varying" comment="Converts VARCHAR to NUMBER. Some format models could return incorrect result. NLS params must be valid." unique-suffix="(pval character varying, pformat character varying, pnlsparam character varying)" routine-number="22461" is-returning-set="f" ret-datatype="numeric" function-arguments="pval character varying, pformat character varying, pnlsparam character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22461" volatility="VOLATILE" is-window="f" function-identity-arguments="pval character varying, pformat character varying, pnlsparam character varying" overload-function-count="6" proc-language="plpgsql" function-signature="to_number(pval character varying, pformat character varying, pnlsparam character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vResult NUMERIC DEFAULT NULL;
    vFormat VARCHAR;
BEGIN

    IF pVal IS NOT NULL AND pVal <> '' THEN

        vResult := aws_oracle_ext.to_number_formatter
        (
            pVal      => pVal,
            pFormat   => pFormat,
            pNlsParam => pNlsParam
        );

    END IF;
    
    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="2fc79bc4-1041-4db3-b640-83f43dbd777f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3f3fe3c3-3f9f-4f90-86c6-591910dd55e1" name="to_number" is-trigger-function="0" unique-function-name="to_number(pval double precision)" is-aggregate="f" language-name="plpgsql" context="to_number(pval double precision)" subcategories-loading="none" object-loading="extended" arguments-datatypes="double precision" comment="Converts BINARY_DOUBLE to NUMBER, no additional params allowed" unique-suffix="(pval double precision)" routine-number="22454" is-returning-set="f" ret-datatype="numeric" function-arguments="pval double precision" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22454" volatility="VOLATILE" is-window="f" function-identity-arguments="pval double precision" overload-function-count="6" proc-language="plpgsql" function-signature="to_number(pval double precision)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    RETURN aws_oracle_ext.number_limit_correct(pVal::NUMERIC);

END;
]]></complex-attribute>
                        <category _I_D="4cd2b158-6ecf-431c-9bf9-0afd6f1c489e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="36d358ef-db68-41c9-814e-62e26098c19c" name="to_number" is-trigger-function="0" unique-function-name="to_number(pval numeric)" is-aggregate="f" language-name="plpgsql" context="to_number(pval numeric)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" comment="Converts NUMBER to NUMBER when no additional params set" unique-suffix="(pval numeric)" routine-number="22457" is-returning-set="f" ret-datatype="numeric" function-arguments="pval numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22457" volatility="VOLATILE" is-window="f" function-identity-arguments="pval numeric" overload-function-count="6" proc-language="plpgsql" function-signature="to_number(pval numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    RETURN aws_oracle_ext.number_limit_correct(pVal);

END;
]]></complex-attribute>
                        <category _I_D="fd1faf73-59eb-4fb9-8ba0-6dedd8014613" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="cd2380a0-4192-4af8-9204-8a4f13b024b5" name="to_number" is-trigger-function="0" unique-function-name="to_number(pval numeric, pformat character varying, pnlsparam character varying)" is-aggregate="f" language-name="plpgsql" context="to_number(pval numeric, pformat character varying, pnlsparam character varying)" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric,character varying,character varying" comment="Converts NUMBER to NUMBER when additional params are set. Some format models could return incorrect result. NLS params must be valid." unique-suffix="(pval numeric, pformat character varying, pnlsparam character varying)" routine-number="22458" is-returning-set="f" ret-datatype="numeric" function-arguments="pval numeric, pformat character varying, pnlsparam character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22458" volatility="VOLATILE" is-window="f" function-identity-arguments="pval numeric, pformat character varying, pnlsparam character varying" overload-function-count="6" proc-language="plpgsql" function-signature="to_number(pval numeric, pformat character varying, pnlsparam character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vResult NUMERIC DEFAULT NULL;
    vFormat VARCHAR;
BEGIN

    IF pVal IS NOT NULL THEN

        vResult := aws_oracle_ext.to_number_formatter
        (
            pVal      => pVal,
            pFormat   => pFormat,
            pNlsParam => pNlsParam
        );

    END IF;
    
    RETURN vResult;

END;
]]></complex-attribute>
                        <category _I_D="edfedb86-9174-4943-8d21-4f35f1430a6e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a1574fc3-c8ca-4669-bc59-b1deec1eb091" name="to_number" is-trigger-function="0" unique-function-name="to_number(pval real)" is-aggregate="f" language-name="plpgsql" context="to_number(pval real)" subcategories-loading="none" object-loading="extended" arguments-datatypes="real" comment="Converts BINARY_FLOAT to NUMBER, no additional params allowed" unique-suffix="(pval real)" routine-number="22459" is-returning-set="f" ret-datatype="numeric" function-arguments="pval real" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22459" volatility="VOLATILE" is-window="f" function-identity-arguments="pval real" overload-function-count="6" proc-language="plpgsql" function-signature="to_number(pval real)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    RETURN aws_oracle_ext.number_limit_correct(pVal::NUMERIC);

END;
]]></complex-attribute>
                        <category _I_D="a80e9d6f-b10d-4cf6-a253-5eb3ba29a858" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="55370192-6a65-4acf-8d13-16be862d5433" name="to_number_formatter" is-trigger-function="0" unique-function-name="to_number_formatter" is-aggregate="f" language-name="plpgsql" context="to_number_formatter" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyelement,character varying,character varying,character varying" comment="Utility function making to_number results similar to expected on Oracle side" is-returning-set="f" ret-datatype="numeric" function-arguments="pval anyelement, pformat character varying DEFAULT NULL::character varying, pnlsparam character varying DEFAULT NULL::character varying, pnonumberformat character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22455" volatility="VOLATILE" is-window="f" function-identity-arguments="pval anyelement, pformat character varying, pnlsparam character varying, pnonumberformat character varying" overload-function-count="1" proc-language="plpgsql" function-signature="to_number_formatter(pval anyelement, pformat character varying, pnlsparam character varying, pnonumberformat character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    rec RECORD;
    cAllowedDatatypes CONSTANT VARCHAR[] := ARRAY
    [
        'NUMERIC',
        'INTEGER',
        'CHARACTER',
        'CHARACTER VARYING',
        'TEXT'
    ];
    vResult NUMERIC DEFAULT NULL;
    vDataType VARCHAR;
    verrorMessages CONSTANT VARCHAR[] := ARRAY
    [
        'ORA-00902: invalid datatype', --1
        'ORA-22835: Buffer too small for CLOB to CHAR', --2
        'ORA-01481: invalid number format model', --3
        'ORA-12702: invalid NLS parameter string used in SQL function', --4
        'ORA-01722: invalid number', --5
        'ORA-01481: invalid number format model' --6
    ];
    vNlsParam VARCHAR;
    vNlsParamCopy VARCHAR;
    vGroupSeparator VARCHAR(2) DEFAULT NULL;
    vDecimalSeparator VARCHAR(2) DEFAULT NULL;
    vCurrencySymbol VARCHAR;
    vIsoCurrency VARCHAR;
    vDualCurrency VARCHAR;
    vVal VARCHAR;
    vFmt VARCHAR;
    vtail VARCHAR;
    vfm VARCHAR;
    vTextResult VARCHAR;
    bd BOOLEAN DEFAULT FALSE;
    vurrisset BOOLEAN DEFAULT FALSE;
BEGIN

    vDataType := UPPER(PG_TYPEOF(pVal)::VARCHAR);

    IF ARRAY_POSITION(cAllowedDatatypes,  vDataType) IS NULL THEN

        RAISE USING MESSAGE := verrorMessages[1];

    END IF;

    vVal := pVal::TEXT;

    IF LENGTH(vVal) > 4000 THEN

        RAISE USING MESSAGE := verrorMessages[2];

    END IF;

    IF pNoNumberFormat IS NOT NULL THEN
        
        vResult := pVal::NUMERIC;
        bd := TRUE;

    ELSE

        CASE
            WHEN pNlsParam = '' THEN

                vResult := NULL;

            WHEN pNlsParam IS NOT NULL THEN

                bd := TRUE;

                SELECT STRING_AGG(CASE WHEN nls ~* 'CALENDAR' THEN '' ELSE nls END, '')
                INTO vNlsParamCopy
                FROM REGEXP_SPLIT_TO_TABLE
                ( 
                    TRIM(E'\n\ ' FROM pNlsParam),
                    'NLS_',
                'i') nls;
                
                vNlsParam := REGEXP_REPLACE
                (
                    vNlsParamCopy,
                    $$NUMERIC_CHARACTERS\s*=\s*('?)(.+?)('?)$$,
                    '',
                    'i'
                );

                vNlsParam := REGEXP_REPLACE
                (
                    vNlsParam,
                    $$ISO_CURRENCY\s*=\s*('?)(.+?)('?)$$,
                    '',
                    'i'
                );

                vNlsParam := REGEXP_REPLACE
                (
                    vNlsParam,
                    $$CURRENCY\s*=\s*('?)(.+?)('?)$$,
                    '',
                    'i'
                );

                IF LENGTH(TRIM(E'\n\ ' FROM vNlsParam)) > 0 THEN

                    RAISE USING MESSAGE := verrorMessages[4];

                END IF;

                -- Try to get set NLS parts
                FOR rec IN 
                (
                    SELECT REGEXP_MATCHES
                    (
                        vNlsParamCopy,
                        $$NUMERIC_CHARACTERS\s*=\s*('?)(.+?)('?)$$,
                        'i'
                    ) m
                ) LOOP

                    vDecimalSeparator := SUBSTR((rec.m)[2], 1, 1);
                  
                    IF LENGTH(vDecimalSeparator) = 0 THEN

                        RAISE USING MESSAGE := verrorMessages[4];

                    END IF;

                    vGroupSeparator := SUBSTR((rec.m)[2], 2, 1);

                    IF LENGTH(vGroupSeparator) = 0 THEN

                        RAISE USING MESSAGE := verrorMessages[4];

                    END IF;

                END LOOP;

                FOR rec IN 
                (
                    SELECT REGEXP_MATCHES
                    (
                        vNlsParamCopy,
                        $$CURRENCY\s*=\s*('?)(.+?)('?)$$,
                        'i'
                    ) m
                ) LOOP

                    vCurrencySymbol := (rec.m)[2];

                    IF LENGTH(vCurrencySymbol) = 0 THEN

                        RAISE USING MESSAGE := verrorMessages[4];

                    END IF;

                END LOOP;

                FOR rec IN 
                (
                    SELECT REGEXP_MATCHES
                    (
                        vNlsParamCopy,
                        $$ISO_CURRENCY\s*=\s*('?)(.+?)('?)$$,
                        'i'
                    ) m
                ) LOOP

                    vIsoCurrency := (rec.m)[2];

                    IF LENGTH(vIsoCurrency) = 0 THEN

                        RAISE USING MESSAGE := verrorMessages[4];

                    END IF;

                    SELECT icl.code
                    INTO vIsoCurrency
                    FROM aws_oracle_ext.iso_currency_list icl
                    WHERE icl.nls_iso_currency = (rec.m)[2];

                END LOOP;

            ELSE

                NULL;       

        END CASE;

        IF NOT bd THEN

            vTextResult := aws_oracle_ext.get_cache_value
            (
                typeofcache => 'tonumber',
                sourecmodel => pFormat
            );

            IF vTextResult IS NOT NULL THEN

                RETURN aws_oracle_ext.number_limit_correct(TO_NUMBER(vVal, vTextResult));

            END IF;

        END IF;

        vtail:= pFormat;

        LOOP

            SELECT ok, tail, fm
            INTO vFmt, vtail, vfm
            FROM aws_oracle_ext.to_char_parser
            (
                pStr  => vtail,
                pType => 'number',
                pFm   => vfm
            );
            
        
            vTextResult := CONCAT(vTextResult, vFmt);

            EXIT WHEN vtail IS NULL;

        END LOOP;

        /* Restrictions */
            --A comma element cannot begin a number format model
        IF SUBSTR(vTextResult, 1, 1) = ',' THEN

            RAISE USING MESSAGE := verrorMessages[6];

        END IF;
        -- A comma cannot appear to the right of a decimal
        -- character or period in a number format model
        CASE 
            WHEN vTextResult ~* '[\.D].*\,' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            --only one period in a number format model
            WHEN vTextResult ~ '\..*\.' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- only one decimal character in a number format model
            WHEN vTextResult ~* 'd.*d' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- group separator cannot appear to the right of a decimal 
            -- character or period in a number format model
            -- V also
            WHEN vTextResult ~* '[\.DV].*g' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- Start with g is not allowed
            WHEN vTextResult ~* '^G' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- It's not allowed to mix different type group and
            -- decimal model symbols
            WHEN vTextResult ~ '\.|\,' AND vTextResult ~* 'D|G' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- The MI format element can appear only in the last position 
            -- of a number format model
            WHEN vTextResult ~* 'MI.+' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            --The PR format element can appear only in the last position
            -- of a number format model
            WHEN vTextResult ~* 'PR.+' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- The S format element can appear only in the first 
            -- or last position of a number format model
            WHEN vTextResult ~* '[^S]+S[^S]+' OR vTextResult ~* 'S[^S]*S' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- You cannot precede this element with any other element
            WHEN vTextResult ~* '.+TM' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- You can follow this element only with one 9 or 
            -- one E (or e), but not with any combination of these
            WHEN vTextResult ~* 'TM.{2,}' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            WHEN vTextResult ~* 'TM[^9e]' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- You can precede this element only with 0 (which returns leading zeroes)
            -- or FM. Any other elements return an error
            WHEN vTextResult ~* '.*X.?'
                AND vTextResult !~* '^0+X{1,}$'
                AND vTextResult !~* '^FMX{1,}$'
                AND vTextResult !~* '^FM0{1,}X{1,}$'
                AND vTextResult !~* '^X{1,}$' THEN

                    RAISE USING MESSAGE := verrorMessages[6];
            -- only one $ allowed
            WHEN vTextResult ~ '\$.*\$' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- only one C allowed
            WHEN vTextResult ~* 'C.*C' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- only one L allowed
            WHEN vTextResult ~* 'L.*L' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- only one U allowed
            WHEN vTextResult ~* 'U.*U' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- C, L, $, U together is not allowed
            WHEN vTextResult ~* 'C.*[\$LU]' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            WHEN vTextResult ~* '[UL\$].*C' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- only one V allowed
            WHEN vTextResult ~* 'V.*V' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- V and period or decimal is not allowed
            WHEN vTextResult ~* 'V.*[\.D]' OR vTextResult ~* '[\.D].*V' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- If RN - no other models allowed
            WHEN vTextResult ~* '.+RN' OR vTextResult ~* 'RN.+' THEN

                RAISE USING MESSAGE := verrorMessages[6];
            -- Only EEEE is not allowed. No chars after EEEE. No comma before EEEE
            WHEN vTextResult ~* '^EEEE$' 
                OR vTextResult ~* 'EEEE[^S]+' 
                OR vTextResult ~* '\,.*EEEE'
                OR vTextResult ~* 'EEEE.{2,}' THEN

                    RAISE USING MESSAGE := verrorMessages[6];
            ELSE

                NULL;
        END CASE;
        
        -- converting
        IF vTextResult ~* 'U|C|L' THEN

            bd := TRUE;

                IF vTextResult ~* 'U' THEN

                    IF vDualCurrency IS NULL THEN

                        SELECT value
                        INTO vDualCurrency
                        FROM aws_oracle_ext.v$nls_parameters
                        WHERE parameter = 'NLS_DUAL_CURRENCY';

                    END IF;

                    vVal := REGEXP_REPLACE(vVal, vDualCurrency, '$', 'i');
                    vTextResult := REGEXP_REPLACE(vTextResult, 'U', '$', 'i');
                    vurrisset := TRUE;

                END IF;

                IF vTextResult ~* 'C' AND NOT vurrisset THEN

                    IF vIsoCurrency IS NULL THEN

                        SELECT icl.code
                        INTO vIsoCurrency
                        FROM aws_oracle_ext.iso_currency_list icl
                        WHERE icl.nls_iso_currency = (SELECT value
                        FROM aws_oracle_ext.v$nls_parameters WHERE parameter = 'NLS_ISO_CURRENCY');

                    END IF;

                    vVal := REGEXP_REPLACE(vVal, vIsoCurrency, '$' , 'i');
                    vTextResult := REGEXP_REPLACE(vTextResult, 'C', '$', 'i');
                    vurrisset := TRUE;

                END IF;

                IF vTextResult ~* 'L'  AND NOT vurrisset THEN

                    IF vCurrencySymbol IS NULL THEN

                        SELECT value
                        INTO vCurrencySymbol
                        FROM aws_oracle_ext.v$nls_parameters
                        WHERE parameter = 'NLS_CURRENCY';

                    END IF;

                    vVal := REGEXP_REPLACE(vVal, vCurrencySymbol, '$' , 'i');
                    vTextResult := REGEXP_REPLACE(vTextResult, 'L', '$', 'i');

                    vurrisset := TRUE;

                END IF;

        END IF;

        IF vTextResult ~* 'G|D' AND vDecimalSeparator IS NOT NULL AND vGroupSeparator IS NOT NULL THEN

            bd := TRUE;

            vVal := REPLACE(vVal, vGroupSeparator, '#,');

            IF vDecimalSeparator = ',' THEN

                vVal := REGEXP_REPLACE(vVal, '([^#]),', '\1#.');

            ELSE

                vVal := REPLACE(vVal, vDecimalSeparator, '#.');

            END IF;

            vVal := REPLACE(vVal, '#.', '.');
            vVal := REPLACE(vVal, '#,', ',');

            vTextResult := REGEXP_REPLACE(vTextResult, 'D', '.', 'i');
            vTextResult := REGEXP_REPLACE(vTextResult, 'G', ',', 'ig');

        END IF;
        
        CASE
            WHEN vTextResult ~* 'X' THEN

                bd := TRUE;

                EXECUTE 'SELECT x''' || vVal || '''::BIGINT::NUMERIC' INTO vResult;

            WHEN vTextResult ~* 'EEEE' THEN

                bd := TRUE;

                vResult := vVal::NUMERIC;

            ELSE

                IF NOT bd THEN

                    PERFORM aws_oracle_ext.set_cache_value
                    (
                        typeofcache => 'tonumber',
                        sourecmodel => pFormat,
                        targetmodel => vTextResult
                    );

                END IF;

                vResult := TO_NUMBER(vVal, vTextResult);

        END CASE;

    END IF;
    
    RETURN aws_oracle_ext.number_limit_correct(vResult);

END;
]]></complex-attribute>
                        <category _I_D="21e3f7b4-e9c3-47fa-ae8e-144cc137c5d1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6e5a040d-5485-4ab1-a248-17302925ca91" name="to_oct" is-trigger-function="0" unique-function-name="to_oct" is-aggregate="f" language-name="sql" context="to_oct" subcategories-loading="none" object-loading="extended" arguments-datatypes="numeric" comment="Convert decimal to octal" is-returning-set="f" ret-datatype="text" function-arguments="p_dec numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22519" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_dec numeric" overload-function-count="1" proc-language="sql" function-signature="to_oct(p_dec numeric)">
                        <complex-attribute name="sql"><![CDATA[
  SELECT aws_oracle_ext.to_base($1, 8); 
]]></complex-attribute>
                        <category _I_D="da1fc07d-4280-428c-850c-21124427bae8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="99d74826-a302-47f2-9387-f955f186e1e9" name="to_single_byte" is-trigger-function="0" unique-function-name="to_single_byte" is-aggregate="f" language-name="plpgsql" context="to_single_byte" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" comment="Returns char with all of its multibyte characters converted to their corresponding single-byte characters." is-returning-set="f" ret-datatype="text" function-arguments="p_str text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22513" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p_str text" overload-function-count="1" proc-language="plpgsql" function-signature="to_single_byte(p_str text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  db_encoding TEXT;

  TO_MULTI_BYTE_UTF8 CONSTANT TEXT[95] :=
  ARRAY
  [
	'\343\200\200',
	'\357\274\201',
	'\342\200\235',
	'\357\274\203',
	'\357\274\204',
	'\357\274\205',
	'\357\274\206',
	'\342\200\231',
	'\357\274\210',
	'\357\274\211',
	'\357\274\212',
	'\357\274\213',
	'\357\274\214',
	'\357\274\215',
	'\357\274\216',
	'\357\274\217',
	'\357\274\220',
	'\357\274\221',
	'\357\274\222',
	'\357\274\223',
	'\357\274\224',
	'\357\274\225',
	'\357\274\226',
	'\357\274\227',
	'\357\274\230',
	'\357\274\231',
	'\357\274\232',
	'\357\274\233',
	'\357\274\234',
	'\357\274\235',
	'\357\274\236',
	'\357\274\237',
	'\357\274\240',
	'\357\274\241',
	'\357\274\242',
	'\357\274\243',
	'\357\274\244',
	'\357\274\245',
	'\357\274\246',
	'\357\274\247',
	'\357\274\250',
	'\357\274\251',
	'\357\274\252',
	'\357\274\253',
	'\357\274\254',
	'\357\274\255',
	'\357\274\256',
	'\357\274\257',
	'\357\274\260',
	'\357\274\261',
	'\357\274\262',
	'\357\274\263',
	'\357\274\264',
	'\357\274\265',
	'\357\274\266',
	'\357\274\267',
	'\357\274\270',
	'\357\274\271',
	'\357\274\272',
	'\357\274\273',
	'\357\277\245',
	'\357\274\275',
	'\357\274\276',
	'\357\274\277',
	'\342\200\230',
	'\357\275\201',
	'\357\275\202',
	'\357\275\203',
	'\357\275\204',
	'\357\275\205',
	'\357\275\206',
	'\357\275\207',
	'\357\275\210',
	'\357\275\211',
	'\357\275\212',
	'\357\275\213',
	'\357\275\214',
	'\357\275\215',
	'\357\275\216',
	'\357\275\217',
	'\357\275\220',
	'\357\275\221',
	'\357\275\222',
	'\357\275\223',
	'\357\275\224',
	'\357\275\225',
	'\357\275\226',
	'\357\275\227',
	'\357\275\230',
	'\357\275\231',
	'\357\275\232',
	'\357\275\233',
	'\357\275\234',
	'\357\275\235',
	'\357\275\236',
	'\357\277\243'
  ];

  TO_MULTI_BYTE_EUCJP CONSTANT TEXT[95] :=
  ARRAY
  [
	'\241\241',
	'\241\252',
	'\241\311',
	'\241\364',
	'\241\360',
	'\241\363',
	'\241\365',
	'\241\307',
	'\241\312',
	'\241\313',
	'\241\366',
	'\241\334',
	'\241\244',
	'\241\335',
	'\241\245',
	'\241\277',
	'\243\260',
	'\243\261',
	'\243\262',
	'\243\263',
	'\243\264',
	'\243\265',
	'\243\266',
	'\243\267',
	'\243\270',
	'\243\271',
	'\241\247',
	'\241\250',
	'\241\343',
	'\241\341',
	'\241\344',
	'\241\251',
	'\241\367',
	'\243\301',
	'\243\302',
	'\243\303',
	'\243\304',
	'\243\305',
	'\243\306',
	'\243\307',
	'\243\310',
	'\243\311',
	'\243\312',
	'\243\313',
	'\243\314',
	'\243\315',
	'\243\316',
	'\243\317',
	'\243\320',
	'\243\321',
	'\243\322',
	'\243\323',
	'\243\324',
	'\243\325',
	'\243\326',
	'\243\327',
	'\243\330',
	'\243\331',
	'\243\332',
	'\241\316',
	'\241\357',
	'\241\317',
	'\241\260',
	'\241\262',
	'\241\306',
	'\243\341',
	'\243\342',
	'\243\343',
	'\243\344',
	'\243\345',
	'\243\346',
	'\243\347',
	'\243\350',
	'\243\351',
	'\243\352',
	'\243\353',
	'\243\354',
	'\243\355',
	'\243\356',
	'\243\357',
	'\243\360',
	'\243\361',
	'\243\362',
	'\243\363',
	'\243\364',
	'\243\365',
	'\243\366',
	'\243\367',
	'\243\370',
	'\243\371',
	'\243\372',
	'\241\320',
	'\241\303',
	'\241\321',
	'\241\301',
	'\241\261'
  ];

  map TEXT[];
  result TEXT;
BEGIN
  IF p_str ='' THEN RETURN NULL::TEXT; END IF;

  SELECT character_set_name FROM information_schema.character_sets INTO db_encoding;

  CASE db_encoding
    WHEN 'UTF8' THEN map := TO_MULTI_BYTE_UTF8;
    WHEN 'EUC_JP' THEN map := TO_MULTI_BYTE_EUCJP;
    WHEN 'PG_EUC_JIS_2004' THEN map := TO_MULTI_BYTE_EUCJP;
    ELSE RETURN p_str; --no need to convert
  END CASE;

  SELECT ARRAY_TO_STRING(ARRAY_AGG(CONCAT(CASE
                                            WHEN array_position(map,u) IS NOT NULL
                                            THEN CONVERT_FROM(DECODE(to_hex(array_position(map,u)+32-1),'hex'),db_encoding)
                                            ELSE v
                                          END
                                         ,'')
                                  )
                        ,'')
    FROM (SELECT v, encode(v::bytea,'escape') AS u
            FROM REGEXP_SPLIT_TO_TABLE(p_str,'') AS v) t
    INTO result;

  RETURN result;
END;
]]></complex-attribute>
                        <category _I_D="1ba3b191-ada2-46c4-aa76-b25387c065b5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e06cdce4-5915-4730-b7aa-2a2ddcd640b0" name="trim" is-trigger-function="0" unique-function-name="trim" is-aggregate="f" language-name="plpgsql" context="trim" subcategories-loading="none" object-loading="extended" arguments-datatypes="anyarray,numeric" comment="Implements Oracle Collection method TRIM" is-returning-set="f" ret-datatype="anyarray" function-arguments="parray anyarray, pn numeric DEFAULT NULL::numeric" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22462" volatility="VOLATILE" is-window="f" function-identity-arguments="parray anyarray, pn numeric" overload-function-count="1" proc-language="plpgsql" function-signature="trim(parray anyarray, pn numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    
    vN INTEGER;
    vLength INTEGER;
BEGIN

    vLength := ARRAY_LENGTH(parray, 1);
    
    IF pn IS NULL THEN

        vN := 1;

    ELSE

        vN := ROUND(pn)::INTEGER;

    END IF;

    IF vN < 0 THEN 
    
        RAISE EXCEPTION USING MESSAGE := 'ORA-06502: PL/SQL: numeric or value error';

    END IF;
    
    IF vN > vLength THEN
    
        RAISE EXCEPTION USING MESSAGE := 'ORA-06533: Subscript beyond count';

    END IF;

    RETURN parray[1:vLength - vN];

END;
]]></complex-attribute>
                        <category _I_D="d13a99f3-a001-43d1-b0d9-dc1190e1f72e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="71aa2c32-e0cb-4912-9273-15866b2ad0f2" name="trunc" is-trigger-function="0" unique-function-name="trunc" is-aggregate="f" language-name="sql" context="trunc" subcategories-loading="none" object-loading="extended" arguments-datatypes="timestamp without time zone,text" comment="This function returns the date with the time portion of the day truncated to a specific unit of measure. It operates according to the rules of the Gregorian calendar." is-returning-set="f" ret-datatype="timestamp" function-arguments="p_date timestamp without time zone, p_fmt text DEFAULT 'DD'::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22464" volatility="VOLATILE" is-window="f" function-identity-arguments="p_date timestamp without time zone, p_fmt text" overload-function-count="1" proc-language="sql" function-signature="trunc(p_date timestamp without time zone, p_fmt text)">
                        <complex-attribute name="sql"><![CDATA[
    SELECT
        CASE
            WHEN LENGTH(p_fmt) = 0 THEN
                
                NULL::TIMESTAMP
            
            WHEN UPPER(p_fmt) IN
            (
                'CC', 'SCC', 'SYYYY', 'YYYY', 'YEAR', 'SYEAR', 'YYY', 'YY', 'Y', 'Q',
                'MONTH', 'MON', 'MM', 'RM', 'IW', 'DDD', 'DD', 'J', 'HH', 'HH12', 'HH24', 'MI'
            ) THEN

                DATE_TRUNC
                (
                    CASE
                        WHEN UPPER(p_fmt) IN ('CC', 'SCC') THEN 'CENTURY'
                        WHEN UPPER(p_fmt) IN ('SYYYY', 'YYYY', 'YEAR', 'SYEAR', 'YYY', 'YY', 'Y') THEN 'YEAR'
                        WHEN UPPER(p_fmt) = 'Q' THEN 'QUARTER'
                        WHEN UPPER(p_fmt) IN ('MONTH', 'MON', 'MM', 'RM') THEN 'MONTH'
                        WHEN UPPER(p_fmt) = 'IW' THEN 'WEEK'
                        WHEN UPPER(p_fmt) IN ('DDD', 'DD', 'J') THEN 'DAY'
                        WHEN UPPER(p_fmt) IN ('HH', 'HH12', 'HH24') THEN 'HOUR'
                        WHEN UPPER(p_fmt) = 'MI' THEN 'MINUTE'
                    END,
                    p_date
                )
            
            WHEN UPPER(p_fmt) IN ('IYYY', 'IYY', 'IY', 'I') THEN

                CASE
                    WHEN 
                    (
                        EXTRACT 
                        (
                            EPOCH FROM
                            aws_oracle_ext.next_day
                            (
                                TO_TIMESTAMP('01.01.' || extract(ISOYEAR from p_date)::INTEGER, 'DD.MM.YYYY')::TIMESTAMP,
                                'MONDAY'
                            ) - TO_TIMESTAMP('01.01.' || extract(ISOYEAR from p_date)::INTEGER, 'DD.MM.YYYY')::TIMESTAMP
                        )/86400
                    )::INTEGER >= 4 THEN

                        aws_oracle_ext.next_day
                        (
                            TO_TIMESTAMP('01.01.' || extract(ISOYEAR from p_date)::INTEGER, 'DD.MM.YYYY')::TIMESTAMP - INTERVAL '7' DAY,
                            'MONDAY'
                        )
                        
                    ELSE
                        aws_oracle_ext.next_day
                        (
                            TO_TIMESTAMP('01.01.' || extract(ISOYEAR from p_date)::INTEGER, 'DD.MM.YYYY')::TIMESTAMP,
                            'MONDAY'
                        )
                END

            WHEN UPPER(p_fmt) IN ('W', 'WW') THEN

                aws_oracle_ext.next_day
                (
                    DATE_TRUNC('DAY',p_date) - INTERVAL '7' DAY,
                    RTRIM
                    (
                        TO_CHAR
                        (
                            DATE_TRUNC
                            (
                                CASE
                                    WHEN UPPER(p_fmt) = 'W' THEN 'MONTH'
                                    ELSE 'YEAR'
                                END,
                                p_date
                            ),
                            'DAY'
                        )
                    )
                )

            WHEN UPPER(p_fmt) IN ('DAY', 'DY', 'D') THEN
            -- todo d is incorrect 

                aws_oracle_ext.next_day
                (
                    DATE_TRUNC('DAY',p_date) - INTERVAL '7' DAY,
                    'MONDAY'
                )

            ELSE

                DATE_TRUNC(p_fmt, p_date)

        END;

]]></complex-attribute>
                        <category _I_D="1527f40a-c76f-469b-b34e-87f2b59b716c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="6153ab1b-5b6e-4795-ab67-d428cf1b2a3b" name="unistr" is-trigger-function="0" unique-function-name="unistr" is-aggregate="f" language-name="plpgsql" context="unistr" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="text" function-arguments="p text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22465" volatility="IMMUTABLE" is-window="f" function-identity-arguments="p text" overload-function-count="1" proc-language="plpgsql" function-signature="unistr(p text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    res TEXT;
BEGIN

    EXECUTE CONCAT
    (
        $$SELECT E'$$,
        REPLACE(REPLACE(REPLACE(p,'\\','zZzZ'),'\','\u'),'zZzZ','\\'),
        $$'$$
    ) INTO RES;

    RETURN RES;

END;
]]></complex-attribute>
                        <category _I_D="db3a634a-3a06-407a-b3fd-c096f29d44b5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="175dcc84-1a28-4222-aec3-f7e18658be3f" name="update_job" is-trigger-function="0" unique-function-name="update_job" is-aggregate="f" language-name="plpgsql" context="update_job" subcategories-loading="none" object-loading="extended" arguments-datatypes="bigint,text" is-returning-set="f" ret-datatype="void" function-arguments="p_job bigint, p_error_message text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22466" volatility="VOLATILE" is-window="f" function-identity-arguments="p_job bigint, p_error_message text" overload-function-count="1" proc-language="plpgsql" function-signature="update_job(p_job bigint, p_error_message text)">
                        <complex-attribute name="sql"><![CDATA[
  declare
    l_failure boolean := p_error_message is not null and p_error_message <> '';
    l_interval aws_oracle_ext.jobs."interval"%type;
    l_next_date timestamp with time zone;
    l_now timestamp with time zone := clock_timestamp();
  begin
    begin
      select j.interval into strict l_interval from aws_oracle_ext.jobs j where j.job = p_job;
    exception
      when no_data_found then
        raise exception 'Job #% not found', p_job;
    end;
  
    execute 'select ' || l_interval into l_next_date;

    if l_next_date is not null or l_failure then
      update aws_oracle_ext.jobs j
         set last_date = case when l_failure then last_date else this_date end
           , this_date = null
           , failures = case when l_failure then failures + 1 else 0 end
           , broken = case when l_failure and failures + 1 > 16 then 'Y' else 'N' end
           , last_failure_message = case when l_failure then p_error_message end
           , next_date = coalesce( l_next_date, next_date )
           , total_time = total_time + case when l_failure then 0 else extract( second from l_now - this_date ) end
       where j.job = p_job
         and j.this_date is not null;
    end if;   

    if l_next_date is null and not l_failure then
      delete from aws_oracle_ext.jobs where job = p_job;
    end if;
  end;
]]></complex-attribute>
                        <category _I_D="3eeea343-dab6-4ed7-860c-108b9bc4ac65" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ae0d3a10-b111-444b-b124-7d31013bbfa2" name="userenv" is-trigger-function="0" unique-function-name="userenv" is-aggregate="f" language-name="plpgsql" context="userenv" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="varchar" function-arguments="parameter character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22468" volatility="VOLATILE" is-window="f" function-identity-arguments="parameter character varying" overload-function-count="1" proc-language="plpgsql" function-signature="userenv(parameter character varying)">
                        <complex-attribute name="sql"><![CDATA[
begin
  if upper(parameter) in ('ISDBA', 'LANG', 'LANGUAGE', 'CLIENT_INFO', 'TERMINAL') then
  return aws_oracle_ext.SYS_CONTEXT_USERENV(parameter);
  else raise EXCEPTION 'invalid USERENV parameter';  
  end if;
end;
]]></complex-attribute>
                        <category _I_D="f2f9a5ee-e7a1-4e3f-90aa-aefbdc4585fc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2a488c9c-9df7-41b6-98bb-cccca4b42652" name="userenv_number" is-trigger-function="0" unique-function-name="userenv_number" is-aggregate="f" language-name="plpgsql" context="userenv_number" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" is-returning-set="f" ret-datatype="int4" function-arguments="parameter character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22467" volatility="VOLATILE" is-window="f" function-identity-arguments="parameter character varying" overload-function-count="1" proc-language="plpgsql" function-signature="userenv_number(parameter character varying)">
                        <complex-attribute name="sql"><![CDATA[
begin
  if upper(parameter) = ('SESSIONID') then
    return pg_backend_pid();
  else 
    /*another  calls with the COMMITSCN and ENTRYID parameters have no analogs in PostgreSQL*/
    return NULL;
  end if;
end;
]]></complex-attribute>
                        <category _I_D="5d20e2db-340f-496b-87ff-d3a3719b11fc" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5893c511-5612-45d7-86ab-0b77d6dbd1ae" name="utl_encode$base64" is-trigger-function="0" unique-function-name="utl_encode$base64" is-aggregate="f" language-name="plpgsql" context="utl_encode$base64" subcategories-loading="none" object-loading="extended" comment="Emulates UTL_ENCODE.BASE64 package constant" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22469" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="utl_encode$base64()">
                        <complex-attribute name="sql"><![CDATA[  
begin
  return 1;
end;
]]></complex-attribute>
                        <category _I_D="677d1c07-7799-4d8b-af1c-825bc7d0bde6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ff9a0ba1-8b90-4d94-a781-578c96c1ddae" name="utl_encode$mimeheader_decode" is-trigger-function="0" unique-function-name="utl_encode$mimeheader_decode" is-aggregate="f" language-name="plpgsql" context="utl_encode$mimeheader_decode" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying" comment="This function accepts as input an &quot;encoded word&quot; of the form:&amp;#x000a;=?&lt;charset&gt;?&lt;encoding&gt;?&lt;encoded text&gt;?= &amp;#x000a;=?ISO-8859-1?Q?Here is some encoded text?= &amp;#x000a;The &lt;encoded text&gt; is encapsulated in mime header tags which give the MIMEHEADER_DECODE function information about how to decode the string. &amp;#x000a;The mime header metadata tags are stripped from the input string and the &lt;encoded text&gt; is converted to the base database character set&amp;#x000a;" is-returning-set="f" ret-datatype="varchar" function-arguments="buf character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22470" volatility="VOLATILE" is-window="f" function-identity-arguments="buf character varying" overload-function-count="1" proc-language="plpgsql" function-signature="utl_encode$mimeheader_decode(buf character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
  l_charset CHARACTER VARYING;
  encoding_flag  CHARACTER VARYING;
BEGIN
  l_charset := (regexp_matches(buf, '\=\?(.*?)\?', 'g'))[1];
  encoding_flag := (regexp_matches(buf, '\?(.)\?', 'g'))[1];

  if l_charset is null or encoding_flag is null then return null; end if;  

  buf := (regexp_matches(buf, concat(encoding_flag, '\?(.*?)\?\='), 'g'))[1];

  return decode(convert_from(buf::bytea, l_charset), case when encoding_flag = 'B' then 'base64' else 'escape' end); 
END
]]></complex-attribute>
                        <category _I_D="7a09d650-4cdd-4843-9b7c-ee29c94df186" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0a9ef85f-4fbc-44a2-a0f3-1af1430a50f4" name="utl_encode$mimeheader_encode" is-trigger-function="0" unique-function-name="utl_encode$mimeheader_encode" is-aggregate="f" language-name="plpgsql" context="utl_encode$mimeheader_encode" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,integer" comment="The buf input parameter is the text to be encoded and becomes the &lt;encoded text&gt;.&amp;#x000a;The &lt;encoding&gt; value is either &quot;Q&quot; or &quot;B&quot; for quoted-printable encode or base64 encoding respectively. The ENCODING input parameter accepts as valid values UTL_ENCODE.QUOTED_PRINTABLE or UTL_ENCODE.BASE64 or NULL. If NULL, quoted-printable encoding is selected as a default value.&amp;#x000a;The &lt;charset&gt; value is specified as the input parameter encode_charset. If NULL, the database character set is selected as a default value.&amp;#x000a;" is-returning-set="f" ret-datatype="varchar" function-arguments="buf character varying, encode_charset character varying DEFAULT NULL::character varying, encoding_flag integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22471" volatility="VOLATILE" is-window="f" function-identity-arguments="buf character varying, encode_charset character varying, encoding_flag integer" overload-function-count="1" proc-language="plpgsql" function-signature="utl_encode$mimeheader_encode(buf character varying, encode_charset character varying, encoding_flag integer)">
                        <complex-attribute name="sql"><![CDATA[  
BEGIN
  if encode_charset is null then
    -- if encode_charset is null the current db charset will be used instead 
    SELECT pg_encoding_to_char(encoding) into encode_charset FROM pg_database WHERE datname = current_database();
  else 
    -- override encode_charset due mapping info
    encode_charset := aws_oracle_ext.get_charset_name(encode_charset);   
  end if;
  return concat('=?', 
		encode_charset, 
		case when encoding_flag = 1 then '?B?' else '?Q?' end, 
		encode(convert_to(buf, encode_charset)::bytea, case when encoding_flag = 1 then 'base64' else 'escape' end), 		
		'?=');
END;  
]]></complex-attribute>
                        <category _I_D="8e64feb8-d304-49fd-87ee-97c6a0a0e84c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="97a1cd50-60fe-420c-8d08-e90ca33cc124" name="utl_encode$quoted_printable" is-trigger-function="0" unique-function-name="utl_encode$quoted_printable" is-aggregate="f" language-name="plpgsql" context="utl_encode$quoted_printable" subcategories-loading="none" object-loading="extended" comment="Emulates UTL_ENCODE.BASE64 package constant" is-returning-set="f" ret-datatype="int4" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22472" volatility="IMMUTABLE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="utl_encode$quoted_printable()">
                        <complex-attribute name="sql"><![CDATA[  
begin
  return 2;
end;
]]></complex-attribute>
                        <category _I_D="8e13f218-2be1-4a1c-b2ee-707dda930b7c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="649ac298-f558-43a2-a0eb-a9afc1ebe564" name="utl_encode$text_decode" is-trigger-function="0" unique-function-name="utl_encode$text_decode" is-aggregate="f" language-name="plpgsql" context="utl_encode$text_decode" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,integer" comment="This function converts the input text to the target character set as specified by the encode_charset parameter, if not NULL. The encoded text is converted to the base character set of database" is-returning-set="f" ret-datatype="varchar" function-arguments="buf character varying, encode_charset character varying DEFAULT NULL::character varying, encoding_flag integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22473" volatility="VOLATILE" is-window="f" function-identity-arguments="buf character varying, encode_charset character varying, encoding_flag integer" overload-function-count="1" proc-language="plpgsql" function-signature="utl_encode$text_decode(buf character varying, encode_charset character varying, encoding_flag integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
BEGIN
  if encode_charset is not null then buf := convert_from(buf::bytea, encode_charset); end if;
  return decode(buf, case when encoding_flag = 1 then 'base64' else 'escape' end); 
END;
]]></complex-attribute>
                        <category _I_D="ce93bc72-01c2-4c4a-9686-aafd2ab83c7b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="522f7cfe-aa47-4470-a1e0-8385d46c4cd3" name="utl_encode$text_encode" is-trigger-function="0" unique-function-name="utl_encode$text_encode" is-aggregate="f" language-name="plpgsql" context="utl_encode$text_encode" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying,integer" comment="This function converts the input text to the target character set as specified by the encode_charset parameter, if not NULL. &amp;#x000a;The text is encoded to either base64 or quoted-printable format, as specified by the encoding parameter." is-returning-set="f" ret-datatype="varchar" function-arguments="buf character varying, encode_charset character varying DEFAULT NULL::character varying, encoding_flag integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22474" volatility="VOLATILE" is-window="f" function-identity-arguments="buf character varying, encode_charset character varying, encoding_flag integer" overload-function-count="1" proc-language="plpgsql" function-signature="utl_encode$text_encode(buf character varying, encode_charset character varying, encoding_flag integer)">
                        <complex-attribute name="sql"><![CDATA[  
BEGIN
  if encode_charset is null then    
    SELECT pg_encoding_to_char(encoding) into encode_charset FROM pg_database WHERE datname = current_database();
  else 
    encode_charset := aws_oracle_ext.get_charset_name(encode_charset);   
  end if;
  return encode(convert_to(buf, encode_charset)::bytea, case when encoding_flag = 1 then 'base64' else 'escape' end);
END;  
]]></complex-attribute>
                        <category _I_D="8c97d684-ac76-40b0-8714-6380764f5808" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="2af9889f-99ea-44b0-8423-3a8c0694e184" name="utl_file$exceptions" is-trigger-function="0" unique-function-name="utl_file$exceptions" is-aggregate="f" language-name="plpgsql" context="utl_file$exceptions" subcategories-loading="none" object-loading="extended" arguments-datatypes="text" is-returning-set="f" ret-datatype="void" function-arguments="src_exception text" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22900" volatility="VOLATILE" is-window="f" function-identity-arguments="src_exception text" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$exceptions(src_exception text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    oracodes CONSTANT JSONB :=
    '
    {
        "invalid_path": {
            "code": -29280,
            "message": "invalid directory path"
        },
        "invalid_mode": {
            "code": -29281,
            "message": "invalid mode"
        },
        "invalid_filehandle": {
            "code": -29282,
            "message": "invalid file ID"
        },
        "invalid_operation": {
            "code": -29283,
            "message": "invalid file operation"
        },
        "read_error": {
            "code": -29284,
            "message": "file read error"
        },
        "write_error": {
            "code": -29285,
            "message": "file write error"
        },
        "internal_error": {
            "code": -29286,
            "message": "internal error"
        },
        "charsetmismatch": {
            "code": -29298,
            "message": "Character set mismatch"
        },
        "invalid_maxlinesize": {
            "code": -29287,
            "message": "invalid maximum line size"
        },
        "invalid_filename": {
            "code": -29288,
            "message": "invalid file name"
        },
        "access_denied": {
            "code": -29289,
            "message": "directory access denied"
        },
        "invalid_offset": {
            "code": -29290,
            "message": "invalid offset specified for seek"
        },
        "delete_failed": {
            "code": -29291,
            "message": "file remove operation failed"
        },
        "rename_failed": {
            "code": -29292,
            "message": "file rename operation failed"
        }
    }
    '::JSONB;
    vCode TEXT;
    vException TEXT;
    vMessage TEXT;
BEGIN

    vException := TRIM(LOWER(src_exception));

    IF vException = 'no_data_found' THEN

        RAISE no_data_found;

    END IF;

    IF NOT oracodes ? vException THEN

        RAISE UNDEFINED_OBJECT;

    ELSE

        vCode := oracodes -> vException ->> 'code' ;

        vMessage := oracodes -> vException ->> 'message';
        
        RAISE USING HINT = vCode, message = vMessage;

    END IF;

END;        
]]></complex-attribute>
                        <category _I_D="bd8e04dc-b6f6-4756-b444-2efe61d1ffa5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5e20f8ec-a65f-4ea8-b773-6a5fcf387aa5" name="utl_file$fclose" is-trigger-function="0" unique-function-name="utl_file$fclose" is-aggregate="f" language-name="plpgsql" context="utl_file$fclose" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_file$file_type&quot;" is-returning-set="f" ret-datatype="utl_file$file_type" function-arguments="INOUT file aws_oracle_ext.&quot;utl_file$file_type&quot;" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22902" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT file aws_oracle_ext.&quot;utl_file$file_type&quot;" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$fclose(INOUT file aws_oracle_ext.&quot;utl_file$file_type&quot;)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    DELETE FROM aws$utl_file_files
    WHERE id = file.id;

    IF NOT FOUND THEN

        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_filehandle');        

    END IF;

END;
]]></complex-attribute>
                        <category _I_D="48bbd66c-1ee6-4e75-a536-b24853b7420a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="79bb5a85-411f-41b2-81a7-1782b1303717" name="utl_file$fclose_all" is-trigger-function="0" unique-function-name="utl_file$fclose_all" is-aggregate="f" language-name="plpgsql" context="utl_file$fclose_all" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22906" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$fclose_all()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN

    TRUNCATE TABLE aws$utl_file_files;

END;
]]></complex-attribute>
                        <category _I_D="b563dbcb-16bb-4273-a393-e2f0dce8917e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0c5fae21-5bb4-45b8-949e-99a7e91b1c5c" name="utl_file$fcopy" is-trigger-function="0" unique-function-name="utl_file$fcopy" is-aggregate="f" language-name="plpgsql" context="utl_file$fcopy" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,text,integer,integer" is-returning-set="f" ret-datatype="void" function-arguments="src_location text, src_filename text, dest_location text, dest_filename text, start_line integer DEFAULT 1, end_line integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22904" volatility="VOLATILE" is-window="f" function-identity-arguments="src_location text, src_filename text, dest_location text, dest_filename text, start_line integer, end_line integer" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$fcopy(src_location text, src_filename text, dest_location text, dest_filename text, start_line integer, end_line integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vDirectory TEXT;
    vsrcBucket TEXT;
    vdstBucket TEXT;
    vResponse JSON;
    vPayload JSON;
    vErrorMessage TEXT;
    vEXCEPTION TEXT;
BEGIN
    SELECT directory_name,
           concat_ws('/', s3_bucket_name, s3_bucket_path)
      INTO vDirectory,
           vsrcBucket
      FROM aws_oracle_ext.sys_dba_directories
     WHERE directory_name = src_location;

    IF NOT FOUND THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_path');
    END IF;

    IF src_location <> dest_location
    THEN
        SELECT directory_name,
               concat_ws('/', s3_bucket_name, s3_bucket_path)
          INTO vDirectory,
               vdstBucket
          FROM aws_oracle_ext.sys_dba_directories
         WHERE directory_name = dest_location;

        IF NOT FOUND THEN
            PERFORM aws_oracle_ext.utl_file$exceptions('invalid_path');
        END IF;
    ELSE
        vdstBucket := vsrcBucket;
    END IF;

    vPayload := JSON_BUILD_OBJECT
    (
        'Action', 'FCOPY',
        'srcBucket', vsrcBucket,
        'srcDIRECTORY', src_location,
        'srcFilename', src_filename,
        'dstBucket', vdstBucket,
        'dstDIRECTORY', dest_location,
        'dstFilename', dest_filename
    );

    vResponse := aws_oracle_ext.awslambda_fn
    (
        aws_oracle_ext.get_service_setting
        (
            'UTL_FILE',
            'LAMBDA_ARN' 
        ),
        vPayload
    );

    IF vResponse -> 'error' IS NOT NULL
    THEN
        vEXCEPTION := vResponse -> 'error' ->> 'EXCEPTION';

        IF vEXCEPTION = '-1' THEN
            vErrorMessage := vResponse -> 'error' ->> 'Description';
            RAISE USING MESSAGE = vErrorMessage;
        END IF;

        PERFORM aws_oracle_ext.utl_file$exceptions(vEXCEPTION);
    END IF;
END;
]]></complex-attribute>
                        <category _I_D="a873aa89-5103-4523-9454-417d51408dfa" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4f20e712-d3a4-4f2d-9750-217ecdbed86e" name="utl_file$fhstorage" is-trigger-function="0" unique-function-name="utl_file$fhstorage" is-aggregate="f" language-name="plpgsql" context="utl_file$fhstorage" subcategories-loading="none" object-loading="extended" is-returning-set="f" ret-datatype="void" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="22896" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$fhstorage()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CREATE TEMPORARY TABLE IF NOT EXISTS aws$utl_file_files
    (
        id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
        open_mode TEXT NOT NULL,
        directory_name TEXT NOT NULL,
        open_filename TEXT NOT NULL,
        max_linesize SMALLINT NOT NULL,
        fpos BIGINT NOT NULL DEFAULT 0,
        text_contents TEXT,
        CONSTRAINT uk_directory_file UNIQUE(directory_name, open_filename)
    );
END;
]]></complex-attribute>
                        <category _I_D="4f5a380d-3945-455c-bac8-553add331a00" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ebb47281-4aeb-4112-8165-45e811af3e9c" name="utl_file$fopen" is-trigger-function="0" unique-function-name="utl_file$fopen" is-aggregate="f" language-name="plpgsql" context="utl_file$fopen" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text,text,integer" is-returning-set="f" ret-datatype="utl_file$file_type" function-arguments="location text, filename text, open_mode text, max_linesize integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22901" volatility="VOLATILE" is-window="f" function-identity-arguments="location text, filename text, open_mode text, max_linesize integer" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$fopen(location text, filename text, open_mode text, max_linesize integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vResult aws_oracle_ext.utl_file$file_type;
    vDirectory TEXT;
    vBucket TEXT;
    vResponse JSON;
    vPayload JSON;
    vErrorMessage TEXT;
    vEXCEPTION TEXT;
    vmax_linesize INTEGER;
BEGIN
    vmax_linesize := COALESCE(max_linesize, 1024);

    IF vmax_linesize NOT BETWEEN 1 AND 32767 THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_maxlinesize');
    END IF;

    IF ARRAY_POSITION(ARRAY['R', 'W', 'A', 'RB', 'WB', 'AB'], UPPER(open_mode)) IS NULL THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_mode');
    END IF;

    SELECT directory_name,
           concat_ws('/', s3_bucket_name, s3_bucket_path)
      INTO vDirectory,
           vBucket
      FROM aws_oracle_ext.sys_dba_directories
     WHERE directory_name = location;

    IF NOT FOUND THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_path');
    END IF;

    vPayload := JSON_BUILD_OBJECT
    (
        'Action', 'FOPEN',
        'Bucket', vBucket,
        'DIRECTORY', vDirectory,
        'filename', filename,
        'openmode', open_mode
    );

    vResponse := aws_oracle_ext.awslambda_fn
    (
        aws_oracle_ext.get_service_setting
        (
            'UTL_FILE',
            'LAMBDA_ARN' 
        ),
        vPayload
    );
    
    IF vResponse -> 'error' IS NOT NULL THEN
        vEXCEPTION := vResponse -> 'error' ->> 'EXCEPTION';

        IF vEXCEPTION = '-1' THEN
            vErrorMessage := vResponse -> 'error' ->> 'Description';
            RAISE USING MESSAGE = vErrorMessage;
        END IF;

        PERFORM aws_oracle_ext.utl_file$exceptions(vEXCEPTION);
    END IF;

    IF vResponse::TEXT = 'null' THEN
        PERFORM aws_oracle_ext.utl_file$fhstorage();

        DELETE FROM aws$utl_file_files
        WHERE directory_name = vDirectory
        AND open_filename = filename;

        INSERT INTO aws$utl_file_files(open_mode, directory_name, open_filename, max_linesize)
        VALUES(LOWER(open_mode), vDirectory, filename, vmax_linesize)
        RETURNING id INTO vResult.id;

        vResult.datatype := 1;
        vResult.byte_mode := CASE WHEN UPPER(open_mode) LIKE '%B' THEN TRUE ELSE FALSE END;
    END IF;

    RETURN vResult;
END;
]]></complex-attribute>
                        <category _I_D="0e613d60-67f4-4d1d-9a5d-9e50f9c16797" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="88065e79-ab5f-415c-b7d5-5938488bd271" name="utl_file$fremove" is-trigger-function="0" unique-function-name="utl_file$fremove" is-aggregate="f" language-name="plpgsql" context="utl_file$fremove" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" is-returning-set="f" ret-datatype="void" function-arguments="location text, filename text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22903" volatility="VOLATILE" is-window="f" function-identity-arguments="location text, filename text" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$fremove(location text, filename text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vDirectory TEXT;
    vBucket TEXT;
    vResponse JSON;
    vPayload JSON;
    vErrorMessage TEXT;
    vEXCEPTION TEXT;
BEGIN
    SELECT directory_name,
           concat_ws('/', s3_bucket_name, s3_bucket_path)
      INTO vDirectory,
           vBucket
      FROM aws_oracle_ext.sys_dba_directories
     WHERE directory_name = location;

    IF NOT FOUND THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_path');
    END IF;

    vPayload := JSON_BUILD_OBJECT
    (
        'Action', 'FREMOVE',
        'Bucket', vBucket,
        'DIRECTORY', vDirectory,
        'filename', filename
    );

    vResponse := aws_oracle_ext.awslambda_fn
    (
        aws_oracle_ext.get_service_setting
        (
            'UTL_FILE',
            'LAMBDA_ARN' 
        ),
        vPayload
    );
    
    IF vResponse -> 'error' IS NOT NULL THEN
        vEXCEPTION := vResponse -> 'error' ->> 'EXCEPTION';

        IF vEXCEPTION = '-1' THEN
            vErrorMessage := vResponse -> 'error' ->> 'Description';
            RAISE USING MESSAGE = vErrorMessage;
        END IF;

        PERFORM aws_oracle_ext.utl_file$exceptions(vEXCEPTION);
    END IF;
END;
]]></complex-attribute>
                        <category _I_D="4cfb190f-fe90-4597-950b-0c8d94534fd6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a1461e6c-dd98-4358-87ba-4d2fdf031a86" name="utl_file$get_line" is-trigger-function="0" unique-function-name="utl_file$get_line" is-aggregate="f" language-name="plpgsql" context="utl_file$get_line" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_file$file_type&quot;,text,integer" is-returning-set="f" ret-datatype="text" function-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;, OUT buffer text, len integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22905" volatility="VOLATILE" is-window="f" function-identity-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;, OUT buffer text, len integer" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$get_line(file aws_oracle_ext.&quot;utl_file$file_type&quot;, OUT buffer text, len integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vDirectory TEXT;
    vBucket TEXT;
    vFilename TEXT;
    vOpenMode TEXT;
    vLen INTEGER;
    vOpenLen INTEGER;
    vResponse JSON;
    vPayload JSON;
    vErrorMessage TEXT;
    vEXCEPTION TEXT;
    vPos INTEGER;
    vData TEXT;
    vNl TEXT;
    vNLpos INTEGER;
    vText TEXT;
BEGIN
    SELECT f.open_mode,
           d.directory_name,
           f.open_filename,
           f.max_linesize,
           concat_ws('/', d.s3_bucket_name, d.s3_bucket_path),
           f.text_contents,
           f.fpos
      INTO vOpenMode,
           vDirectory,
           vFilename,
           vOpenLen,
           vBucket,
           vText,
           vPos
      FROM aws$utl_file_files f
           JOIN aws_oracle_ext.sys_dba_directories d ON (d.directory_name = f.directory_name)
     WHERE id = file.id;

    IF NOT FOUND THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_filehandle');
    END IF;

    IF UPPER(vOpenMode) <> 'R' THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_operation');
    END IF;

    IF vText IS NULL THEN
        vPayload := JSON_BUILD_OBJECT
        (
            'Action', 'GET_LINE',
            'Bucket', vBucket,
            'DIRECTORY', vDirectory,
            'filename', vFilename,
            'pos', 0,
            'len', 0
        );

        vResponse := aws_oracle_ext.awslambda_fn
        (
            aws_oracle_ext.get_service_setting
            (
                'UTL_FILE',
                'LAMBDA_ARN' 
            ),
            vPayload
        );
    
        IF vResponse -> 'error' IS NOT NULL THEN
            vEXCEPTION := vResponse -> 'error' ->> 'EXCEPTION';

            IF vEXCEPTION = '-1' THEN
                vErrorMessage := vResponse -> 'error' ->> 'Description';
                RAISE USING MESSAGE = vErrorMessage;
            END IF;

            PERFORM aws_oracle_ext.utl_file$exceptions(vEXCEPTION);
        END IF;

        vData := vResponse ->> 'data';

        vNl := COALESCE
        (
            aws_oracle_ext.get_service_setting
            (
                'UTL_FILE',
                'NEWLINE' 
            ),
            E'\n'
        );

        IF vNl <> E'\n' THEN
            vData := REPLACE(vData, vNl, E'\n');
        END IF;

        UPDATE aws$utl_file_files
           SET text_contents = vData;

        vText := vData;
    END IF;

    vData := SUBSTR(vText, vPos + 1);

    IF LENGTH(vData) = 0 THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('read_error');
    END IF;

    vNLpos := POSITION(E'\n' IN vData);

    IF (vNLpos = 0 AND LENGTH(vData) >= vOpenLen) OR (vNLpos > vOpenLen) THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('read_error');
    END IF;

    vLen := LEAST(len, vOpenLen);

    vData := SUBSTR
    (
        vData,
        1,
        CASE
            WHEN vNLpos <> 0 THEN least(vLen, vNLpos)
            ELSE vLen
        END
    );

    vPos := LENGTH(vData);

    buffer := REPLACE(vData, E'\n', '');

    UPDATE aws$utl_file_files
       SET fpos = fpos + vPos;
END;
]]></complex-attribute>
                        <category _I_D="cedee384-3adf-4f16-9924-fad19e339ea1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="ced6164d-7ebb-4754-9570-302dae776720" name="utl_file$get_raw" is-trigger-function="0" unique-function-name="utl_file$get_raw" is-aggregate="f" language-name="plpgsql" context="utl_file$get_raw" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_file$file_type&quot;,bytea,integer" is-returning-set="f" ret-datatype="bytea" function-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;, OUT buffer bytea, len integer DEFAULT NULL::integer" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22907" volatility="VOLATILE" is-window="f" function-identity-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;, OUT buffer bytea, len integer" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$get_raw(file aws_oracle_ext.&quot;utl_file$file_type&quot;, OUT buffer bytea, len integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vDirectory TEXT;
    vBucket TEXT;
    vFilename TEXT;
    vOpenMode TEXT;
    vLen INTEGER;
    vOpenLen INTEGER;
    vResponse JSON;
    vPayload JSON;
    vErrorMessage TEXT;
    vEXCEPTION TEXT;
    vPos BIGINT;
    vData TEXT;
BEGIN
    SELECT f.open_mode,
           d.directory_name,
           f.open_filename,
           f.max_linesize,
           concat_ws('/', d.s3_bucket_name, d.s3_bucket_path),
           f.fpos
      INTO vOpenMode,
           vDirectory,
           vFilename,
           vOpenLen,
           vBucket,
           vPos
      FROM aws$utl_file_files f
           JOIN aws_oracle_ext.sys_dba_directories d ON (d.directory_name = f.directory_name)
     WHERE id = file.id;

    IF NOT FOUND THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_filehandle');
    END IF;

    IF UPPER(vOpenMode) <> 'RB' THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_operation');
    END IF;

    vLen := COALESCE(len, 32767);

    vPayload := JSON_BUILD_OBJECT
    (
        'Action', 'GET_RAW',
        'Bucket', vBucket,
        'DIRECTORY', vDirectory,
        'filename', vFilename,
        'pos', vPos,
        'len', vLen
    );

    vResponse := aws_oracle_ext.awslambda_fn
    (
        aws_oracle_ext.get_service_setting
        (
            'UTL_FILE',
            'LAMBDA_ARN' 
        ),
        vPayload
    );

    IF vResponse -> 'error' IS NOT NULL THEN
        vEXCEPTION := vResponse -> 'error' ->> 'EXCEPTION';

        IF vEXCEPTION = '-1' THEN
            vErrorMessage := vResponse -> 'error' ->> 'Description';
            RAISE USING MESSAGE = vErrorMessage;
        END IF;

        PERFORM aws_oracle_ext.utl_file$exceptions(vEXCEPTION);
    END IF;

    SELECT string_agg(upper(lpad(to_hex(v::INT), 2, '0')),''),
           COUNT(1)
      INTO vData,
           vPos
      FROM json_array_elements_text(vResponse -> 'data') AS v;

    buffer := DECODE(vData, 'hex');

    UPDATE aws$utl_file_files
       SET fpos = fpos + vPos;
END;
]]></complex-attribute>
                        <category _I_D="483cf8d6-3eb1-477a-b5b5-1c3235e8ed68" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a4fa02c0-6b8a-4405-b9e9-0205d6652c53" name="utl_file$is_open" is-trigger-function="0" unique-function-name="utl_file$is_open" is-aggregate="f" language-name="plpgsql" context="utl_file$is_open" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_file$file_type&quot;" is-returning-set="f" ret-datatype="bool" function-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22913" volatility="VOLATILE" is-window="f" function-identity-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$is_open(file aws_oracle_ext.&quot;utl_file$file_type&quot;)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vResult BOOLEAN DEFAULT FALSE;
BEGIN

    SELECT TRUE
    INTO
    vResult
    FROM aws$utl_file_files
    WHERE id = file.id;

    IF NOT FOUND THEN

        vResult := FALSE;

    END IF;

    RETURN vResult;

EXCEPTION
    WHEN undefined_table THEN
    
        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_filehandle');

END;
]]></complex-attribute>
                        <category _I_D="8f193634-cea3-4224-b26c-de2900fcd6b3" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="dd8ccdb8-71c4-41a5-86d8-6aa436b7efac" name="utl_file$new_line" is-trigger-function="0" unique-function-name="utl_file$new_line" is-aggregate="f" language-name="plpgsql" context="utl_file$new_line" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_file$file_type&quot;,integer" is-returning-set="f" ret-datatype="void" function-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;, lines integer DEFAULT 1" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22911" volatility="VOLATILE" is-window="f" function-identity-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;, lines integer" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$new_line(file aws_oracle_ext.&quot;utl_file$file_type&quot;, lines integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vNl TEXT;
BEGIN

    vNl := COALESCE
    (
        CASE
            WHEN aws_oracle_ext.get_service_setting
            (
                'UTL_FILE',
                'NEWLINE' 
            ) = '\r\n' THEN
                E'\r\n'
            ELSE
                NULL
        END,
        E'\n'
    );

    vNl := REPEAT(vNl, lines);

    PERFORM aws_oracle_ext.utl_file$put(file, vNl);

END;
]]></complex-attribute>
                        <category _I_D="cdbb8c00-8e21-4ade-a1b9-c696cd083bf6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3a404410-3e3c-482c-bde5-de1d50d24c14" name="utl_file$put" is-trigger-function="0" unique-function-name="utl_file$put" is-aggregate="f" language-name="plpgsql" context="utl_file$put" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_file$file_type&quot;,text" is-returning-set="f" ret-datatype="void" function-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;, buffer text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22908" volatility="VOLATILE" is-window="f" function-identity-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;, buffer text" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$put(file aws_oracle_ext.&quot;utl_file$file_type&quot;, buffer text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vDirectory TEXT;
    vBucket TEXT;
    vFilename TEXT;
    vOpenMode TEXT;
    vLen INTEGER;
    vOpenLen INTEGER;
    vResponse JSON;
    vPayload JSON;
    vErrorMessage TEXT;
    vEXCEPTION TEXT;
BEGIN
    SELECT f.open_mode,
           d.directory_name,
           f.open_filename,
           f.max_linesize,
           concat_ws('/', d.s3_bucket_name, d.s3_bucket_path)
      INTO vOpenMode,
           vDirectory,
           vFilename,
           vOpenLen,
           vBucket
      FROM aws$utl_file_files f
           JOIN aws_oracle_ext.sys_dba_directories d ON (d.directory_name = f.directory_name)
     WHERE id = file.id;

    IF NOT FOUND THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_filehandle');
    END IF;

    IF NOT (UPPER(vOpenMode) LIKE 'W%' OR UPPER(vOpenMode) LIKE 'A%') THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_operation');
    END IF;

    vPayload := JSON_BUILD_OBJECT
    (
        'Action', 'PUT',
        'Bucket', vBucket,
        'DIRECTORY', vDirectory,
        'filename', vFilename,
        'buffer', SUBSTR(buffer, 1, 32767)
    );

    vResponse := aws_oracle_ext.awslambda_fn
    (
        aws_oracle_ext.get_service_setting
        (
            'UTL_FILE',
            'LAMBDA_ARN' 
        ),
        vPayload
    );

    IF vResponse -> 'error' IS NOT NULL THEN
        vEXCEPTION := vResponse -> 'error' ->> 'EXCEPTION';

        IF vEXCEPTION = '-1' THEN
            vErrorMessage := vResponse -> 'error' ->> 'Description';
            RAISE USING MESSAGE = vErrorMessage;
        END IF;

        PERFORM aws_oracle_ext.utl_file$exceptions(vEXCEPTION);
    END IF;
END;
]]></complex-attribute>
                        <category _I_D="5373346f-ca73-483a-aedc-091c5056981c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5a5bbe7a-6d54-42bc-93b8-b51f18427c27" name="utl_file$put_line" is-trigger-function="0" unique-function-name="utl_file$put_line" is-aggregate="f" language-name="plpgsql" context="utl_file$put_line" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_file$file_type&quot;,text,boolean" is-returning-set="f" ret-datatype="void" function-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;, buffer text, autoflush boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22910" volatility="VOLATILE" is-window="f" function-identity-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;, buffer text, autoflush boolean" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$put_line(file aws_oracle_ext.&quot;utl_file$file_type&quot;, buffer text, autoflush boolean)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vNl TEXT;
BEGIN

    vNl := COALESCE
    (
        CASE
            WHEN aws_oracle_ext.get_service_setting
            (
                'UTL_FILE',
                'NEWLINE' 
            ) = '\r\n' THEN
                E'\r\n'
            ELSE
                NULL
        END,
        E'\n'
    );

    PERFORM  aws_oracle_ext.utl_file$put
    (
        $1,
        CONCAT
        (
            $2,
            vNl
        )
    );

END;
]]></complex-attribute>
                        <category _I_D="0b67f099-b858-43a4-84f0-6ddd990eb3ce" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a245c3e5-68b9-43f0-8055-d6ce787f6785" name="utl_file$put_raw" is-trigger-function="0" unique-function-name="utl_file$put_raw" is-aggregate="f" language-name="plpgsql" context="utl_file$put_raw" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_file$file_type&quot;,bytea,boolean" is-returning-set="f" ret-datatype="void" function-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;, buffer bytea, autoflush boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22909" volatility="VOLATILE" is-window="f" function-identity-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;, buffer bytea, autoflush boolean" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$put_raw(file aws_oracle_ext.&quot;utl_file$file_type&quot;, buffer bytea, autoflush boolean)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vDirectory TEXT;
    vBucket TEXT;
    vFilename TEXT;
    vOpenMode TEXT;
    vLen INTEGER;
    vOpenLen INTEGER;
    vResponse JSON;
    vPayload JSON;
    vErrorMessage TEXT;
    vEXCEPTION TEXT;
BEGIN
    SELECT f.open_mode,
           d.directory_name,
           f.open_filename,
           f.max_linesize,
           concat_ws('/', d.s3_bucket_name, d.s3_bucket_path)
      INTO vOpenMode,
           vDirectory,
           vFilename,
           vOpenLen,
           vBucket
      FROM aws$utl_file_files f
           JOIN aws_oracle_ext.sys_dba_directories d ON (d.directory_name = f.directory_name)
     WHERE id = file.id;

    IF NOT FOUND THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_filehandle');
    END IF;

    IF UPPER(vOpenMode) NOT IN ('WB', 'AB') THEN
        PERFORM aws_oracle_ext.utl_file$exceptions('invalid_operation');
    END IF;

    vPayload := JSON_BUILD_OBJECT
    (
        'Action', 'PUT_RAW',
        'Bucket', vBucket,
        'DIRECTORY', vDirectory,
        'filename', vFilename,
        'buffer', ENCODE(buffer, 'hex')
    );

    vResponse := aws_oracle_ext.awslambda_fn
    (
        aws_oracle_ext.get_service_setting
        (
            'UTL_FILE',
            'LAMBDA_ARN' 
        ),
        vPayload
    );

    IF vResponse -> 'error' IS NOT NULL THEN
        vEXCEPTION := vResponse -> 'error' ->> 'EXCEPTION';

        IF vEXCEPTION = '-1' THEN
            vErrorMessage := vResponse -> 'error' ->> 'Description';
            RAISE USING MESSAGE = vErrorMessage;
        END IF;

        PERFORM aws_oracle_ext.utl_file$exceptions(vEXCEPTION);
    END IF;
END;
]]></complex-attribute>
                        <category _I_D="2dc24ba4-57c6-4939-b12c-c33be7a1940f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f6c1d87b-4a4f-4bb4-9023-4139234dde20" name="utl_file$putf" is-trigger-function="0" unique-function-name="utl_file$putf" is-aggregate="f" language-name="plpgsql" context="utl_file$putf" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_file$file_type&quot;,text,text,text,text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;, format text, arg1 text DEFAULT NULL::text, arg2 text DEFAULT NULL::text, arg3 text DEFAULT NULL::text, arg4 text DEFAULT NULL::text, arg5 text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="7" function-id="22912" volatility="VOLATILE" is-window="f" function-identity-arguments="file aws_oracle_ext.&quot;utl_file$file_type&quot;, format text, arg1 text, arg2 text, arg3 text, arg4 text, arg5 text" overload-function-count="1" proc-language="plpgsql" function-signature="utl_file$putf(file aws_oracle_ext.&quot;utl_file$file_type&quot;, format text, arg1 text, arg2 text, arg3 text, arg4 text, arg5 text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vText TEXT;
    vNl TEXT;
    vAddNewLine BOOLEAN DEFAULT TRUE;
BEGIN

    vNl := COALESCE
    (
        CASE
            WHEN aws_oracle_ext.get_service_setting
            (
                'UTL_FILE',
                'NEWLINE' 
            ) = '\r\n' THEN
                E'\r\n'
            ELSE
                NULL
        END,
        E'\n'
    );

    IF SUBSTR(REVERSE(format), 1, 2) = '\n' THEN

        vAddNewLine := FALSE;
        
    END IF;
    
    vText := REPLACE(format, '\n', vNl);

    vText := format(vText, arg1, arg2, arg3, arg4, arg5);

    IF vAddNewLine THEN

        vText := CONCAT(vText, vNl);

    EnD IF;

    PERFORM aws_oracle_ext.utl_file$put(file, vText);

END;
]]></complex-attribute>
                        <category _I_D="d92408b8-cd9f-4dde-ac89-9a5a2345aff4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e52d5058-0afa-45b5-a8f2-67d1c0646b43" name="utl_match$edit_distance" is-trigger-function="0" unique-function-name="utl_match$edit_distance" is-aggregate="f" language-name="sql" context="utl_match$edit_distance" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying" is-returning-set="f" ret-datatype="int4" function-arguments="s1 character varying, s2 character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23298" volatility="IMMUTABLE" is-window="f" function-identity-arguments="s1 character varying, s2 character varying" overload-function-count="1" proc-language="sql" function-signature="utl_match$edit_distance(s1 character varying, s2 character varying)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
    CASE
        WHEN COALESCE(s1, '') = '' OR COALESCE(s2, '') = '' THEN
            -1
        ELSE
            LEVENSHTEIN(s1, s2)
    END;
]]></complex-attribute>
                        <category _I_D="ae5a09ef-4881-41e1-a191-2392157dee4f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="9210089e-7aac-4080-aa95-54288d9f700e" name="utl_match$edit_distance_similarity" is-trigger-function="0" unique-function-name="utl_match$edit_distance_similarity" is-aggregate="f" language-name="sql" context="utl_match$edit_distance_similarity" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying" is-returning-set="f" ret-datatype="int4" function-arguments="s1 character varying, s2 character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23299" volatility="IMMUTABLE" is-window="f" function-identity-arguments="s1 character varying, s2 character varying" overload-function-count="1" proc-language="sql" function-signature="utl_match$edit_distance_similarity(s1 character varying, s2 character varying)">
                        <complex-attribute name="sql"><![CDATA[
SELECT
    CASE
        WHEN COALESCE(s1, '') = '' AND COALESCE(s2, '') = '' THEN
            100
        WHEN COALESCE(s1, '') = COALESCE(s2, '') THEN
            100
        WHEN (COALESCE(s1, '') != '' AND COALESCE(s2, '') = '') OR
        (COALESCE(s1, '') = '' AND COALESCE(s2, '') != '') THEN
            0
        ELSE
            CEIL((1 - LEVENSHTEIN(s1, s2)::NUMERIC /(GREATEST(LENGTH(s1), LENGTH(s2)))::NUMERIC) * 100)
    END;
]]></complex-attribute>
                        <category _I_D="aa0814e3-99ae-4e4b-bdf4-f64f3c066c8c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c49afbce-0853-49ff-9f6c-840d5da42110" name="utl_match$jaro_winkler" is-trigger-function="0" unique-function-name="utl_match$jaro_winkler" is-aggregate="f" language-name="plpgsql" context="utl_match$jaro_winkler" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying" is-returning-set="f" ret-datatype="float8" function-arguments="s1 character varying, s2 character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23300" volatility="IMMUTABLE" is-window="f" function-identity-arguments="s1 character varying, s2 character varying" overload-function-count="1" proc-language="plpgsql" function-signature="utl_match$jaro_winkler(s1 character varying, s2 character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    s_len INTEGER := LENGTH(COALESCE(s1, ''));
    t_len INTEGER := LENGTH(COALESCE(s2, ''));
    s_matches BOOLEAN[];
    t_matches BOOLEAN[];
    matches INTEGER DEFAULT 0;
    transpositions INTEGER DEFAULT 0;
    l INTEGER DEFAULT 0;
    ss BOOLEAN DEFAULT TRUE;
    match_distance INTEGER;
    s VARCHAR[];
    t VARCHAR[];
    start INTEGER;
    finish INTEGER;
    k INTEGER DEFAULT 1;
    res DOUBLE PRECISION;
BEGIN

    IF s_len = 0 OR t_len = 0 THEN

        RETURN 0;

    END IF;

    IF s1 = s2 THEN

        RETURN 1;

    END IF;

    match_distance := TRUNC(GREATEST(s_len, t_len) / 2::DOUBLE PRECISION) - 1;

    s :=  string_to_array(s1, NULL);
    t :=  string_to_array(s2, NULL);

    FOR i IN 1..s_len LOOP

        IF l < 4 THEN

            IF ss THEN

                IF s[i] <> COALESCE(t[i], '') THEN

                    ss := FALSE;

                ELSE

                    l:= l + 1;

                END IF;

            END IF;

        END IF;

        start := GREATEST(1, i - match_distance);
        finish := LEAST(i + match_distance , t_len);

        FOR j IN start..finish LOOP

            CONTINUE WHEN COALESCE(t_matches[j], FALSE);
            CONTINUE WHEN s[i] != COALESCE(t[j], '');

            s_matches[i] = TRUE;
            t_matches[j] = TRUE;
            matches := matches + 1;
            EXIT;

        END LOOP;

    END LOOP;

    IF matches = 0 THEN

        RETURN 0;

    END IF;
 
    FOR i IN 1..s_len LOOP

        CONTINUE WHEN NOT COALESCE(s_matches[i], FALSE);

        WHILE NOT COALESCE(t_matches[k], FALSE) LOOP

            k := k + 1;

        END LOOP;

        IF s[i] != COALESCE(t[k], '') THEN

            transpositions := transpositions + 1;

        END IF;

        k := k + 1;

    END LOOP;

    res := (matches::DOUBLE PRECISION / s_len::DOUBLE PRECISION +
        matches::DOUBLE PRECISION / t_len::DOUBLE PRECISION +
        (matches - transpositions/2)::DOUBLE PRECISION / matches::DOUBLE PRECISION) / 3;

    RETURN res + (l * 0.1 * (1 - res));

END;
]]></complex-attribute>
                        <category _I_D="163c2a25-8d2a-4969-8b1b-3c2ed0d8533a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3aac5dd0-e147-4f99-8f28-4a80f42ee1e8" name="utl_match$jaro_winkler_similarity" is-trigger-function="0" unique-function-name="utl_match$jaro_winkler_similarity" is-aggregate="f" language-name="sql" context="utl_match$jaro_winkler_similarity" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,character varying" is-returning-set="f" ret-datatype="int4" function-arguments="s1 character varying, s2 character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23301" volatility="IMMUTABLE" is-window="f" function-identity-arguments="s1 character varying, s2 character varying" overload-function-count="1" proc-language="sql" function-signature="utl_match$jaro_winkler_similarity(s1 character varying, s2 character varying)">
                        <complex-attribute name="sql"><![CDATA[
SELECT TRUNC(100 * aws_oracle_ext.utl_match$jaro_winkler(s1, s2));
]]></complex-attribute>
                        <category _I_D="8cb5df06-d630-463e-a0f7-76b2d45254a4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0dd67b4c-03e4-4909-8ec6-cdc27cb6eed8" name="utl_smtp$auth" is-trigger-function="0" unique-function-name="utl_smtp$auth" is-aggregate="f" language-name="plpgsql" context="utl_smtp$auth" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;,character varying,character varying,character varying" is-returning-set="f" ret-datatype="utl_smtp$reply" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, username character varying, password character varying, schemes character varying DEFAULT 'CRAM-MD5'::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="4" function-id="22475" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, username character varying, password character varying, schemes character varying" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$auth(c aws_oracle_ext.&quot;utl_smtp$connection&quot;, username character varying, password character varying, schemes character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare
  l_result aws_oracle_ext.utl_smtp$reply;
begin
  l_result.code := 235;
  l_result.text := 'Authentication successful';
  return l_result;
end;
]]></complex-attribute>
                        <category _I_D="a389ab07-9ac8-4a3a-9f0c-70e0847d03be" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="0ce0585f-c258-405e-ba71-4a0a14fba007" name="utl_smtp$close_connection" is-trigger-function="0" unique-function-name="utl_smtp$close_connection" is-aggregate="f" language-name="plpgsql" context="utl_smtp$close_connection" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;" is-returning-set="f" ret-datatype="void" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22476" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$close_connection(c aws_oracle_ext.&quot;utl_smtp$connection&quot;)">
                        <complex-attribute name="sql"><![CDATA[
begin

  drop table if exists utl_smtp$new_message;
  drop table if exists utl_smtp$recipients;
  drop table if exists utl_smtp$connection;

  return;
end;
]]></complex-attribute>
                        <category _I_D="9b795264-879f-433d-8aaa-9fedc9e0dc79" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="7dc0a5fb-eda0-4ab9-8f87-5e77a5f67873" name="utl_smtp$close_data" is-trigger-function="0" unique-function-name="utl_smtp$close_data" is-aggregate="f" language-name="plpgsql" context="utl_smtp$close_data" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;" is-returning-set="f" ret-datatype="utl_smtp$reply" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22477" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$close_data(c aws_oracle_ext.&quot;utl_smtp$connection&quot;)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  l_reply aws_oracle_ext.utl_smtp$reply;
begin
  l_reply.code := 250;
  l_reply.text := 'Requested mail action okay, completed';

  return l_reply;
end;
]]></complex-attribute>
                        <category _I_D="23fe861a-5a44-4eaa-83a5-3cd7845396d1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="b3c7b10d-32cc-4f86-89ff-18b35045bc53" name="utl_smtp$data" is-trigger-function="0" unique-function-name="utl_smtp$data" is-aggregate="f" language-name="plpgsql" context="utl_smtp$data" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;,character varying" is-returning-set="f" ret-datatype="utl_smtp$reply" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, body character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22478" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, body character varying" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$data(c aws_oracle_ext.&quot;utl_smtp$connection&quot;, body character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  l_reply aws_oracle_ext.utl_smtp$reply;
begin

  insert into utl_smtp$new_message( msg_body ) values( body );

  l_reply.code := 250;
  l_reply.text := 'Requested mail action okay, completed';

  return l_reply;
end;
]]></complex-attribute>
                        <category _I_D="c11def73-7178-49d2-bb18-2249b97062b2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="c3a34f3f-7fc8-4cd1-8df7-ba534a0b9bd6" name="utl_smtp$ehlo" is-trigger-function="0" unique-function-name="utl_smtp$ehlo" is-aggregate="f" language-name="plpgsql" context="utl_smtp$ehlo" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;,character varying" is-returning-set="f" ret-datatype="utl_smtp$replies" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, domain character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22479" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, domain character varying" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$ehlo(c aws_oracle_ext.&quot;utl_smtp$connection&quot;, domain character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  l_reply aws_oracle_ext.utl_smtp$reply;
begin
  l_reply.code := 250;
  l_reply.text := '250-AUTH';
  return ARRAY[ l_reply ]::aws_oracle_ext.utl_smtp$replies;
end;
]]></complex-attribute>
                        <category _I_D="939f517e-3477-4377-a10d-e1121d614ef8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="06e471d2-a982-4032-89ca-67ab6c30ba3c" name="utl_smtp$helo" is-trigger-function="0" unique-function-name="utl_smtp$helo" is-aggregate="f" language-name="plpgsql" context="utl_smtp$helo" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;,character varying" is-returning-set="f" ret-datatype="utl_smtp$reply" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, domain character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22480" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, domain character varying" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$helo(c aws_oracle_ext.&quot;utl_smtp$connection&quot;, domain character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  l_reply aws_oracle_ext.utl_smtp$reply;
begin
  l_reply.code := 250;
  l_reply.text := 'Hello ' || domain;
  return l_reply;
end;
]]></complex-attribute>
                        <category _I_D="ee932d0c-9659-4899-8101-a597309bed6b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="e16aad97-44dc-4fe4-9e76-e8f80660cf11" name="utl_smtp$mail" is-trigger-function="0" unique-function-name="utl_smtp$mail" is-aggregate="f" language-name="plpgsql" context="utl_smtp$mail" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;,character varying,character varying" is-returning-set="f" ret-datatype="utl_smtp$reply" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, sender character varying, parameters character varying DEFAULT ''::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22481" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, sender character varying, parameters character varying" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$mail(c aws_oracle_ext.&quot;utl_smtp$connection&quot;, sender character varying, parameters character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  l_reply aws_oracle_ext.utl_smtp$reply;
  l_sender character varying := sender;
begin
  /* Temporary table to store message parts */
  drop table if exists utl_smtp$new_message;
  create temporary table if not exists utl_smtp$new_message
    ( msg_part serial
    , msg_body text );
  /* Temporary table to store recepients */
  drop table if exists utl_smtp$recipients;
  create temporary table if not exists utl_smtp$recipients
    ( num serial
    , address character varying( 512 ) );

  update tutl_smtp$connection set sender = l_sender;

  l_reply.code := 250;
  l_reply.text := 'Requested mail action okay, completed';
  return l_reply;
end;
]]></complex-attribute>
                        <category _I_D="369763b4-3d6c-47a2-bf54-24a6063248f9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="399eb627-2ea6-40e6-8ff8-052c79d62487" name="utl_smtp$noop" is-trigger-function="0" unique-function-name="utl_smtp$noop" is-aggregate="f" language-name="plpgsql" context="utl_smtp$noop" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;" is-returning-set="f" ret-datatype="utl_smtp$reply" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22482" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$noop(c aws_oracle_ext.&quot;utl_smtp$connection&quot;)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  l_reply aws_oracle_ext.utl_smtp$reply;
begin
  l_reply.code := 250;
  l_reply.text := 'Requested mail action okay, completed';
  return l_reply;
end;
]]></complex-attribute>
                        <category _I_D="b739f9ec-fb6e-4457-9ea3-4888ae56a3ba" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="05b6d76c-196a-4ce0-920f-928536e11e1b" name="utl_smtp$open_connection" is-trigger-function="0" unique-function-name="utl_smtp$open_connection" is-aggregate="f" language-name="plpgsql" context="utl_smtp$open_connection" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,double precision,double precision,character varying,character varying,boolean" is-returning-set="f" ret-datatype="utl_smtp$connection" function-arguments="host character varying, port double precision DEFAULT 25, tx_timeout double precision DEFAULT NULL::double precision, wallet_path character varying DEFAULT NULL::character varying, wallet_password character varying DEFAULT NULL::character varying, secure_connection_before_smtp boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="6" function-id="22484" volatility="VOLATILE" is-window="f" function-identity-arguments="host character varying, port double precision, tx_timeout double precision, wallet_path character varying, wallet_password character varying, secure_connection_before_smtp boolean" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$open_connection(host character varying, port double precision, tx_timeout double precision, wallet_path character varying, wallet_password character varying, secure_connection_before_smtp boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
  l_result aws_oracle_ext.utl_smtp$connection;
begin

  drop table if exists tutl_smtp$connection;

  create temporary table if not exists tutl_smtp$connection
    ( conn aws_oracle_ext.utl_smtp$connection
    , sender character varying );

  l_result.host := host;
  l_result.port := port;
  l_result.tx_timeout := tx_timeout;

  insert into tutl_smtp$connection( conn ) values( l_result );

  return l_result;

end;
]]></complex-attribute>
                        <category _I_D="05524b2f-a678-403e-96df-ec4842864128" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="8d5f3ad9-5366-44db-b78b-b0fbac7ad5f3" name="utl_smtp$open_connection2" is-trigger-function="0" unique-function-name="utl_smtp$open_connection2" is-aggregate="f" language-name="plpgsql" context="utl_smtp$open_connection2" subcategories-loading="none" object-loading="extended" arguments-datatypes="character varying,double precision,aws_oracle_ext.&quot;utl_smtp$connection&quot;,double precision,character varying,character varying,boolean" is-returning-set="f" ret-datatype="utl_smtp$reply" function-arguments="host character varying, port double precision DEFAULT 25, c aws_oracle_ext.&quot;utl_smtp$connection&quot; DEFAULT NULL::aws_oracle_ext.&quot;utl_smtp$connection&quot;, tx_timeout double precision DEFAULT NULL::double precision, wallet_path character varying DEFAULT NULL::character varying, wallet_password character varying DEFAULT NULL::character varying, secure_connection_before_smtp boolean DEFAULT false" schema-id="21999" function-type="RET_SCALAR" count-arguments="7" function-id="22483" volatility="VOLATILE" is-window="f" function-identity-arguments="host character varying, port double precision, c aws_oracle_ext.&quot;utl_smtp$connection&quot;, tx_timeout double precision, wallet_path character varying, wallet_password character varying, secure_connection_before_smtp boolean" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$open_connection2(host character varying, port double precision, c aws_oracle_ext.&quot;utl_smtp$connection&quot;, tx_timeout double precision, wallet_path character varying, wallet_password character varying, secure_connection_before_smtp boolean)">
                        <complex-attribute name="sql"><![CDATA[
declare
  l_conn aws_oracle_ext.utl_smtp$connection;
  
  l_result aws_oracle_ext.utl_smtp$reply;
begin
  l_conn := aws_oracle_ext.utl_smtp$open_connection
    ( host, port, tx_timeout, wallet_path, wallet_password, secure_connection_before_smtp );

  l_result.code := 220;
  l_result.text := host || ' Service ready.';

  return l_result;
end;
]]></complex-attribute>
                        <category _I_D="5d0dcf1e-dfe3-47f9-bdd5-9ade127c2800" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="f9a9adf3-4e23-496f-ad83-b387ffb8edab" name="utl_smtp$open_data" is-trigger-function="0" unique-function-name="utl_smtp$open_data" is-aggregate="f" language-name="plpgsql" context="utl_smtp$open_data" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;" is-returning-set="f" ret-datatype="utl_smtp$reply" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22485" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$open_data(c aws_oracle_ext.&quot;utl_smtp$connection&quot;)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  l_reply aws_oracle_ext.utl_smtp$reply;
begin
  l_reply.code := 354;
  l_reply.text := 'Start mail input end <CRLF>.<CRLF>';

  return l_reply;
end;
]]></complex-attribute>
                        <category _I_D="3c562ed3-f81f-4c6b-ac29-90b8ee573e0c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="5460e170-f5e2-43f9-9bc0-185f292fd725" name="utl_smtp$quit" is-trigger-function="0" unique-function-name="utl_smtp$quit" is-aggregate="f" language-name="plpgsql" context="utl_smtp$quit" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;" is-returning-set="f" ret-datatype="utl_smtp$reply" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22486" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$quit(c aws_oracle_ext.&quot;utl_smtp$connection&quot;)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE 
    l_response JSON;
    l_reply aws_oracle_ext.utl_smtp$reply;
    l_message TEXT;
    l_sender TEXT;
    vto TEXT[];
    verror TEXT;
BEGIN

    SELECT sender,
        message,
        recipient_list
    INTO strict l_sender,
        l_message,
        vto
    FROM
    (     
        SELECT ct.sender,
        (
            SELECT STRING_AGG(msg_body, '') AS msg_body 
            FROM
            (
                SELECT msg_body
                FROM utl_smtp$new_message
                order by msg_part 
            ) r
        ) AS message,
        (
            SELECT ARRAY_AGG(address)
            FROM utl_smtp$recipients
        ) AS recipient_list
        FROM tutl_smtp$connection ct
       ) x;

    l_response := aws_oracle_ext.awslambda_fn
    (
        aws_oracle_ext.get_service_setting
        (
            'MAIL',
            'LAMBDA_ARN'
        ),
        JSON_BUILD_OBJECT
        (
            'service', 'ses',
            'args', JSON_BUILD_OBJECT
            (
                'Destinations', vto,
                'source', l_sender,
                'rawmessage', JSON_BUILD_OBJECT
                (
                    'Data', l_message
                )
            )
        )
    );

    verror := l_response ->> 'Error';

    IF  COALESCE(verror, '') <> '' THEN

        RAISE EXCEPTION 'Email sending failed: %', verror;

    END IF;

    l_reply.code := 221;
    l_reply.text := 'Service closing transmission channel';
    
    RETURN l_reply;

END;
]]></complex-attribute>
                        <category _I_D="0200a0b1-a41d-4a5b-b70a-f46249694c47" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="62a75162-055c-430f-8524-3ce7ade46f84" name="utl_smtp$rcpt" is-trigger-function="0" unique-function-name="utl_smtp$rcpt" is-aggregate="f" language-name="plpgsql" context="utl_smtp$rcpt" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;,character varying,character varying" is-returning-set="f" ret-datatype="utl_smtp$reply" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, recipient character varying, parameters character varying DEFAULT NULL::character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22487" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, recipient character varying, parameters character varying" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$rcpt(c aws_oracle_ext.&quot;utl_smtp$connection&quot;, recipient character varying, parameters character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  l_reply aws_oracle_ext.utl_smtp$reply;
begin

  insert into utl_smtp$recipients( address ) values( recipient );

  l_reply.code := 250;
  l_reply.text := 'Requested mail action okay, completed';
  return l_reply;
end;
]]></complex-attribute>
                        <category _I_D="138b2e6a-dd6a-4d9b-927d-c3717cd7d5ba" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="3349e5d8-82af-45ef-b5f5-4f039b0385fd" name="utl_smtp$rset" is-trigger-function="0" unique-function-name="utl_smtp$rset" is-aggregate="f" language-name="plpgsql" context="utl_smtp$rset" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;" is-returning-set="f" ret-datatype="utl_smtp$reply" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22488" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$rset(c aws_oracle_ext.&quot;utl_smtp$connection&quot;)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  l_reply aws_oracle_ext.utl_smtp$reply;
begin

  delete from utl_mail$recipients;

  delete from utl_mail$new_message;

  l_reply.code := 250;
  l_reply.text := 'Requested mail action okay, completed';
  return l_reply;

end;
]]></complex-attribute>
                        <category _I_D="e1eeecd4-c501-4c63-86d2-65111d8e56f6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="96253533-bc73-4e81-9bbd-7aa0758d70d7" name="utl_smtp$starttls" is-trigger-function="0" unique-function-name="utl_smtp$starttls" is-aggregate="f" language-name="plpgsql" context="utl_smtp$starttls" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;" is-returning-set="f" ret-datatype="utl_smtp$reply" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;" schema-id="21999" function-type="RET_SCALAR" count-arguments="1" function-id="22489" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$starttls(c aws_oracle_ext.&quot;utl_smtp$connection&quot;)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  l_reply aws_oracle_ext.utl_smtp$reply;
begin
  l_reply.code := 220;
  l_reply.text := 'Go ahead';
  return l_reply;
end;
]]></complex-attribute>
                        <category _I_D="0d578edb-e04b-4a33-89be-e1fcf343f846" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="a5b8b2f0-8609-447d-aa09-d43836a290be" name="utl_smtp$write_data" is-trigger-function="0" unique-function-name="utl_smtp$write_data" is-aggregate="f" language-name="plpgsql" context="utl_smtp$write_data" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;,character varying" is-returning-set="f" ret-datatype="void" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, data character varying" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22490" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, data character varying" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$write_data(c aws_oracle_ext.&quot;utl_smtp$connection&quot;, data character varying)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  l_reply aws_oracle_ext.utl_smtp$reply;
begin
  insert into utl_smtp$new_message( msg_body ) values( data );

  return;
end;
]]></complex-attribute>
                        <category _I_D="1086e7c1-775a-4f5f-929b-2b9e36f95501" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="47afcaa1-3481-4ab6-b949-9532716cb6a3" name="utl_smtp$write_raw_data" is-trigger-function="0" unique-function-name="utl_smtp$write_raw_data" is-aggregate="f" language-name="plpgsql" context="utl_smtp$write_raw_data" subcategories-loading="none" object-loading="extended" arguments-datatypes="aws_oracle_ext.&quot;utl_smtp$connection&quot;,bytea" is-returning-set="f" ret-datatype="void" function-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, data bytea" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22491" volatility="VOLATILE" is-window="f" function-identity-arguments="c aws_oracle_ext.&quot;utl_smtp$connection&quot;, data bytea" overload-function-count="1" proc-language="plpgsql" function-signature="utl_smtp$write_raw_data(c aws_oracle_ext.&quot;utl_smtp$connection&quot;, data bytea)">
                        <complex-attribute name="sql"><![CDATA[
declare 
  l_reply aws_oracle_ext.utl_smtp$reply;
begin
  insert into utl_smtp$new_message_data( msg_body ) values( data );

  return;
end;
]]></complex-attribute>
                        <category _I_D="3482935e-4c72-4be5-8d75-ac585a67d43a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="39a19958-20cc-4d56-8830-b20f8f080261" name="utl_url$escape" is-trigger-function="0" unique-function-name="utl_url$escape" is-aggregate="f" language-name="plpgsql" context="utl_url$escape" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,boolean,text" comment="This function returns a URL with illegal characters (and optionally reserved characters) escaped using the %2-digit-hex-code format." is-returning-set="f" ret-datatype="text" function-arguments="p_url text, p_escape_reserved boolean DEFAULT false, p_url_charset text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="3" function-id="22492" volatility="VOLATILE" is-window="f" function-identity-arguments="p_url text, p_escape_reserved boolean, p_url_charset text" overload-function-count="1" proc-language="plpgsql" function-signature="utl_url$escape(p_url text, p_escape_reserved boolean, p_url_charset text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
   v_err_message TEXT;
   v_encoded_url TEXT;
   v_temp_char VARCHAR;
   v_char_reqexp VARCHAR;
   v_url_charset VARCHAR;
   v_ascii_val INTEGER;
   v_temp_charcode BYTEA;
BEGIN
   /* Requires functions to be installed in "aws_oracle_ext" schema:
      - get_charset_name.
    */

   -- Determining the set of unescapable characters
   v_char_reqexp := CASE
                       WHEN p_escape_reserved THEN '[0-9a-zA-Z\-_.!~*`()]+'
                       ELSE '[0-9a-zA-Z\-_.!~*`();/?:@&=+$,\[\]]+'
                    END;

   -- Determining the charset for character encoding
   v_url_charset := CASE
                       WHEN p_url_charset IS NULL THEN pg_client_encoding()
                       ELSE aws_oracle_ext.get_charset_name(p_url_charset)
                    END;

   -- Iterating over all characters in the string
   FOR i_charpos IN 1..char_length(coalesce(p_url, ''))
   LOOP
      v_temp_char := substr(p_url, i_charpos, 1);

      -- Skipping unescapable characters and convert others
      IF (v_temp_char ~ v_char_reqexp) THEN
         v_encoded_url := concat(v_encoded_url, v_temp_char);
      ELSE
         -- Encoding character to selected charset
         v_temp_charcode := convert_to(v_temp_char, v_url_charset);
         
         -- Casting each character byte to hex and escaping it with "%"
         FOR i_charcode IN 1..octet_length(v_temp_charcode)
         LOOP
            v_temp_char := upper(encode(substring(v_temp_charcode, i_charcode, 1), 'hex'));
            v_encoded_url := concat(v_encoded_url, '%', v_temp_char);
         END LOOP;
      END IF;
   END LOOP;

   RETURN v_encoded_url;
EXCEPTION
   WHEN untranslatable_character THEN
      GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;

      RAISE USING MESSAGE := format('Failed to encode character "%s" to %s charset (Oracle %s).',
                                    v_temp_char,
                                    upper(v_url_charset),
                                    upper(p_url_charset)),
                  DETAIL := concat(v_err_message, '.'),
                  HINT := format('Try to use another charset (not %s) in order to encode mentioned character (symbol).',
                                 upper(p_url_charset));
END;
]]></complex-attribute>
                        <category _I_D="16e8a97b-208f-4ce4-a474-aeb5dd532cfe" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="d56a4ee4-7036-4a8f-87ea-1dc94085d571" name="utl_url$unescape" is-trigger-function="0" unique-function-name="utl_url$unescape" is-aggregate="f" language-name="plpgsql" context="utl_url$unescape" subcategories-loading="none" object-loading="extended" arguments-datatypes="text,text" comment="This function unescapes the escape character sequences to its original form in a URL, to convert the %XX escape character sequences to the original characters." is-returning-set="f" ret-datatype="text" function-arguments="p_url text, p_url_charset text DEFAULT NULL::text" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="22493" volatility="VOLATILE" is-window="f" function-identity-arguments="p_url text, p_url_charset text" overload-function-count="1" proc-language="plpgsql" function-signature="utl_url$unescape(p_url text, p_url_charset text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
   v_err_message TEXT;
   v_char_code TEXT;
   v_char_byte BYTEA;
   v_url_charset VARCHAR;
   v_decoded_url BYTEA := '';
BEGIN
   /* Requires functions to be installed in "aws_oracle_ext" schema:
      - get_charset_name.
    */

   -- Determining the charset for character decoding
   v_url_charset := CASE
                       WHEN p_url_charset IS NULL THEN pg_client_encoding()
                       ELSE aws_oracle_ext.get_charset_name(p_url_charset)
                    END;

   -- Iterating over all significant characters in the string
   FOR v_char_code IN
   (SELECT unnest(regexp_matches(p_url, '(%..|.)', 'g')) url_char)
   LOOP
      -- Unescaping "%XX" characters
      v_char_byte := CASE
                        WHEN v_char_code !~ '%' THEN v_char_code::BYTEA
                        ELSE decode(substring(v_char_code, 2, 2), 'hex')
                     END;

      -- Concatenating into resulting byte string
      v_decoded_url := v_decoded_url || v_char_byte;
   END LOOP;

   RETURN convert_from(v_decoded_url, v_url_charset);
EXCEPTION
   WHEN character_not_in_repertoire THEN
      GET STACKED DIAGNOSTICS v_err_message = MESSAGE_TEXT;

      RAISE USING MESSAGE := format('Failed to decode url byte string "%s" to %s charset (Oracle %s).',
                                    v_decoded_url::TEXT,
                                    upper(v_url_charset),
                                    upper(p_url_charset)),
                  DETAIL := concat(v_err_message, '.'),
                  HINT := format('Try to use another charset (not %s) or correct initial url string.',
                                 upper(p_url_charset));
END;
]]></complex-attribute>
                        <category _I_D="2512b958-e4be-4700-baed-cf4b1f6a08ce" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="85882927-7680-4795-9d6f-5060a7e27f65" name="wrap_refcursor" is-trigger-function="0" unique-function-name="wrap_refcursor" is-aggregate="f" language-name="plpgsql" context="wrap_refcursor" subcategories-loading="none" object-loading="extended" arguments-datatypes="refcursor,refcursor" is-returning-set="f" ret-datatype="refcursor" function-arguments="refcursor, INOUT refcursor" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23130" volatility="VOLATILE" is-window="f" function-identity-arguments="refcursor, INOUT refcursor" overload-function-count="1" proc-language="plpgsql" function-signature="wrap_refcursor(refcursor, INOUT refcursor)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    vstmt TEXT;
BEGIN
    
	vstmt := $1;

	SELECT pc.statement 
	INTO vstmt
	FROM pg_cursors pc
	WHERE pc.name = vstmt;

	OPEN $2 FOR EXECUTE vstmt;

	CLOSE $1;
    
END;
]]></complex-attribute>
                        <category _I_D="291b6f20-92d4-48c5-94a6-6faa93f6bea9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                    <function _I_D="4469c27c-823b-44ca-9de3-cfc897142d62" name="xmltype$tojson" is-trigger-function="0" unique-function-name="xmltype$tojson" is-aggregate="f" language-name="plpgsql" context="xmltype$tojson" subcategories-loading="none" object-loading="extended" arguments-datatypes="xml,json" is-returning-set="f" ret-datatype="json" function-arguments="pxml xml, ptargetjobj json" schema-id="21999" function-type="RET_SCALAR" count-arguments="2" function-id="23049" volatility="STABLE" is-window="f" function-identity-arguments="pxml xml, ptargetjobj json" overload-function-count="1" proc-language="plpgsql" function-signature="xmltype$tojson(pxml xml, ptargetjobj json)">
                        <complex-attribute name="sql"><![CDATA[
declare
    ILIMIT constant integer := 1024;
    PDELIMETER constant varchar(1) := '/';
    PROOT constant varchar(2) := '//';
    XVALUE constant varchar(7) := '/text()';
    XSCHEMA constant varchar(3) := 'xsi';
    XURI constant varchar(41) := 'http://www.w3.org/2001/XMLSchema-instance';

    mainData aws_oracle_ext.xmltype$txml2json[];
    dummyData aws_oracle_ext.xmltype$txml2json[];
    lnMx int;
    lnMn int;
begin

	if pXML is null or pTargetJObj is null then
	    raise exception 'XMLTYPE.Null Exception.' using hint = '29532';
	end if;

	with recursive rStructure (iNum, rNum, pNum, recFullKey, recKey, recValue, recValType)
	               as (select 0 as iNum,
		                      row_number() over () as rNum,
		                      0::bigint as pNum,
		                      t.key as recFullKey,
		                      t.key as recKey,
		                      t.value as recValue,
		                      json_typeof(t.value) as recValType
		                 from json_each(pTargetJObj) t
		                union all
		               select r.iNum + 1 as iNum,
		                       row_number() over () as rNum,
		                       r.rNum as pNum,
		                       r.recFullKey||PDELIMETER||t.key as recFullKey,
		                       t.key as recKey,
		                       t.value as recValue,
		                       json_typeof(t.value) as recValType
		                  from rStructure r left join json_each(r.recValue) t on r.recValue is not null
		                 where r.recValType = json_typeof(pTargetJObj)
		                   and r.iNum < ILIMIT
		               ),
				   rMatchData (iNum, rNum, pNum, recFullKey, recKey, recValue, recValType)
				   as (select r.iNum as iNum,
			              	  r.rNum as rNum,
			              	  r.pNum as pNum,
			              	  r.recFullKey as recFullKey,
			              	  r.recKey as recKey,
			              	  to_json(case when r.recValType != json_typeof(pTargetJObj) then
								              coalesce((xpath(PROOT||r.recFullKey||XVALUE, pXML, array[array[XSCHEMA, XURI]]))[1]::text,
								                       (xpath(PROOT||r.recFullKey, pXML, array[array[XSCHEMA, XURI]]))[1]::text
						                     		  )
					                       else null end
					                  ) as recValue,
			                  r.recValType as recValType
			             from rStructure r
			            where r.recFullKey is not null
			          )
    select array_agg(row(d.iNum, d.rNum, d.pNum, d.recKey, d.recValue)::aws_oracle_ext.xmltype$txml2json)
      into mainData
      from rMatchData d;

    select max(iNum), min(iNum)
      into lnMx, lnMn
      from unnest(mainData);

    select array_agg(row(d.iNum, null, d.pNum, null, d.recValue)::aws_oracle_ext.xmltype$txml2json)
      into dummyData
      from (select d1.iNum, d1.pNum, json_object_agg(d1.recKey, d1.recValue) recValue
              from unnest(mainData) d1
             where d1.iNum = lnMx
             group by d1.iNum, d1.pNum
           ) d;

    for i in reverse lnMx -1 .. lnMn loop
		 select array_agg(row(d.iNum, null, d.pNum, null, d.recValue)::aws_oracle_ext.xmltype$txml2json)
		   into dummyData
		   from (select d1.iNum, d1.pNum, json_object_agg(d1.recKey, coalesce(d1.recValue, g1.recValue)) recValue
				   from unnest(mainData) d1 left join unnest(dummyData) g1 on d1.iNum = g1.iNum -1 and d1.rNum = g1.pNum
				  where d1.iNum = i
				  group by d1.iNum, d1.pNum
		        ) d;
	end loop;

    return dummyData[1].recValue;
end; ]]></complex-attribute>
                        <category _I_D="84b1d556-499c-497e-a09f-6b45ac351e50" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                </category>
                <category _I_D="02261968-2c91-4801-a700-57367bcdf8a4" name="Trigger functions" order-num="9" objects-loading="extended" subcategories-loading="none" child-type="function">
                    <function _I_D="3eb8c7b0-649d-4991-b98e-1d49dbce8c53" name="refresh_dba_directories" is-trigger-function="1" unique-function-name="refresh_dba_directories" is-aggregate="f" language-name="plpgsql" context="refresh_dba_directories" subcategories-loading="none" object-loading="extended" comment="This trigger function refreshes the sys_dba_directories materialized view." is-returning-set="f" ret-datatype="trigger" schema-id="21999" function-type="RET_SCALAR" count-arguments="0" function-id="23518" volatility="VOLATILE" is-window="f" overload-function-count="1" proc-language="plpgsql" function-signature="refresh_dba_directories()">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    REFRESH MATERIALIZED VIEW aws_oracle_ext.sys_dba_directories;

    RETURN NULL;
END
]]></complex-attribute>
                        <category _I_D="13b542ea-fb06-45d3-917e-856c6a5a68c4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </function>
                </category>
                <category _I_D="9dd62276-6573-4465-81b1-9411efaf784f" name="Procedures" order-num="10" objects-loading="extended" subcategories-loading="none" child-type="procedure">
                    <procedure _I_D="b8ec11e9-e7fe-4a50-a612-3ae435860090" schema-id="21999" name="dbms_lob$append" context="dbms_lob$append(INOUT dest_lob bytea, IN src_lob bytea)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT dest_lob bytea, IN src_lob bytea)" unique-function-name="dbms_lob$append(INOUT dest_lob bytea, IN src_lob bytea)" is-aggregate="f" language-name="plpgsql" routine-number="23312" comment="This procedure appends the contents of a source internal binary LOB to a destination binary LOB. It appends the complete source LOB." arguments-datatypes="bytea,bytea" is-returning-set="f" ret-datatype="record" function-arguments="INOUT dest_lob bytea, IN src_lob bytea" function-type="RET_SCALAR" count-arguments="2" function-id="23312" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT dest_lob bytea, IN src_lob bytea" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$append(INOUT dest_lob bytea, IN src_lob bytea)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    -- Checking input arguments
    IF (dest_lob IS NULL OR
        src_lob IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    END IF;

    dest_lob := dest_lob || src_lob;
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
END;
]]></complex-attribute>
                        <category _I_D="a0a7ba73-58da-4b7c-b4cc-d883de7ff3c2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="af9269a1-420d-4d90-a012-c5eca5a7ebca" schema-id="21999" name="dbms_lob$append" context="dbms_lob$append(INOUT dest_lob character varying, IN src_lob text)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT dest_lob character varying, IN src_lob text)" unique-function-name="dbms_lob$append(INOUT dest_lob character varying, IN src_lob text)" is-aggregate="f" language-name="plpgsql" routine-number="23311" comment="This procedure appends the contents of a source internal character LOB to a destination character LOB. It appends the complete source LOB." arguments-datatypes="character varying,text" is-returning-set="f" ret-datatype="record" function-arguments="INOUT dest_lob character varying, IN src_lob text" function-type="RET_SCALAR" count-arguments="2" function-id="23311" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT dest_lob character varying, IN src_lob text" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$append(INOUT dest_lob character varying, IN src_lob text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_dest_lob TEXT;
BEGIN
    v_dest_lob := dest_lob;

    CALL aws_oracle_ext.dbms_lob$append(dest_lob => v_dest_lob,
                                        src_lob => src_lob);
    dest_lob := v_dest_lob;
END;
]]></complex-attribute>
                        <category _I_D="08640b63-f3bd-4437-b1d3-da41c139fc78" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="72beebe9-6345-4be6-85de-c1e81fc18ed0" schema-id="21999" name="dbms_lob$append" context="dbms_lob$append(INOUT dest_lob text, IN src_lob text)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT dest_lob text, IN src_lob text)" unique-function-name="dbms_lob$append(INOUT dest_lob text, IN src_lob text)" is-aggregate="f" language-name="plpgsql" routine-number="23310" comment="This procedure appends the contents of a source internal character LOB to a destination character LOB. It appends the complete source LOB." arguments-datatypes="text,text" is-returning-set="f" ret-datatype="record" function-arguments="INOUT dest_lob text, IN src_lob text" function-type="RET_SCALAR" count-arguments="2" function-id="23310" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT dest_lob text, IN src_lob text" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$append(INOUT dest_lob text, IN src_lob text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    -- Checking input arguments
    IF (dest_lob IS NULL OR
        src_lob IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    END IF;

    dest_lob := dest_lob || src_lob;
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
END;
]]></complex-attribute>
                        <category _I_D="52f12b9f-ca3b-4009-9cdc-5c65228d84f1" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="0cb6036e-fb80-443c-ac85-d1bf32a04cc1" schema-id="21999" name="dbms_lob$copy" context="dbms_lob$copy(INOUT dest_lob bytea, IN src_lob bytea, IN amount numeric, IN dest_offset numeric, IN src_offset numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT dest_lob bytea, IN src_lob bytea, IN amount numeric, IN dest_offset numeric, IN src_offset numeric)" unique-function-name="dbms_lob$copy(INOUT dest_lob bytea, IN src_lob bytea, IN amount numeric, IN dest_offset numeric, IN src_offset numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23317" comment="This procedure copies all, or a part of, a source binary LOB to a destination binary LOB. You can specify the offsets for both the source and destination LOBs, and the bytes to copy." arguments-datatypes="bytea,bytea,numeric,numeric,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT dest_lob bytea, IN src_lob bytea, IN amount numeric, IN dest_offset numeric DEFAULT 1, IN src_offset numeric DEFAULT 1" function-type="RET_SCALAR" count-arguments="5" function-id="23317" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT dest_lob bytea, IN src_lob bytea, IN amount numeric, IN dest_offset numeric, IN src_offset numeric" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$copy(INOUT dest_lob bytea, IN src_lob bytea, IN amount numeric, IN dest_offset numeric, IN src_offset numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_dest_before BYTEA;
    v_src_part BYTEA;
    v_dest_after BYTEA;
    v_amount NUMERIC;
BEGIN
    -- Checking input arguments
    IF (dest_lob IS NULL OR
        src_lob IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    ELSIF (amount IS NULL OR
           dest_offset IS NULL OR
           src_offset IS NULL)
    THEN
        -- Numeric or value error
        RAISE zero_length_character_string;
    ELSIF (amount < 1 OR
           dest_offset < 1 OR
           src_offset < 1)
    THEN
        -- Argument is out of range
        RAISE check_violation;
    END IF;

    -- NUMERIC -> INTEGER DBMS_LOB.LOBMAXSIZE workaround
    v_amount := CASE amount
                   WHEN aws_oracle_ext.dbms_lob$lobmaxsize()
                   THEN 2147483647 -- Maximum positive value for data type INTEGER
                   ELSE amount
                END;

    -- Extracting left part of the object
    v_dest_before := substr(dest_lob, 1, floor(dest_offset)::INTEGER - 1);

    -- Extracting the substring from the source object
    v_src_part := substr(src_lob, floor(src_offset)::INTEGER, floor(v_amount)::INTEGER);

    -- Extracting right part of the object
    v_dest_after := substr(dest_lob, octet_length(v_src_part) + octet_length(v_dest_before) + 1);

    -- Constructing the resulting object
    dest_lob := v_dest_before || v_src_part || v_dest_after;
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
    WHEN zero_length_character_string THEN
        RAISE USING MESSAGE := 'Numeric or value error.',
                    DETAIL := 'Amount of bytes to copy, source and destination offset could not be NULL.',
                    HINT := '-6502';
    WHEN check_violation THEN
        RAISE USING MESSAGE := format('Argument %s is invalid or out of range.',
                                      CASE
                                         WHEN amount < 1 THEN 3
                                         WHEN dest_offset < 1 THEN 4
                                         WHEN src_offset < 1 THEN 5
                                      END),
                    DETAIL := 'Amount of bytes to copy, source and destination offset must be 1 or above.',
                    HINT := '-21560';
END;
]]></complex-attribute>
                        <category _I_D="63ad7898-7dd7-4afb-9982-3c24ebbc0f8a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="59059664-ef93-49f6-b99f-3d57389ef6b7" schema-id="21999" name="dbms_lob$copy" context="dbms_lob$copy(INOUT dest_lob character varying, IN src_lob text, IN amount numeric, IN dest_offset numeric, IN src_offset numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT dest_lob character varying, IN src_lob text, IN amount numeric, IN dest_offset numeric, IN src_offset numeric)" unique-function-name="dbms_lob$copy(INOUT dest_lob character varying, IN src_lob text, IN amount numeric, IN dest_offset numeric, IN src_offset numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23316" comment="This procedure copies all, or a part of, a source character LOB to a destination character LOB. You can specify the offsets for both the source and destination LOBs, and the characters to copy." arguments-datatypes="character varying,text,numeric,numeric,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT dest_lob character varying, IN src_lob text, IN amount numeric, IN dest_offset numeric DEFAULT 1, IN src_offset numeric DEFAULT 1" function-type="RET_SCALAR" count-arguments="5" function-id="23316" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT dest_lob character varying, IN src_lob text, IN amount numeric, IN dest_offset numeric, IN src_offset numeric" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$copy(INOUT dest_lob character varying, IN src_lob text, IN amount numeric, IN dest_offset numeric, IN src_offset numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_dest_lob TEXT;
BEGIN
    v_dest_lob := dest_lob;

    CALL aws_oracle_ext.dbms_lob$copy(dest_lob => v_dest_lob,
                                      src_lob => src_lob,
                                      amount => amount,
                                      dest_offset => dest_offset,
                                      src_offset => src_offset);
    dest_lob := v_dest_lob;
END;
]]></complex-attribute>
                        <category _I_D="84c4c42f-c9e0-4f8b-9d0c-fb33f7653d59" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="44ea50b4-b50b-4809-a75b-131788b30891" schema-id="21999" name="dbms_lob$copy" context="dbms_lob$copy(INOUT dest_lob text, IN src_lob text, IN amount numeric, IN dest_offset numeric, IN src_offset numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT dest_lob text, IN src_lob text, IN amount numeric, IN dest_offset numeric, IN src_offset numeric)" unique-function-name="dbms_lob$copy(INOUT dest_lob text, IN src_lob text, IN amount numeric, IN dest_offset numeric, IN src_offset numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23315" comment="This procedure copies all, or a part of, a source character LOB to a destination character LOB. You can specify the offsets for both the source and destination LOBs, and the characters to copy." arguments-datatypes="text,text,numeric,numeric,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT dest_lob text, IN src_lob text, IN amount numeric, IN dest_offset numeric DEFAULT 1, IN src_offset numeric DEFAULT 1" function-type="RET_SCALAR" count-arguments="5" function-id="23315" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT dest_lob text, IN src_lob text, IN amount numeric, IN dest_offset numeric, IN src_offset numeric" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$copy(INOUT dest_lob text, IN src_lob text, IN amount numeric, IN dest_offset numeric, IN src_offset numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_dest_before TEXT;
    v_src_part TEXT;
    v_dest_after TEXT;
    v_amount NUMERIC;
BEGIN
    -- Checking input arguments
    IF (dest_lob IS NULL OR
        src_lob IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    ELSIF (amount IS NULL OR
           dest_offset IS NULL OR
           src_offset IS NULL)
    THEN
        -- Numeric or value error
        RAISE zero_length_character_string;
    ELSIF (amount < 1 OR
           dest_offset < 1 OR
           src_offset < 1)
    THEN
        -- Argument is out of range
        RAISE check_violation;
    END IF;

    -- NUMERIC -> INTEGER DBMS_LOB.LOBMAXSIZE workaround
    v_amount := CASE amount
                   WHEN aws_oracle_ext.dbms_lob$lobmaxsize()
                   THEN 2147483647 -- Maximum positive value for data type INTEGER
                   ELSE amount
                END;

    -- Extracting left part of the object
    v_dest_before := substr(dest_lob, 1, floor(dest_offset)::INTEGER - 1);

    -- Extracting the substring from the source object
    v_src_part := substr(src_lob, floor(src_offset)::INTEGER, floor(v_amount)::INTEGER);

    -- Extracting right part of the object
    v_dest_after := substr(dest_lob, char_length(v_src_part) + char_length(v_dest_before) + 1);

    -- Constructing the resulting object
    dest_lob := v_dest_before || v_src_part || v_dest_after;
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
    WHEN zero_length_character_string THEN
        RAISE USING MESSAGE := 'Numeric or value error.',
                    DETAIL := 'Amount of characters to copy, source and destination offset could not be NULL.',
                    HINT := '-6502';
    WHEN check_violation THEN
        RAISE USING MESSAGE := format('Argument %s is invalid or out of range.',
                                      CASE
                                         WHEN amount < 1 THEN 3
                                         WHEN dest_offset < 1 THEN 4
                                         WHEN src_offset < 1 THEN 5
                                      END),
                    DETAIL := 'Amount of characters to copy, source and destination offset must be 1 or above.',
                    HINT := '-21560';
END;
]]></complex-attribute>
                        <category _I_D="552f0f3b-0fc2-4828-878c-e33444326461" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="57094c21-8b38-4d1b-9eae-b4934d044032" schema-id="21999" name="dbms_lob$createtemporary" context="dbms_lob$createtemporary(INOUT lob_loc bytea)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc bytea)" unique-function-name="dbms_lob$createtemporary(INOUT lob_loc bytea)" is-aggregate="f" language-name="plpgsql" routine-number="23304" comment="This procedure initializes a binary large object (BLOB)." arguments-datatypes="bytea" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc bytea" function-type="RET_SCALAR" count-arguments="1" function-id="23304" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc bytea" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$createtemporary(INOUT lob_loc bytea)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    lob_loc := '\x'::BYTEA;
END;
]]></complex-attribute>
                        <category _I_D="0fdcb666-de12-4eb2-a2b4-85bf0e7f431a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="7f6a0da8-bfb9-405e-9082-423c9f6a57a6" schema-id="21999" name="dbms_lob$createtemporary" context="dbms_lob$createtemporary(INOUT lob_loc character varying)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc character varying)" unique-function-name="dbms_lob$createtemporary(INOUT lob_loc character varying)" is-aggregate="f" language-name="plpgsql" routine-number="23303" comment="This procedure initializes a character large object (CLOB)." arguments-datatypes="character varying" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc character varying" function-type="RET_SCALAR" count-arguments="1" function-id="23303" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc character varying" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$createtemporary(INOUT lob_loc character varying)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    lob_loc := NULL::VARCHAR;
END;
]]></complex-attribute>
                        <category _I_D="ee5842d0-b381-43d9-9c7f-aadb3cde85b0" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="dd56d7be-f3c4-40c9-9409-3c2dc5d7945a" schema-id="21999" name="dbms_lob$createtemporary" context="dbms_lob$createtemporary(INOUT lob_loc text)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc text)" unique-function-name="dbms_lob$createtemporary(INOUT lob_loc text)" is-aggregate="f" language-name="plpgsql" routine-number="23302" comment="This procedure initializes a character large object (CLOB)." arguments-datatypes="text" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc text" function-type="RET_SCALAR" count-arguments="1" function-id="23302" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc text" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$createtemporary(INOUT lob_loc text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    lob_loc := ''::TEXT;
END;
]]></complex-attribute>
                        <category _I_D="a83a2f07-fb62-4f03-b7b3-8ba8f666dd5a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="8062dfd1-6d5d-47f9-8433-aae8d363b7a3" schema-id="21999" name="dbms_lob$erase" context="dbms_lob$erase(INOUT lob_loc bytea, INOUT amount double precision, IN &quot;offset&quot; numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc bytea, INOUT amount double precision, IN &quot;offset&quot; numeric)" unique-function-name="dbms_lob$erase(INOUT lob_loc bytea, INOUT amount double precision, IN &quot;offset&quot; numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23325" comment="This procedure erases an entire binary LOB or part of a binary LOB." arguments-datatypes="bytea,double precision,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc bytea, INOUT amount double precision, IN &quot;offset&quot; numeric DEFAULT 1" function-type="RET_SCALAR" count-arguments="3" function-id="23325" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc bytea, INOUT amount double precision, IN &quot;offset&quot; numeric" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$erase(INOUT lob_loc bytea, INOUT amount double precision, IN &quot;offset&quot; numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount NUMERIC;
BEGIN
    v_amount := amount;

    CALL aws_oracle_ext.dbms_lob$erase(lob_loc => lob_loc,
                                       amount => v_amount,
                                       "offset" => "offset");
    amount := v_amount;
END;
]]></complex-attribute>
                        <category _I_D="de809783-8e9a-4a57-8a25-29e568230141" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="98d756f5-d5b4-4f6f-b4c8-89c8f09b4cc4" schema-id="21999" name="dbms_lob$erase" context="dbms_lob$erase(INOUT lob_loc bytea, INOUT amount integer, IN &quot;offset&quot; numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc bytea, INOUT amount integer, IN &quot;offset&quot; numeric)" unique-function-name="dbms_lob$erase(INOUT lob_loc bytea, INOUT amount integer, IN &quot;offset&quot; numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23326" comment="This procedure erases an entire character LOB or part of a character LOB." arguments-datatypes="bytea,integer,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc bytea, INOUT amount integer, IN &quot;offset&quot; numeric DEFAULT 1" function-type="RET_SCALAR" count-arguments="3" function-id="23326" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc bytea, INOUT amount integer, IN &quot;offset&quot; numeric" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$erase(INOUT lob_loc bytea, INOUT amount integer, IN &quot;offset&quot; numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount NUMERIC;
BEGIN
    v_amount := amount;

    CALL aws_oracle_ext.dbms_lob$erase(lob_loc => lob_loc,
                                       amount => v_amount,
                                       "offset" => "offset");
    amount := v_amount;
END;
]]></complex-attribute>
                        <category _I_D="2cf0737b-f53a-456a-b75e-916a14aecb14" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="2743660b-64ee-493f-a324-2db7bc5f70a9" schema-id="21999" name="dbms_lob$erase" context="dbms_lob$erase(INOUT lob_loc bytea, INOUT amount numeric, IN &quot;offset&quot; numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc bytea, INOUT amount numeric, IN &quot;offset&quot; numeric)" unique-function-name="dbms_lob$erase(INOUT lob_loc bytea, INOUT amount numeric, IN &quot;offset&quot; numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23324" comment="This procedure erases an entire binary LOB or part of a binary LOB." arguments-datatypes="bytea,numeric,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc bytea, INOUT amount numeric, IN &quot;offset&quot; numeric DEFAULT 1" function-type="RET_SCALAR" count-arguments="3" function-id="23324" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc bytea, INOUT amount numeric, IN &quot;offset&quot; numeric" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$erase(INOUT lob_loc bytea, INOUT amount numeric, IN &quot;offset&quot; numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount INTEGER;
    v_offset INTEGER;
    v_lob_len INTEGER;
BEGIN
    -- Checking input arguments
    IF (lob_loc IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    ELSIF (amount IS NULL OR
           "offset" IS NULL)
    THEN
        -- Numeric or value error
        RAISE zero_length_character_string;
    ELSIF (amount < 1 OR
           "offset" < 1)
    THEN
        -- Argument is out of range
        RAISE check_violation;
    END IF;

    -- Determining object length (bytes)
    v_lob_len := octet_length(lob_loc);

    -- Extracting integer part of offset
    v_offset := floor("offset")::INTEGER;

    -- Make sense only if offset lies within the object
    IF (v_lob_len >= v_offset)
    THEN
        -- Determining actual amount of bytes to erase
        amount := least(v_lob_len - v_offset + 1, amount);

        -- NUMERIC -> INTEGER DBMS_LOB.LOBMAXSIZE workaround
        v_amount := CASE amount
                       WHEN aws_oracle_ext.dbms_lob$lobmaxsize()
                       THEN 2147483647 -- Maximum positive value for data type INTEGER
                       ELSE floor(amount) -- Extracting integer part of amount
                    END;

        -- Erasing part of the object at the specified offset
        lob_loc := overlay(lob_loc placing ('\x' || repeat('00', v_amount))::BYTEA -- replacing gap with zero-bytes
                                      from v_offset
                                       for v_amount);
    END IF;
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
    WHEN zero_length_character_string THEN
        RAISE USING MESSAGE := 'Numeric or value error.',
                    DETAIL := 'Amount of bytes to erase and offset could not be NULL.',
                    HINT := '-6502';
    WHEN check_violation THEN
        RAISE USING MESSAGE := format('Argument %s is invalid or out of range.',
                                      CASE
                                         WHEN amount < 1 THEN 2
                                         WHEN "offset" < 1 THEN 3
                                      END),
                    DETAIL := 'Amount of bytes to erase and offset must be 1 or above.',
                    HINT := '-21560';
END;
]]></complex-attribute>
                        <category _I_D="cad4d451-45ca-4a16-a832-df48192354d6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="5fd4b48c-4b52-4bfa-b003-1112ac281e5a" schema-id="21999" name="dbms_lob$erase" context="dbms_lob$erase(INOUT lob_loc character varying, INOUT amount double precision, IN &quot;offset&quot; numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc character varying, INOUT amount double precision, IN &quot;offset&quot; numeric)" unique-function-name="dbms_lob$erase(INOUT lob_loc character varying, INOUT amount double precision, IN &quot;offset&quot; numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23322" comment="This procedure erases an entire character LOB or part of a character LOB." arguments-datatypes="character varying,double precision,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc character varying, INOUT amount double precision, IN &quot;offset&quot; numeric DEFAULT 1" function-type="RET_SCALAR" count-arguments="3" function-id="23322" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc character varying, INOUT amount double precision, IN &quot;offset&quot; numeric" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$erase(INOUT lob_loc character varying, INOUT amount double precision, IN &quot;offset&quot; numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_lob_loc TEXT;
    v_amount NUMERIC;
BEGIN
    v_lob_loc := lob_loc;
    v_amount := amount;

    CALL aws_oracle_ext.dbms_lob$erase(lob_loc => v_lob_loc,
                                       amount => v_amount,
                                       "offset" => "offset");
    lob_loc := v_lob_loc;
    amount := v_amount;
END;
]]></complex-attribute>
                        <category _I_D="74730607-8587-4e70-9137-633aba3f104c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="3f5393a9-ed9b-4c43-9de3-74f961082f20" schema-id="21999" name="dbms_lob$erase" context="dbms_lob$erase(INOUT lob_loc character varying, INOUT amount integer, IN &quot;offset&quot; numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc character varying, INOUT amount integer, IN &quot;offset&quot; numeric)" unique-function-name="dbms_lob$erase(INOUT lob_loc character varying, INOUT amount integer, IN &quot;offset&quot; numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23323" comment="This procedure erases an entire character LOB or part of a character LOB." arguments-datatypes="character varying,integer,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc character varying, INOUT amount integer, IN &quot;offset&quot; numeric DEFAULT 1" function-type="RET_SCALAR" count-arguments="3" function-id="23323" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc character varying, INOUT amount integer, IN &quot;offset&quot; numeric" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$erase(INOUT lob_loc character varying, INOUT amount integer, IN &quot;offset&quot; numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_lob_loc TEXT;
    v_amount NUMERIC;
BEGIN
    v_lob_loc := lob_loc;
    v_amount := amount;

    CALL aws_oracle_ext.dbms_lob$erase(lob_loc => v_lob_loc,
                                       amount => v_amount,
                                       "offset" => "offset");
    lob_loc := v_lob_loc;
    amount := v_amount;
END;
]]></complex-attribute>
                        <category _I_D="73972abc-26dd-4064-9d10-e98219077364" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="0647f5ec-04d1-432f-97e2-03d59c2f320f" schema-id="21999" name="dbms_lob$erase" context="dbms_lob$erase(INOUT lob_loc character varying, INOUT amount numeric, IN &quot;offset&quot; numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc character varying, INOUT amount numeric, IN &quot;offset&quot; numeric)" unique-function-name="dbms_lob$erase(INOUT lob_loc character varying, INOUT amount numeric, IN &quot;offset&quot; numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23321" comment="This procedure erases an entire character LOB or part of a character LOB." arguments-datatypes="character varying,numeric,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc character varying, INOUT amount numeric, IN &quot;offset&quot; numeric DEFAULT 1" function-type="RET_SCALAR" count-arguments="3" function-id="23321" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc character varying, INOUT amount numeric, IN &quot;offset&quot; numeric" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$erase(INOUT lob_loc character varying, INOUT amount numeric, IN &quot;offset&quot; numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_lob_loc TEXT;
BEGIN
    v_lob_loc := lob_loc;

    CALL aws_oracle_ext.dbms_lob$erase(lob_loc => v_lob_loc,
                                       amount => amount,
                                       "offset" => "offset");
    lob_loc := v_lob_loc;
END;
]]></complex-attribute>
                        <category _I_D="b611de52-2f13-4e12-b6a3-b43de29eab07" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="a25e4e0f-f7b6-46cb-8329-994274ef8593" schema-id="21999" name="dbms_lob$erase" context="dbms_lob$erase(INOUT lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric)" unique-function-name="dbms_lob$erase(INOUT lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23319" comment="This procedure erases an entire character LOB or part of a character LOB." arguments-datatypes="text,double precision,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric DEFAULT 1" function-type="RET_SCALAR" count-arguments="3" function-id="23319" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$erase(INOUT lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount NUMERIC;
BEGIN
    v_amount := amount;

    CALL aws_oracle_ext.dbms_lob$erase(lob_loc => lob_loc,
                                       amount => v_amount,
                                       "offset" => "offset");
    amount := v_amount;
END;
]]></complex-attribute>
                        <category _I_D="a67a8184-ee09-439b-b92a-3cf351913ed8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="cc5bb88b-a010-4b73-8bdb-35e15633b6a6" schema-id="21999" name="dbms_lob$erase" context="dbms_lob$erase(INOUT lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric)" unique-function-name="dbms_lob$erase(INOUT lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23320" comment="This procedure erases an entire character LOB or part of a character LOB." arguments-datatypes="text,integer,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric DEFAULT 1" function-type="RET_SCALAR" count-arguments="3" function-id="23320" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$erase(INOUT lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount NUMERIC;
BEGIN
    v_amount := amount;

    CALL aws_oracle_ext.dbms_lob$erase(lob_loc => lob_loc,
                                       amount => v_amount,
                                       "offset" => "offset");
    amount := v_amount;
END;
]]></complex-attribute>
                        <category _I_D="c3d6c1ee-7c91-4a26-8d26-052c4bd56cd7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="4ff2abff-cce2-4940-a218-da83125a90a5" schema-id="21999" name="dbms_lob$erase" context="dbms_lob$erase(INOUT lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric)" unique-function-name="dbms_lob$erase(INOUT lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23318" comment="This procedure erases an entire character LOB or part of a character LOB." arguments-datatypes="text,numeric,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric DEFAULT 1" function-type="RET_SCALAR" count-arguments="3" function-id="23318" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$erase(INOUT lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount INTEGER;
    v_offset INTEGER;
    v_lob_len INTEGER;
BEGIN
    -- Checking input arguments
    IF (lob_loc IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    ELSIF (amount IS NULL OR
           "offset" IS NULL)
    THEN
        -- Numeric or value error
        RAISE zero_length_character_string;
    ELSIF (amount < 1 OR
           "offset" < 1)
    THEN
        -- Argument is out of range
        RAISE check_violation;
    END IF;

    -- Determining object length (characters)
    v_lob_len := char_length(lob_loc);

    -- Extracting integer part of offset
    v_offset := floor("offset")::INTEGER;

    -- Make sense only if offset lies within the object
    IF (v_lob_len >= v_offset)
    THEN
        -- Determining actual amount of characters to erase
        amount := least(v_lob_len - v_offset + 1, amount);

        -- NUMERIC -> INTEGER DBMS_LOB.LOBMAXSIZE workaround
        v_amount := CASE amount
                       WHEN aws_oracle_ext.dbms_lob$lobmaxsize()
                       THEN 2147483647 -- Maximum positive value for data type INTEGER
                       ELSE floor(amount)  -- Extracting integer part of amount
                    END;

        -- Erasing part of the object at the specified offset
        lob_loc := overlay(lob_loc placing repeat(' ', v_amount) -- replacing gap with spaces
                                      from v_offset
                                       for v_amount);
    END IF;
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
    WHEN zero_length_character_string THEN
        RAISE USING MESSAGE := 'Numeric or value error.',
                    DETAIL := 'Amount of characters to erase and offset could not be NULL.',
                    HINT := '-6502';
    WHEN check_violation THEN
        RAISE USING MESSAGE := format('Argument %s is invalid or out of range.',
                                      CASE
                                         WHEN amount < 1 THEN 2
                                         WHEN "offset" < 1 THEN 3
                                      END),
                    DETAIL := 'Amount of characters to erase and offset must be 1 or above.',
                    HINT := '-21560';
END;
]]></complex-attribute>
                        <category _I_D="727912b5-24ff-48ea-a82c-3c92319508b5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="18905551-e7e5-4320-9eab-9af52face1cd" schema-id="21999" name="dbms_lob$freetemporary" context="dbms_lob$freetemporary(INOUT lob_loc bytea)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc bytea)" unique-function-name="dbms_lob$freetemporary(INOUT lob_loc bytea)" is-aggregate="f" language-name="plpgsql" routine-number="23309" arguments-datatypes="bytea" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc bytea" function-type="RET_SCALAR" count-arguments="1" function-id="23309" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc bytea" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$freetemporary(INOUT lob_loc bytea)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    -- Checking input argument
    IF (lob_loc IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    END IF;

    lob_loc := NULL::BYTEA;
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
END;
]]></complex-attribute>
                        <category _I_D="e6f56426-6d46-4beb-b565-000fd53fb758" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="ec93757a-73c2-4616-bd42-380d06c32294" schema-id="21999" name="dbms_lob$freetemporary" context="dbms_lob$freetemporary(INOUT lob_loc character varying)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc character varying)" unique-function-name="dbms_lob$freetemporary(INOUT lob_loc character varying)" is-aggregate="f" language-name="plpgsql" routine-number="23308" comment="This procedure deinitializes a character large object (CLOB)." arguments-datatypes="character varying" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc character varying" function-type="RET_SCALAR" count-arguments="1" function-id="23308" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc character varying" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$freetemporary(INOUT lob_loc character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_lob_loc TEXT;
BEGIN
    RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                DETAIL := 'LOB locator variable is not initialized.',
                HINT := '-22275';
END;
]]></complex-attribute>
                        <category _I_D="bde78c61-9527-436f-b1af-badb1921bb82" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="37e7937c-6991-40d2-95b9-4744000fc6ea" schema-id="21999" name="dbms_lob$freetemporary" context="dbms_lob$freetemporary(INOUT lob_loc text)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc text)" unique-function-name="dbms_lob$freetemporary(INOUT lob_loc text)" is-aggregate="f" language-name="plpgsql" routine-number="23307" comment="This procedure deinitializes a character large object (CLOB)." arguments-datatypes="text" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc text" function-type="RET_SCALAR" count-arguments="1" function-id="23307" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc text" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$freetemporary(INOUT lob_loc text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    -- Checking input argument
    IF (lob_loc IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    END IF;

    lob_loc := NULL::TEXT;
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
END;
]]></complex-attribute>
                        <category _I_D="665f0938-1154-427f-95ef-e9ffc7d58531" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="3e9a2c3e-6d21-4769-ac1f-c488ad7bb8cc" schema-id="21999" name="dbms_lob$read" context="dbms_lob$read(IN lob_loc bytea, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer bytea)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN lob_loc bytea, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer bytea)" unique-function-name="dbms_lob$read(IN lob_loc bytea, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer bytea)" is-aggregate="f" language-name="plpgsql" routine-number="23338" comment="This procedure reads a piece of a character LOB, and returns the specified amount into the buffer parameter, starting from an absolute offset from the beginning of the LOB." arguments-datatypes="bytea,double precision,numeric,bytea" is-returning-set="f" ret-datatype="record" function-arguments="IN lob_loc bytea, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer bytea" function-type="RET_SCALAR" count-arguments="4" function-id="23338" volatility="VOLATILE" is-window="f" function-identity-arguments="IN lob_loc bytea, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer bytea" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$read(IN lob_loc bytea, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer bytea)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount NUMERIC;
BEGIN
    v_amount := amount;

    CALL aws_oracle_ext.dbms_lob$read(lob_loc => lob_loc,
                                      amount => v_amount,
                                      "offset" => "offset",
                                      buffer => buffer);
    amount := v_amount;
END;
]]></complex-attribute>
                        <category _I_D="6ead70da-b9aa-4ed4-af26-d22e349bb8ae" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="35611431-8411-463b-83b3-7ccffa84bc08" schema-id="21999" name="dbms_lob$read" context="dbms_lob$read(IN lob_loc bytea, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer bytea)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN lob_loc bytea, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer bytea)" unique-function-name="dbms_lob$read(IN lob_loc bytea, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer bytea)" is-aggregate="f" language-name="plpgsql" routine-number="23339" comment="This procedure reads a piece of a character LOB, and returns the specified amount into the buffer parameter, starting from an absolute offset from the beginning of the LOB." arguments-datatypes="bytea,integer,numeric,bytea" is-returning-set="f" ret-datatype="record" function-arguments="IN lob_loc bytea, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer bytea" function-type="RET_SCALAR" count-arguments="4" function-id="23339" volatility="VOLATILE" is-window="f" function-identity-arguments="IN lob_loc bytea, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer bytea" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$read(IN lob_loc bytea, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer bytea)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount NUMERIC;
BEGIN
    v_amount := amount;

    CALL aws_oracle_ext.dbms_lob$read(lob_loc => lob_loc,
                                      amount => v_amount,
                                      "offset" => "offset",
                                      buffer => buffer);
    amount := v_amount;
END;
]]></complex-attribute>
                        <category _I_D="1a4e00a6-06a7-4e7e-902b-812c86a5d91f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="326a8607-9a4d-4941-b6f7-f636508c015a" schema-id="21999" name="dbms_lob$read" context="dbms_lob$read(IN lob_loc bytea, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer bytea)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN lob_loc bytea, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer bytea)" unique-function-name="dbms_lob$read(IN lob_loc bytea, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer bytea)" is-aggregate="f" language-name="plpgsql" routine-number="23337" comment="This procedure reads a piece of a character LOB, and returns the specified amount into the buffer parameter, starting from an absolute offset from the beginning of the LOB." arguments-datatypes="bytea,numeric,numeric,bytea" is-returning-set="f" ret-datatype="record" function-arguments="IN lob_loc bytea, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer bytea" function-type="RET_SCALAR" count-arguments="4" function-id="23337" volatility="VOLATILE" is-window="f" function-identity-arguments="IN lob_loc bytea, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer bytea" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$read(IN lob_loc bytea, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer bytea)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_offset INTEGER;
    v_lob_len INTEGER;
BEGIN
    -- Extracting integer part of amount
    amount := floor(amount);

    -- Checking input arguments
    IF (lob_loc IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    ELSIF (amount IS NULL OR
           "offset" IS NULL)
    THEN
        -- Numeric or value error
        RAISE zero_length_character_string;
    ELSIF (amount NOT BETWEEN 1 AND 32767 OR
           "offset" < 1)
    THEN
        -- Argument is out of range
        RAISE check_violation;
    END IF;

    -- Determining object length (bytes)
    v_lob_len := octet_length(lob_loc);

    -- Extracting integer part of offset
    v_offset := floor("offset")::INTEGER;

    -- Determining actual amount of bytes to read
    amount := least(v_lob_len - v_offset + 1, amount);

    -- Make sense only if offset lies within the object
    IF (v_lob_len >= v_offset)
    THEN
        -- Reading a specified part of an object
        buffer := substr(lob_loc, v_offset, amount::INTEGER);
    ELSE
        -- Nothing to read
        RAISE no_data_found;
    END IF;
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
    WHEN zero_length_character_string THEN
        RAISE USING MESSAGE := 'Numeric or value error.',
                    DETAIL := 'Amount of characters to read and offset could not be NULL.',
                    HINT := '-6502';
    WHEN check_violation THEN
        RAISE USING MESSAGE := format('Argument %s is invalid or out of range.',
                                      CASE
                                         WHEN (amount NOT BETWEEN 1 AND 32767) THEN 2
                                         WHEN "offset" < 1 THEN 3
                                      END),
                    DETAIL := 'Amount of characters to read and offset must be 1 or above.',
                    HINT := '-21560';
END;
]]></complex-attribute>
                        <category _I_D="93d20889-eeff-40a4-915f-f63e03fa1b68" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="046feb52-bb56-4dcf-ae0a-c929c3f72e61" schema-id="21999" name="dbms_lob$read" context="dbms_lob$read(IN lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer character varying)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer character varying)" unique-function-name="dbms_lob$read(IN lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer character varying)" is-aggregate="f" language-name="plpgsql" routine-number="23335" comment="This procedure reads a piece of a character LOB, and returns the specified amount into the buffer parameter, starting from an absolute offset from the beginning of the LOB." arguments-datatypes="text,double precision,numeric,character varying" is-returning-set="f" ret-datatype="record" function-arguments="IN lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer character varying" function-type="RET_SCALAR" count-arguments="4" function-id="23335" volatility="VOLATILE" is-window="f" function-identity-arguments="IN lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer character varying" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$read(IN lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount NUMERIC;
    v_buffer TEXT;
BEGIN
    v_amount := amount;
    v_buffer := buffer;

    CALL aws_oracle_ext.dbms_lob$read(lob_loc => lob_loc,
                                      amount => v_amount,
                                      "offset" => "offset",
                                      buffer => v_buffer);
    amount := v_amount;
    buffer := v_buffer;
END;
]]></complex-attribute>
                        <category _I_D="02e86741-852e-425e-b103-f9b52360ab54" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="393a0944-2c08-469e-80fc-ec9f11c2cc13" schema-id="21999" name="dbms_lob$read" context="dbms_lob$read(IN lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer text)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer text)" unique-function-name="dbms_lob$read(IN lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer text)" is-aggregate="f" language-name="plpgsql" routine-number="23332" comment="This procedure reads a piece of a character LOB, and returns the specified amount into the buffer parameter, starting from an absolute offset from the beginning of the LOB." arguments-datatypes="text,double precision,numeric,text" is-returning-set="f" ret-datatype="record" function-arguments="IN lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer text" function-type="RET_SCALAR" count-arguments="4" function-id="23332" volatility="VOLATILE" is-window="f" function-identity-arguments="IN lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer text" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$read(IN lob_loc text, INOUT amount double precision, IN &quot;offset&quot; numeric, INOUT buffer text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount NUMERIC;
BEGIN
    v_amount := amount;

    CALL aws_oracle_ext.dbms_lob$read(lob_loc => lob_loc,
                                      amount => v_amount,
                                      "offset" => "offset",
                                      buffer => buffer);
    amount := v_amount;
END;
]]></complex-attribute>
                        <category _I_D="4793d7f1-7fcc-4f45-b7e5-0d50904cf961" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="3225b18f-9bbf-4639-8835-d84fb2207b34" schema-id="21999" name="dbms_lob$read" context="dbms_lob$read(IN lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer character varying)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer character varying)" unique-function-name="dbms_lob$read(IN lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer character varying)" is-aggregate="f" language-name="plpgsql" routine-number="23336" comment="This procedure reads a piece of a character LOB, and returns the specified amount into the buffer parameter, starting from an absolute offset from the beginning of the LOB." arguments-datatypes="text,integer,numeric,character varying" is-returning-set="f" ret-datatype="record" function-arguments="IN lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer character varying" function-type="RET_SCALAR" count-arguments="4" function-id="23336" volatility="VOLATILE" is-window="f" function-identity-arguments="IN lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer character varying" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$read(IN lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount NUMERIC;
    v_buffer TEXT;
BEGIN
    v_amount := amount;
    v_buffer := buffer;

    CALL aws_oracle_ext.dbms_lob$read(lob_loc => lob_loc,
                                      amount => v_amount,
                                      "offset" => "offset",
                                      buffer => v_buffer);
    amount := v_amount;
    buffer := v_buffer;
END;
]]></complex-attribute>
                        <category _I_D="a3c02db4-9590-498a-8a96-2b5c1801f011" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="6299440d-f10e-4cbc-b49b-3a1d79280b40" schema-id="21999" name="dbms_lob$read" context="dbms_lob$read(IN lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer text)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer text)" unique-function-name="dbms_lob$read(IN lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer text)" is-aggregate="f" language-name="plpgsql" routine-number="23333" comment="This procedure reads a piece of a character LOB, and returns the specified amount into the buffer parameter, starting from an absolute offset from the beginning of the LOB." arguments-datatypes="text,integer,numeric,text" is-returning-set="f" ret-datatype="record" function-arguments="IN lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer text" function-type="RET_SCALAR" count-arguments="4" function-id="23333" volatility="VOLATILE" is-window="f" function-identity-arguments="IN lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer text" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$read(IN lob_loc text, INOUT amount integer, IN &quot;offset&quot; numeric, INOUT buffer text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount NUMERIC;
BEGIN
    v_amount := amount;

    CALL aws_oracle_ext.dbms_lob$read(lob_loc => lob_loc,
                                      amount => v_amount,
                                      "offset" => "offset",
                                      buffer => buffer);
    amount := v_amount;
END;
]]></complex-attribute>
                        <category _I_D="f7611731-4707-478c-b00d-59dc58f37510" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="fb3c36c2-9dec-47be-b9bb-227b71338e41" schema-id="21999" name="dbms_lob$read" context="dbms_lob$read(IN lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer character varying)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer character varying)" unique-function-name="dbms_lob$read(IN lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer character varying)" is-aggregate="f" language-name="plpgsql" routine-number="23334" comment="This procedure reads a piece of a character LOB, and returns the specified amount into the buffer parameter, starting from an absolute offset from the beginning of the LOB." arguments-datatypes="text,numeric,numeric,character varying" is-returning-set="f" ret-datatype="record" function-arguments="IN lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer character varying" function-type="RET_SCALAR" count-arguments="4" function-id="23334" volatility="VOLATILE" is-window="f" function-identity-arguments="IN lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer character varying" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$read(IN lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer character varying)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_buffer TEXT;
BEGIN
    v_buffer := buffer;

    CALL aws_oracle_ext.dbms_lob$read(lob_loc => lob_loc,
                                      amount => amount,
                                      "offset" => "offset",
                                      buffer => v_buffer);
    buffer := v_buffer;
END;
]]></complex-attribute>
                        <category _I_D="a2c7a383-cd15-4d4c-b9a6-8d0d2930f1c6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="6080c95f-8503-4c19-8c23-d02bdeba45d7" schema-id="21999" name="dbms_lob$read" context="dbms_lob$read(IN lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer text)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer text)" unique-function-name="dbms_lob$read(IN lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer text)" is-aggregate="f" language-name="plpgsql" routine-number="23331" comment="This procedure reads a piece of a character LOB, and returns the specified amount into the buffer parameter, starting from an absolute offset from the beginning of the LOB." arguments-datatypes="text,numeric,numeric,text" is-returning-set="f" ret-datatype="record" function-arguments="IN lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer text" function-type="RET_SCALAR" count-arguments="4" function-id="23331" volatility="VOLATILE" is-window="f" function-identity-arguments="IN lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer text" overload-function-count="9" proc-language="plpgsql" function-signature="dbms_lob$read(IN lob_loc text, INOUT amount numeric, IN &quot;offset&quot; numeric, INOUT buffer text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_offset INTEGER;
    v_lob_len INTEGER;
BEGIN
    -- Extracting integer part of amount
    amount := floor(amount);

    -- Checking input arguments
    IF (lob_loc IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    ELSIF (amount IS NULL OR
           "offset" IS NULL)
    THEN
        -- Numeric or value error
        RAISE zero_length_character_string;
    ELSIF (amount NOT BETWEEN 1 AND 32767 OR
           "offset" < 1)
    THEN
        -- Argument is out of range
        RAISE check_violation;
    END IF;

    -- Determining object length (characters)
    v_lob_len := char_length(lob_loc);

    -- Extracting integer part of offset
    v_offset := floor("offset")::INTEGER;

    -- Determining actual amount of characters to read
    amount := least(v_lob_len - v_offset + 1, amount);

    -- Make sense only if offset lies within the object
    IF (v_lob_len >= v_offset)
    THEN
        -- Reading a specified part of an object
        buffer := substr(lob_loc, v_offset, amount::INTEGER);
    ELSE
        -- Nothing to read
        RAISE no_data_found;
    END IF;
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
    WHEN zero_length_character_string THEN
        RAISE USING MESSAGE := 'Numeric or value error.',
                    DETAIL := 'Amount of characters to read and offset could not be NULL.',
                    HINT := '-6502';
    WHEN check_violation THEN
        RAISE USING MESSAGE := format('Argument %s is invalid or out of range.',
                                      CASE
                                         WHEN (amount NOT BETWEEN 1 AND 32767) THEN 2
                                         WHEN "offset" < 1 THEN 3
                                      END),
                    DETAIL := 'Amount of characters to read and offset must be 1 or above.',
                    HINT := '-21560';
END;
]]></complex-attribute>
                        <category _I_D="c34c5938-6dff-4f37-9ee7-cb5db234600a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="229176dc-4f1f-498e-a870-b663450284e6" schema-id="21999" name="dbms_lob$trim" context="dbms_lob$trim(INOUT lob_loc bytea, IN newlen numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc bytea, IN newlen numeric)" unique-function-name="dbms_lob$trim(INOUT lob_loc bytea, IN newlen numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23344" comment="This procedure trims the value of the binary LOB to the length specified in the newlen parameter." arguments-datatypes="bytea,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc bytea, IN newlen numeric" function-type="RET_SCALAR" count-arguments="2" function-id="23344" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc bytea, IN newlen numeric" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$trim(INOUT lob_loc bytea, IN newlen numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_lob_len INTEGER;
BEGIN
    -- Determining object length (characters)
    v_lob_len := octet_length(lob_loc);

    -- Checking input arguments
    IF (lob_loc IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    ELSIF (newlen > v_lob_len AND
           v_lob_len >= 0)
    THEN
        -- Trim length is greater than LOB length
        RAISE check_violation;
    END IF;

    lob_loc := substr(lob_loc, 1, floor(newlen)::INTEGER);
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
    WHEN check_violation THEN
        RAISE USING MESSAGE := 'Trim length is greater than LOB length.',
                    DETAIL := 'Specified trim length is greater than current LOB value''s length.',
                    HINT := '-22926';
END;
]]></complex-attribute>
                        <category _I_D="26231414-6639-474a-86df-8665392ec736" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="811f8300-c875-4ae8-a518-07d4c64f4704" schema-id="21999" name="dbms_lob$trim" context="dbms_lob$trim(INOUT lob_loc character varying, IN newlen numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc character varying, IN newlen numeric)" unique-function-name="dbms_lob$trim(INOUT lob_loc character varying, IN newlen numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23343" comment="This procedure trims the value of the character LOB to the length specified in the newlen parameter." arguments-datatypes="character varying,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc character varying, IN newlen numeric" function-type="RET_SCALAR" count-arguments="2" function-id="23343" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc character varying, IN newlen numeric" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$trim(INOUT lob_loc character varying, IN newlen numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_lob_loc TEXT;
BEGIN
    v_lob_loc := lob_loc;

    CALL aws_oracle_ext.dbms_lob$trim(lob_loc => v_lob_loc,
                                      newlen => newlen);
    lob_loc := v_lob_loc;
END;
]]></complex-attribute>
                        <category _I_D="f86bbba5-9487-440f-99cf-10eba323dbd9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="aced5f69-ad69-4008-ae30-77d9fee89c0b" schema-id="21999" name="dbms_lob$trim" context="dbms_lob$trim(INOUT lob_loc text, IN newlen numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc text, IN newlen numeric)" unique-function-name="dbms_lob$trim(INOUT lob_loc text, IN newlen numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23342" comment="This procedure trims the value of the character LOB to the length specified in the newlen parameter." arguments-datatypes="text,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc text, IN newlen numeric" function-type="RET_SCALAR" count-arguments="2" function-id="23342" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc text, IN newlen numeric" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$trim(INOUT lob_loc text, IN newlen numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_lob_len INTEGER;
BEGIN
    -- Determining object length (characters)
    v_lob_len := char_length(lob_loc);

    -- Checking input arguments
    IF (lob_loc IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    ELSIF (newlen > v_lob_len AND
           v_lob_len >= 0)
    THEN
        -- Trim length is greater than LOB length
        RAISE check_violation;
    END IF;

    lob_loc := substr(lob_loc, 1, floor(newlen)::INTEGER);
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
    WHEN check_violation THEN
        RAISE USING MESSAGE := 'Trim length is greater than LOB length.',
                    DETAIL := 'Specified trim length is greater than current LOB value''s length.',
                    HINT := '-22926';
END;
]]></complex-attribute>
                        <category _I_D="7b87815f-4a70-4017-b055-bd7f6e3c4101" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="e112d9b4-5d75-4454-bb0f-a39794e22049" schema-id="21999" name="dbms_lob$write" context="dbms_lob$write(INOUT lob_loc bytea, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer bytea)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc bytea, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer bytea)" unique-function-name="dbms_lob$write(INOUT lob_loc bytea, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer bytea)" is-aggregate="f" language-name="plpgsql" routine-number="23347" comment="This procedure writes a specified amount of data into a binary LOB, starting from an absolute offset from the beginning of the LOB. The data is written from the buffer parameter." arguments-datatypes="bytea,numeric,numeric,bytea" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc bytea, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer bytea" function-type="RET_SCALAR" count-arguments="4" function-id="23347" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc bytea, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer bytea" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$write(INOUT lob_loc bytea, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer bytea)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount INTEGER;
    v_buff_len INTEGER;
BEGIN
    -- Determining buffer length (bytes)
    v_buff_len := octet_length(buffer);

    -- Checking input arguments
    IF (lob_loc IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    ELSIF (amount IS NULL OR
           "offset" IS NULL OR
           buffer IS NULL OR
           v_buff_len = 0)
    THEN
        -- Numeric or value error
        RAISE zero_length_character_string;
    ELSIF (amount < 1 OR
           "offset" < 1 OR
           amount > v_buff_len)
    THEN
        -- Argument is out of range
        RAISE check_violation;
    END IF;

    -- NUMERIC -> INTEGER DBMS_LOB.LOBMAXSIZE workaround
    v_amount := CASE amount
                   WHEN aws_oracle_ext.dbms_lob$lobmaxsize()
                   THEN 2147483647 -- Maximum positive value for data type INTEGER
                   ELSE amount
                END;

    -- Writing part of the buffer over the source object
    lob_loc := overlay(lob_loc placing substr(buffer, 1, v_amount)
                                  from floor("offset")::INTEGER
                                   for v_amount);
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
    WHEN zero_length_character_string THEN
        RAISE USING MESSAGE := 'Numeric or value error.',
                    DETAIL := 'Binary data buffer could not be NULL or empty.',
                    HINT := '-6502';
    WHEN check_violation THEN
        RAISE USING MESSAGE := format('Argument %s is invalid or out of range.',
                                      CASE
                                         WHEN (amount < 1 OR
                                               amount > v_buff_len) THEN 2
                                         WHEN "offset" < 1 THEN 3
                                      END),
                    DETAIL := 'Amount of bytes to write and offset must be 1 or above.',
                    HINT := '-21560';
END;
]]></complex-attribute>
                        <category _I_D="180bd9b8-de3e-4968-8e92-de3747880347" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="1f712b8e-2108-4a73-af41-d472b6775bf3" schema-id="21999" name="dbms_lob$write" context="dbms_lob$write(INOUT lob_loc character varying, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer text)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc character varying, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer text)" unique-function-name="dbms_lob$write(INOUT lob_loc character varying, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer text)" is-aggregate="f" language-name="plpgsql" routine-number="23346" comment="This procedure writes a specified amount of data into an chracter LOB, starting from an absolute offset from the beginning of the LOB. The data is written from the buffer parameter." arguments-datatypes="character varying,numeric,numeric,text" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc character varying, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer text" function-type="RET_SCALAR" count-arguments="4" function-id="23346" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc character varying, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer text" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$write(INOUT lob_loc character varying, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_lob_loc TEXT;
BEGIN
    v_lob_loc := lob_loc;

    CALL aws_oracle_ext.dbms_lob$write(lob_loc => v_lob_loc,
                                       amount => amount,
                                       "offset" => "offset",
                                       buffer => buffer);
    lob_loc := v_lob_loc;
END;
]]></complex-attribute>
                        <category _I_D="ee479b25-3c96-4aac-864b-9ecc6369fdbe" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="f213b38d-89a7-45ea-bec7-553c08218138" schema-id="21999" name="dbms_lob$write" context="dbms_lob$write(INOUT lob_loc text, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer text)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc text, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer text)" unique-function-name="dbms_lob$write(INOUT lob_loc text, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer text)" is-aggregate="f" language-name="plpgsql" routine-number="23345" comment="This procedure writes a specified amount of data into an chracter LOB, starting from an absolute offset from the beginning of the LOB. The data is written from the buffer parameter." arguments-datatypes="text,numeric,numeric,text" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc text, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer text" function-type="RET_SCALAR" count-arguments="4" function-id="23345" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc text, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer text" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$write(INOUT lob_loc text, IN amount numeric, IN &quot;offset&quot; numeric, IN buffer text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount INTEGER;
    v_buff_len INTEGER;
BEGIN
    -- Determining buffer length (characters)
    v_buff_len := char_length(buffer);

    -- Checking input arguments
    IF (lob_loc IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    ELSIF (amount IS NULL OR
           "offset" IS NULL OR
           buffer IS NULL OR
           v_buff_len = 0)
    THEN
        -- Numeric or value error
        RAISE zero_length_character_string;
    ELSIF (amount < 1 OR
           "offset" < 1 OR
           amount > v_buff_len)
    THEN
        -- Argument is out of range
        RAISE check_violation;
    END IF;

    -- NUMERIC -> INTEGER DBMS_LOB.LOBMAXSIZE workaround
    v_amount := CASE amount
                   WHEN aws_oracle_ext.dbms_lob$lobmaxsize()
                   THEN 2147483647 -- Maximum positive value for data type INTEGER
                   ELSE amount
                END;

    -- Writing part of the buffer over the source object
    lob_loc := overlay(lob_loc placing substr(buffer, 1, v_amount)
                                  from floor("offset")::INTEGER
                                   for v_amount);
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
    WHEN zero_length_character_string THEN
        RAISE USING MESSAGE := 'Numeric or value error.',
                    DETAIL := 'Character data buffer could not be NULL or empty.',
                    HINT := '-6502';
    WHEN check_violation THEN
        RAISE USING MESSAGE := format('Argument %s is invalid or out of range.',
                                      CASE
                                         WHEN (amount < 1 OR
                                               amount > v_buff_len) THEN 2
                                         WHEN "offset" < 1 THEN 3
                                      END),
                    DETAIL := 'Amount of characters to write and offset must be 1 or above.',
                    HINT := '-21560';
END;
]]></complex-attribute>
                        <category _I_D="99223d7a-7cfa-4a6a-a4ff-67a38bf9de85" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="ed078f82-c65c-4d95-aba5-c033448bdfba" schema-id="21999" name="dbms_lob$writeappend" context="dbms_lob$writeappend(INOUT lob_loc bytea, IN amount numeric, IN buffer bytea)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc bytea, IN amount numeric, IN buffer bytea)" unique-function-name="dbms_lob$writeappend(INOUT lob_loc bytea, IN amount numeric, IN buffer bytea)" is-aggregate="f" language-name="plpgsql" routine-number="23350" comment="This procedure writes a specified amount of data to the end of a binary LOB. The data is written from the buffer parameter." arguments-datatypes="bytea,numeric,bytea" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc bytea, IN amount numeric, IN buffer bytea" function-type="RET_SCALAR" count-arguments="3" function-id="23350" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc bytea, IN amount numeric, IN buffer bytea" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$writeappend(INOUT lob_loc bytea, IN amount numeric, IN buffer bytea)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount INTEGER;
    v_buff_len INTEGER;
BEGIN
    -- Determining buffer length (bytes)
    v_buff_len := octet_length(buffer);

    -- Checking input argument
    IF (lob_loc IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    ELSIF (buffer IS NULL OR
           v_buff_len = 0)
    THEN
        -- Numeric or value error
        RAISE zero_length_character_string;
    ELSIF (amount < 1 OR
           amount > v_buff_len)
    THEN
        -- Argument is out of range
        RAISE check_violation;
    END IF;

    -- NUMERIC -> INTEGER DBMS_LOB.LOBMAXSIZE workaround
    v_amount := CASE amount
                   WHEN aws_oracle_ext.dbms_lob$lobmaxsize()
                   THEN 2147483647 -- Maximum positive value for data type INTEGER
                   ELSE amount
                END;

    lob_loc := lob_loc || substr(buffer, 1, v_amount);
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
    WHEN zero_length_character_string THEN
        RAISE USING MESSAGE := 'Numeric or value error.',
                    DETAIL := 'Binary data buffer could not be NULL or empty.',
                    HINT := '-6502';
    WHEN check_violation THEN
        RAISE USING MESSAGE := 'Argument 2 is invalid or out of range.',
                    DETAIL := 'Amount of bytes to write must be 1 or above.',
                    HINT := '-21560';
END;
]]></complex-attribute>
                        <category _I_D="30a1ac92-2035-4353-92f3-5a45fd8ca51c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="a75b5ef2-56df-403b-97fe-8e1de05bffb4" schema-id="21999" name="dbms_lob$writeappend" context="dbms_lob$writeappend(INOUT lob_loc character varying, IN amount numeric, IN buffer text)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc character varying, IN amount numeric, IN buffer text)" unique-function-name="dbms_lob$writeappend(INOUT lob_loc character varying, IN amount numeric, IN buffer text)" is-aggregate="f" language-name="plpgsql" routine-number="23349" comment="This procedure writes a specified amount of data to the end of a chracter LOB. The data is written from the buffer parameter." arguments-datatypes="character varying,numeric,text" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc character varying, IN amount numeric, IN buffer text" function-type="RET_SCALAR" count-arguments="3" function-id="23349" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc character varying, IN amount numeric, IN buffer text" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$writeappend(INOUT lob_loc character varying, IN amount numeric, IN buffer text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_lob_loc TEXT;
BEGIN
    v_lob_loc := lob_loc;

    CALL aws_oracle_ext.dbms_lob$writeappend(lob_loc => v_lob_loc,
                                             amount => amount,
                                             buffer => buffer);
    lob_loc := v_lob_loc;
END;
]]></complex-attribute>
                        <category _I_D="558f4852-7ae6-47d4-89a0-c911659863a7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="bb7eccb3-d3ff-445e-a1c7-0d57a315b3bb" schema-id="21999" name="dbms_lob$writeappend" context="dbms_lob$writeappend(INOUT lob_loc text, IN amount numeric, IN buffer text)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT lob_loc text, IN amount numeric, IN buffer text)" unique-function-name="dbms_lob$writeappend(INOUT lob_loc text, IN amount numeric, IN buffer text)" is-aggregate="f" language-name="plpgsql" routine-number="23348" comment="This procedure writes a specified amount of data to the end of a chracter LOB. The data is written from the buffer parameter." arguments-datatypes="text,numeric,text" is-returning-set="f" ret-datatype="record" function-arguments="INOUT lob_loc text, IN amount numeric, IN buffer text" function-type="RET_SCALAR" count-arguments="3" function-id="23348" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT lob_loc text, IN amount numeric, IN buffer text" overload-function-count="3" proc-language="plpgsql" function-signature="dbms_lob$writeappend(INOUT lob_loc text, IN amount numeric, IN buffer text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_amount INTEGER;
    v_buff_len INTEGER;
BEGIN
    -- Determining buffer length (characters)
    v_buff_len := char_length(buffer);

    -- Checking input argument
    IF (lob_loc IS NULL)
    THEN
        -- Invalid LOB locator specified
        RAISE null_value_not_allowed;
    ELSIF (buffer IS NULL OR
           v_buff_len = 0)
    THEN
        -- Numeric or value error
        RAISE zero_length_character_string;
    ELSIF (amount < 1 OR
           amount > v_buff_len)
    THEN
        -- Argument is out of range
        RAISE check_violation;
    END IF;

    -- NUMERIC -> INTEGER DBMS_LOB.LOBMAXSIZE workaround
    v_amount := CASE amount
                   WHEN aws_oracle_ext.dbms_lob$lobmaxsize()
                   THEN 2147483647 -- Maximum positive value for data type INTEGER
                   ELSE amount
                END;

    lob_loc := lob_loc || substr(buffer, 1, v_amount);
EXCEPTION
    WHEN null_value_not_allowed THEN
        RAISE USING MESSAGE := 'Invalid LOB locator specified.',
                    DETAIL := 'LOB locator variable is not initialized.',
                    HINT := '-22275';
    WHEN zero_length_character_string THEN
        RAISE USING MESSAGE := 'Numeric or value error.',
                    DETAIL := 'Character data buffer could not be NULL or empty.',
                    HINT := '-6502';
    WHEN check_violation THEN
        RAISE USING MESSAGE := 'Argument 2 is invalid or out of range.',
                    DETAIL := 'Amount of characters to write must be 1 or above.',
                    HINT := '-21560';
END;
]]></complex-attribute>
                        <category _I_D="fe00b99a-2d90-4967-8087-e8b22c6658e6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="56c3085a-35c4-47db-854e-113b5739547e" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line character varying, INOUT status bigint)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line character varying, INOUT status bigint)" unique-function-name="dbms_output$get_line(INOUT line character varying, INOUT status bigint)" is-aggregate="f" language-name="plpgsql" routine-number="23462" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="character varying,bigint" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line character varying, INOUT status bigint" function-type="RET_SCALAR" count-arguments="2" function-id="23462" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line character varying, INOUT status bigint" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line character varying, INOUT status bigint)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="6050899e-1964-4ace-860c-d0028205b6bb" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="5b59f19e-1765-4f14-8b2e-deef243472be" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line character varying, INOUT status double precision)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line character varying, INOUT status double precision)" unique-function-name="dbms_output$get_line(INOUT line character varying, INOUT status double precision)" is-aggregate="f" language-name="plpgsql" routine-number="23468" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="character varying,double precision" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line character varying, INOUT status double precision" function-type="RET_SCALAR" count-arguments="2" function-id="23468" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line character varying, INOUT status double precision" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line character varying, INOUT status double precision)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="ef2b8561-6beb-45cf-b872-ce68bff86573" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="0e9f2c29-1473-4da6-8e41-d899def15d79" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line character varying, INOUT status integer)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line character varying, INOUT status integer)" unique-function-name="dbms_output$get_line(INOUT line character varying, INOUT status integer)" is-aggregate="f" language-name="plpgsql" routine-number="23459" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="character varying,integer" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line character varying, INOUT status integer" function-type="RET_SCALAR" count-arguments="2" function-id="23459" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line character varying, INOUT status integer" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line character varying, INOUT status integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="f1ab744c-f38e-4f7b-aa39-59753ff81661" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="2f85413f-cfce-4cd6-8125-2e90fa5190e5" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line character varying, INOUT status numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line character varying, INOUT status numeric)" unique-function-name="dbms_output$get_line(INOUT line character varying, INOUT status numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23453" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="character varying,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line character varying, INOUT status numeric" function-type="RET_SCALAR" count-arguments="2" function-id="23453" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line character varying, INOUT status numeric" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line character varying, INOUT status numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="f4dffcf1-0c4c-4615-9e94-776ee4e034e9" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="fc391915-c413-46e4-8d22-6c0784d1ccd9" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line character varying, INOUT status real)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line character varying, INOUT status real)" unique-function-name="dbms_output$get_line(INOUT line character varying, INOUT status real)" is-aggregate="f" language-name="plpgsql" routine-number="23465" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="character varying,real" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line character varying, INOUT status real" function-type="RET_SCALAR" count-arguments="2" function-id="23465" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line character varying, INOUT status real" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line character varying, INOUT status real)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="d1c23fc0-f425-4c36-871b-764e0ae00cef" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="19f8a0ad-2f38-4345-8fd4-fe88c059bb77" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line character varying, INOUT status smallint)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line character varying, INOUT status smallint)" unique-function-name="dbms_output$get_line(INOUT line character varying, INOUT status smallint)" is-aggregate="f" language-name="plpgsql" routine-number="23456" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="character varying,smallint" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line character varying, INOUT status smallint" function-type="RET_SCALAR" count-arguments="2" function-id="23456" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line character varying, INOUT status smallint" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line character varying, INOUT status smallint)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="44bfe602-4d81-4903-9bbd-7d3634cec4ca" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="2084b461-8f8c-4f32-b63d-aa5af661e22f" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line character, INOUT status bigint)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line character, INOUT status bigint)" unique-function-name="dbms_output$get_line(INOUT line character, INOUT status bigint)" is-aggregate="f" language-name="plpgsql" routine-number="23461" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="character,bigint" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line character, INOUT status bigint" function-type="RET_SCALAR" count-arguments="2" function-id="23461" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line character, INOUT status bigint" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line character, INOUT status bigint)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="abcf0754-b04b-48ac-b189-16c3503d603c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="26319d0d-56f9-475d-b25f-f816e6cbd572" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line character, INOUT status double precision)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line character, INOUT status double precision)" unique-function-name="dbms_output$get_line(INOUT line character, INOUT status double precision)" is-aggregate="f" language-name="plpgsql" routine-number="23467" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="character,double precision" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line character, INOUT status double precision" function-type="RET_SCALAR" count-arguments="2" function-id="23467" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line character, INOUT status double precision" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line character, INOUT status double precision)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="41ac8139-d855-44f7-99e7-55b7b3e17c1c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="a528523d-9a8e-43ad-9e7f-7efd471839b9" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line character, INOUT status integer)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line character, INOUT status integer)" unique-function-name="dbms_output$get_line(INOUT line character, INOUT status integer)" is-aggregate="f" language-name="plpgsql" routine-number="23458" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="character,integer" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line character, INOUT status integer" function-type="RET_SCALAR" count-arguments="2" function-id="23458" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line character, INOUT status integer" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line character, INOUT status integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="e65768a7-469e-4692-9917-e265d989256f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="fd3baca9-2109-4ad4-b80b-7c6dfec82404" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line character, INOUT status numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line character, INOUT status numeric)" unique-function-name="dbms_output$get_line(INOUT line character, INOUT status numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23452" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="character,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line character, INOUT status numeric" function-type="RET_SCALAR" count-arguments="2" function-id="23452" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line character, INOUT status numeric" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line character, INOUT status numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="7bbd1c39-9787-44ce-99a3-6c8a40df743d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="e70670c2-20c7-43c0-8fd9-700bddfc0b67" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line character, INOUT status real)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line character, INOUT status real)" unique-function-name="dbms_output$get_line(INOUT line character, INOUT status real)" is-aggregate="f" language-name="plpgsql" routine-number="23464" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="character,real" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line character, INOUT status real" function-type="RET_SCALAR" count-arguments="2" function-id="23464" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line character, INOUT status real" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line character, INOUT status real)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="116c9953-c009-4d62-8def-5c9c32dc1fe8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="4b5e0d69-c593-4ec2-a190-828669c89fc3" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line character, INOUT status smallint)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line character, INOUT status smallint)" unique-function-name="dbms_output$get_line(INOUT line character, INOUT status smallint)" is-aggregate="f" language-name="plpgsql" routine-number="23455" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="character,smallint" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line character, INOUT status smallint" function-type="RET_SCALAR" count-arguments="2" function-id="23455" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line character, INOUT status smallint" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line character, INOUT status smallint)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="1af6d816-245e-4fab-97c1-3850487c7d36" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="07a1394b-20e1-4c6e-b5f9-9e24493849a3" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line text, INOUT status bigint)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line text, INOUT status bigint)" unique-function-name="dbms_output$get_line(INOUT line text, INOUT status bigint)" is-aggregate="f" language-name="plpgsql" routine-number="23460" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="text,bigint" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line text, INOUT status bigint" function-type="RET_SCALAR" count-arguments="2" function-id="23460" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line text, INOUT status bigint" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line text, INOUT status bigint)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="b93b4ee3-a115-410a-99cb-2d88caba1633" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="e049c398-fd72-4584-a994-041c9e635061" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line text, INOUT status double precision)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line text, INOUT status double precision)" unique-function-name="dbms_output$get_line(INOUT line text, INOUT status double precision)" is-aggregate="f" language-name="plpgsql" routine-number="23466" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="text,double precision" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line text, INOUT status double precision" function-type="RET_SCALAR" count-arguments="2" function-id="23466" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line text, INOUT status double precision" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line text, INOUT status double precision)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="793e8248-42d3-4355-b248-1ff0ea93c0c6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="ebdaa492-fee2-45f6-98c3-6da4bf1eb556" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line text, INOUT status integer)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line text, INOUT status integer)" unique-function-name="dbms_output$get_line(INOUT line text, INOUT status integer)" is-aggregate="f" language-name="plpgsql" routine-number="23457" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="text,integer" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line text, INOUT status integer" function-type="RET_SCALAR" count-arguments="2" function-id="23457" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line text, INOUT status integer" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line text, INOUT status integer)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="d90e3ddd-4242-4e0b-9600-0bb10255ff00" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="728b556b-82db-475c-bbd2-146e84eb5a77" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line text, INOUT status numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line text, INOUT status numeric)" unique-function-name="dbms_output$get_line(INOUT line text, INOUT status numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23451" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="text,numeric" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line text, INOUT status numeric" function-type="RET_SCALAR" count-arguments="2" function-id="23451" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line text, INOUT status numeric" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line text, INOUT status numeric)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_out_line_obj JSONB;
BEGIN
    -- Obtaining the output buffer line info.
    v_out_line_obj := aws_oracle_ext.dbms_output$get_buffer_line();

    -- Obtaining the character string value (line).
    line := v_out_line_obj ->> 'line';

    -- Obtaining the output buffer emptiness boolean flag.
    status := v_out_line_obj ->> 'status';
END;
]]></complex-attribute>
                        <category _I_D="cfa896df-1a97-4d9d-b20f-347241cf1d7d" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="119415be-c7eb-4d2b-8d78-7e46e0839012" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line text, INOUT status real)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line text, INOUT status real)" unique-function-name="dbms_output$get_line(INOUT line text, INOUT status real)" is-aggregate="f" language-name="plpgsql" routine-number="23463" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="text,real" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line text, INOUT status real" function-type="RET_SCALAR" count-arguments="2" function-id="23463" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line text, INOUT status real" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line text, INOUT status real)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="f4769060-f2db-46dc-b3d0-ea3b5f0f0249" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="d6c6e40b-7ad2-4778-ba61-ba880ba56631" schema-id="21999" name="dbms_output$get_line" context="dbms_output$get_line(INOUT line text, INOUT status smallint)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(INOUT line text, INOUT status smallint)" unique-function-name="dbms_output$get_line(INOUT line text, INOUT status smallint)" is-aggregate="f" language-name="plpgsql" routine-number="23454" comment="This procedure gets a character string (single line) back from the output buffer. Also returns a boolean status flag that indicates whether there are any more lines in the output buffer to return." arguments-datatypes="text,smallint" is-returning-set="f" ret-datatype="record" function-arguments="INOUT line text, INOUT status smallint" function-type="RET_SCALAR" count-arguments="2" function-id="23454" volatility="VOLATILE" is-window="f" function-identity-arguments="INOUT line text, INOUT status smallint" overload-function-count="18" proc-language="plpgsql" function-signature="dbms_output$get_line(INOUT line text, INOUT status smallint)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_line TEXT;
    v_status NUMERIC;
BEGIN
    CALL aws_oracle_ext.dbms_output$get_line(line => v_line,
                                             status => v_status);
    -- Character string value (line).
    line := v_line;

    -- Output buffer emptiness flag.
    status := v_status;
END;
]]></complex-attribute>
                        <category _I_D="914ce653-129a-47b1-a8b7-6ddfd78106b8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="5bc2b54b-4f0c-479b-8bc1-fc9e58724bac" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a bigint)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a bigint)" unique-function-name="dbms_output$put(IN a bigint)" is-aggregate="f" language-name="plpgsql" routine-number="23403" comment="This procedure puts a piece of numeric (bigint) information in the output buffer." arguments-datatypes="bigint" is-returning-set="f" ret-datatype="void" function-arguments="IN a bigint" function-type="RET_SCALAR" count-arguments="1" function-id="23403" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a bigint" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a bigint)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => aws_oracle_ext.to_char(a::NUMERIC));
END;
]]></complex-attribute>
                        <category _I_D="8144b1f5-1028-4d1f-8626-5e099ef43455" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="8bb766bb-66bf-48d0-9417-75b61a1385c4" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a boolean)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a boolean)" unique-function-name="dbms_output$put(IN a boolean)" is-aggregate="f" language-name="plpgsql" routine-number="23419" comment="This procedure puts a piece of boolean information in the output buffer." arguments-datatypes="boolean" is-returning-set="f" ret-datatype="void" function-arguments="IN a boolean" function-type="RET_SCALAR" count-arguments="1" function-id="23419" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a boolean" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a boolean)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => a::TEXT);
END;
]]></complex-attribute>
                        <category _I_D="16a09796-05f4-467c-bbcf-9dbd59c13f0c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="db4774b4-7db5-48f4-9b2f-d191f0a05b4a" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a bytea)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a bytea)" unique-function-name="dbms_output$put(IN a bytea)" is-aggregate="f" language-name="plpgsql" routine-number="23408" comment="This procedure puts a piece of binary information in the output buffer." arguments-datatypes="bytea" is-returning-set="f" ret-datatype="void" function-arguments="IN a bytea" function-type="RET_SCALAR" count-arguments="1" function-id="23408" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a bytea" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a bytea)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => upper(encode(a, 'hex')));
END;
]]></complex-attribute>
                        <category _I_D="43158b75-4f72-4457-accd-84a25159a48c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="c1c57d35-af17-4d2f-8df8-f74aaa97565b" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a date)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a date)" unique-function-name="dbms_output$put(IN a date)" is-aggregate="f" language-name="plpgsql" routine-number="23409" comment="This procedure puts a piece of date information in the output buffer." arguments-datatypes="date" is-returning-set="f" ret-datatype="void" function-arguments="IN a date" function-type="RET_SCALAR" count-arguments="1" function-id="23409" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a date" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a date)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => aws_oracle_ext.to_char(a));
END;
]]></complex-attribute>
                        <category _I_D="bb3a50ec-e85f-4836-9c4e-5c760e95479e" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="51adf0ff-fb4a-4fd4-947b-49c33f59555f" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a double precision)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a double precision)" unique-function-name="dbms_output$put(IN a double precision)" is-aggregate="f" language-name="plpgsql" routine-number="23406" comment="This procedure puts a piece of numeric (double precision) information in the output buffer." arguments-datatypes="double precision" is-returning-set="f" ret-datatype="void" function-arguments="IN a double precision" function-type="RET_SCALAR" count-arguments="1" function-id="23406" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a double precision" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a double precision)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_num_part_arr TEXT[];
    v_double_prec_num VARCHAR := '0';
BEGIN
    IF (a != 0)
    THEN
        -- 7386346580.845332 => " 7.3863465808453321e+09"
        v_double_prec_num := to_char(a, '9.9999999999999999EEEE');

        -- " 7.3863465808453321e+09" => {" 7.3863465808453321", "09"}
        v_num_part_arr := regexp_split_to_array(v_double_prec_num, 'e(\+|-)');

        -- Collecting all three parts together.
        v_double_prec_num := concat(rtrim(ltrim(v_num_part_arr[1]), '0'), -- " 7.3863465808453321" => "7.3863465808453321"
                                    upper(substring(v_double_prec_num from '(e(\+|-))')), -- (e+)"E+" or (e-)"E-"
                                    lpad(v_num_part_arr[2], 3, '0')); -- "09" => "009"
        -- 1.E+000 => 1.0E+000
        v_double_prec_num := replace(v_double_prec_num, '.E', '.0E');
    END IF;

    CALL aws_oracle_ext.dbms_output$put(a => CASE
                                                WHEN a IS NOT NULL
                                                THEN v_double_prec_num
                                             END);
END;
]]></complex-attribute>
                        <category _I_D="7697f5f6-6854-47b2-a9fb-ec6fe3bc6325" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="a964641e-a396-4bfa-af78-3aa10690c813" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a integer)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a integer)" unique-function-name="dbms_output$put(IN a integer)" is-aggregate="f" language-name="plpgsql" routine-number="23402" comment="This procedure puts a piece of numeric (integer) information in the output buffer." arguments-datatypes="integer" is-returning-set="f" ret-datatype="void" function-arguments="IN a integer" function-type="RET_SCALAR" count-arguments="1" function-id="23402" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a integer" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => aws_oracle_ext.to_char(a));
END;
]]></complex-attribute>
                        <category _I_D="1d41e5c2-1611-4f7f-9f85-9ed5fbe296f6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="37d41315-2dd4-4ba9-92c0-6ec9e6c956c8" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a interval)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a interval)" unique-function-name="dbms_output$put(IN a interval)" is-aggregate="f" language-name="plpgsql" routine-number="23414" comment="This procedure puts a piece of interval information in the output buffer." arguments-datatypes="interval" is-returning-set="f" ret-datatype="void" function-arguments="IN a interval" function-type="RET_SCALAR" count-arguments="1" function-id="23414" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a interval" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a interval)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => aws_oracle_ext.to_char(a));
END;
]]></complex-attribute>
                        <category _I_D="69d6a114-e7f2-4228-befe-bd56a5883ed2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="809bba8f-0781-4e2d-82e2-49c650576f35" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a json)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a json)" unique-function-name="dbms_output$put(IN a json)" is-aggregate="f" language-name="plpgsql" routine-number="23415" comment="This procedure puts a piece of JSON document information in the output buffer." arguments-datatypes="json" is-returning-set="f" ret-datatype="void" function-arguments="IN a json" function-type="RET_SCALAR" count-arguments="1" function-id="23415" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a json" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a json)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => jsonb_pretty(a::JSONB));
END;
]]></complex-attribute>
                        <category _I_D="30c870dc-0d82-48e2-9182-cf2f3a4f9330" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="100b4a6e-da11-4c60-926d-9d8b4d212be3" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a jsonb)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a jsonb)" unique-function-name="dbms_output$put(IN a jsonb)" is-aggregate="f" language-name="plpgsql" routine-number="23416" comment="This procedure puts a piece of binary JSON document information in the output buffer." arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="void" function-arguments="IN a jsonb" function-type="RET_SCALAR" count-arguments="1" function-id="23416" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a jsonb" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a jsonb)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => jsonb_pretty(a));
END;
]]></complex-attribute>
                        <category _I_D="ce9a0722-0c75-413e-b63d-c773ba913e86" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="7bcb929e-191c-47de-8027-f9e71d057643" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a money)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a money)" unique-function-name="dbms_output$put(IN a money)" is-aggregate="f" language-name="plpgsql" routine-number="23407" comment="This procedure puts a piece of money information in the output buffer." arguments-datatypes="money" is-returning-set="f" ret-datatype="void" function-arguments="IN a money" function-type="RET_SCALAR" count-arguments="1" function-id="23407" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a money" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a money)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => aws_oracle_ext.to_char(a::NUMERIC, 'fmL999G999G999G999G999G999D00'));
END;
]]></complex-attribute>
                        <category _I_D="266b3a0f-9f16-498a-bddd-e7006e58cf60" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="17908669-f0f8-4fc9-915e-c5c3c42b36e9" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a numeric)" unique-function-name="dbms_output$put(IN a numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23404" comment="This procedure puts a piece of numeric information in the output buffer." arguments-datatypes="numeric" is-returning-set="f" ret-datatype="void" function-arguments="IN a numeric" function-type="RET_SCALAR" count-arguments="1" function-id="23404" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a numeric" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => aws_oracle_ext.to_char(a));
END;
]]></complex-attribute>
                        <category _I_D="a8baf6f7-6d11-4f0b-9c3c-7a402c2a4ec8" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="0f1574ed-ae4e-4f8b-83ac-d776a9f7148b" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a real)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a real)" unique-function-name="dbms_output$put(IN a real)" is-aggregate="f" language-name="plpgsql" routine-number="23405" comment="This procedure puts a piece of numeric (real) information in the output buffer." arguments-datatypes="real" is-returning-set="f" ret-datatype="void" function-arguments="IN a real" function-type="RET_SCALAR" count-arguments="1" function-id="23405" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a real" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a real)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_num_part_arr TEXT[];
    v_real_num VARCHAR := '0';
BEGIN
    IF (a != 0)
    THEN
        -- 183546872.2342 => " 1.83546880e+08"
        v_real_num := to_char(a, '9.99999999EEEE');

        -- " 1.83546880e+08" => {" 1.83546880", "08"}
        v_num_part_arr := regexp_split_to_array(v_real_num, 'e(\+|-)');

        -- Collecting all three parts together.
        v_real_num := concat(rtrim(ltrim(v_num_part_arr[1]), '0'), -- " 1.83546880" => "1.8354688"
                                    upper(substring(v_real_num from '(e(\+|-))')), -- (e+)"E+" or (e-)"E-"
                                    lpad(v_num_part_arr[2], 3, '0')); -- "08" => "008"
        -- 1.E+000 => 1.0E+000
        v_real_num := replace(v_real_num, '.E', '.0E');
    END IF;

    CALL aws_oracle_ext.dbms_output$put(a => CASE
                                                WHEN a IS NOT NULL
                                                THEN v_real_num
                                             END);
END;
]]></complex-attribute>
                        <category _I_D="65c8d366-e311-4dde-882b-d4feb2b8ac21" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="e9b516e2-402b-41f4-9a0c-bad66feee522" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a smallint)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a smallint)" unique-function-name="dbms_output$put(IN a smallint)" is-aggregate="f" language-name="plpgsql" routine-number="23401" comment="This procedure puts a piece of numeric (smallint) information in the output buffer." arguments-datatypes="smallint" is-returning-set="f" ret-datatype="void" function-arguments="IN a smallint" function-type="RET_SCALAR" count-arguments="1" function-id="23401" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a smallint" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a smallint)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => aws_oracle_ext.to_char(a));
END;
]]></complex-attribute>
                        <category _I_D="33c2f24a-7981-4b77-95fc-c10b88b8d25b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="a37753d6-1df5-4292-b61c-6edbf76db9dc" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a time with time zone)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a time with time zone)" unique-function-name="dbms_output$put(IN a time with time zone)" is-aggregate="f" language-name="plpgsql" routine-number="23413" comment="This procedure puts a piece of time (with time zone) information in the output buffer." arguments-datatypes="time with time zone" is-returning-set="f" ret-datatype="void" function-arguments="IN a time with time zone" function-type="RET_SCALAR" count-arguments="1" function-id="23413" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a time with time zone" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a time with time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => a::TEXT);
END;
]]></complex-attribute>
                        <category _I_D="ebed8414-addb-4334-9abd-51897826ba25" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="446f3b5d-a520-4185-9345-977e5fcdaf1a" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a time without time zone)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a time without time zone)" unique-function-name="dbms_output$put(IN a time without time zone)" is-aggregate="f" language-name="plpgsql" routine-number="23412" comment="This procedure puts a piece of time (without time zone) information in the output buffer." arguments-datatypes="time without time zone" is-returning-set="f" ret-datatype="void" function-arguments="IN a time without time zone" function-type="RET_SCALAR" count-arguments="1" function-id="23412" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a time without time zone" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a time without time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => a::TEXT);
END;
]]></complex-attribute>
                        <category _I_D="76fc10cd-ce2b-4294-8ee9-cc096a48cbed" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="ec903b3c-f7f1-40bb-b7a7-2450d36194b7" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a timestamp with time zone)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a timestamp with time zone)" unique-function-name="dbms_output$put(IN a timestamp with time zone)" is-aggregate="f" language-name="plpgsql" routine-number="23411" comment="This procedure puts a piece of timestamp (with time zone) information in the output buffer." arguments-datatypes="timestamp with time zone" is-returning-set="f" ret-datatype="void" function-arguments="IN a timestamp with time zone" function-type="RET_SCALAR" count-arguments="1" function-id="23411" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a timestamp with time zone" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a timestamp with time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => aws_oracle_ext.to_char(a));
END;
]]></complex-attribute>
                        <category _I_D="56d7ae00-ef8a-40ff-8410-e804e5880ec6" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="c078b8ae-78f5-4c09-8e2a-d03efa6883da" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a timestamp without time zone)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a timestamp without time zone)" unique-function-name="dbms_output$put(IN a timestamp without time zone)" is-aggregate="f" language-name="plpgsql" routine-number="23410" comment="This procedure puts a piece of timestamp (without time zone) information in the output buffer." arguments-datatypes="timestamp without time zone" is-returning-set="f" ret-datatype="void" function-arguments="IN a timestamp without time zone" function-type="RET_SCALAR" count-arguments="1" function-id="23410" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a timestamp without time zone" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => aws_oracle_ext.to_char(a));
END;
]]></complex-attribute>
                        <category _I_D="b4d1cc02-f1bb-4e02-8dc8-9d0a0f7007e7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="0c17bc25-d604-4572-8545-25d8c1c5cc22" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a uuid)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a uuid)" unique-function-name="dbms_output$put(IN a uuid)" is-aggregate="f" language-name="plpgsql" routine-number="23418" comment="This procedure puts a piece of UUID information in the output buffer." arguments-datatypes="uuid" is-returning-set="f" ret-datatype="void" function-arguments="IN a uuid" function-type="RET_SCALAR" count-arguments="1" function-id="23418" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a uuid" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a uuid)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => a::TEXT);
END;
]]></complex-attribute>
                        <category _I_D="80c4ae44-83ac-4dbe-a513-ecf5d6f94ed4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="f2249738-69ea-48b2-b2d4-68b439f0344c" schema-id="21999" name="dbms_output$put" context="dbms_output$put(IN a xml)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a xml)" unique-function-name="dbms_output$put(IN a xml)" is-aggregate="f" language-name="plpgsql" routine-number="23417" comment="This procedure puts a piece of XML document information in the output buffer." arguments-datatypes="xml" is-returning-set="f" ret-datatype="void" function-arguments="IN a xml" function-type="RET_SCALAR" count-arguments="1" function-id="23417" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a xml" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put(IN a xml)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put(a => a::TEXT);
END;
]]></complex-attribute>
                        <category _I_D="b6b78ba3-2d1e-4359-8b2d-87c7c8dfe658" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="ae712013-b808-4b5c-9fe1-427143cac214" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a bigint)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a bigint)" unique-function-name="dbms_output$put_line(IN a bigint)" is-aggregate="f" language-name="plpgsql" routine-number="23422" comment="This procedure puts a piece of numeric (bigint) information in the output buffer followed by an end-of-line marker." arguments-datatypes="bigint" is-returning-set="f" ret-datatype="void" function-arguments="IN a bigint" function-type="RET_SCALAR" count-arguments="1" function-id="23422" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a bigint" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a bigint)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => aws_oracle_ext.to_char(a::NUMERIC));
END;
]]></complex-attribute>
                        <category _I_D="afc62331-188a-40cf-bca0-960a2b7dd3c5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="10872cd0-3a75-4d53-a748-21f737e26f76" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a boolean)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a boolean)" unique-function-name="dbms_output$put_line(IN a boolean)" is-aggregate="f" language-name="plpgsql" routine-number="23450" comment="This procedure puts a piece of boolean information in the output buffer followed by an end-of-line marker." arguments-datatypes="boolean" is-returning-set="f" ret-datatype="void" function-arguments="IN a boolean" function-type="RET_SCALAR" count-arguments="1" function-id="23450" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a boolean" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a boolean)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => a::TEXT);
END;
]]></complex-attribute>
                        <category _I_D="b38fa7a6-548e-4309-b346-7e9f9283b4da" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="c2d37b9d-24d3-4a95-8750-f3e3af041948" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a bytea)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a bytea)" unique-function-name="dbms_output$put_line(IN a bytea)" is-aggregate="f" language-name="plpgsql" routine-number="23427" comment="This procedure puts a piece of binary information in the output buffer followed by an end-of-line marker." arguments-datatypes="bytea" is-returning-set="f" ret-datatype="void" function-arguments="IN a bytea" function-type="RET_SCALAR" count-arguments="1" function-id="23427" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a bytea" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a bytea)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => upper(encode(a, 'hex')));
END;
]]></complex-attribute>
                        <category _I_D="7410d5bc-3c87-43e0-aed4-704cee479933" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="3500201d-fff8-4460-8d1b-8fda9809bf59" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a date)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a date)" unique-function-name="dbms_output$put_line(IN a date)" is-aggregate="f" language-name="plpgsql" routine-number="23428" arguments-datatypes="date" is-returning-set="f" ret-datatype="void" function-arguments="IN a date" function-type="RET_SCALAR" count-arguments="1" function-id="23428" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a date" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a date)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => aws_oracle_ext.to_char(a));
END;
]]></complex-attribute>
                        <category _I_D="771111a5-e02a-4357-98eb-197cbb7663f4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="715353fb-34b5-4578-a5d5-d49d133c77e3" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a double precision)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a double precision)" unique-function-name="dbms_output$put_line(IN a double precision)" is-aggregate="f" language-name="plpgsql" routine-number="23425" comment="This procedure puts a piece of numeric (double precision) information in the output buffer followed by an end-of-line marker." arguments-datatypes="double precision" is-returning-set="f" ret-datatype="void" function-arguments="IN a double precision" function-type="RET_SCALAR" count-arguments="1" function-id="23425" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a double precision" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a double precision)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_num_part_arr TEXT[];
    v_double_prec_num VARCHAR := '0';
BEGIN
    IF (a != 0)
    THEN
        -- 7386346580.845332 => " 7.3863465808453321e+09"
        v_double_prec_num := to_char(a, '9.9999999999999999EEEE');

        -- " 7.3863465808453321e+09" => {" 7.3863465808453321", "09"}
        v_num_part_arr := regexp_split_to_array(v_double_prec_num, 'e(\+|-)');

        -- Collecting all three parts together.
        v_double_prec_num := concat(rtrim(ltrim(v_num_part_arr[1]), '0'), -- " 7.3863465808453321" => "7.3863465808453321"
                                    upper(substring(v_double_prec_num from '(e(\+|-))')), -- (e+)"E+" or (e-)"E-"
                                    lpad(v_num_part_arr[2], 3, '0')); -- "09" => "009"
        -- 1.E+000 => 1.0E+000
        v_double_prec_num := replace(v_double_prec_num, '.E', '.0E');
    END IF;

    CALL aws_oracle_ext.dbms_output$put_line(a => CASE
                                                     WHEN a IS NOT NULL
                                                     THEN v_double_prec_num
                                                  END);
END;
]]></complex-attribute>
                        <category _I_D="b26459bb-57c3-4136-857b-d6fbcaf56e25" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="b9aae6fa-70e7-40b5-8b86-b4883c694db9" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a integer)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a integer)" unique-function-name="dbms_output$put_line(IN a integer)" is-aggregate="f" language-name="plpgsql" routine-number="23421" comment="This procedure puts a piece of numeric (integer) information in the output buffer followed by an end-of-line marker." arguments-datatypes="integer" is-returning-set="f" ret-datatype="void" function-arguments="IN a integer" function-type="RET_SCALAR" count-arguments="1" function-id="23421" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a integer" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a integer)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => aws_oracle_ext.to_char(a));
END;
]]></complex-attribute>
                        <category _I_D="8d9ba9a5-872a-47c3-80af-f56c12ec4757" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="6b0e0277-f5e0-4606-b399-469c29644028" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a interval)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a interval)" unique-function-name="dbms_output$put_line(IN a interval)" is-aggregate="f" language-name="plpgsql" routine-number="23433" comment="This procedure puts a piece of interval information in the output buffer followed by an end-of-line marker." arguments-datatypes="interval" is-returning-set="f" ret-datatype="void" function-arguments="IN a interval" function-type="RET_SCALAR" count-arguments="1" function-id="23433" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a interval" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a interval)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => aws_oracle_ext.to_char(a));
END;
]]></complex-attribute>
                        <category _I_D="7b8724f2-2a82-4041-bd06-803e1d3d85d2" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="146fd273-ac81-44a2-86c4-f53d20d8106f" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a json)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a json)" unique-function-name="dbms_output$put_line(IN a json)" is-aggregate="f" language-name="plpgsql" routine-number="23435" comment="This procedure puts a piece of JSON document information in the output buffer followed by an end-of-line marker." arguments-datatypes="json" is-returning-set="f" ret-datatype="void" function-arguments="IN a json" function-type="RET_SCALAR" count-arguments="1" function-id="23435" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a json" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a json)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => jsonb_pretty(a::JSONB));
END;
]]></complex-attribute>
                        <category _I_D="e7e1ae70-f5cb-4738-818b-643197118c52" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="f328c1a8-6c27-44cc-8592-7bb079fd75b8" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a jsonb)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a jsonb)" unique-function-name="dbms_output$put_line(IN a jsonb)" is-aggregate="f" language-name="plpgsql" routine-number="23439" comment="This procedure puts a piece of binary JSON document information in the output buffer followed by an end-of-line marker." arguments-datatypes="jsonb" is-returning-set="f" ret-datatype="void" function-arguments="IN a jsonb" function-type="RET_SCALAR" count-arguments="1" function-id="23439" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a jsonb" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a jsonb)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => jsonb_pretty(a));
END;
]]></complex-attribute>
                        <category _I_D="a0d34546-6204-4a74-ab23-fefd5fc8d512" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="c91afde2-f082-4ff3-8531-84e9048ab326" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a money)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a money)" unique-function-name="dbms_output$put_line(IN a money)" is-aggregate="f" language-name="plpgsql" routine-number="23426" comment="This procedure puts a piece of money information in the output buffer followed by an end-of-line marker." arguments-datatypes="money" is-returning-set="f" ret-datatype="void" function-arguments="IN a money" function-type="RET_SCALAR" count-arguments="1" function-id="23426" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a money" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a money)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => aws_oracle_ext.to_char(a::NUMERIC, 'fmL999G999G999G999G999G999D00'));
END;
]]></complex-attribute>
                        <category _I_D="9bf2a8bd-c6a4-494d-8a3c-5f7ef29b00b4" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="62415a95-ceb2-422b-98b7-dd78fd1fc4bb" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a numeric)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a numeric)" unique-function-name="dbms_output$put_line(IN a numeric)" is-aggregate="f" language-name="plpgsql" routine-number="23423" comment="This procedure puts a piece of numeric information in the output buffer followed by an end-of-line marker." arguments-datatypes="numeric" is-returning-set="f" ret-datatype="void" function-arguments="IN a numeric" function-type="RET_SCALAR" count-arguments="1" function-id="23423" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a numeric" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a numeric)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => aws_oracle_ext.to_char(a));
END;
]]></complex-attribute>
                        <category _I_D="fe706727-9b83-4214-a196-bb6a56de2250" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="5d4f6f2e-4966-4d71-b253-6bbb63ed8fc1" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a real)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a real)" unique-function-name="dbms_output$put_line(IN a real)" is-aggregate="f" language-name="plpgsql" routine-number="23424" comment="This procedure puts a piece of numeric (real) information in the output buffer followed by an end-of-line marker." arguments-datatypes="real" is-returning-set="f" ret-datatype="void" function-arguments="IN a real" function-type="RET_SCALAR" count-arguments="1" function-id="23424" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a real" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a real)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_num_part_arr TEXT[];
    v_real_num VARCHAR := '0';
BEGIN
    IF (a != 0)
    THEN
        -- 183546872.2342 => " 1.83546880e+08"
        v_real_num := to_char(a, '9.99999999EEEE');

        -- " 1.83546880e+08" => {" 1.83546880", "08"}
        v_num_part_arr := regexp_split_to_array(v_real_num, 'e(\+|-)');

        -- Collecting all three parts together.
        v_real_num := concat(rtrim(ltrim(v_num_part_arr[1]), '0'), -- " 1.83546880" => "1.8354688"
                                    upper(substring(v_real_num from '(e(\+|-))')), -- (e+)"E+" or (e-)"E-"
                                    lpad(v_num_part_arr[2], 3, '0')); -- "08" => "008"
        -- 1.E+000 => 1.0E+000
        v_real_num := replace(v_real_num, '.E', '.0E');
    END IF;

    CALL aws_oracle_ext.dbms_output$put_line(a => CASE
                                                     WHEN a IS NOT NULL
                                                     THEN v_real_num
                                                  END);
END;
]]></complex-attribute>
                        <category _I_D="bf86c0f3-4fc1-4eed-9110-3bf412938d03" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="96b67084-1f65-4b38-b596-b807c4612b9e" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a smallint)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a smallint)" unique-function-name="dbms_output$put_line(IN a smallint)" is-aggregate="f" language-name="plpgsql" routine-number="23420" comment="This procedure puts a piece of numeric (smallint) information in the output buffer followed by an end-of-line marker." arguments-datatypes="smallint" is-returning-set="f" ret-datatype="void" function-arguments="IN a smallint" function-type="RET_SCALAR" count-arguments="1" function-id="23420" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a smallint" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a smallint)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => aws_oracle_ext.to_char(a));
END;
]]></complex-attribute>
                        <category _I_D="b2f841ed-c67f-470f-9f16-43b5023dbc8c" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="8683c695-f811-4e34-a344-6d2f2aefe1d3" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a time with time zone)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a time with time zone)" unique-function-name="dbms_output$put_line(IN a time with time zone)" is-aggregate="f" language-name="plpgsql" routine-number="23432" comment="This procedure puts a piece of time (with time zone) information in the output buffer followed by an end-of-line marker." arguments-datatypes="time with time zone" is-returning-set="f" ret-datatype="void" function-arguments="IN a time with time zone" function-type="RET_SCALAR" count-arguments="1" function-id="23432" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a time with time zone" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a time with time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => a::TEXT);
END;
]]></complex-attribute>
                        <category _I_D="e73fab40-c92c-4a77-8939-229f7a43f12a" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="8ee3c101-7b44-454d-8817-fafc9c7b52c2" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a time without time zone)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a time without time zone)" unique-function-name="dbms_output$put_line(IN a time without time zone)" is-aggregate="f" language-name="plpgsql" routine-number="23431" comment="This procedure puts a piece of time (without time zone) information in the output buffer followed by an end-of-line marker." arguments-datatypes="time without time zone" is-returning-set="f" ret-datatype="void" function-arguments="IN a time without time zone" function-type="RET_SCALAR" count-arguments="1" function-id="23431" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a time without time zone" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a time without time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => a::TEXT);
END;
]]></complex-attribute>
                        <category _I_D="4ec1d201-9a99-44f9-973d-9740611de0f5" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="1c2026fa-fcc8-45d4-969a-94d9bfc78ba6" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a timestamp with time zone)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a timestamp with time zone)" unique-function-name="dbms_output$put_line(IN a timestamp with time zone)" is-aggregate="f" language-name="plpgsql" routine-number="23430" comment="This procedure puts a piece of timestamp (with time zone) information in the output buffer followed by an end-of-line marker." arguments-datatypes="timestamp with time zone" is-returning-set="f" ret-datatype="void" function-arguments="IN a timestamp with time zone" function-type="RET_SCALAR" count-arguments="1" function-id="23430" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a timestamp with time zone" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a timestamp with time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => aws_oracle_ext.to_char(a));
END;
]]></complex-attribute>
                        <category _I_D="d1b6c333-e9e2-4282-8f5c-19d4a8890d09" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="51c96c31-d8cf-4fb3-accf-53298eccfee3" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a timestamp without time zone)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a timestamp without time zone)" unique-function-name="dbms_output$put_line(IN a timestamp without time zone)" is-aggregate="f" language-name="plpgsql" routine-number="23429" comment="This procedure puts a piece of timestamp (without time zone) information in the output buffer followed by an end-of-line marker." arguments-datatypes="timestamp without time zone" is-returning-set="f" ret-datatype="void" function-arguments="IN a timestamp without time zone" function-type="RET_SCALAR" count-arguments="1" function-id="23429" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a timestamp without time zone" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a timestamp without time zone)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => aws_oracle_ext.to_char(a));
END;
]]></complex-attribute>
                        <category _I_D="bf065493-2ecb-42c0-a198-a93710bd1a9b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="5d86b234-b3d3-4857-b651-e76ceb3de3ae" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a uuid)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a uuid)" unique-function-name="dbms_output$put_line(IN a uuid)" is-aggregate="f" language-name="plpgsql" routine-number="23449" comment="This procedure puts a piece of UUID information in the output buffer followed by an end-of-line marker." arguments-datatypes="uuid" is-returning-set="f" ret-datatype="void" function-arguments="IN a uuid" function-type="RET_SCALAR" count-arguments="1" function-id="23449" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a uuid" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a uuid)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => a::TEXT);
END;
]]></complex-attribute>
                        <category _I_D="a063b9da-cbaf-4c2f-911b-b3d22250d1fd" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="984c104b-08cf-4f8a-a78c-8b6aa2c51c90" schema-id="21999" name="dbms_output$put_line" context="dbms_output$put_line(IN a xml)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN a xml)" unique-function-name="dbms_output$put_line(IN a xml)" is-aggregate="f" language-name="plpgsql" routine-number="23441" comment="This procedure puts a piece of XML document information in the output buffer followed by an end-of-line marker." arguments-datatypes="xml" is-returning-set="f" ret-datatype="void" function-arguments="IN a xml" function-type="RET_SCALAR" count-arguments="1" function-id="23441" volatility="VOLATILE" is-window="f" function-identity-arguments="IN a xml" overload-function-count="19" proc-language="plpgsql" function-signature="dbms_output$put_line(IN a xml)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.dbms_output$put_line(a => a::TEXT);
END;
]]></complex-attribute>
                        <category _I_D="17f15361-3698-4910-abaf-92a3341ad24b" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="00f37c72-3978-46a2-9c20-c0f9dc8e193e" schema-id="21999" name="dbms_xslprocessor$clob2file" context="dbms_xslprocessor$clob2file(IN cl text, IN flocation character varying, IN fname character varying)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN cl text, IN flocation character varying, IN fname character varying)" unique-function-name="dbms_xslprocessor$clob2file(IN cl text, IN flocation character varying, IN fname character varying)" is-aggregate="f" language-name="plpgsql" routine-number="23533" comment="This procedure writes content of a character large object (CLOB) into a file." arguments-datatypes="text,character varying,character varying" is-returning-set="f" ret-datatype="void" function-arguments="IN cl text, IN flocation character varying, IN fname character varying" function-type="RET_SCALAR" count-arguments="3" function-id="23533" volatility="VOLATILE" is-window="f" function-identity-arguments="IN cl text, IN flocation character varying, IN fname character varying" overload-function-count="4" proc-language="plpgsql" function-signature="dbms_xslprocessor$clob2file(IN cl text, IN flocation character varying, IN fname character varying)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.put_text_file_on_s3(text_data      => cl, /* Text data (CLOB) */
                                            directory_name => flocation::TEXT, /* DIRECTORY name */
                                            file_name      => fname::TEXT); /* File name */
END;
]]></complex-attribute>
                        <category _I_D="05e143a7-253f-4697-afa8-60159150e835" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="8da64adf-d8a4-4884-b8c8-8cbf589f3f51" schema-id="21999" name="dbms_xslprocessor$clob2file" context="dbms_xslprocessor$clob2file(IN cl text, IN flocation character varying, IN fname text)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN cl text, IN flocation character varying, IN fname text)" unique-function-name="dbms_xslprocessor$clob2file(IN cl text, IN flocation character varying, IN fname text)" is-aggregate="f" language-name="plpgsql" routine-number="23531" comment="This procedure writes content of a character large object (CLOB) into a file." arguments-datatypes="text,character varying,text" is-returning-set="f" ret-datatype="void" function-arguments="IN cl text, IN flocation character varying, IN fname text" function-type="RET_SCALAR" count-arguments="3" function-id="23531" volatility="VOLATILE" is-window="f" function-identity-arguments="IN cl text, IN flocation character varying, IN fname text" overload-function-count="4" proc-language="plpgsql" function-signature="dbms_xslprocessor$clob2file(IN cl text, IN flocation character varying, IN fname text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.put_text_file_on_s3(text_data      => cl, /* Text data (CLOB) */
                                            directory_name => flocation::TEXT, /* DIRECTORY name */
                                            file_name      => fname); /* File name */
END;
]]></complex-attribute>
                        <category _I_D="3e39ce5b-7a6e-4c70-b137-15151b5dc03f" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="4cf6908e-9e0a-492f-bb30-8e54a4c2911b" schema-id="21999" name="dbms_xslprocessor$clob2file" context="dbms_xslprocessor$clob2file(IN cl text, IN flocation text, IN fname character varying)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN cl text, IN flocation text, IN fname character varying)" unique-function-name="dbms_xslprocessor$clob2file(IN cl text, IN flocation text, IN fname character varying)" is-aggregate="f" language-name="plpgsql" routine-number="23532" comment="This procedure writes content of a character large object (CLOB) into a file." arguments-datatypes="text,text,character varying" is-returning-set="f" ret-datatype="void" function-arguments="IN cl text, IN flocation text, IN fname character varying" function-type="RET_SCALAR" count-arguments="3" function-id="23532" volatility="VOLATILE" is-window="f" function-identity-arguments="IN cl text, IN flocation text, IN fname character varying" overload-function-count="4" proc-language="plpgsql" function-signature="dbms_xslprocessor$clob2file(IN cl text, IN flocation text, IN fname character varying)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.put_text_file_on_s3(text_data      => cl, /* Text data (CLOB) */
                                            directory_name => flocation, /* DIRECTORY name */
                                            file_name      => fname::TEXT); /* File name */
END;
]]></complex-attribute>
                        <category _I_D="f76b1417-696d-4e9a-9132-f262b4fc8158" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="c79e980d-a007-475d-95d7-58c5e2873b71" schema-id="21999" name="dbms_xslprocessor$clob2file" context="dbms_xslprocessor$clob2file(IN cl text, IN flocation text, IN fname text)" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-suffix="(IN cl text, IN flocation text, IN fname text)" unique-function-name="dbms_xslprocessor$clob2file(IN cl text, IN flocation text, IN fname text)" is-aggregate="f" language-name="plpgsql" routine-number="23530" comment="This procedure writes content of a character large object (CLOB) into a file." arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="IN cl text, IN flocation text, IN fname text" function-type="RET_SCALAR" count-arguments="3" function-id="23530" volatility="VOLATILE" is-window="f" function-identity-arguments="IN cl text, IN flocation text, IN fname text" overload-function-count="4" proc-language="plpgsql" function-signature="dbms_xslprocessor$clob2file(IN cl text, IN flocation text, IN fname text)">
                        <complex-attribute name="sql"><![CDATA[
BEGIN
    CALL aws_oracle_ext.put_text_file_on_s3(text_data      => cl, /* Text data (CLOB) */
                                            directory_name => flocation, /* DIRECTORY name */
                                            file_name      => fname); /* File name */
END;
]]></complex-attribute>
                        <category _I_D="114f027b-1e46-41d5-9675-0d2202d4a4f7" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="6463972c-72b3-49fd-abbb-c74bbd32e59c" schema-id="21999" name="put_text_file_on_s3" context="put_text_file_on_s3" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-function-name="put_text_file_on_s3" is-aggregate="f" language-name="plpgsql" comment="This procedure reads the provided text data and uploads it a text file to an AWS S3 bucket." arguments-datatypes="text,text,text" is-returning-set="f" ret-datatype="void" function-arguments="IN text_data text, IN directory_name text, IN file_name text" function-type="RET_SCALAR" count-arguments="3" function-id="23529" volatility="VOLATILE" is-window="f" function-identity-arguments="IN text_data text, IN directory_name text, IN file_name text" overload-function-count="1" proc-language="plpgsql" function-signature="put_text_file_on_s3(IN text_data text, IN directory_name text, IN file_name text)">
                        <complex-attribute name="sql"><![CDATA[
DECLARE
    v_file_data TEXT;
    v_bucket_name TEXT;
    v_bucket_path TEXT;
    v_aws_region VARCHAR(50);
    v_err_message TEXT;
BEGIN
    IF (file_name ~ '^\s*$')
    THEN
        -- ORA-22288: file or LOB operation FILEOPEN failed
        RAISE USING MESSAGE := 'File or LOB operation failed.',
                    DETAIL := 'Make sure the file name is correct and that the file actually exists.',
                    HINT := '-22288';
    ELSIF (file_name IS NULL)
    THEN
        -- ORA-06502: PL/SQL: numeric or value error
        RAISE USING MESSAGE := 'Numeric or value error.',
                    DETAIL := 'The file name is null. Correct the file name and make sure that the file actually exists.',
                    HINT := '-6502';
    END IF;

    SELECT s3_bucket_name,
           s3_bucket_path,
           aws_region
      INTO STRICT
           v_bucket_name,
           v_bucket_path,
           v_aws_region
      FROM aws_oracle_ext.sys_dba_directories drs
     WHERE drs.directory_name = put_text_file_on_s3.directory_name;

    -- Temp table for exporting the text file data from
    CREATE TEMP TABLE aws_s3_file_data$f8e6cd5394ee3e
    ON COMMIT DROP
    AS
    SELECT text_data AS file_data;

    -- Inserting the file into a given table and uploading it to the S3 bucket
    PERFORM 1
       FROM aws_s3.query_export_to_s3(query     => 'SELECT file_data
                                                      FROM aws_s3_file_data$f8e6cd5394ee3e',
                                      bucket    => v_bucket_name,
                                      file_path => concat_ws('/', v_bucket_path, file_name),
                                      region    => v_aws_region,
                                      options   => 'NULL ''''');
EXCEPTION
    WHEN no_data_found THEN
        -- ORA-29280: invalid directory object
        RAISE USING MESSAGE := 'Invalid directory object.',
                    DETAIL := 'The directory object passed in does not exist in the database. Check that the name is correct and create a directory object if necessary.',
                    HINT := '-29280';
    WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS
            v_err_message = MESSAGE_TEXT;

        IF (v_err_message ~* 'credentials stored with the database')
        THEN
            -- IAM role containing the s3Import feature error
            RAISE USING MESSAGE := 'The IAM role containing the s3Export feature is not associated with the DB instance.',
                        DETAIL := 'The credentials stored with the database instance can''t be accessed.',
                        HINT := 'Make sure that the desired Amazon Resource Name (ARN) is associated with the feature-name: s3Export.';
        ELSE
            RAISE;
        END IF;
END;
]]></complex-attribute>
                        <category _I_D="c4172eb5-cddf-4529-ac45-f2d506923a81" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                    <procedure _I_D="c8106ac0-16c7-439c-9794-083e91a1566d" schema-id="21999" name="raise_ai_exception" context="raise_ai_exception" subcategories-loading="none" object-loading="extended" is-trigger-function="0" unique-function-name="raise_ai_exception" is-aggregate="f" language-name="plpgsql" arguments-datatypes="integer,text,text" is-returning-set="f" ret-datatype="void" function-arguments="IN p_ai_code integer, IN p_message text, IN p_severity text DEFAULT 'CRITICAL'::text" function-type="RET_SCALAR" count-arguments="3" function-id="23228" volatility="VOLATILE" is-window="f" function-identity-arguments="IN p_ai_code integer, IN p_message text, IN p_severity text" overload-function-count="1" proc-language="plpgsql" function-signature="raise_ai_exception(IN p_ai_code integer, IN p_message text, IN p_severity text)">
                        <complex-attribute name="sql"><![CDATA[ 
declare
  l_stack text;
  l_object text;
  l_line integer;
begin
 get diagnostics l_stack = pg_context;
 
  select line[1], line[2]
    into l_object, l_line
    from regexp_matches(l_stack,'PL/pgSQL function (.*?)line (.*?) ', 'g') as stack_lines(line)
   limit 1 offset 1;
  
  if l_object is null then
  select line[1], line[2]
    into l_object, l_line
    from regexp_matches( l_stack, 'SQL function (\S+) statement (\d+)', 'g') as stack_lines(line)
    limit 1;
  end if;
  raise exception 
    using message = format('%I at line %s, AI %s [%s]: %s', l_object, l_line, p_ai_code, p_severity, p_message);
end;
]]></complex-attribute>
                        <category _I_D="fe33b647-a40a-4676-b6f3-8f91aab132ec" name="Parameters" order-num="0" objects-loading="none" subcategories-loading="none" child-type="parameter"/>
                    </procedure>
                </category>
                <category _I_D="df60c693-e812-4e95-9dc7-bcc1270381ed" name="Sequences" order-num="11" objects-loading="extended" subcategories-loading="full" child-type="sequence">
                    <sequence _I_D="e0d32f60-a1ac-488c-83b3-982a573c817b" name="charset_mapping_id_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="charset_mapping_id_seq" subcategories-loading="full" object-loading="extended" cache-value="1" last-value="230"/>
                    <sequence _I_D="3914a6f9-9d35-4c7c-a671-5135227f7cc5" name="jobs_job_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="jobs_job_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="59b397ef-bd91-4203-a4e5-4d836e2761dd" name="mail_messages_id_seq" data-type="bigint" start-value="1" minimum-value="1" maximum-value="9223372036854775807" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="mail_messages_id_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                    <sequence _I_D="0eaae6d6-205a-486b-9726-a95b98b440f5" name="sqs_queues_tables_id_seq" data-type="integer" start-value="1" minimum-value="1" maximum-value="2147483647" increment="1" cycle-option="NO" cache-size="1" owner="postgres" context="sqs_queues_tables_id_seq" subcategories-loading="full" object-loading="extended" cache-value="1"/>
                </category>
                <category _I_D="d0f9c210-a073-4e8a-8a27-5957de98b5a3" name="User defined types" order-num="12" objects-loading="extended" subcategories-loading="none" child-type="type">
                    <type _I_D="816151f3-efa5-4859-b62f-9d94fedfe586" name="dbms_aq$dequeue_options_t" udt-type="STRUCTURED" context="dbms_aq$dequeue_options_t" subcategories-loading="none" object-loading="extended">
                        <category _I_D="5f592731-8685-43f3-84e0-0e078904f012" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="698e75e3-142c-4400-820e-29305a2838c4" name="dbms_aq$enqueue_options_t" udt-type="STRUCTURED" context="dbms_aq$enqueue_options_t" subcategories-loading="none" object-loading="extended">
                        <category _I_D="50643d0d-931b-4bbc-a450-863bd78d05bc" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="bea7f21c-7a3a-464e-ab02-cb5b87f78df1" name="dbms_aq$message_properties_t" udt-type="STRUCTURED" context="dbms_aq$message_properties_t" subcategories-loading="none" object-loading="extended">
                        <category _I_D="c3ab1e29-aa23-46fe-ae42-b3c6cc11eb87" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="8af91718-b8d1-41b5-9846-89205ed30bb0" name="dbms_xmlgen$tcontext" udt-type="STRUCTURED" context="dbms_xmlgen$tcontext" subcategories-loading="none" object-loading="extended">
                        <category _I_D="dbd8a08c-b934-4709-98a3-865b5fa99e36" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="62a218cb-81ad-435c-a10d-ebef808d5907" name="dbms_xmlgen$tctxattributes" udt-type="STRUCTURED" context="dbms_xmlgen$tctxattributes" subcategories-loading="none" object-loading="extended">
                        <category _I_D="de5ad761-99bc-4b47-aefc-68abe85002e2" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="a50ed856-5e01-4320-822c-b4c09aabfd93" name="dbms_xmlquery$tcontext" udt-type="STRUCTURED" context="dbms_xmlquery$tcontext" subcategories-loading="none" object-loading="extended">
                        <category _I_D="131fa82a-5ed3-4050-a130-ac40491806cf" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="368bf332-921a-4f4a-abdb-f64b3f376157" name="dbms_xmlquery$tctxattributes" udt-type="STRUCTURED" context="dbms_xmlquery$tctxattributes" subcategories-loading="none" object-loading="extended">
                        <category _I_D="a6aa059c-f1f2-4b82-9b9f-fa9e41dab852" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="2af12fe2-3777-40ab-aa8e-15958f187192" name="dbms_xmlquery$tctxdictionary" udt-type="STRUCTURED" context="dbms_xmlquery$tctxdictionary" subcategories-loading="none" object-loading="extended">
                        <category _I_D="59a59d73-d7bc-442c-af9a-e0794ca107b1" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="43c5227f-ba0b-4974-aadb-c271a741b392" name="nls_param" udt-type="STRUCTURED" context="nls_param" subcategories-loading="none" object-loading="extended">
                        <category _I_D="99c70f94-6cdc-4d73-bcdc-c973eec7961d" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="3238ad54-7ca7-45a7-8a23-cbfa65343be9" name="sql$bulk_exceptions" udt-type="STRUCTURED" context="sql$bulk_exceptions" subcategories-loading="none" object-loading="extended">
                        <category _I_D="cc7a4f15-abe7-4cff-bf8a-dbac6b2018af" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="c45643b8-16f9-4de4-b4c4-4b40d67aa5b0" name="sqs_aq$_agent" udt-type="STRUCTURED" context="sqs_aq$_agent" subcategories-loading="none" object-loading="extended">
                        <category _I_D="16ea3bdb-8469-4a45-ac7a-b13e3ee1cb7d" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="c0b2f64d-b246-4f17-a276-4ffdfaaf08e2" name="sqs_aq$_sig_prop" udt-type="STRUCTURED" context="sqs_aq$_sig_prop" subcategories-loading="none" object-loading="extended">
                        <category _I_D="f8ed1a37-af9e-48ec-a8a8-accac6bacb0f" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="054b0dc5-0de2-4f72-90e6-0a4084aa2393" name="sqs_queue_record" udt-type="STRUCTURED" context="sqs_queue_record" subcategories-loading="none" object-loading="extended">
                        <category _I_D="8714ea07-5ef8-4d6a-a73e-5286ec4bafc0" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="870e2436-7b2a-4997-8c32-5c52af1163a0" name="utl_file$file_type" udt-type="STRUCTURED" context="utl_file$file_type" subcategories-loading="none" object-loading="extended">
                        <category _I_D="2a588f86-811d-4168-b41d-6eabf98702bc" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="144f1173-c3dc-429c-a651-fc7a2dfa3782" name="utl_smtp$connection" udt-type="STRUCTURED" context="utl_smtp$connection" subcategories-loading="none" object-loading="extended">
                        <category _I_D="aee60aa0-3145-4b5e-836e-5f56f2ce4912" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="3bf0ffa6-89ee-4fe1-8fe3-2b134a56955c" name="utl_smtp$reply" udt-type="STRUCTURED" context="utl_smtp$reply" subcategories-loading="none" object-loading="extended">
                        <category _I_D="edc3f67c-b96b-45fd-a8d3-3b5370d97ce4" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                    <type _I_D="45744355-df30-471a-86be-f3b158f5b517" name="xmltype$txml2json" udt-type="STRUCTURED" context="xmltype$txml2json" subcategories-loading="none" object-loading="extended">
                        <category _I_D="60808425-bc4f-45c7-a4d5-66c2fd6856ec" name="Attributes" order-num="0" objects-loading="none" subcategories-loading="none" child-type="attribute"/>
                    </type>
                </category>
                <category _I_D="d4b03ae3-ab1c-412d-857a-b6e6ab10e035" name="Domains" order-num="13" objects-loading="extended" subcategories-loading="none" child-type="domain">
                    <domain _I_D="56cd7bbc-87ec-45f2-80e8-d721d0605e4e" domain-schema="aws_oracle_ext" name="ora_exception" data-type="character varying" character-maximum-length="92" dt-name="character varying" dt-attr-1="92" is-nullable="N" context="ora_exception" subcategories-loading="none" object-loading="extended">
                        <category _I_D="677b9bf8-1801-4419-b915-57c380733f26" name="Constraints" order-num="0" objects-loading="none" subcategories-loading="none" child-type="constraint"/>
                    </domain>
                    <domain _I_D="461916fd-f92b-4898-8ad3-99ea4cc70e50" domain-schema="aws_oracle_ext" name="utl_smtp$replies" data-type="aws_oracle_ext.&quot;utl_smtp$reply&quot;[]" dt-name="aws_oracle_ext.&quot;utl_smtp$reply&quot;[]" is-nullable="Y" context="utl_smtp$replies" subcategories-loading="none" object-loading="extended" element-type="USER-DEFINED">
                        <category _I_D="88c2c8ee-38b0-4526-8f63-d3e4abf548f1" name="Constraints" order-num="0" objects-loading="none" subcategories-loading="none" child-type="constraint"/>
                    </domain>
                </category>
                <category _I_D="309350c7-2c3f-4618-a3f3-18ee5ce9590d" name="Materialized Views" order-num="14" objects-loading="main" subcategories-loading="none" child-type="materialized-view">
                    <materialized-view _I_D="e25db2c9-c3d2-4c7c-99e2-a1443473b5c7" name="sys_dba_directories" context="sys_dba_directories" subcategories-loading="none" object-loading="extended" with-data="WITH DATA">
                        <complex-attribute name="sql"><![CDATA[ SELECT 'aws_oracle_ext'::character varying(128) AS owner,
    directory_name,
    directory_path,
    NULLIF("substring"(directory_path, '^\s*(?:(?:arn:aws:[sS]3:::\s*)|(?:[sS]3://\s*))?([[:alnum:]\?\.-]*)'::text), ''::text) AS s3_bucket_name,
    NULLIF(regexp_replace("substring"(directory_path, '^\s*(?:(?:arn:aws:[sS]3:::\s*)|(?:[sS]3://\s*))?[[:alnum:]\?\.-]*/(.*)'::text), '/?\s*\*?\s*$'::text, ''::text, 'g'::text), ''::text) AS s3_bucket_path,
    (TRIM(BOTH FROM aws_region))::character varying(50) AS aws_region,
    (origin_con_id)::numeric AS origin_con_id
   FROM aws_oracle_ext.directories;]]></complex-attribute>
                        <category _I_D="034f6d67-5bbc-402a-852c-5d8fef5131b6" name="Columns" order-num="0" objects-loading="none" subcategories-loading="none" child-type="column"/>
                        <category _I_D="e2b0341d-15d0-46fb-868e-d090d969932d" name="Indexes" order-num="1" objects-loading="none" subcategories-loading="none" child-type="index" mdl-expected-node-count="2"/>
                    </materialized-view>
                </category>
                <category _I_D="7034a95a-7d4c-4b81-895c-7338f5e8b1a0" name="Aggregates" order-num="15" objects-loading="empty" subcategories-loading="full" child-type="aggregate"/>
            </schema>
            <schema _I_D="f3fbc432-6a6b-414a-8e6e-4e821ee8985f" name="information_schema" is-empty="N" context="information_schema" subcategories-loading="none" object-loading="extended" schema-owner="postgres" is-system="Y">
                <category _I_D="e544776a-85a0-4157-816a-20f9ef98dce2" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="36e70832-8b93-41e0-99e8-3cf3c1e83f3f" name="Foreign tables" order-num="1" objects-loading="none" subcategories-loading="none" child-type="foreigntable"/>
                <category _I_D="e454c1c7-7a20-4d18-bf4c-7d2a242d3733" name="Views" order-num="2" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="0c29b588-71e5-4236-81ef-c3072f1ab985" name="Collations" order-num="3" objects-loading="none" subcategories-loading="none" child-type="collation"/>
                <category _I_D="f6925294-148f-4868-92d0-325d6b174fd7" name="Operators" order-num="4" objects-loading="none" subcategories-loading="none" child-type="operator"/>
                <category _I_D="b642a0bb-a9d9-41cc-9d85-148e11d1531d" name="Rules" order-num="5" objects-loading="none" subcategories-loading="none" child-type="rule"/>
                <category _I_D="3b28b746-750b-48b5-b8b7-3dcbb8360052" name="FTS Configurations" order-num="6" objects-loading="none" subcategories-loading="none" child-type="ftsconfiguration"/>
                <category _I_D="c396acd8-d5a4-4c21-b04b-8da2d3b8c7fd" name="FTS Dictionaries" order-num="7" objects-loading="none" subcategories-loading="none" child-type="ftsdictionary"/>
                <category _I_D="0578e9c2-3a40-4018-b358-4db7e322b774" name="Functions" order-num="8" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="d2aa04f1-7553-4006-bdd3-725d5d6e1768" name="Trigger functions" order-num="9" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="306cca7f-72e7-4d1a-92a4-fabb1af85331" name="Procedures" order-num="10" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="0585aadf-54bd-4faf-ac6c-fe41ac329da9" name="Sequences" order-num="11" objects-loading="none" subcategories-loading="none" child-type="sequence"/>
                <category _I_D="35cbdd5e-4dab-4580-8317-8fef244ed500" name="User defined types" order-num="12" objects-loading="none" subcategories-loading="none" child-type="type"/>
                <category _I_D="c8589b15-29bc-415e-ba9d-58aeb50f1388" name="Domains" order-num="13" objects-loading="none" subcategories-loading="none" child-type="domain"/>
                <category _I_D="637e7fbc-ebce-4222-a6e0-9e31f1afdc1f" name="Materialized Views" order-num="14" objects-loading="none" subcategories-loading="none" child-type="materialized-view"/>
                <category _I_D="515011bf-4715-4682-9c6f-d0c1a95fd3a0" name="Aggregates" order-num="15" objects-loading="none" subcategories-loading="none" child-type="aggregate"/>
            </schema>
            <schema _I_D="91b4b7bb-09e8-4cf3-b0e7-df42b1ff6ee6" name="pg_catalog" is-empty="N" context="pg_catalog" subcategories-loading="none" object-loading="extended" schema-owner="postgres" is-system="Y">
                <category _I_D="e658d428-9cfb-4203-8b7d-a8d85ef5f87b" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="0fcb0db8-4749-4687-9a4b-c6592fd232ce" name="Foreign tables" order-num="1" objects-loading="none" subcategories-loading="none" child-type="foreigntable"/>
                <category _I_D="2156007a-d88a-483b-9c80-7e42f5fa784f" name="Views" order-num="2" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="ddfdd58b-20b1-40b0-b5ec-22d5b6f3de09" name="Collations" order-num="3" objects-loading="none" subcategories-loading="none" child-type="collation"/>
                <category _I_D="75299a05-f2a0-4490-abb4-6c74a1d29e1f" name="Operators" order-num="4" objects-loading="none" subcategories-loading="none" child-type="operator"/>
                <category _I_D="48ed493a-b125-4b19-bd2f-2e34f833165b" name="Rules" order-num="5" objects-loading="none" subcategories-loading="none" child-type="rule"/>
                <category _I_D="deaaec1e-cc4a-4903-bde7-6721eed79d2d" name="FTS Configurations" order-num="6" objects-loading="none" subcategories-loading="none" child-type="ftsconfiguration"/>
                <category _I_D="f15070f2-602a-43d8-8d7a-c929829c902b" name="FTS Dictionaries" order-num="7" objects-loading="none" subcategories-loading="none" child-type="ftsdictionary"/>
                <category _I_D="a3cd6f3c-26b2-48d4-b0d8-2403cccc5a3c" name="Functions" order-num="8" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="6d5bc5ba-bf1e-41fc-ae58-e3c479b51ebb" name="Trigger functions" order-num="9" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="761f45f2-d62c-4e9a-81df-aedd63d3e20e" name="Procedures" order-num="10" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="e3650949-cb43-4f82-8852-e7f96bbc8533" name="Sequences" order-num="11" objects-loading="none" subcategories-loading="none" child-type="sequence"/>
                <category _I_D="dd8c51a3-b71f-4e6a-8dcc-5790503fbea2" name="User defined types" order-num="12" objects-loading="none" subcategories-loading="none" child-type="type"/>
                <category _I_D="1f3f7fd5-65ac-475c-91e7-79662413e019" name="Domains" order-num="13" objects-loading="none" subcategories-loading="none" child-type="domain"/>
                <category _I_D="87c5d54e-35d4-4ded-a228-a83e2615e2ca" name="Materialized Views" order-num="14" objects-loading="none" subcategories-loading="none" child-type="materialized-view"/>
                <category _I_D="2b191ea3-a17d-4a1b-b084-732921259f49" name="Aggregates" order-num="15" objects-loading="none" subcategories-loading="none" child-type="aggregate"/>
            </schema>
            <schema _I_D="f9c5763c-9807-4fc1-9d8e-345889631814" name="pg_toast" is-empty="N" context="pg_toast" subcategories-loading="none" object-loading="extended" schema-owner="postgres" is-system="Y">
                <category _I_D="f3989f99-fa28-4aed-8f58-736b6f37700e" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="2e909f7a-292f-4bb0-93b0-980604c5a207" name="Foreign tables" order-num="1" objects-loading="none" subcategories-loading="none" child-type="foreigntable"/>
                <category _I_D="c6df1ebd-2e5d-48a5-a1e8-4bd1ed93ffdf" name="Views" order-num="2" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="ebce539f-ab23-468e-9cde-70ae8848cb67" name="Collations" order-num="3" objects-loading="none" subcategories-loading="none" child-type="collation"/>
                <category _I_D="13e2c729-7b33-49ee-b6fe-e05469e80499" name="Operators" order-num="4" objects-loading="none" subcategories-loading="none" child-type="operator"/>
                <category _I_D="a06bae81-bebc-466a-8126-9a52b2cdd149" name="Rules" order-num="5" objects-loading="none" subcategories-loading="none" child-type="rule"/>
                <category _I_D="531f07d2-98c5-4cf7-838f-a8bfdf9f4bae" name="FTS Configurations" order-num="6" objects-loading="none" subcategories-loading="none" child-type="ftsconfiguration"/>
                <category _I_D="6686896f-021d-40fa-a4fb-af2848514e19" name="FTS Dictionaries" order-num="7" objects-loading="none" subcategories-loading="none" child-type="ftsdictionary"/>
                <category _I_D="0b4c9859-4117-4a8b-a413-e3108b0ea38a" name="Functions" order-num="8" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="1130e572-2f62-450f-9fd8-7e6596a2e67a" name="Trigger functions" order-num="9" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="88b0e2cb-1d9c-4871-91f2-20da0cbad779" name="Procedures" order-num="10" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="b1bba2d6-14a8-4da3-9003-50982ed0d2ad" name="Sequences" order-num="11" objects-loading="none" subcategories-loading="none" child-type="sequence"/>
                <category _I_D="10027b90-525f-4602-bee0-cc98304d82a5" name="User defined types" order-num="12" objects-loading="none" subcategories-loading="none" child-type="type"/>
                <category _I_D="aa76c87b-def2-41a6-b82c-a6cb11d0f163" name="Domains" order-num="13" objects-loading="none" subcategories-loading="none" child-type="domain"/>
                <category _I_D="bf90ae66-4549-48b0-8e66-5f393789cbd7" name="Materialized Views" order-num="14" objects-loading="none" subcategories-loading="none" child-type="materialized-view"/>
                <category _I_D="05e5b48b-bcde-4f37-a686-b8cd881cd226" name="Aggregates" order-num="15" objects-loading="none" subcategories-loading="none" child-type="aggregate"/>
            </schema>
            <schema _I_D="f7409442-f870-4e34-a1aa-aea56eb7cf73" name="public" is-empty="Y" context="public" subcategories-loading="none" object-loading="extended" schema-owner="pg_database_owner" is-system="N">
                <category _I_D="03005627-f777-41bf-b7eb-7c8338abc34f" name="Tables" order-num="0" objects-loading="none" subcategories-loading="none" child-type="table"/>
                <category _I_D="92d1f193-3f97-4fbd-80f9-3419d79af4eb" name="Foreign tables" order-num="1" objects-loading="none" subcategories-loading="none" child-type="foreigntable"/>
                <category _I_D="899fa773-86be-4566-bf61-2644c6adccd9" name="Views" order-num="2" objects-loading="none" subcategories-loading="none" child-type="view"/>
                <category _I_D="38f3613b-a9e1-477a-8039-1e3f4a165b2d" name="Collations" order-num="3" objects-loading="none" subcategories-loading="none" child-type="collation"/>
                <category _I_D="c540baed-dea0-44ef-96a9-966e69b1f3c6" name="Operators" order-num="4" objects-loading="none" subcategories-loading="none" child-type="operator"/>
                <category _I_D="0618f33a-a302-4edc-a1d5-69be4e500a9f" name="Rules" order-num="5" objects-loading="none" subcategories-loading="none" child-type="rule"/>
                <category _I_D="13bac093-9578-4062-bf95-09320c02723b" name="FTS Configurations" order-num="6" objects-loading="none" subcategories-loading="none" child-type="ftsconfiguration"/>
                <category _I_D="4b4f3ec7-7e95-412f-aca7-bf38fe3992e3" name="FTS Dictionaries" order-num="7" objects-loading="none" subcategories-loading="none" child-type="ftsdictionary"/>
                <category _I_D="ac31766a-56e3-4b8f-a081-88d7b21ed887" name="Functions" order-num="8" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="b1f9a45d-044a-44b6-b2d6-014dc96b4495" name="Trigger functions" order-num="9" objects-loading="none" subcategories-loading="none" child-type="function"/>
                <category _I_D="2558c5be-a923-4ef8-a08f-cda2cca9a72f" name="Procedures" order-num="10" objects-loading="none" subcategories-loading="none" child-type="procedure"/>
                <category _I_D="e9f6ff5f-547d-4182-8d2f-0ea6107dbbe6" name="Sequences" order-num="11" objects-loading="none" subcategories-loading="none" child-type="sequence"/>
                <category _I_D="d8c0266d-d6d6-4477-bc87-dfdc542cb52b" name="User defined types" order-num="12" objects-loading="none" subcategories-loading="none" child-type="type"/>
                <category _I_D="6fe7ea98-9d05-4c7b-9e63-0313ced58dcc" name="Domains" order-num="13" objects-loading="none" subcategories-loading="none" child-type="domain"/>
                <category _I_D="be4a4266-1952-40b8-aea5-b6daeb3ee329" name="Materialized Views" order-num="14" objects-loading="none" subcategories-loading="none" child-type="materialized-view"/>
                <category _I_D="9cea7de6-bd13-4479-ac28-2ce5ff5a9453" name="Aggregates" order-num="15" objects-loading="none" subcategories-loading="none" child-type="aggregate"/>
            </schema>
            <schema _I_D="a53d4c6d-b101-483e-b4b1-cfe78ff1def3" name="C##CHINOOK" is-empty="N" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:03">
                <category _I_D="b04fd224-61ea-4459-bc40-3d42dad518c7" name="Tables" order-num="0" child-type="table" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables" conversion-version="15">
                    <table _I_D="0df5bf47-adb2-4a17-a984-a386b9c548d2" name="album" transformed="2024-08-25 20:57:14" is-typed="N" partitioned="NO" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04">
                        <category _I_D="d22e6f7b-8d7c-4721-a972-642a725c6670" name="Columns" order-num="0" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Columns" conversion-version="15">
                            <column _I_D="dde731cd-534a-4d2a-abd4-c468b1f4c2ac" name="albumid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Columns,column ALBUMID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="ALBUM" error-code="5984"/>
                            <column _I_D="602c1667-9584-481d-afba-e468d0654f62" name="title" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="N" dt-attr-1="160" ordinal-position="2" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Columns,column TITLE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="ALBUM"/>
                            <column _I_D="4b53f599-3c3c-4333-93eb-4273d3b22096" name="artistid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="3" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Columns,column ARTISTID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="ALBUM" error-code="5984"/>
                        </category>
                        <category _I_D="2c3e3c7d-b4c7-4ccb-bc80-67b57e10b6b8" name="Partition columns" order-num="1" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Partition columns" conversion-version="15"/>
                        <category _I_D="7b393971-276e-4d6d-960a-cda537e9e99b" name="Subpartition columns" order-num="2" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Subpartition columns" conversion-version="15"/>
                        <category _I_D="0b170717-5cb8-4d19-8027-c705c6d6b118" name="Constraints" order-num="4" child-type="constraint" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Constraints" conversion-version="15">
                            <constraint _I_D="8a1357d3-9c26-4008-be95-d2a46d2ca0b3" name="fk_albumartistid" constraint-type-desc="FOREIGN KEY" transformed="2024-08-25 20:57:14" referenced-table-name="artist" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" validated="true" referenced-constraint-schema="C##CHINOOK" referenced-constraint-name="C##CHINOOK" referenced-table-schema="C##CHINOOK" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Constraints,constraint FK_ALBUMARTISTID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="2df244e1-cdd5-4833-98b4-34c19fc9b215" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Constraints,constraint FK_ALBUMARTISTID,category Columns" conversion-version="15">
                                    <column _I_D="a981ba31-07a2-4ec0-b955-c16c42301880" name="artistid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Constraints,constraint FK_ALBUMARTISTID,category Columns,column ARTISTID" conversion-version="15" source-vendor="ORACLE" column-in-referenced-unique-constraint="artistid" mdl-applying-result="applying-success" position-in-referenced-unique-constraint="artistid"/>
                                </category>
                            </constraint>
                            <constraint _I_D="081b9cf6-cae5-4bf3-b19b-ce1502e8a5b9" name="pk_album" constraint-type-desc="PRIMARY KEY" transformed="2024-08-25 20:57:14" constraint-type="PRIMARY KEY" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Constraints,constraint PK_ALBUM" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="bfe71bf1-e81f-41f1-92aa-f7e42bcf5829" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Constraints,constraint PK_ALBUM,category Columns" conversion-version="15">
                                    <column _I_D="bab4b3ef-db0c-4816-9f8b-b558d27175e2" name="albumid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Constraints,constraint PK_ALBUM,category Columns,column ALBUMID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="50e590a3-b23a-46dd-8923-574ed1e93c69" name="Indexes" order-num="5" child-type="index" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Indexes" conversion-version="15"/>
                        <category _I_D="4fd851d9-addb-4a89-88bd-7b1e3e99fff6" name="Triggers" order-num="6" child-type="trigger" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Triggers" conversion-version="15"/>
                        <category _I_D="dd9f411b-66cb-49c4-99e3-b8ba80c13a98" name="Partitions" order-num="7" child-type="partition" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ALBUM,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="8f5f4493-fe5b-4113-b146-1d7f25310bd1" name="artist" transformed="2024-08-25 20:57:14" is-typed="N" partitioned="NO" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ARTIST" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04">
                        <category _I_D="1f641a9e-0b5b-4b8b-b9c2-0b84fa46cedf" name="Columns" order-num="0" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ARTIST,category Columns" conversion-version="15">
                            <column _I_D="eaa13fb7-89b4-4a56-89a5-3c71630ee6ba" name="artistid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ARTIST,category Columns,column ARTISTID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="ARTIST" error-code="5984"/>
                            <column _I_D="09c34a79-26b3-4554-9b8e-824abb3b1781" name="name" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="120" ordinal-position="2" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ARTIST,category Columns,column NAME" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="ARTIST"/>
                        </category>
                        <category _I_D="786ffa98-8409-4373-a591-d53ef1e6bf4e" name="Partition columns" order-num="1" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ARTIST,category Partition columns" conversion-version="15"/>
                        <category _I_D="3530506a-655d-4317-a579-e078a020e92d" name="Subpartition columns" order-num="2" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ARTIST,category Subpartition columns" conversion-version="15"/>
                        <category _I_D="a6f0d7d7-87f9-4274-a7a6-4c155fd30f25" name="Constraints" order-num="4" child-type="constraint" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ARTIST,category Constraints" conversion-version="15">
                            <constraint _I_D="b451a6f2-b813-49ca-ada7-e11e2257909c" name="pk_artist" constraint-type-desc="PRIMARY KEY" transformed="2024-08-25 20:57:14" constraint-type="PRIMARY KEY" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ARTIST,category Constraints,constraint PK_ARTIST" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="4ba9d91b-1c50-4e11-b8c3-105d05885a12" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ARTIST,category Constraints,constraint PK_ARTIST,category Columns" conversion-version="15">
                                    <column _I_D="fddfc1f3-b8e6-4f95-ae29-0913864c0e48" name="artistid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ARTIST,category Constraints,constraint PK_ARTIST,category Columns,column ARTISTID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="2f8184b7-bb52-4bdb-9dae-670668cccdd3" name="Indexes" order-num="5" child-type="index" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ARTIST,category Indexes" conversion-version="15"/>
                        <category _I_D="253e1ae1-c30b-47d7-825b-d031388b3501" name="Triggers" order-num="6" child-type="trigger" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ARTIST,category Triggers" conversion-version="15"/>
                        <category _I_D="d2517728-e623-469f-a4ce-6f8aec886b61" name="Partitions" order-num="7" child-type="partition" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table ARTIST,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="26fc8059-6c01-48aa-a750-b43c34585edd" name="customer" transformed="2024-08-25 20:57:14" is-typed="N" partitioned="NO" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04">
                        <category _I_D="0f429b67-feee-4907-a153-1bfe7659089f" name="Columns" order-num="0" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Columns" conversion-version="15">
                            <column _I_D="5392a7cf-1d0a-458d-be9c-08a34d5ed72b" name="customerid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Columns,column CUSTOMERID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="CUSTOMER" error-code="5984"/>
                            <column _I_D="89ba73db-d7ea-4ef8-9223-2942bd4228c8" name="firstname" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="N" dt-attr-1="40" ordinal-position="2" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Columns,column FIRSTNAME" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="CUSTOMER"/>
                            <column _I_D="a36f3d14-3578-4474-9f7e-1fe7fe4fc66b" name="lastname" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="N" dt-attr-1="20" ordinal-position="3" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Columns,column LASTNAME" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="CUSTOMER"/>
                            <column _I_D="08d89bf7-c66b-468c-a008-3bbc82d2e052" name="company" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="80" ordinal-position="4" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Columns,column COMPANY" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="CUSTOMER"/>
                            <column _I_D="c5b1bad1-b9e5-4667-9748-729ac428cd76" name="address" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="70" ordinal-position="5" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Columns,column ADDRESS" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="CUSTOMER"/>
                            <column _I_D="93e7b0d8-70c5-4dba-acc9-bc8d6cff6fc2" name="city" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="40" ordinal-position="6" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Columns,column CITY" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="CUSTOMER"/>
                            <column _I_D="90809327-bd24-4315-8e05-51907f013453" name="state" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="40" ordinal-position="7" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Columns,column STATE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="CUSTOMER"/>
                            <column _I_D="ef789f2e-09b3-4594-b8a4-07bd625b03c3" name="country" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="40" ordinal-position="8" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Columns,column COUNTRY" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="CUSTOMER"/>
                            <column _I_D="602c035e-42e6-4460-a74c-33530096425c" name="postalcode" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="10" ordinal-position="9" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Columns,column POSTALCODE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="CUSTOMER"/>
                            <column _I_D="8d0853a5-bd62-4bc6-8d8f-bad2c4ebdd77" name="phone" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="24" ordinal-position="10" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Columns,column PHONE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="CUSTOMER"/>
                            <column _I_D="32b936d3-985d-4ace-9237-4008624582f8" name="fax" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="24" ordinal-position="11" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Columns,column FAX" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="CUSTOMER"/>
                            <column _I_D="5935ad76-5034-4ae2-8ba9-99d6424e2ecc" name="email" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="N" dt-attr-1="60" ordinal-position="12" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Columns,column EMAIL" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="CUSTOMER"/>
                            <column _I_D="37fb53ee-ab0d-4def-98b4-470f1ab8f884" name="supportrepid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="Y" ordinal-position="13" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Columns,column SUPPORTREPID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="CUSTOMER" error-code="5984"/>
                        </category>
                        <category _I_D="7f298b60-b16e-4d21-8407-fe318497e51f" name="Partition columns" order-num="1" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Partition columns" conversion-version="15"/>
                        <category _I_D="d630d628-00fc-427a-8663-7499876c4445" name="Subpartition columns" order-num="2" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Subpartition columns" conversion-version="15"/>
                        <category _I_D="857ddd0b-0efc-4ea5-b71d-74905521ce93" name="Constraints" order-num="4" child-type="constraint" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Constraints" conversion-version="15">
                            <constraint _I_D="aee9060e-72b2-47a2-b059-487343c56e2b" name="fk_customersupportrepid" constraint-type-desc="FOREIGN KEY" transformed="2024-08-25 20:57:14" referenced-table-name="employee" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" validated="true" referenced-constraint-schema="C##CHINOOK" referenced-constraint-name="C##CHINOOK" referenced-table-schema="C##CHINOOK" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Constraints,constraint FK_CUSTOMERSUPPORTREPID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="2f04fb2e-3bb9-45df-96e5-c78ff34c7cc8" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Constraints,constraint FK_CUSTOMERSUPPORTREPID,category Columns" conversion-version="15">
                                    <column _I_D="782f76f7-dee7-4441-9066-0f38856d24ea" name="supportrepid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Constraints,constraint FK_CUSTOMERSUPPORTREPID,category Columns,column SUPPORTREPID" conversion-version="15" source-vendor="ORACLE" column-in-referenced-unique-constraint="employeeid" mdl-applying-result="applying-success" position-in-referenced-unique-constraint="employeeid"/>
                                </category>
                            </constraint>
                            <constraint _I_D="1aad49d1-7165-4566-9873-1c6c11f2919c" name="pk_customer" constraint-type-desc="PRIMARY KEY" transformed="2024-08-25 20:57:14" constraint-type="PRIMARY KEY" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Constraints,constraint PK_CUSTOMER" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="e8e75e99-8885-47d0-94e5-3fbc9ea19eee" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Constraints,constraint PK_CUSTOMER,category Columns" conversion-version="15">
                                    <column _I_D="6317d57b-432a-4331-9c69-efb0c2863ae6" name="customerid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Constraints,constraint PK_CUSTOMER,category Columns,column CUSTOMERID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="5d790c25-ef4a-44ec-8567-1e212c32c8e7" name="Indexes" order-num="5" child-type="index" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Indexes" conversion-version="15"/>
                        <category _I_D="114d2871-b66c-4fac-a9b7-5c158dc234e9" name="Triggers" order-num="6" child-type="trigger" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Triggers" conversion-version="15"/>
                        <category _I_D="2dc4c507-677d-4944-b47c-fe6a69061216" name="Partitions" order-num="7" child-type="partition" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table CUSTOMER,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="44136fdb-df91-4251-868e-fffa4dc627b5" name="employee" transformed="2024-08-25 20:57:14" is-typed="N" partitioned="NO" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04">
                        <category _I_D="39be7a94-b2a5-4210-aa22-24bd3afd820e" name="Columns" order-num="0" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns" conversion-version="15">
                            <column _I_D="0ff73cf8-544d-45b0-97ad-dcd04131bb1a" name="employeeid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column EMPLOYEEID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE" error-code="5984"/>
                            <column _I_D="e12f1cfa-4c43-41e0-8cc8-1fe4b83182fa" name="lastname" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="N" dt-attr-1="20" ordinal-position="2" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column LASTNAME" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE"/>
                            <column _I_D="7280d1cf-08a7-46fc-bace-52afc8ee1b1f" name="firstname" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="N" dt-attr-1="20" ordinal-position="3" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column FIRSTNAME" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE"/>
                            <column _I_D="2ef3f016-66df-4016-9cb3-36aa32ca410d" name="title" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="30" ordinal-position="4" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column TITLE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE"/>
                            <column _I_D="887ac243-816b-44ec-86e1-3c283d33ddc4" name="reportsto" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="Y" ordinal-position="5" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column REPORTSTO" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE" error-code="5984"/>
                            <column _I_D="b81f625f-9e57-4bd6-80a6-a4c27d281c02" name="birthdate" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="0" ordinal-position="6" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column BIRTHDATE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE"/>
                            <column _I_D="c879ec60-c44f-4f26-b22a-0784cedb83ac" name="hiredate" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="0" ordinal-position="7" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column HIREDATE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE"/>
                            <column _I_D="a1201f5d-7634-47ad-b208-78121d6cb8ef" name="address" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="70" ordinal-position="8" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column ADDRESS" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE"/>
                            <column _I_D="1a204b4a-5997-4946-844f-ea039970c1ef" name="city" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="40" ordinal-position="9" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column CITY" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE"/>
                            <column _I_D="a1196c4b-6b46-4c2e-a713-5d5139444f59" name="state" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="40" ordinal-position="10" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column STATE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE"/>
                            <column _I_D="ab2e573f-0803-4f9d-a2b6-a6e0b01b46b0" name="country" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="40" ordinal-position="11" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column COUNTRY" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE"/>
                            <column _I_D="d54cec95-148a-4204-869b-4d7c4d51ab75" name="postalcode" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="10" ordinal-position="12" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column POSTALCODE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE"/>
                            <column _I_D="542100e6-3c06-4281-a37a-cee876673af9" name="phone" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="24" ordinal-position="13" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column PHONE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE"/>
                            <column _I_D="7385777f-07b7-42a2-97a3-ff8780343aea" name="fax" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="24" ordinal-position="14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column FAX" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE"/>
                            <column _I_D="239c434e-5672-4ffe-b119-45c6c4444542" name="email" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="60" ordinal-position="15" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Columns,column EMAIL" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="EMPLOYEE"/>
                        </category>
                        <category _I_D="55c5108a-679d-42b0-8270-b006360eab1f" name="Partition columns" order-num="1" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Partition columns" conversion-version="15"/>
                        <category _I_D="c012ae76-9c8b-467a-ab27-a5aaeb518ad3" name="Subpartition columns" order-num="2" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Subpartition columns" conversion-version="15"/>
                        <category _I_D="b02ba2eb-5587-4f38-92cc-94732005c938" name="Constraints" order-num="4" child-type="constraint" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Constraints" conversion-version="15">
                            <constraint _I_D="2c103412-d01f-4062-a7fe-726c0d3e0dbb" name="fk_employeereportsto" constraint-type-desc="FOREIGN KEY" transformed="2024-08-25 20:57:14" referenced-table-name="employee" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" validated="true" referenced-constraint-schema="C##CHINOOK" referenced-constraint-name="C##CHINOOK" referenced-table-schema="C##CHINOOK" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Constraints,constraint FK_EMPLOYEEREPORTSTO" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="416fcc15-f749-4030-bcd2-a4b3c395fbba" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Constraints,constraint FK_EMPLOYEEREPORTSTO,category Columns" conversion-version="15">
                                    <column _I_D="628f524e-54d7-4018-8894-62b3998ad745" name="reportsto" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Constraints,constraint FK_EMPLOYEEREPORTSTO,category Columns,column REPORTSTO" conversion-version="15" source-vendor="ORACLE" column-in-referenced-unique-constraint="employeeid" mdl-applying-result="applying-success" position-in-referenced-unique-constraint="employeeid"/>
                                </category>
                            </constraint>
                            <constraint _I_D="8f14527d-97f4-4859-b8e8-375156539f2b" name="pk_employee" constraint-type-desc="PRIMARY KEY" transformed="2024-08-25 20:57:14" constraint-type="PRIMARY KEY" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Constraints,constraint PK_EMPLOYEE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="11d3ecb5-c5be-4ca7-a37e-a50585c72962" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Constraints,constraint PK_EMPLOYEE,category Columns" conversion-version="15">
                                    <column _I_D="3d892f9b-b77e-439e-b73c-b7c256692d90" name="employeeid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Constraints,constraint PK_EMPLOYEE,category Columns,column EMPLOYEEID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="39a07ed4-ab61-4750-87e1-32a23a86bd94" name="Indexes" order-num="5" child-type="index" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Indexes" conversion-version="15"/>
                        <category _I_D="11e558f2-8648-4de3-ad0f-844fc6bc2f76" name="Triggers" order-num="6" child-type="trigger" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Triggers" conversion-version="15"/>
                        <category _I_D="9d188881-88e1-4813-ab56-b6caec4a4f5e" name="Partitions" order-num="7" child-type="partition" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table EMPLOYEE,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="bcd443ec-d580-4995-9ce0-a98ebfc1bd57" name="genre" transformed="2024-08-25 20:57:14" is-typed="N" partitioned="NO" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table GENRE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04">
                        <category _I_D="4110b82e-90b8-485a-948f-8f264348c589" name="Columns" order-num="0" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table GENRE,category Columns" conversion-version="15">
                            <column _I_D="90e604bc-4da7-47c9-87e2-93f862a07cf8" name="genreid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table GENRE,category Columns,column GENREID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="GENRE" error-code="5984"/>
                            <column _I_D="97ae03bc-982c-425a-b520-e8c4331ad90a" name="name" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="120" ordinal-position="2" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table GENRE,category Columns,column NAME" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="GENRE"/>
                        </category>
                        <category _I_D="eccca49d-b905-4ae1-912f-d37db986edcd" name="Partition columns" order-num="1" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table GENRE,category Partition columns" conversion-version="15"/>
                        <category _I_D="0d7ef56a-3e8a-4ebc-9057-bb015e12e118" name="Subpartition columns" order-num="2" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table GENRE,category Subpartition columns" conversion-version="15"/>
                        <category _I_D="daf51ba4-46fd-4e4a-a846-cb072fe3a27a" name="Constraints" order-num="4" child-type="constraint" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table GENRE,category Constraints" conversion-version="15">
                            <constraint _I_D="a4c1ded9-cfd8-4d13-8be3-3c7f6fa02d88" name="pk_genre" constraint-type-desc="PRIMARY KEY" transformed="2024-08-25 20:57:14" constraint-type="PRIMARY KEY" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table GENRE,category Constraints,constraint PK_GENRE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="23daa6ab-961c-4b07-8629-b5688e395601" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table GENRE,category Constraints,constraint PK_GENRE,category Columns" conversion-version="15">
                                    <column _I_D="ce520868-93f6-4333-8863-abe5e75be76d" name="genreid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table GENRE,category Constraints,constraint PK_GENRE,category Columns,column GENREID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="19120541-c2be-4f3c-aaa7-0acf7de0d92d" name="Indexes" order-num="5" child-type="index" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table GENRE,category Indexes" conversion-version="15"/>
                        <category _I_D="fec9a9a2-22d9-48af-945a-6c33eac07334" name="Triggers" order-num="6" child-type="trigger" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table GENRE,category Triggers" conversion-version="15"/>
                        <category _I_D="9c9b5d4d-d4e5-4f54-b578-fe9baedabfba" name="Partitions" order-num="7" child-type="partition" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table GENRE,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="edb632e7-0c48-450e-800d-9a54204d381e" name="invoice" transformed="2024-08-25 20:57:14" is-typed="N" partitioned="NO" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04">
                        <category _I_D="e2ba5fd0-b891-42a8-b2ea-89a9bafd2500" name="Columns" order-num="0" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Columns" conversion-version="15">
                            <column _I_D="bf0ace9e-0a4a-4778-a730-a96c8218d40c" name="invoiceid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Columns,column INVOICEID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="INVOICE" error-code="5984"/>
                            <column _I_D="dc2ad494-497f-4a7c-bec1-c056ebdfcb0a" name="customerid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="2" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Columns,column CUSTOMERID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="INVOICE" error-code="5984"/>
                            <column _I_D="789e4f65-7ca7-41b6-9df9-300e83abb10d" name="invoicedate" dt-name="TIMESTAMP WITHOUT TIME ZONE" transformed="2024-08-25 20:57:14" is-nullable="N" dt-attr-1="0" ordinal-position="3" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Columns,column INVOICEDATE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="INVOICE"/>
                            <column _I_D="c0a9150a-3294-4ccb-9b26-10e5e41f560a" name="billingaddress" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="70" ordinal-position="4" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Columns,column BILLINGADDRESS" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="INVOICE"/>
                            <column _I_D="27499485-4849-42c6-aaea-eebda88ab0f3" name="billingcity" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="40" ordinal-position="5" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Columns,column BILLINGCITY" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="INVOICE"/>
                            <column _I_D="f8406c03-6f90-4596-a3a9-ff9ec907dbc0" name="billingstate" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="40" ordinal-position="6" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Columns,column BILLINGSTATE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="INVOICE"/>
                            <column _I_D="bc411887-84f2-451e-a049-f5f4f33e4c09" name="billingcountry" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="40" ordinal-position="7" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Columns,column BILLINGCOUNTRY" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="INVOICE"/>
                            <column _I_D="2b477efe-64bc-4b3d-a07d-389b97e76154" name="billingpostalcode" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="10" ordinal-position="8" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Columns,column BILLINGPOSTALCODE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="INVOICE"/>
                            <column _I_D="ca8946c6-2fff-4a6c-9127-1024d39cc8a5" name="total" dt-name="DOUBLE PRECISION" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="9" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Columns,column TOTAL" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="INVOICE"/>
                        </category>
                        <category _I_D="6c4c0f5b-968e-425d-ad6d-8138125b2d4f" name="Partition columns" order-num="1" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Partition columns" conversion-version="15"/>
                        <category _I_D="46a9d857-615e-4e1b-8b4c-e0ec24eef293" name="Subpartition columns" order-num="2" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Subpartition columns" conversion-version="15"/>
                        <category _I_D="cd724f7f-7ef1-4971-8925-bd6713a8f52b" name="Constraints" order-num="4" child-type="constraint" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Constraints" conversion-version="15">
                            <constraint _I_D="bccf58c2-586a-4c30-8e5c-14a420967da6" name="fk_invoicecustomerid" constraint-type-desc="FOREIGN KEY" transformed="2024-08-25 20:57:14" referenced-table-name="customer" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" validated="true" referenced-constraint-schema="C##CHINOOK" referenced-constraint-name="C##CHINOOK" referenced-table-schema="C##CHINOOK" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Constraints,constraint FK_INVOICECUSTOMERID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="77bd4475-4c8f-4851-a42f-90ac045bbc75" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Constraints,constraint FK_INVOICECUSTOMERID,category Columns" conversion-version="15">
                                    <column _I_D="bb09d4eb-6d15-4384-bf7c-f6824500238f" name="customerid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Constraints,constraint FK_INVOICECUSTOMERID,category Columns,column CUSTOMERID" conversion-version="15" source-vendor="ORACLE" column-in-referenced-unique-constraint="customerid" mdl-applying-result="applying-success" position-in-referenced-unique-constraint="customerid"/>
                                </category>
                            </constraint>
                            <constraint _I_D="b752ba67-4771-4a23-a800-3504a8ad9b27" name="pk_invoice" constraint-type-desc="PRIMARY KEY" transformed="2024-08-25 20:57:14" constraint-type="PRIMARY KEY" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Constraints,constraint PK_INVOICE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="59801cf3-66b0-43c0-bdb5-b7acb9925dc5" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Constraints,constraint PK_INVOICE,category Columns" conversion-version="15">
                                    <column _I_D="6dbcedad-5c31-4fb9-a476-d87da1fafd98" name="invoiceid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Constraints,constraint PK_INVOICE,category Columns,column INVOICEID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="578edd86-6f1b-481b-90aa-73d87a56e548" name="Indexes" order-num="5" child-type="index" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Indexes" conversion-version="15"/>
                        <category _I_D="f74c46c8-893c-4d56-bee1-710cb32e9279" name="Triggers" order-num="6" child-type="trigger" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Triggers" conversion-version="15"/>
                        <category _I_D="80d221d1-f59c-4f54-b495-bedac73c5c07" name="Partitions" order-num="7" child-type="partition" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICE,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="fbd88694-8798-41fd-afa3-8ac38735a45a" name="invoiceline" transformed="2024-08-25 20:57:14" is-typed="N" partitioned="NO" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04">
                        <category _I_D="2e407775-82cd-4bf6-b972-74efebf89335" name="Columns" order-num="0" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Columns" conversion-version="15">
                            <column _I_D="80c931bf-7779-46a3-94bd-aaf3ea89dceb" name="invoicelineid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Columns,column INVOICELINEID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="INVOICELINE" error-code="5984"/>
                            <column _I_D="42c5c905-5d59-448a-aecc-937be0f5dd6a" name="invoiceid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="2" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Columns,column INVOICEID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="INVOICELINE" error-code="5984"/>
                            <column _I_D="e36e2964-f0a2-4d53-baad-386987d70ae0" name="trackid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="3" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Columns,column TRACKID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="INVOICELINE" error-code="5984"/>
                            <column _I_D="9cb1386b-31b9-43a4-a3e1-83d1f6b7dc05" name="unitprice" dt-name="DOUBLE PRECISION" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="4" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Columns,column UNITPRICE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="INVOICELINE"/>
                            <column _I_D="f262379c-88a8-49dd-bb6c-b4b25bc9a352" name="quantity" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="5" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Columns,column QUANTITY" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="INVOICELINE" error-code="5984"/>
                        </category>
                        <category _I_D="30a6f3cc-f9bc-496d-bcc0-c115160818bc" name="Partition columns" order-num="1" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Partition columns" conversion-version="15"/>
                        <category _I_D="e311359c-1bc3-479e-a382-5791a56fade5" name="Subpartition columns" order-num="2" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Subpartition columns" conversion-version="15"/>
                        <category _I_D="631daaf7-21bd-404b-a3e0-d2a99e03814d" name="Constraints" order-num="4" child-type="constraint" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Constraints" conversion-version="15">
                            <constraint _I_D="59561cbb-a0d6-477c-83bb-0cf98dfe61d1" name="fk_invoicelineinvoiceid" constraint-type-desc="FOREIGN KEY" transformed="2024-08-25 20:57:14" referenced-table-name="invoice" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" validated="true" referenced-constraint-schema="C##CHINOOK" referenced-constraint-name="C##CHINOOK" referenced-table-schema="C##CHINOOK" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Constraints,constraint FK_INVOICELINEINVOICEID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="778aeddb-22a6-4979-a314-d6a872a73937" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Constraints,constraint FK_INVOICELINEINVOICEID,category Columns" conversion-version="15">
                                    <column _I_D="6834850d-0471-4bb3-829e-060bace8199c" name="invoiceid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Constraints,constraint FK_INVOICELINEINVOICEID,category Columns,column INVOICEID" conversion-version="15" source-vendor="ORACLE" column-in-referenced-unique-constraint="invoiceid" mdl-applying-result="applying-success" position-in-referenced-unique-constraint="invoiceid"/>
                                </category>
                            </constraint>
                            <constraint _I_D="1ca738b0-d2e3-4b8b-9027-a4378216dd6f" name="fk_invoicelinetrackid" constraint-type-desc="FOREIGN KEY" transformed="2024-08-25 20:57:14" referenced-table-name="track" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" validated="true" referenced-constraint-schema="C##CHINOOK" referenced-constraint-name="C##CHINOOK" referenced-table-schema="C##CHINOOK" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Constraints,constraint FK_INVOICELINETRACKID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="db8cb948-db9c-4dbd-a03f-a6e286a291a7" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Constraints,constraint FK_INVOICELINETRACKID,category Columns" conversion-version="15">
                                    <column _I_D="4b59f572-b283-42ca-8725-d1dd0ab6251e" name="trackid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Constraints,constraint FK_INVOICELINETRACKID,category Columns,column TRACKID" conversion-version="15" source-vendor="ORACLE" column-in-referenced-unique-constraint="trackid" mdl-applying-result="applying-success" position-in-referenced-unique-constraint="trackid"/>
                                </category>
                            </constraint>
                            <constraint _I_D="c112fae5-51c7-4c75-a8f7-dfa87c35c20a" name="pk_invoiceline" constraint-type-desc="PRIMARY KEY" transformed="2024-08-25 20:57:14" constraint-type="PRIMARY KEY" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Constraints,constraint PK_INVOICELINE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="1c530748-c474-4930-ab43-b8c7712dc7b9" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Constraints,constraint PK_INVOICELINE,category Columns" conversion-version="15">
                                    <column _I_D="b88d5ae2-6d66-4d10-9603-2e980a99aac8" name="invoicelineid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Constraints,constraint PK_INVOICELINE,category Columns,column INVOICELINEID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="1ab84d2a-bb2e-40c4-8d6f-f059d029e25f" name="Indexes" order-num="5" child-type="index" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Indexes" conversion-version="15"/>
                        <category _I_D="65cccc10-19a2-4c2c-a84f-9fca13ccf23f" name="Triggers" order-num="6" child-type="trigger" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Triggers" conversion-version="15"/>
                        <category _I_D="8d62f3b7-87be-460e-87eb-88d61f8755da" name="Partitions" order-num="7" child-type="partition" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table INVOICELINE,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="b4041a18-1e1a-4430-9e04-9daa2cca4968" name="mediatype" transformed="2024-08-25 20:57:14" is-typed="N" partitioned="NO" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table MEDIATYPE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04">
                        <category _I_D="68a5d17f-7142-4ca8-b996-215ab0631ebf" name="Columns" order-num="0" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table MEDIATYPE,category Columns" conversion-version="15">
                            <column _I_D="46ee77df-ee01-449e-97f2-fd624052bb50" name="mediatypeid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table MEDIATYPE,category Columns,column MEDIATYPEID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="MEDIATYPE" error-code="5984"/>
                            <column _I_D="6171cec2-a086-468e-8b9e-411a47cda74c" name="name" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="120" ordinal-position="2" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table MEDIATYPE,category Columns,column NAME" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="MEDIATYPE"/>
                        </category>
                        <category _I_D="ff138cc7-efed-4b2c-9af2-947ae6b9cafd" name="Partition columns" order-num="1" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table MEDIATYPE,category Partition columns" conversion-version="15"/>
                        <category _I_D="d00bd5eb-76c2-4c9e-b589-cd29ea8a84d1" name="Subpartition columns" order-num="2" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table MEDIATYPE,category Subpartition columns" conversion-version="15"/>
                        <category _I_D="b0903f98-78ee-4eb0-b7e8-94ab04dd6bf8" name="Constraints" order-num="4" child-type="constraint" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table MEDIATYPE,category Constraints" conversion-version="15">
                            <constraint _I_D="06957100-b1e6-486f-a32f-f98a9e17f3ed" name="pk_mediatype" constraint-type-desc="PRIMARY KEY" transformed="2024-08-25 20:57:14" constraint-type="PRIMARY KEY" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table MEDIATYPE,category Constraints,constraint PK_MEDIATYPE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="de4081aa-cb7e-42de-9faa-f9c0fd2dd971" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table MEDIATYPE,category Constraints,constraint PK_MEDIATYPE,category Columns" conversion-version="15">
                                    <column _I_D="e7ed5e68-24de-4f34-8a63-b41446f6444d" name="mediatypeid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table MEDIATYPE,category Constraints,constraint PK_MEDIATYPE,category Columns,column MEDIATYPEID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="8a6e20b3-b7f7-451c-ae11-2a4d697d4a46" name="Indexes" order-num="5" child-type="index" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table MEDIATYPE,category Indexes" conversion-version="15"/>
                        <category _I_D="1a0a6c95-14c1-49d6-993c-6287d5e80b3c" name="Triggers" order-num="6" child-type="trigger" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table MEDIATYPE,category Triggers" conversion-version="15"/>
                        <category _I_D="6d034524-b931-4242-80ad-84bb45b3a392" name="Partitions" order-num="7" child-type="partition" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table MEDIATYPE,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="c62eba2b-8b48-4944-96d7-5947a3e4c19c" name="playlist" transformed="2024-08-25 20:57:14" is-typed="N" partitioned="NO" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLIST" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04">
                        <category _I_D="fee4efee-9ad1-410d-afec-eae7d3ef7940" name="Columns" order-num="0" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLIST,category Columns" conversion-version="15">
                            <column _I_D="e9a41672-8427-4096-80bb-7c91259593f6" name="playlistid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLIST,category Columns,column PLAYLISTID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="PLAYLIST" error-code="5984"/>
                            <column _I_D="58bf1629-d36b-4af8-a77d-9e5c95c51209" name="name" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="120" ordinal-position="2" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLIST,category Columns,column NAME" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="PLAYLIST"/>
                        </category>
                        <category _I_D="01cf1b95-3839-479e-be07-70a501edb910" name="Partition columns" order-num="1" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLIST,category Partition columns" conversion-version="15"/>
                        <category _I_D="98785830-d6c7-4f73-9902-7a3b9cf104e7" name="Subpartition columns" order-num="2" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLIST,category Subpartition columns" conversion-version="15"/>
                        <category _I_D="553e6ba0-c319-4739-8eff-c3390bf081b3" name="Constraints" order-num="4" child-type="constraint" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLIST,category Constraints" conversion-version="15">
                            <constraint _I_D="7ef7a498-73e9-49f1-ab1b-735d76f4a24d" name="pk_playlist" constraint-type-desc="PRIMARY KEY" transformed="2024-08-25 20:57:14" constraint-type="PRIMARY KEY" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLIST,category Constraints,constraint PK_PLAYLIST" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="610b6411-d4a3-402f-872c-40301fc6633a" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLIST,category Constraints,constraint PK_PLAYLIST,category Columns" conversion-version="15">
                                    <column _I_D="40474478-4ebb-41a1-8cb3-4cacdb84901d" name="playlistid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLIST,category Constraints,constraint PK_PLAYLIST,category Columns,column PLAYLISTID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="5b71b6e7-c771-434e-a2e6-a38e567324c8" name="Indexes" order-num="5" child-type="index" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLIST,category Indexes" conversion-version="15"/>
                        <category _I_D="88b78b4e-f647-449d-a8fd-f45e251b4fbc" name="Triggers" order-num="6" child-type="trigger" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLIST,category Triggers" conversion-version="15"/>
                        <category _I_D="6dc00a7c-6ff2-4c4b-ad5f-e93187ae5493" name="Partitions" order-num="7" child-type="partition" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLIST,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="ca972181-5cba-48dc-a9de-894d92c4f585" name="playlisttrack" transformed="2024-08-25 20:57:14" is-typed="N" partitioned="NO" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04">
                        <category _I_D="1786e1e4-6713-45c6-a7ea-21648f6b39a6" name="Columns" order-num="0" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Columns" conversion-version="15">
                            <column _I_D="04a54eab-5ecb-448e-832f-ff8c7a3da3f2" name="playlistid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Columns,column PLAYLISTID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="PLAYLISTTRACK" error-code="5984"/>
                            <column _I_D="184a6414-6c4d-48be-bb48-bb9e189ee846" name="trackid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="2" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Columns,column TRACKID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="PLAYLISTTRACK" error-code="5984"/>
                        </category>
                        <category _I_D="cabf3157-8eb5-4aba-8e8c-a538a429fb2a" name="Partition columns" order-num="1" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Partition columns" conversion-version="15"/>
                        <category _I_D="17b7b2c4-498c-4de3-8aa1-a40a9384b58c" name="Subpartition columns" order-num="2" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Subpartition columns" conversion-version="15"/>
                        <category _I_D="87f63f7c-b49b-4d48-84ac-17e7939bd99d" name="Constraints" order-num="4" child-type="constraint" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Constraints" conversion-version="15">
                            <constraint _I_D="c2ede992-ec3f-450c-bc73-fb1e43827920" name="fk_playlisttrackplaylistid" constraint-type-desc="FOREIGN KEY" transformed="2024-08-25 20:57:14" referenced-table-name="playlist" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" validated="true" referenced-constraint-schema="C##CHINOOK" referenced-constraint-name="C##CHINOOK" referenced-table-schema="C##CHINOOK" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Constraints,constraint FK_PLAYLISTTRACKPLAYLISTID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="61ba3692-2568-4741-b940-e9bbba212c75" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Constraints,constraint FK_PLAYLISTTRACKPLAYLISTID,category Columns" conversion-version="15">
                                    <column _I_D="9eac2b83-019b-407c-aceb-a0d40f2c68b4" name="playlistid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Constraints,constraint FK_PLAYLISTTRACKPLAYLISTID,category Columns,column PLAYLISTID" conversion-version="15" source-vendor="ORACLE" column-in-referenced-unique-constraint="playlistid" mdl-applying-result="applying-success" position-in-referenced-unique-constraint="playlistid"/>
                                </category>
                            </constraint>
                            <constraint _I_D="e6db3463-c571-4ef2-94cc-56f04538731e" name="fk_playlisttracktrackid" constraint-type-desc="FOREIGN KEY" transformed="2024-08-25 20:57:14" referenced-table-name="track" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" validated="true" referenced-constraint-schema="C##CHINOOK" referenced-constraint-name="C##CHINOOK" referenced-table-schema="C##CHINOOK" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Constraints,constraint FK_PLAYLISTTRACKTRACKID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="210b9328-c880-4884-8dff-09630d21ef12" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Constraints,constraint FK_PLAYLISTTRACKTRACKID,category Columns" conversion-version="15">
                                    <column _I_D="0ac3eaa5-2adb-4325-88cc-f180eb4e33a5" name="trackid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Constraints,constraint FK_PLAYLISTTRACKTRACKID,category Columns,column TRACKID" conversion-version="15" source-vendor="ORACLE" column-in-referenced-unique-constraint="trackid" mdl-applying-result="applying-success" position-in-referenced-unique-constraint="trackid"/>
                                </category>
                            </constraint>
                            <constraint _I_D="934e3efe-4640-458d-928c-ea1da38ce774" name="pk_playlisttrack" constraint-type-desc="PRIMARY KEY" transformed="2024-08-25 20:57:14" constraint-type="PRIMARY KEY" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Constraints,constraint PK_PLAYLISTTRACK" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="df86e694-a705-400f-9d6f-1ab5a0368c28" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Constraints,constraint PK_PLAYLISTTRACK,category Columns" conversion-version="15">
                                    <column _I_D="9b0cec78-a89a-4134-b8c1-adfe321ac5cf" name="playlistid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Constraints,constraint PK_PLAYLISTTRACK,category Columns,column PLAYLISTID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success"/>
                                    <column _I_D="e609e97e-3436-4604-b66d-222c0419f7a9" name="trackid" transformed="2024-08-25 20:57:14" ordinal-position="2" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Constraints,constraint PK_PLAYLISTTRACK,category Columns,column TRACKID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="9b520d30-b00c-4d9c-81d2-ba26061e53b5" name="Indexes" order-num="5" child-type="index" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Indexes" conversion-version="15"/>
                        <category _I_D="cd5cdd69-d627-407d-a748-50379263f463" name="Triggers" order-num="6" child-type="trigger" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Triggers" conversion-version="15"/>
                        <category _I_D="258271ee-fb57-4ee3-abb9-a82b56c520ac" name="Partitions" order-num="7" child-type="partition" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table PLAYLISTTRACK,category Partitions" conversion-version="15"/>
                    </table>
                    <table _I_D="fa3d5659-0198-44ad-b14d-484339d6551d" name="track" transformed="2024-08-25 20:57:14" is-typed="N" partitioned="NO" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04">
                        <category _I_D="109c63e6-abd3-456f-87fb-d127690f230d" name="Columns" order-num="0" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Columns" conversion-version="15">
                            <column _I_D="58423972-19fb-4a4d-96f5-38c2c46f0e37" name="trackid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Columns,column TRACKID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="TRACK" error-code="5984"/>
                            <column _I_D="ee64f9da-72e2-4f1c-b2ad-b045ad50b6f1" name="name" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="N" dt-attr-1="200" ordinal-position="2" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Columns,column NAME" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="TRACK"/>
                            <column _I_D="58ab8c03-839d-40e1-bbc7-800762a80d58" name="albumid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="Y" ordinal-position="3" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Columns,column ALBUMID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="TRACK" error-code="5984"/>
                            <column _I_D="025cf7d9-951d-4ac7-bf67-6c72e718a096" name="mediatypeid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="4" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Columns,column MEDIATYPEID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="TRACK" error-code="5984"/>
                            <column _I_D="959c0d81-1ee4-4f66-b438-e671f2a93d70" name="genreid" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="Y" ordinal-position="5" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Columns,column GENREID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="TRACK" error-code="5984"/>
                            <column _I_D="f73f146c-b16f-4549-a36f-d3414840b94f" name="composer" dt-name="CHARACTER VARYING" transformed="2024-08-25 20:57:14" is-nullable="Y" dt-attr-1="220" ordinal-position="6" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Columns,column COMPOSER" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="TRACK"/>
                            <column _I_D="7abbf37a-fe3a-4c0c-aa09-f045f0619415" name="milliseconds" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="7" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Columns,column MILLISECONDS" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="TRACK" error-code="5984"/>
                            <column _I_D="62c2d778-a570-4847-ac2d-81220de18a46" name="bytes" dt-name="NUMERIC" transformed="2024-08-25 20:57:14" is-nullable="Y" ordinal-position="8" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Columns,column BYTES" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="TRACK" error-code="5984"/>
                            <column _I_D="bbb24c32-ed8f-450e-b26b-5c6f3ec38b6c" name="unitprice" dt-name="DOUBLE PRECISION" transformed="2024-08-25 20:57:14" is-nullable="N" ordinal-position="9" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Columns,column UNITPRICE" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" table-schema="C##CHINOOK" table-name="TRACK"/>
                        </category>
                        <category _I_D="d125b95e-977c-4f2f-a1cd-dc9d4d314fe7" name="Partition columns" order-num="1" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Partition columns" conversion-version="15"/>
                        <category _I_D="2a8f1f43-fe49-456e-8c10-bb8101ee72b0" name="Subpartition columns" order-num="2" child-type="column" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Subpartition columns" conversion-version="15"/>
                        <category _I_D="8140adf0-4110-4192-9163-52c54282a95d" name="Constraints" order-num="4" child-type="constraint" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Constraints" conversion-version="15">
                            <constraint _I_D="8be7cbc1-2299-4d92-a1dd-0692eb85d86f" name="fk_trackalbumid" constraint-type-desc="FOREIGN KEY" transformed="2024-08-25 20:57:14" referenced-table-name="album" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" validated="true" referenced-constraint-schema="C##CHINOOK" referenced-constraint-name="C##CHINOOK" referenced-table-schema="C##CHINOOK" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Constraints,constraint FK_TRACKALBUMID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="1fbd76a9-20d2-4246-ba80-e03bbced8c7d" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Constraints,constraint FK_TRACKALBUMID,category Columns" conversion-version="15">
                                    <column _I_D="09fc6f75-1047-4a62-8461-96ecd28c65e4" name="albumid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Constraints,constraint FK_TRACKALBUMID,category Columns,column ALBUMID" conversion-version="15" source-vendor="ORACLE" column-in-referenced-unique-constraint="albumid" mdl-applying-result="applying-success" position-in-referenced-unique-constraint="albumid"/>
                                </category>
                            </constraint>
                            <constraint _I_D="2926921d-6341-4c6e-9001-0abe4d4d5e20" name="fk_trackgenreid" constraint-type-desc="FOREIGN KEY" transformed="2024-08-25 20:57:14" referenced-table-name="genre" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" validated="true" referenced-constraint-schema="C##CHINOOK" referenced-constraint-name="C##CHINOOK" referenced-table-schema="C##CHINOOK" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Constraints,constraint FK_TRACKGENREID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="a50a15a8-cbce-4650-bf45-0936f7d44530" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Constraints,constraint FK_TRACKGENREID,category Columns" conversion-version="15">
                                    <column _I_D="f128944f-cf85-476a-8283-714a5de21661" name="genreid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Constraints,constraint FK_TRACKGENREID,category Columns,column GENREID" conversion-version="15" source-vendor="ORACLE" column-in-referenced-unique-constraint="genreid" mdl-applying-result="applying-success" position-in-referenced-unique-constraint="genreid"/>
                                </category>
                            </constraint>
                            <constraint _I_D="7da2f477-9792-4a59-b63f-14eae243e3e4" name="fk_trackmediatypeid" constraint-type-desc="FOREIGN KEY" transformed="2024-08-25 20:57:14" referenced-table-name="mediatype" constraint-type="FOREIGN KEY" delete-rule="NO ACTION" validated="true" referenced-constraint-schema="C##CHINOOK" referenced-constraint-name="C##CHINOOK" referenced-table-schema="C##CHINOOK" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Constraints,constraint FK_TRACKMEDIATYPEID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="f43a85eb-969b-4d91-9f2c-01bf2b69310c" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Constraints,constraint FK_TRACKMEDIATYPEID,category Columns" conversion-version="15">
                                    <column _I_D="6e1bd911-af64-4465-8662-300d00aec99b" name="mediatypeid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Constraints,constraint FK_TRACKMEDIATYPEID,category Columns,column MEDIATYPEID" conversion-version="15" source-vendor="ORACLE" column-in-referenced-unique-constraint="mediatypeid" mdl-applying-result="applying-success" position-in-referenced-unique-constraint="mediatypeid"/>
                                </category>
                            </constraint>
                            <constraint _I_D="27c38f34-f634-4e8a-b530-13a9bfdc64f3" name="pk_track" constraint-type-desc="PRIMARY KEY" transformed="2024-08-25 20:57:14" constraint-type="PRIMARY KEY" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Constraints,constraint PK_TRACK" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success" mdl-applied="2024-08-25 21:02:04" generated="USER">
                                <category _I_D="a5026246-e5e6-4035-a855-48cd2e0ba4b5" name="Columns" order-num="0" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Constraints,constraint PK_TRACK,category Columns" conversion-version="15">
                                    <column _I_D="0b3c74bd-47c2-46bb-ad51-a3b40a53d552" name="trackid" transformed="2024-08-25 20:57:14" ordinal-position="1" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Constraints,constraint PK_TRACK,category Columns,column TRACKID" conversion-version="15" source-vendor="ORACLE" mdl-applying-result="applying-success"/>
                                </category>
                            </constraint>
                        </category>
                        <category _I_D="c9c7fa42-92d5-4bcb-8267-25b6ab4d1377" name="Indexes" order-num="5" child-type="index" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Indexes" conversion-version="15"/>
                        <category _I_D="cfca1890-700c-437b-9b3c-2d6def8f5e2c" name="Triggers" order-num="6" child-type="trigger" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Triggers" conversion-version="15"/>
                        <category _I_D="23ce82fe-5a15-4681-a788-7137d6bb4db7" name="Partitions" order-num="7" child-type="partition" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Tables,table TRACK,category Partitions" conversion-version="15"/>
                    </table>
                </category>
                <category _I_D="0d11987d-8810-4b06-848e-1b8770865cbc" name="Views" order-num="2" child-type="view" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Views" conversion-version="15"/>
                <category _I_D="43fac229-d80b-4406-b6bc-ea4dd4bcb3ce" name="Procedures" order-num="4" child-type="procedure" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Procedures" conversion-version="15"/>
                <category _I_D="bbe6575f-bbb5-46b8-8588-51ce31fd2434" name="Functions" order-num="5" child-type="function" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Functions" conversion-version="15"/>
                <category _I_D="38afd849-2683-4f3f-8b99-eab59a1ad6f4" name="User defined types" order-num="6" child-type="type" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category User Defined Types" conversion-version="15"/>
                <category _I_D="80ebc3cb-442e-400d-9a17-2146bd22490a" name="Sequences" order-num="8" child-type="sequence" transformed="2024-08-25 20:57:14" artificial-src-full-name="category Schemas,schema C##CHINOOK,category Sequences" conversion-version="15"/>
            </schema>
        </category>
        <category _I_D="d08c7361-2a83-4f18-86d7-a4f2c0a59144" name="Foreign Servers" order-num="1" objects-loading="empty" subcategories-loading="full" child-type="foreign-server"/>
        <category-group _I_D="e98c63b8-0194-4eef-9281-6b0497c4d049" name="Server Level Objects" order-num="2" objects-loading="empty" subcategories-loading="full">
            <category _I_D="9b072220-7ff6-412b-bdf5-120b40e76bac" name="Contexts" order-num="0" objects-loading="empty" subcategories-loading="full" child-type="context"/>
        </category-group>
        <category _I_D="0a642639-41d9-4abc-9657-7556be04f5b9" name="SQL Scripts" script-root="true" disable-autocommit="true" data-format="DD-MON-RR" sql-plus-settings="{&quot;tnsAliases&quot;:[]}"/>
    </metadata>
</tree>